package TestZOS;

import java.util.*;
import java.io.*;
import java.util.Formatter;
import java.math.*;

public class DispHexCA {
  final String RunEci_V = "DispHexCA V1.0";

  private ArrayList<String> dispit_lns = new ArrayList<>();  // collect formated lines
  private HashMap<Integer,Integer> dispit_pgs = new HashMap<>();  // collect formated page line references
  
  public static String fmttr(int k) {
       Formatter f = new Formatter();
       return f.format("%08X",k).toString();
     }
  
  //            page#,start in dispit_lns
  /**
   Constructor.
   @param aFileName full name of an existing, readable file.
  */
 public DispHexCA(){


  } 
public static String padRight(String s, int n) {
     return String.format("%1$-" + n + "s", s);  
}

public static String padLeft(String s, int n) {
    return String.format("%1$" + n + "s", s);  
}

public static String toHexString(byte[] bytes) {
    char[] hexArray = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
    char[] hexChars = new char[bytes.length * 2];
    String k;
    int v;
    for ( int j = 0; j < bytes.length; j++ ) {
        v = bytes[j] & 0xFF;
        hexChars[j*2] = hexArray[v/16];  // was v/16
        hexChars[j*2 + 1] = hexArray[v%16];  // was v%16
        k = Integer.toHexString(v);
    }
    return new String(hexChars);
}

public void dispit(byte[] abytCA, int OP_max_size) {

  InputStreamReader isr = new InputStreamReader(System.in);
  BufferedReader input = new BufferedReader(isr);
    byte[] abytCommarea = abytCA;
    int abytCA_Len = abytCommarea.length;
    int lnsz_abytCA_Len = 0;  // will be used to format partial page, full lines
    
    int mx_sub_grp_lng = 4; // four hex chars dumped per sub grouping (8 displayable chars)
    int mx_grp_lng = 16;    // four sub groups per displayable line (32 displayable chars)
    
    if (OP_max_size < (10 * mx_grp_lng)) {
      OP_max_size = 10 * mx_grp_lng;
    } else {
      if ((OP_max_size % mx_grp_lng) > 0) {
       OP_max_size = OP_max_size / mx_grp_lng;
       OP_max_size = OP_max_size * mx_grp_lng;
       }
    }
           
    StringBuilder DispBuf = new StringBuilder(80);  
    StringBuilder DispStr = new StringBuilder(mx_grp_lng);    

// first collect as many full formated lines into dispit_lns ArrayList
// then collect the final (if any) formateed line, space filling, into last dispit_lns ArrayList
// next create formatted full pages into dispit_pgs ArrayList
// and last, format last parial page into dispit_pgs ArrayList

     int cur_OP_max_size = 0; // set up loop to accumulate pages by i_ct the abytCommarea  
     int maxpg = -1, maxln = -1, Rmaxpg = -1, Rmaxln = -1, ln_abytCA_modulo = 0;
     
     dispit_lns.clear();
     dispit_pgs.clear();
    
           if (abytCA_Len < mx_grp_lng) {
            Rmaxln = 0; //only  partial page formated             
            cur_OP_max_size = 0;  // controls entry into full page logic, not needed here
            ln_abytCA_modulo = abytCA_Len;
            } else {
            Rmaxln = abytCA_Len/mx_grp_lng;
            cur_OP_max_size = mx_grp_lng * Rmaxln; // controls entry into full page logic, needed here
            ln_abytCA_modulo = abytCA_Len - cur_OP_max_size;  // could be zero
            }
            
            if (abytCA_Len < OP_max_size) {
             maxpg = 1;
            } else {
             maxpg = abytCA_Len / OP_max_size;  
             if ((abytCA_Len % OP_max_size) > 0) {
               maxpg++;
             }
            }
           int m, n, i_ct = 0;
           byte[] t_byt = new byte[mx_sub_grp_lng];
           byte[] t_byt1 = new byte[1]; 
           
           while (i_ct < cur_OP_max_size) {
              DispBuf.setLength(0);             
              DispStr.setLength(0); 
              DispBuf.append(Integer.toString(i_ct + 1000000).substring(1)).append(" | ");
              DispBuf.append(fmttr(i_ct)).append(" |"); 
              // run for loop 4 times normally 4 grps or 4 sub_grps
              for (m = 0; m < mx_grp_lng; m = m +  mx_sub_grp_lng) {
                // run for loop 4 times 4 chars at a time 
                for (n = 0; n < mx_sub_grp_lng; n++) {
   /*              
                  if (i_ct > 2030) {
                   i_ct = i_ct;
                  }
     */             
//                  DispBuf.append(Integer.toHexString(abytCommarea[i_ct]));
                  t_byt[n] = abytCommarea[i_ct];
                  if ((t_byt[n] < 0x20) || (t_byt[n] > 0x7E)) {
                    t_byt1[0] = 0x2E;
                  } else {
                    t_byt1[0] = t_byt[n];
                  }
                  DispStr.append((char) t_byt1[0]);
                  i_ct++;
                  }
                DispBuf.append(toHexString(t_byt)).append(" "); 
              }
              DispBuf.setLength(DispBuf.length() - 1);
              DispBuf.append("|").append(DispStr.toString()).append("|"); 
//              System.out.println(DispBuf.toString());
//              i_ct = i_ct + mx_grp_lng;
             dispit_lns.add(DispBuf.toString());
           }
// 
// if we have a ln_abytCA_modulo, then we have a partial line to format.
         if (ln_abytCA_modulo > 0 ) {
              DispBuf.setLength(0);            
              DispStr.setLength(0); 
              DispBuf.append(Integer.toString(i_ct + 1000000).substring(1)).append(" |");
              for (m = 0; m < mx_grp_lng; m = m +  mx_sub_grp_lng) {
                // run for loop 4 times 4 chars at a time 
                for (n = 0; n < mx_sub_grp_lng; n++) {
                  if (i_ct < abytCA_Len) {
                  t_byt[n] = abytCommarea[i_ct];
                  if ((t_byt[n] < 0x20) || (t_byt[n] > 0x7E)) {
                    t_byt1[0] = 0x2E;
                    } else {
                    t_byt1[0] = t_byt[n];
                    }
                   DispStr.append((char) t_byt1[0]);
                   i_ct++;
                  } else {
                   t_byt[n] = 0x20; 
                   DispStr.append((char) 0x20); 
                   }
                }  
                DispBuf.append(toHexString(t_byt)).append(" "); 
              }
           DispBuf.setLength(DispBuf.length() - 1);
           DispBuf.append("|").append(DispStr.toString()).append("|"); 
           dispit_lns.add(DispBuf.toString());
           }   
   maxln = dispit_lns.size();

   if (maxln < 0) {
     System.out.println("Error. No Pages found for Display. CAL was " + abytCA_Len + ": No pages created (?)");
     return;
   } 
   Rmaxln =  OP_max_size / mx_grp_lng;    // Lines per page
   ln_abytCA_modulo = maxln % Rmaxln;     // partial page Length in lines
   Rmaxpg = (maxln / Rmaxln);             // calculated number of full pages

   Integer Im;
   Integer In;
   n = 0;
   for (m = 1; m <= Rmaxpg; m++) {
     Im = m;
     In = n;
     dispit_pgs.put(Im,In);
     n = n + Rmaxln;
   }
   Rmaxpg = Rmaxpg + 1;
   Im = Rmaxpg;
   In = n;
   int curpg = 0;
   dispit_pgs.put(Im,In);
// we now know the Rmaxpg number of pages, and the start of the dispit_lns line # 
    
   String Stmp = "!";
   int go_pg = 0;
   char tpg;
   while (curpg != -1) {
     if (!Stmp.equals("!")) {
       System.out.println("Current Page:" + curpg);
     }
    System.out.print("There are " + (maxpg + 0) + " pages to display.\nEnter a page number" + 
                     "\nN - Next\nP - Prev\nOr X - Done:");
    try {
    Stmp = "";  
    Stmp = input.readLine().trim().toUpperCase();
    if (Stmp.equals("")) {
       System.out.println("Nothing Entered. Try Again.");
       }
    } catch (IOException e) {
     System.out.println("IOException reading input for next hex display");
     return;
    }
    try { 
    curpg = Integer.parseInt(Stmp);
    if (curpg < 1) {
      curpg = 1;
    }

    if (curpg > Rmaxpg) {
      curpg = maxpg;
    }
    System.out.print("Displaying Page:");
    }  
    catch(NumberFormatException nfe) { 
      if (Stmp.length() > 0) {
       tpg = Stmp.charAt(0);
       switch (tpg) {
         case 'X': {
         System.out.println("\nExit Selected. Done Display");
         curpg = -1;
         return;
         }
         case 'N': 
           if (curpg < maxpg) {
             curpg++;
           } else {
           System.out.print("\nAlready At Last Page: Redisplay " ); 
           }
           break;
         case 'P': 
           if (curpg > 1) {
             curpg--;
           } else {
           System.out.print("\nAlready At First Page: Redisplay " ); 
           }
           break;
         default:
           System.out.print("\nInvalid selection: TRedisplay page:" );
           break; 
         }
      } else {
       System.out.print("Navigation entry was null. Retry:");
       }
     }
     System.out.println(curpg);
     if (curpg  > 0) {
     m = dispit_pgs.get(new Integer(curpg));
     if (curpg == Rmaxpg) {
       n = m + ln_abytCA_modulo;
     } else {
       n = m + Rmaxln;
     }
     for (; m < n; m++) {
     System.out.println(dispit_lns.get(m));   
    }
   }
  }
 }
}//
//         File Name     : EciB1e.java

package TestZOS;

import java.lang.*;
import java.util.*;
import java.text.*;
import java.io.*;
import java.nio.charset.*;
import java.util.Properties;
import java.util.concurrent.TimeUnit;
import java.lang.InterruptedException;
import java.math.*;

//import TestZOS.*;

import com.ibm.ctg.client.*;

public class EciB1e {
   final String RunEci_V = "EciB1e V1.1";
   // Declare objects for use in both methods
   private static JavaGateway javaGatewayObject;

   private static InputStreamReader isr = new InputStreamReader(System.in);
   private static BufferedReader input = new BufferedReader(isr);
   private static int iValidationFailed = 0;
   private static StringBuilder sb_targ_cn_list = new StringBuilder();
   private static HashMap<String, String> ctg_targ = new HashMap<String, String>();
   private static HashMap<String, String> ctg_targ_CN_RQ = new HashMap<String, String>();
   private static HashMap<String, String> hm_ctg_targ_CN_RP_Char = new HashMap<String, String>();
   private static HashMap<String, String> hm_ctg_targ_CN_RP_Bit = new HashMap<>();
   private static HashSet<String> CN_hset = new HashSet<>();
   private static ArrayList<byte[]> CA_bresp = new ArrayList<>();
   private static ArrayList<String> CA_Sresp = new ArrayList<>();
   private static ArrayList<String> Txn_resp = new ArrayList<>();
   private static ArrayList<Date> TxnStDt = new ArrayList<>();
   private static ArrayList<Date> TxnSpDt = new ArrayList<>();

   //Name of the CICS program to execute
   // private String ProgramName = "PONG";    // commarea only
   private String ProgramName = "UCEMPINR";
   public void PromptPN(String PN) {

     if (PN.equals("")) {
       PN = getPN();
     }
     System.out.println("Selected CICS Target Program:" + PN);
     System.out.print("Enter Different CICS Target Program:");
     try {
     PN = input.readLine().trim().toUpperCase();
     setPN(PN);
     } catch (IOException e) {
       System.out.println("Error. IOException reading Target Program. Using Default.");
      }
     System.out.println("\nUsing CICS Target Program:" + getPN());
     }
   public void setPN(String PN)
   {
     if ((PN.length() > 0) && (PN.length() < 9 )) {
       ProgramName = PN;
     }
   }
   public String getPN() {
       return ProgramName;
   }

   //Name of the CICS Transid to execute
   private String MyTransid = "UXXX";
   public void PromptTID(String TID) {
     if (TID.equals("")) {
       TID = getMyTID();
     }
     System.out.print("Enter Different TRANSID:" + TID);
     try {
     TID = input.readLine().trim().toUpperCase();
     if ((TID.length() > 0) && (TID.length() < 5)) {
       setMyTID(TID);
       }
      } catch (IOException e) {
       System.out.println("Error. IOException reading Target TRANSID. Using Default.");
     }
     System.out.print("\nUsing TRANSID:" + getMyTID());
    }
   public void setMyTID(String TID) {
     if ((TID.length() > 0) && (TID.length() < 5 )) {
       MyTransid = TID.toUpperCase();
       MyMirrorTransId = MyTransid;
     }
   }
   public String getMyTID() {
     return MyTransid;
   }
   //Name of the CICS Transid that mirror is to execute
   private String MyMirrorTransId = MyTransid;

//Maximum number of flow attempts
   private int MaxFlowAttempts = 3;
   public void PromptFA(int FA) {
     if ( FA == 0) {
       FA = getMaxFA();
     }
     System.out.println("Current FLOW Retry Setting:" + FA);
     System.out.print("Enter Different FLOW Setting:");
     try {
     FA  = Integer.parseInt( input.readLine().trim() );
     setMaxFA(FA);
     } catch (NumberFormatException e) {
      System.out.println("Error: NumberFormatException Reading FlowAttempts. Using Default.");
      } catch (IOException e) {
       System.out.println("Error. IOException reading FLOW Setting. Using Default.");
     }
     System.out.println("\nUsing FLOW Retry Setting:" + getMaxFA());
    }
   public void setMaxFA(int FA) {
     if ((FA > 0) && (FA < 5 )) {
       MaxFlowAttempts = FA;
     }
   }
   public int getMaxFA() {
       return MaxFlowAttempts;
   }

   // Set program to use CA or CNC
   private String use_ca_or_cNc = "CA";
   //private string use_ca_or_cNc = "CNC";
   public void PromptCAorCnC(String rd_ca_or_cNc) {
     if (rd_ca_or_cNc.equals("")) {
       rd_ca_or_cNc = "CA";
     }
     System.out.print("Select Data Model:\n'CA' for Commarea,\nor 'CNC' for Channel and Container(s):" + rd_ca_or_cNc);
     try {
     rd_ca_or_cNc = input.readLine().trim().toUpperCase();
     } catch (IOException e) {
       System.out.println("Error. IOException reading Data Model. Using Default.");
     }
     if (!(rd_ca_or_cNc.equals("CA")) && !(rd_ca_or_cNc.equals("CNC"))) {
       rd_ca_or_cNc = "CA";
       }
    System.out.print("\nUsing Data Model:" +  rd_ca_or_cNc);
    setCAorCnC(rd_ca_or_cNc);
    }

   public void setCAorCnC(String rd_ca_cnc ) {
     use_ca_or_cNc = rd_ca_cnc;
   }

   public String getCAorCnC() {
     return use_ca_or_cNc;
   }
   //Name of Channel to pass to EC03 program
   private String CHANNEL_NAME = "TesT_Channel";   // max 16
   public void PromptChanNm(String ChanNm) {
     if (ChanNm.equals("")) {
       ChanNm = CHANNEL_NAME;
     }
     boolean CH_flg = true;
     while (CH_flg) {
     System.out.println("enter ''!'' to abort; ''='' to use:" + ChanNm);
     System.out.println("Enter CHANNEL_NAME:" + ChanNm);
     try {
     ChanNm = input.readLine().trim();
     if ((ChanNm.length() > 0) && (ChanNm.length() < 17) && (!(ChanNm.substring(0,1).equals(" "))))  {
 //      CHANNEL_NAME = ChanNm;
       CH_flg = false;
     } else {
       System.out.println("Channel name must begin with a letter and be 1 - 16 alphanum (no spaces)");
     }
     } catch (IOException e) {
       System.out.println("Error. IOException reading CHANNEL_NAME. Using Default.");
     }
     }
     System.out.println("\nUsing CHANNEL_NAME:" + ChanNm);
     setChNm(ChanNm);
    }

      public void setChNm(String cn) {
     CHANNEL_NAME = cn;
   }

   public String getChNm() {
     return CHANNEL_NAME;
   }

   //Name of Container to pass to EC03 program
   private String CONTAINER_NAME = "CEMT0001";   //max 16
   public int Prompt4Containers(String ContNm) {
     if (ContNm == "") {
       ContNm = CONTAINER_NAME;
     }
    boolean CN_flg = true;
   CN_LOOP:    while (CN_flg) {
     System.out.println("CN List:" + CN_hset);
     System.out.print("Enter CONTAINER_NAME:" + ContNm + "\n just enter to end CN loop\nor ''!'' to abort:");
     try {
     ContNm = input.readLine().trim();
     if (ContNm.equals("")){
       break CN_LOOP;
     }
     if (ContNm.equals("!")){
       System.out.println("\nAbort selected");
       return -1;
     }
     if ((ContNm.length() > 0) && (ContNm.length() < 17) && (!(ContNm.substring(0,1).equals(" ")))) {
//       if (sb_targ_cn_list.toString().contains(ContNm)) {
       if (CN_hset.add(ContNm)) {
         String ContNmVal = new String();
         ContNmVal = PromptCN_val(ContNm);
         ctg_targ_CN_RQ.put(ContNm, ContNmVal);
         } else {
         String ChoiceDRT = new String("");
         String strDRT = new String("DRT");
         while (ChoiceDRT.equals("")) {
         ChoiceDRT = PromptChoice("\nCONTAINER_NAME:" + ContNm + " already exists!\n" + ctg_targ_CN_RQ.get(ContNm),
                          "\nChoice: D or R or T:" +
                            "\n\tD (delete existing)\n\tR (replace existing)\n\tT (Try another CN name)",
                          strDRT);
           switch (strDRT.indexOf(ChoiceDRT)) {
           case 0: CN_hset.remove(ContNm);
                   ctg_targ_CN_RQ.remove(ContNm);
                   ContNm = "";
                   System.out.println("\nCONTAINER_NAME:" + ContNm + " was deleted from Channel");
                   break;
           case 1: String ContNmVal = new String(PromptCN_val(ContNm));
                   ctg_targ_CN_RQ.replace(ContNm, ContNmVal);
                   System.out.println("\nCONTAINER_NAME:" + ContNm + " value was replaced");
                   ContNm = "";
                   break;
           case 2: System.out.println("\nCONTAINER_NAME:" + ContNm + " exists, and going to try another Container Name");
                   ContNm = "";
                   break;
             default: ChoiceDRT = "";
            System.out.println("\nInvalid REsponse:" + ChoiceDRT + " is not one of " + strDRT + " choices. Try again.");
                   break;
           }
          }
         }
     } else {
     System.out.print("\nInvalid Container Name:" + ContNm + ": Retry or ! to finish.");
     ContNm = "";
     }
     } catch (IOException e) {
       System.out.println("Error. IOException reading CONTAINER_NAME. Using Default.");
     }
    }
   System.out.println("Number of Containers:" + CN_hset.size() + " Container Names:");
   System.out.println(CN_hset);
//     for (String temp : CN_hset) {
//        System.out.println(temp);
//     }
//    Iterator<String> it = CN_hset.iterator();
//    while(it.hasNext()){
//        System.out.println(it.next());
//     }

   return CN_hset.size();
	}   // end of Prompt4Containers
}

// Get container CHARACTER data
   public String PromptCN_val(String ContNm) {
     String ContCHARVal = new String("");
     if (ContNm.length() > 3) {
       String ContNm4 = new String(ContNm.substring(0,4));
       String ContCMDRest  = new String ("");
       switch (ContNm4) {
         case "CEMT": ContCMDRest = " INQUIRE TASK";
              break;
         case "CEDA": ContCMDRest = " VIEW GROUP(XXXXXXXX) PROGRAM(YYYYYYYY)";
              break;
         case "PONG": ContCMDRest = " This Is A Pong Message";
              break;
         default: ContCMDRest = "";
              ContNm4 = "";
              break;
       }
     ContCHARVal = ContNm4 + ContCMDRest;
     }
     System.out.println("Enter Character data for Continer Named:" + ContNm);
     System.out.println("Press Enter to use the default value:\n" + ContCHARVal);
     String tmp_cn = "";
     while (tmp_cn.equals("")) {
     try {
      tmp_cn = input.readLine().trim();
      if (tmp_cn.equals("")) {
       return ContCHARVal;
      } else {
        return tmp_cn;
      }
     } catch (IOException e) {
       System.out.println("Error. IOException reading data. Try again.");
       return "";
     }
   }
     return  "";
   }

   //The size of the COMMAREA to send to the program - This can be 0 - 32400
   int CAL = 4080;
   public void PromptCAL(int ca_len) {
     int h_ca_len;
     if ( ca_len == 0) {
       ca_len = getCAL();
     }
     h_ca_len = ca_len;
     System.out.println("Current CA Length Setting:" + ca_len);
     System.out.print("Enter Different CA Length Setting:");
      String s_ca_len = "";
     try {
      s_ca_len = input.readLine().trim();
      ca_len  = Integer.parseInt(s_ca_len);
      } catch (NumberFormatException e) {
        if ((s_ca_len.equals("=")) || (s_ca_len.equals(""))) {
          ca_len = h_ca_len;
        } else {
          System.out.println("Error: NumberFormatException Reading CAL. Using Default.");
          ca_len = getCAL();
        }
      } catch (IOException e) {
       System.out.println("Error. IOException reading FLOW Setting. Using Default.");
       ca_len = h_ca_len;
      } finally {
       setCAL(ca_len);
      }
     System.out.println("\nUsing CA Length Setting:" + getCAL());
    }


   public void setCAL(int ca_len) {
     if ((ca_len >= 0) && (ca_len <= 32400 )) {
       CAL = ca_len;
     }
   }
   public int getCAL() {
       return CAL;
   }

   //The size of the COMMAREA to send to the program
//   private String stdmyCA = "Ponged from JAVA EciB1e on my desktop!!";
   private String stdmyCA = "CEMT INQUIRE SYSTEM";
   private String CA = "CEMT INQUIRE TASK";
   private ArrayList<String> CA_aryL = new ArrayList<>();
   private ArrayList<Integer> CA_aryLen = new ArrayList<>();
   protected void setDfltCA() {
    CA_aryL.add(CA);
   }
   public void PromptGetCA(String tmp_ca) {
     String tCA = "";
     CA_aryL.clear();
     int repct = getrep_txn();
     char repDM = getDM();
     if (repDM == 'S') {
       PGetCA(stdmyCA);
       tCA = getMyCA();
       for (int i = 0; i <= repct; i++) {
         CA_aryL.add(tCA);
         CA_aryLen.add(tCA.length());
         }
       System.out.println("Data Mode 'S' Static CA set for all (" + (repct + 1) + ") iterations.");
       return;
     }
     if (repDM == 'E') {
       for (int i = 0; i <= repct; i++) {
         System.out.println("\nEnter CA for iteration:" + (i + 1));
         PGetCA(stdmyCA);
         tCA = getMyCA();
         CA_aryL.add(tCA);
         CA_aryLen.add(tCA.length());
         }
       System.out.println("Data Mode 'E' Each CA individually set. Total " + (repct + 1) + " iterations set.");
       return;
     }
     if (repDM == 'F') {
       String fin = DMDFN;
       int rdct = 0;
         FileInputStream fis = null;
         BufferedReader br = null;
         try {
         fis = new FileInputStream(fin);
         //Construct BufferedReader from InputStreamReader
         br =  new BufferedReader(new InputStreamReader(fis));
         String line = null;
         while ((line = br.readLine()) != null) {
          rdct++;
          tCA = line.trim();
          CA_aryL.add(tCA);
          CA_aryLen.add(tCA.length());
         }
         repct++;
         if (rdct < repct) {
         System.out.println("Repeat count:" + repct + " does not match command count from file:" +
         rdct + ". Reducing Repeat count.");
         setrep_txn(rdct - 1);
         }
         if (rdct > repct) {
         System.out.println("Repeat count:" + repct + " does not match command count from file:" +
         rdct + ". Commands greater than Repeat count ignored.");
         }
        System.out.println("Data Mode 'F' Each CA individually set for " + (getrep_txn() + 1) + " iterations.");
        br.close();
       } catch (IOException e) {
         System.out.println("Error. Could not read file with Commarea List. Goodbye!");
         e.printStackTrace();

       } finally {
         try {
           if (br != null) {
             br.close();
             }
           } catch (IOException e) {
           e.printStackTrace();
         }
       }
       return;
     }
   }

 public String PromptChoice(String Msg, String Inst, String opts) {
     String msgboxans = "";
     String dft_ans = "";
     String dft_hint = "";
     String ans = "";
     int optsl = opts.length();
     if (optsl == 0) {
       dft_ans = "";
       dft_hint = "Press anykey to Continue";
     } else {
       opts = opts.toUpperCase();
       dft_ans = opts.substring(0,1);
       dft_hint = "Valid Reponse is one of <" + opts + "> Default Response is<" + dft_ans + ">";
     }
     System.out.println("------------------------------------------------------");
     System.out.println(Msg);
     System.out.println("------------------------------------------------------");
     String tmp = "";
     do {
     System.out.print(Inst);
     try {
     tmp = input.readLine().trim().toUpperCase();
     if (optsl == 0) {
       return "";
     }
     if (tmp.length() > 0) {
       ans = tmp.substring(0,1);
       if (opts.contains(ans)) {
         return ans;
         }
       } else {
       ans = "";
       }
     System.out.println("Your response:'" + ans + "': is not an Option. Retry.");
     } catch (IOException e) {
      System.out.println("Error. IOException reading your response. Retry.");
      }
     System.out.print(dft_hint);
     ans = "";
   } while(msgboxans.equals(""));
   return ans;
   }

   public String getMyCA_L(int ca_num) {
     if ((ca_num < 0) || ca_num > CA_aryL.size()) {
       return "";
     }
     return CA_aryL.get(ca_num);
   }

   private void PGetCA(String tmp_ca) {
     if (tmp_ca.equals("")) {
       tmp_ca = stdmyCA;
     }
     String tmp1 = tmp_ca;
     String h_tmp_ca = tmp_ca;
     if (tmp_ca.length() > 70) {
       tmp1 = tmp_ca.substring(0,34) + ".." +  tmp_ca.substring(tmp_ca.length() - 34);
     }
     String ans = "";
     String opts = "NYD=";
     do {
     System.out.print("Enter Different Commarea:\n" + tmp1 +"\n");
     ans = "Y";
     try {
     tmp_ca = input.readLine().trim();
     int tmp_cal = tmp_ca.length();
     if (tmp_cal == 0) {
      ans = PromptChoice("CommArea data expected.\nYour Response was zero length. Default GA is\n",
                          "Select Y to use zero length CommArea\nOr N to retry\nOr '=' to use Default CA:",
                          opts);
      if (ans.equals("D") | ans.equals("=")) {
        ans = "Y";
        tmp_ca = getMyCA();
       }
     }
     if (ans.equals("Y")) {
     if (tmp_cal > 32400) {
       tmp_cal = 32400;
       tmp_ca = tmp_ca.substring(0,32399);
     }
     if (tmp_ca.equals("=")) {
       tmp_ca = h_tmp_ca;
     }

     setMyCA(tmp_ca);
     if (tmp_cal > getCAL()) {
         setCAL(tmp_cal);
       }
      }
     } catch (IOException e) {
      System.out.println("Error. IOException reading CommArea. Using Default.");
      }
     } while(ans.equals("N"));
    tmp1 = getMyCA();
    if (tmp1.length() > 70) {
       tmp1 = tmp1.substring(0,34) + ".." +  tmp1.substring(tmp1.length() - 34);
     }
    System.out.print("Commarea:\n" + tmp1 + "\n");
   }

   public void setMyCA(String tmp_ca) {
     int tmp_cal = tmp_ca.length();
     if (tmp_cal > 32400) {
       tmp_cal = 32400;
       tmp_ca = tmp_ca.substring(0,32399);
     }
     CA = tmp_ca;
     if (tmp_cal > getCAL()) {
         setCAL(tmp_cal);
       }
   }
   public String getMyCA() {
     return CA;
   }


   //Repeat Non/Xtended transaction 0-98 times, waiting 0-10000 ms between calls
   //private  int  rep_txn = 0; // 0 means NO repeats Itotal:1 executon)
   private int  rep_txn = 0;
   private int  min_rep_txn = 0, max_rep_txn = 98;
   public void PromptRepNum(int repnum) {
     if ( repnum == 0) {
       repnum = getrep_txn();
     }
     System.out.println("Current Repeat Transaction Count Setting:" + repnum);
     System.out.println("NOTE - Zero (0) Repeats implies Run once;\nOne (1) implies Run Twice,...");
     System.out.print("Enter Different Repeat Transaction Count Setting:");
     try {
     repnum  = Integer.parseInt( input.readLine().trim() );
     setrep_txn(repnum);
     } catch (NumberFormatException e) {
      System.out.println("Error: NumberFormatException Repeat Setting. Using Default.");
      } catch (IOException e) {
      System.out.println("Error. IOException reading Repeat Setting. Using Default.");
      }
     System.out.println("\nUsing Repeat Transaction Count Setting:" + getrep_txn());
    }
   public void setrep_txn(int repnum) {
     if ((repnum >= min_rep_txn) && (repnum <= max_rep_txn )) {
       rep_txn = repnum;
     }
   }
   public int getrep_txn() {
       return rep_txn;
   }

   // repeat txn datamode is only valid for COMMAREA
   // repeat txn datamode 'S' indicates static Datamodel on each eci flow
   //                     'P' indicates Prompt for each Datamodel contents for each iteration
   //                     'E' indicates Datamodel for each iteration setup prior to first iteration
   //                     'F' indicates a file provides the data for each iteration
   private char DMD = 'S';

   public void PromptRepDMD(char tmp) {
     System.out.print("Repeat Count is greater than 0. Choose a DataMode for the Datamodel" +
                        "\n'S' indicates static Datamodel on each eci flow" +
                        "\n'P' indicates Prompt for each Datamodel contents for each iteration" +
                        "\n'E' indicates Datamodel for each iteration setup prior to first iteration" +
                        "\n'F' indicates a file provides the data for each iteration" +
                        "\nMake a selection (default is 'S' static:");

//     Scanner s= new Scanner(System.in);
//     char xtnd = s.next().charAt(0);
//     xtnd = Character.toUpperCase(s.next().charAt(0));
     try {
     String Stmp = input.readLine().trim().toUpperCase();
     if (Stmp.length() > 0) {
       int i = setDM(Stmp.charAt(0));
       if (i > 0 ) {
         System.out.print("\nInvalid Data Mode selection: Using Default.");
       }
      }
     } catch (IOException e) {
      System.out.println("Error. IOException reading Data Mode Setting. Using Default.");
      }
    System.out.println("\nUsing DataMode:" + getDM());
    }
   public int setDM(char tmp) {
     tmp = Character.toUpperCase(tmp);
     if ((tmp == 'S') || (tmp == 'P') || (tmp == 'E') || (tmp == 'F') ) {
       DMD = tmp;
       return 0;
     } else {
       DMD = 'S';
       return 4;
       }
   }
   public char getDM() {
     return DMD;
   }

   private String DMDFN = "";
   protected void DMD_getFN() {
     String dmfn = "";
     do {
     System.out.print("Data Mode is File. Enter full filename for DataModel Data (or 'x' to Quit):");
     try {
     dmfn = input.readLine().trim();
     if (dmfn.equalsIgnoreCase("x")) {
       System.out.println("Quit Selected. Goodbye.");
       System.exit(8);
     }
     if ((dmfn.length() < 1) || (dmfn.length() > 240)) {
     System.out.println("\nError: file:" + dmfn + " is not correct length." +
       "\nRetry entry of filename for DataModel.");
       dmfn = "";
       }
     } catch (IOException e) {
      System.out.println("Error. IOException reading File Name for Data Mode. Using Default.");
      dmfn = "";
      }
     } while (dmfn.equals(""));

     File f = new File(dmfn);
     if (f.exists() && !f.isDirectory()) {
      DMDFN = dmfn;
      System.out.print("\nUsing file:" + DMDFN + " for Data Mode Data");
     } else {
      System.out.print("\nUsing file:" + dmfn + " is not found.\nChanging DataMode to 'S'");
      int i = setDM('S');
     }
   }

   //private int  wt_txn = 0; // 0 means no wait time between txn
   private long  wt_txn = 0;
   private static final long  min_wt_txn=0 * 1000, max_wt_txn = 99*1000;  // in millisec
   public void PromptWtInvl(long wtnum) {
     if ( wtnum == 0) {
       wtnum = getwt_txn();
     }
     System.out.println("Current Wait Between Transactions Setting (seconds):" + wtnum);
     System.out.print("Enter Different Wait Between Transactions Setting:");
     String S_ans = "";
     double ans = 0.00;
     Double FD_ans = ans;

     try {
      S_ans  = input.readLine().trim().toUpperCase();
      ans  = Double.parseDouble( S_ans);
      BigDecimal BD_ans = new BigDecimal(ans).setScale(2,BigDecimal.ROUND_HALF_UP);
      FD_ans= new Double(BD_ans.doubleValue());
    // now convert to long and make the long millesecs
       wtnum  = Math.round(FD_ans * 1000);
       setwt_txn(wtnum);
       } catch (NumberFormatException e) {
       System.out.println("Error: NumberFormatException Wait Interval. Using Default.");
       } catch (IOException e) {
       System.out.println("Error. IOException reading Wait Interval. Using Default.");
      }
     System.out.println("\nUsing Wait Between Transactions Setting (millisecs):" + getwt_txn());
      }
   public void setwt_txn(long wtnum) {
     if ((wtnum >= min_wt_txn) && (wtnum <= max_wt_txn )) {
       wt_txn = wtnum;
     }
   }
   public long getwt_txn() {
       return wt_txn;
   }

   private void EciSleep(long sleep_MS)
     throws InterruptedException {
   try {
     if ( sleep_MS < min_wt_txn ) {
        sleep_MS = min_wt_txn;
        System.out.println("Sleep Value too small: setting to:" + sleep_MS);
     } else {
        if ( sleep_MS > max_wt_txn ) {
        sleep_MS = max_wt_txn;
        System.out.println("Sleep Value too large: setting to:" + sleep_MS);
        }
     }
    TimeUnit.MILLISECONDS.sleep(sleep_MS);
   } catch (InterruptedException e) {
        System.out.print("Warning:EcioB1e:Sleep: Interrupted:");
        System.out.println(e.toString());
        assert false;
        //Handle exception
     }
   }

   //private char  Xtnd_txn = "N"; // "N" means individual txn in repeat cycle
   // "Y" means use LUW information for single LUW
   private char Xtnd_txn = 'N';

   public void PromptXtnd(char xtnd) {
     System.out.print("(This options requires CICS RRS=YES)\nEnter Extend Transaction Y or N:" + xtnd);
//     Scanner s= new Scanner(System.in);
//     char xtnd = s.next().charAt(0);
//     xtnd = Character.toUpperCase(s.next().charAt(0));
     try {
      String tmp = input.readLine().trim().toUpperCase();
      if (tmp.length() > 0) {
       xtnd = tmp.charAt(0);
      }
      setXtnd_txn(xtnd);
      } catch (IOException e) {
      System.out.println("Error:IOException getting Override Values. Using Default.");
      }
     System.out.print("\nUsing Extend Transaction:" + getXtnd_txn());
    }
   public void setXtnd_txn(char xtnd) {
     xtnd = Character.toUpperCase(xtnd);
     if ((xtnd == 'N') || (xtnd == 'Y')) {
       Xtnd_txn = xtnd;
     }
   }
   public char getXtnd_txn() {
     return Xtnd_txn;
   }

   private int eci_TO = 0;
   private static final int  min_TO=0 * 1000, max_TO = 99*1000;  // in millisec
   public void PromptEciTO(int TOnum) {
     if ( TOnum == 0) {
       TOnum = getEciTO();
     }
     System.out.println("Current ECI TimeOut Transactions Setting (seconds):" + TOnum);
     System.out.print("Enter Different ECI TimeOut Transaction Setting:");
     String S_ans = "";
     double ans = 0.00;
     Double FD_ans = ans;

     try {
      S_ans  = input.readLine().trim().toUpperCase();
      ans  = Double.parseDouble( S_ans);
      BigDecimal BD_ans = new BigDecimal(ans).setScale(2,BigDecimal.ROUND_HALF_UP);
      FD_ans= new Double(BD_ans.doubleValue());
    // now convert to long and make the long millesecs
       TOnum  = (int) Math.round(FD_ans * 1000);
       } catch (NumberFormatException e) {
       System.out.println("Error: NumberFormatException ECI TimeOut. Using Default.");
       } catch (IOException io) {
       System.out.println("Error: IOException ECI TimeOut. Using Default.");
       }
       setEciTO(TOnum);
       System.out.println("\nUsing ECI TimeOut Transaction Setting (millisecs):" + getEciTO());
      }
   public void setEciTO(int TOnum) {
     if ((TOnum >= min_TO) && (TOnum <= max_TO )) {
       eci_TO = TOnum;
     }
   }
   public int getEciTO() {
       return eci_TO;
   }

   private char chgdfY_N = 'N';
   public void PromptUseDft() {
     char ansY_N = 'N';
     System.out.println("------------------------------------------------------");
     System.out.println("Default settings:\nProgramName:" + ProgramName +
                        "\nTRANSID:" + MyTransid +
                        "\nData Model:" + use_ca_or_cNc +
                        "\nDefault CA:" + getMyCA() +
                        "\nDefault CA Length:" + getCAL() +
                        "\nMaxFlowAttempts:" + MaxFlowAttempts +
                        "\nRepeat Transaction:" + rep_txn +
                        "\nWait Between Trans:" + wt_txn +
                        "\nExtended Trans:" + Xtnd_txn +
                        "\nEci TimeOut:" + getEciTO());
     System.out.println("------------------------------------------------------");
     System.out.print("Press 'Y'<enter> to Change Values,\n\n Press anyotherkey<enter> to use Defaults," +
                      "\nOr 'Q' to Quit:");
//     Scanner s= new Scanner(System.in);
//     char xtnd = s.next().charAt(0);
     try {
     String tmp = input.readLine().trim().toUpperCase();
     if (tmp.length() > 0) {
       ansY_N = tmp.charAt(0);
     }

    if (ansY_N == 'Q') {
      System.out.println("CTG Selection was 'Q' (QUIT). GoodBye.");
      System.exit(4);
    }
     if (ansY_N == 'Y') {
     System.out.println("\nPrompting for Overrides to Defaults!");
     } else {
     System.out.println("\n(Entered:" + ansY_N + ") Using Defaults!");
     }
     setdfY_N(ansY_N);
     } catch (IOException e) {
     System.out.println("\nError (IOException).Entered:" + ansY_N + ") Using Defaults!");
     }
   }

   private void setdfY_N(char ansY_N) {
     if (ansY_N != 'Y') {
       ansY_N = 'N';
     }
     chgdfY_N = ansY_N;
   }
   public char getdfY_N() {
     return chgdfY_N;
   }
   // hld_pw - holds PW between iterations because cics nulls it out

   private String strMe = "";
   private String h_strMe = "";
   private String strMePW = "";
   private String h_strMePW = "";

//private boolean RetryInd = true;  // used to retry failed transaction FLOW
// true means retry up to retry attempts
   private boolean RetryInd = true;

   private void PromptGetNM_PW() {
     try {
        Console c = System.console();
        if (c == null) {
            System.out.println("\nEnter your CICS User ID:");
            strMe = input.readLine().trim();
            System.out.println("\nEnter your CICS Password:");
            strMePW = input.readLine().trim();
            } else {
            strMe = c.readLine("Enter your CICS User ID:");
            strMePW = new String (c.readPassword("Enter your CICS Password:"));
            }
         h_strMe = strMe;
         h_strMePW = strMePW;
         } catch (IOException e) {
         System.out.println("Error: CICS UserID and Password Required" );
         System.exit(12);
         }
     }

   private void PromptGetNM_PW_agn() {
     try {
        Console c = System.console();
        if (c == null) {
            System.out.println("\nEnter your CICS User ID \n or '=' to use same Userid\n or 'x' to exit:");

            strMe = input.readLine().trim();
             if (strMe.toUpperCase().equals("X")) {
               RetryInd = false;
               //break;
            }
            if (strMe.equals("=")) {
             strMe = h_strMe;
            }
            System.out.println("\nEnter your CICS Password\n or '=' to use same Password\n or 'x' to exit:");
            strMePW = input.readLine().trim();
            if (strMePW.toUpperCase().equals("X")) {
               RetryInd = false;
              // break;
            }
            if (strMePW.toUpperCase().equals("=")) {
             strMePW = h_strMePW;
            }
            } else {
            strMe = c.readLine("\nEnter your CICS User ID \n or '=' to use same Userid\n or 'x' to exit:");
            if (strMe.toUpperCase().equals("X")) {
               RetryInd = false;
              // break;
            }
            if (strMe.equals("=")) {
             strMe = h_strMe;
            }

            strMePW = new String (c.readPassword("\nEnter your CICS Password\n or '=' to use same Password\n or 'x' to exit:"));
            if (strMePW.toUpperCase().equals("X")) {
               RetryInd = false;
              // break;
            }
            if (strMePW.equals("=")) {
             strMePW = h_strMePW;
            }
        }
     } catch (IOException e) {
       System.out.println("Error: CICS UserID and Password Required" );
       System.exit(12);
       }
   }

   protected void fmtDt(Date stDt, Date spDt) {
     SimpleDateFormat formatter;  // Formats the date displayed
     formatter = new SimpleDateFormat ("EEE MMM yyyy dd kk:mm:ss.S", Locale.getDefault());
     String SD = formatter.format(stDt);
     String PD = formatter.format(spDt);
     long millis = spDt.getTime() - stDt.getTime();
     System.out.println("StartTime:" + SD + "\nStop Time:" + PD + "\nResponse (Millsec):" + millis);
     }

   //The size of the console dump display data
   private int OP_max_size = 1600; // 1600 is 100 16 bytes at a time
   // pnthex needs to be compiled to 'Y' if you want a dump of the CA byte array(s)
   private char pnthex = 'N';

   public void PromptPntHex() {
     System.out.print("Hex Dump " + OP_max_size + " bytes from DataMode Data (Y/N):" );
     String Stmp = "";
     do {
      try {
       Stmp = input.readLine().trim().toUpperCase();
       if (Stmp.length() > 0) {
         char tPH = Stmp.charAt(0);
         if ((tPH != 'Y' ) && (tPH != 'N')) {
          System.out.print("\nInvalid selection: Try Again." );
          Stmp = "";
         } else {
           pnthex = tPH;
         }
       }
      } catch (IOException e) {
      System.out.println("Error. Invalid Print Hex selection. Try Again'");
      Stmp = "";
      }
      System.out.println("\nUsing Hex Dump Selection response was:" + pnthex);
     } while (Stmp.equals(""));
    }
   private String Save2FN = "";
   protected String getSavFN() {
     return Save2FN;
   }

   public void SaveData() {
     File f = null;
     char t_save = '-';
     char tPH;
     String Stmp = "";
     System.out.println("Save DataMode Data to file?(N/Y/R/A):" );

     do {
     System.out.print("N - No\nY - Yes (both Raw and ASCII)\nR - Raw Data Only\nA - ASCII Data Only:");
     try {
     Stmp = input.readLine().trim().toUpperCase();
     if (Stmp.length() > 0) {
       tPH = Stmp.charAt(0);
       if ((tPH != 'Y' ) && (tPH != 'N') && (tPH != 'R' ) && (tPH != 'A')) {
         System.out.print("\nInvalid selection: Try Again or 'N' to bypass Save:" );
         } else {
         t_save = tPH;
         }
        }
       } catch (IOException e) {
         System.out.println("Error Response. Try again.");
       }
       } while (t_save == '-');

    if (t_save == 'N') {
      System.out.println("\nYou choose to Bypass Save to File." );
      return;
    }

   String tFN = "";
   do {
     try {
       System.out.print("\nEnter a new or existing path\filename (or 'x' to exit):" );
       tFN = input.readLine().trim();
       if (tFN.equalsIgnoreCase("x")) {
       return;
       }
     f = new File(tFN);
     if (f.isDirectory()) {
      System.out.println("\nYou choose A Directory. Tty Again.");
      } else {
      if (f.exists()) {
       System.out.println("\nFile Exists. Overwrite it (Y/N):" );
       Stmp = input.readLine().trim().toUpperCase();
       if (Stmp.length() > 0) {
        tPH = Stmp.charAt(0);
        if (tPH != 'Y' ) {
         System.out.print("\nYou Choose to NOT overwrite." );
         } else {
         Save2FN = tFN;
         }
        } else {
        System.out.print("\nInvalid Overwrite entry. try again." );
        }
       } else {
       Save2FN = tFN;
       }
      }
     } catch (IOException e) {
     System.out.println("Error Response. Try again.");
     }
    } while(Save2FN.equals(""));
       /**
     * Use FileWriter when number of write operations are less
     * @param data
     */

      //  File file = new File("/Users/pankaj/FileWriter.txt");
   BufferedOutputStream bos = null;
   try {
   //create an object of FileOutputStream
   //FileOutputStream fos = new FileOutputStream(new File(filename));
   FileOutputStream fos = new FileOutputStream(f);

   //create an object of BufferedOutputStream
   bos = new BufferedOutputStream(fos);

      if ((t_save == 'R') || (t_save == 'Y')) {
              int i = CA_bresp.size();
              for (int j = 0; j < i; j++) {
                bos.write(CA_bresp.get(j));
              }
            }
       if ((t_save == 'A') || (t_save == 'Y')) {
              int i = CA_Sresp.size();
              for (int j = 0; j < i; j++) {
                bos.write(CA_Sresp.get(j).getBytes());
              }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }finally{
            //close resources
            try {
                bos.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

   public void DispCA()
   {
         int Txn_ct = Txn_resp.size();
         int CA_ct = CA_Sresp.size();
         int j = CA_ct;
         Date stDt, spDt;
         String tCA = "";
         int tCA_Len = 0;
         DispHexCA d_h_ca = new DispHexCA();
         if (Txn_ct != CA_ct) {
           System.out.println("\nError: Txn count(" + Txn_ct +
                              ") does not match CA count(" + CA_ct + ")\n");
           if (CA_ct > Txn_ct) {
             j = Txn_ct;
           }
         }
         for (int i = 0; i < j; i++) {
           tCA = Txn_resp.get(i);
           tCA_Len = tCA.length();
           System.out.println("Printing CA for iteration:" + (i + 1) + "\nCA Length:" + tCA_Len );
           fmtDt( TxnStDt.get(i), TxnSpDt.get(i));
           System.out.print(tCA.trim());
           System.out.println(CA_Sresp.get(i).trim() +  ":txeT");

            PromptPntHex();
        if (pnthex == 'Y') {

// Use general window size of 80 shars
// format 6digits for offset (0-999990)
//        ^| 2 pos
//        groups of 4 hex chars (8digits) separated by 1 sp
//        | | 3 pos
//        16 chars
//        | 1 pos
// 12345 | 1234ABCD |01010101 01010101 01010101 01010101|123456789abcdef0|      74 chars?
           System.out.println("\nHEX Print of Commarea before CP Conversion : ");
           System.out.println("Variable:abytCommarea in Hex:");

           byte[] abytCommarea = CA_bresp.get(i);
           d_h_ca.dispit(abytCommarea,OP_max_size);

           System.out.println("\nHEX Print of Commarea after CP Conversion : ");
           d_h_ca.dispit(CA_Sresp.get(i).getBytes(), OP_max_size);

         }
         System.out.println("\n###########################################");
      }
   }
     /**
   Constructor.
   @param aFileName full name of an existing, readable file.
  */
//  public EciB1e(String rgnstr, String IPAdr, String IPSocket){
   public EciB1e(String kixport_target) {
    Scanner scanner = new Scanner(kixport_target);
    scanner.useDelimiter(",");
    if ( scanner.hasNext() ){
      try {
       while ( scanner.hasNext() ){
        ctg_targ.put("CTG",scanner.next());
        ctg_targ.put("IPAdr",scanner.next());
        ctg_targ.put("IPSocket",scanner.next());
        ctg_targ.put("JKS",scanner.next());
        ctg_targ.put("CTG_OS",scanner.next());
        ctg_targ.put("CTG_CP",scanner.next());
        ctg_targ.put("SSL",scanner.next());
          }
         } catch  (Exception e) {
         System.out.println("Error: EciB1e:Scanner kixport_line:" + e);
         System.exit(12);
        }
       }
       System.out.print("Local System CodePage Charset is:" );
       Charset cs_dft = Charset.defaultCharset();
       String lcl_cs = cs_dft.displayName();
       System.out.println(lcl_cs);
       Set s = cs_dft.aliases();
       Iterator j = s.iterator();
       String sep = "";
       while (j.hasNext()) {
            String a = (String) j.next();
            System.out.print(sep+a);
            sep=",";
         }
         System.out.println("\n____________________________" );
         PromptGetNM_PW();
         System.out.println("");
         String strUrl = ctg_targ.get("IPAdr");
         int iPort = Integer.parseInt(ctg_targ.get("IPSocket"));
         PromptUseDft();
/*
         try {
         PromptUseDft();
         } catch (IOException e) {
         System.out.println("Warning: IOException on System.in: Override Defaults Query failed.\n" +
                            "\nUsing Default Values. Proceed with that information, if you wish.");
         setdfY_N('N');
         }
*/
   }




/*
 * end of constructor
 *
*/

      public int tryit() {
         CA_bresp.clear();
         CA_Sresp.clear();
         Txn_resp.clear();
         TxnStDt.clear();
         TxnSpDt.clear();
         int rc = 0;
         String strChosenServer = null;  // used to select the target cics region
         String strInput = null;
         String strAns = null;
//
    //   String str_rem_cs = "cp1252";        // Windows CP
    //   String str_rem_cs = "cp1047";        // zOS CP
    //   String str_rem_cs = "cp819";                  // AIX CP

         String ctgrgn = ctg_targ.get("CTG");
         String strUrl = ctg_targ.get("IPAdr");
         String strFullUrl = null;
         int iPort = Integer.parseInt(ctg_targ.get("IPSocket"));
//         String rgnType = ctg_targ.get("RgnType");
         String useJKS = ctg_targ.get("JKS");        // derived jks setting
         String rgnOS = ctg_targ.get("CTG_OS");
         String str_rem_cs = ctg_targ.get("CTG_CP");        // from the kixports file
         String useSSL = ctg_targ.get("SSL");        // derived SSL setting

         int iECISvrct = 0;
         int iChoice = 0;
         // Display banner
         System.out.println("\nConnecting to Selected CTG:" + ctgrgn);
         String strServerNumber = null;
         String strSSLKeyring  = null;
         String strSSLPassword = null;

         // Process the command line arguments and display Gateway settings

        System.out.print("\nThe address of the Gateway has been set to ");
         System.out.println(strUrl + " Port:" + iPort + "\n");

         // Declare and initialize method variables and ECIRequest object n
    try {
         ECIRequest eciRequestObject = null;
         Channel reqChannel = new Channel("test_Ch");
         Channel dftChannel = new Channel("dft_ch");
         int EciNoXtnd = ECIRequest.ECI_NO_EXTEND;
         int EciXtnd = ECIRequest.ECI_EXTENDED;
         int i_eci_xtnd = EciNoXtnd;
         int i_eci_xLUW = 0;
         if (getrep_txn() > 0) {
           if (getXtnd_txn() == 'Y') {
             i_eci_xtnd = EciXtnd;
             i_eci_xLUW = ECIRequest.ECI_LUW_NEW;
           }
         }

         Properties sslProps = new Properties();
         if (useSSL.equals("Y")) {
           int SSLIndex = ctgrgn.indexOf("SSL");
           String ctgrgnX = ctgrgn.substring(0,SSLIndex);
           System.out.println("ctgrgnX:" + ctgrgnX + "\n");
           if (ctgrgnX.endsWith("D")) {
           String myJVM = System.getProperty("java.home");
           strSSLKeyring = myJVM.concat("\\lib\\security\\cacerts");
           strSSLPassword = "changeit";
           System.out.println("\nThis Gateway request is using SSL and cacerts default jks:" + "\n");
           System.out.println(strSSLKeyring + "\n");
           } else {
           System.out.println("Looking for JKS password separator (:)" + "\n");
           int ssl_pw_idx = useJKS.indexOf(":");
           if (ssl_pw_idx > 1) {
           System.out.println("found JKS password separator (:)" + ssl_pw_idx + "\n");
           strSSLPassword = useJKS.substring((ssl_pw_idx + 1));
           System.out.println("PW:" + strSSLPassword);
           useJKS = useJKS.substring(0,ssl_pw_idx);
           System.out.println("JKS:" + useJKS);
           } else {
           System.out.println("JKS password separator (:) not found\nUsing Default:" + "\n");
           strSSLPassword = "CICSabcd";
           }
           if ((useJKS.startsWith("/")) || (useJKS.startsWith("./"))) {
           System.out.println("Found JKS full or relative path:" + "\n");
           strSSLKeyring =  useJKS;
           System.out.println(strSSLKeyring + "\n");
           } else {
           strSSLKeyring = "\\RunCtg\\TestZOS\\" + useJKS + ".jks";
           System.out.println("Using default path to JKS:" + strSSLKeyring + "\n");
           }
         // Set the keyring and keyring password and then initialize
         // the JavaGateway object to flow data to the Gateway
           sslProps.setProperty(JavaGateway.SSL_PROP_KEYRING_CLASS, strSSLKeyring);
           sslProps.setProperty(JavaGateway.SSL_PROP_KEYRING_PW, strSSLPassword);
           System.out.print("\nThis Gateway request is using SSL jks:" + strSSLKeyring + "\n");
           strFullUrl = "SSL://";
           strFullUrl = strFullUrl.concat(strUrl);
           }
         } else {
           System.out.print("\nThis Gateway request is not using SSL\n");
           strFullUrl = "TCP://";
           strFullUrl = strFullUrl.concat(strUrl);
           }


         try {
            javaGatewayObject = new JavaGateway(strFullUrl, iPort, sslProps);
            } catch (Exception e) {
         e.printStackTrace();
         System.exit(30);
      }

         // Obtain a list of CICS servers defined

         // If an ECI_ERR_MORE_SYSTEMS error occurs this is because you have more servers
         // defined in your CICS TG configuration than the value stored in the iServerCount
         // variable. To solve this problem, increase the value assigned to iServerCount,
         // recompile and rerun this sample.
         int iServerCount = 460;
         eciRequestObject = ECIRequest.listSystems(iServerCount);
         System.out.println("MAX Servers count::" + iServerCount);
//         strAns = input.readLine().trim();
         flowRequest(eciRequestObject);

         // Ask for user to choose from the list of defined servers
         Set<String> ctg_targs = new HashSet<String>();
         do {
            if (eciRequestObject.SystemList.isEmpty() == true) {
               System.out.println("No CICS servers have been defined.");
               if (javaGatewayObject.isOpen() == true) {
                  javaGatewayObject.close();
               }
               System.exit(0);
            }
            iECISvrct = eciRequestObject.numServersReturned;
            System.out.println("ECI Servers count:" + iECISvrct);
            System.out.println("CICS Servers Defined:\n");
            for (int i = 0; i < eciRequestObject.numServersReturned; i++) {
               if (i < 9) {
                  strServerNumber = "\t " + (i + 1) + ". ";
               } else {
                  strServerNumber = "\t" + (i + 1) + ". ";
               }

               // Prints the name and description of the server as contained
               // in the SystemList vector
               String V = (String) eciRequestObject.SystemList.elementAt(2*i);
               ctg_targs.add(V);
               System.out.println
                (strServerNumber
                 + eciRequestObject.SystemList.elementAt(2*i) + " -"
                 + eciRequestObject.SystemList.elementAt((2*i)+1));
            }
            System.out.println("\n\nChoose Target Server (by number),"
                               + "a for ALL servers, or q to quit:");
            strInput = input.readLine().trim();
            if ((strInput).equalsIgnoreCase("q")) {
               if (javaGatewayObject.isOpen() == true) {
                  javaGatewayObject.close();
               }
               System.exit(0);
            }
            if ((strInput).equalsIgnoreCase("a")) {
              System.out.println("You Selected ALL CICS Regions.");
            }

            try {
               iChoice = java.lang.Integer.parseInt(strInput);
            } catch (java.lang.NumberFormatException e) {
               System.out.println("\n\nType the number of the "
                                  + "Server to connect to or q to quit\n");
               continue;
            }

            // Validate that the choice is in range using the
            // ECIRequest numServersReturned variable
            if (iChoice > 0 && iChoice <= eciRequestObject.numServersReturned)
            {  strChosenServer =
               (String)eciRequestObject.SystemList.elementAt(((iChoice-1)*2));
            } else {
               System.out.println("\n\nOut of Range\n");
            }
         } while (strChosenServer == null);


         System.out.println("\nServer::" + strChosenServer);

         String strProgram = getPN();
         String strTPNM = getMyTID();
         int iCommareaSize = getCAL();

         StringBuilder strComA = new StringBuilder(getMyCA());
         int n_l = iCommareaSize;
//         strComA.setLength(n_l);
         byte[] abytCommarea = new byte[iCommareaSize];
//         String SComA = strComA.toString();
//         System.out.println("CommareaLength>" + SComA.length());
//        System.out.println("Commarea>" + SComA);
 // Change #5 activate codepage conversion (ie  to and from zos)
 //      Use CP conversion when going to the zOS CICS
         String pnthex = "N";

 //
 // Top of the repeat loop
 //
     int cur_repeat_cnt = 0;
     int strComA_Len = 0;
     do {
       if (this.getCAorCnC().equals("CA")) {
         strComA.setLength(0);
         if (getDM() == 'P') {
          System.out.println("Iteration:" + (cur_repeat_cnt + 1) +
                             ":DataMode is Prompt. Enter next CA:");
          PGetCA(stdmyCA);
          strComA.append(getMyCA());
         } else {
         strComA.append(getMyCA_L(cur_repeat_cnt));
         }
         strComA_Len = strComA.length();
         strComA.setLength(n_l);
         String SComA = strComA.toString();
         System.out.println("True CommareaLength>" + strComA_Len +
                "\nSetting CommareaLength to>" + SComA.length());
         System.out.println("(True) Commarea>" + SComA.substring(0,strComA_Len) + '<');
         abytCommarea = SComA.getBytes(str_rem_cs);
         String aComStr = new String(abytCommarea);
         System.out.println("abytCommarea>" + aComStr.substring(0,strComA_Len) + '<');
         iCommareaSize = n_l;    // set above

         System.out.println("\nText from Commarea before flow (abytCommarea): "
                               + new String(abytCommarea).substring(0,strComA_Len) + '<');
       }
 //        eciRequestObject =
 //        new ECIRequest(ECIRequest.ECI_SYNC_TPN,  //ECI_SYNC call type eci_tranid CSMI
 //                                                 // or use ECI_SYNC_TPN for eci_tpn
 //                                                 // uses the user transid
 //                       strChosenServer,          //CICS server
 //                       null,                     //CICS userid
 //                       null,                     //CICS password
 //                       strProgram,               //CICS program to be run
 //                       null,                     //CICS transid to be run
 //                       abytCommarea,             //Byte array containing the
 //                                                 // COMMAREA
 //                       iCommareaSize,            //COMMAREA length
 //                       ECIRequest.ECI_NO_EXTEND, //ECI extend mode
 //                       0);                       //ECI LUW token
/*
 * TPNName ECIRequest.Call_Type = ECI_SYNC_TPN or ECI_ASYNC_TPN
 *                                and ECIRequest.Transid
 * TranName ECIRequest.Call_Type = ECI_SYNC or ECI_ASYNC
 *                                and ECIRequest.Transid
 * note that TPNNAME specification will use the eci transid as the runtime txn (if specified else csmi)
 */

         if (cur_repeat_cnt == 0) {
           if (use_ca_or_cNc.equals("CA")) {
             eciRequestObject =
               new ECIRequest(ECIRequest.ECI_SYNC_TPN,  //ECI call type
                        strChosenServer,          //CICS server
                        strMe,                     //CICS userid strMe or null
                        strMePW,                     //CICS password or null
                        strProgram,               //CICS program to be run
                        strTPNM,                  //CICS transid to be run strTPNM
                                                  // note that by setting ECI_SYNC_TPN, tells eci request
                                                  // that this is BOTH the TPNAME and TRANID
                        abytCommarea,             //Byte array containing the
                                                  // COMMAREA
                        iCommareaSize,            //COMMAREA length
                        i_eci_xtnd,               // getXtnd_txn() Y or N sets this value
//                        ECIRequest.ECI_NO_EXTEND, //ECI extend mode int value
                        i_eci_xLUW);               //ECI LUW token int
         //ECIRequest.ECI_EXTENDED ECIRequest.ECI_NO_EXTEND, //ECI extend mode
         // Call the flowRequest method and display returned data in hex and
         // ASCII format. If the method returns true a security error has
         // occurred and the user is prompted for a CICS user ID and password.
           } else {
             reqChannel = new Channel(getChNm());
             String dft_ch = "dft_ch";
             if (reqChannel.equals("dft_ch")) {
               dft_ch.concat("0");
             }
             dftChannel = new Channel(dft_ch);
             int cn_ct = CN_hset.size();
             for (String cnm:CN_hset) {
               reqChannel.createContainer(cnm, ctg_targ_CN_RQ.get(cnm));
               dftChannel.createContainer(cnm, ctg_targ_CN_RQ.get(cnm));
             }

             eciRequestObject =
               new ECIRequest(ECIRequest.ECI_SYNC_TPN,  //ECI call type
                        strChosenServer,          //CICS server
                        strMe,                     //CICS userid strMe or null
                        strMePW,                     //CICS password or null
                        strProgram,               //CICS program to be run
                        strTPNM,                  //CICS transid to be run strTPNM
                        reqChannel,                 //Channel
                         i_eci_xtnd,               // getXtnd_txn() Y or N sets this value
//                        ECIRequest.ECI_NO_EXTEND, //ECI extend mode int value
                        i_eci_xLUW);               //ECI LUW token int
           }
         } else {
//           if (this.use_ca_or_cNc.equals("CA")) {
           if (use_ca_or_cNc.equals("CA")) {
           eciRequestObject.Commarea = abytCommarea;
           eciRequestObject.Commarea_Length = iCommareaSize;
           } else {
             for (Container tmp_cn: reqChannel.getContainers()) {
               reqChannel.deleteContainer(tmp_cn.getName());
             }
             for (Container tmp_cn: dftChannel.getContainers()) {
               reqChannel.copyContainer(tmp_cn.getName(), dftChannel);
             }
           }
          }

         short s_int = (short) getEciTO();

         eciRequestObject.setECITimeout(s_int);   // added 20120202
         // while condition here depends on the success of the flow request;
         //  flow request will return 'false' if it was successful
         //  so we would not enter this again unless the flow got a error response
// this is top of the flow loop - loop until we get good resp of MaxFlowAttempts
         while ((flowRequest(eciRequestObject) == true) && RetryInd){
           if (use_ca_or_cNc.equals("CA")) {
           System.out.println("\nText from Commarea on retry (abytCommarea):\n "
                               + new String(abytCommarea));
                      for (int q = 0; q < 200; q++) {
                       System.out.print(Integer.toHexString(abytCommarea[q]));
                      }
           } else {
           System.out.println("\nRetry for Channel:" + getChNm());
           System.out.println(reqChannel.getContainers());
           }

         h_strMe = strMe;
         h_strMePW = strMePW;

         PromptGetNM_PW_agn();

         eciRequestObject.Userid = strMe;
         eciRequestObject.Password = strMePW;
         iValidationFailed++;    // compare to MaxFlowAttempts
         }
         if ( RetryInd ) {
           StringBuffer txnR = new StringBuffer();
           txnR.append("\nTransid>" + strTPNM + "< Userid>" + strMe).append(
               "\nProgram " + strProgram  + " returned with data.");
           if (use_ca_or_cNc.equals("CA")) {
           int ca_len = eciRequestObject.Commarea_Length;
           CA_bresp.add(eciRequestObject.Commarea);

           String ret_ComA = new String(eciRequestObject.Commarea,0,eciRequestObject.Commarea_Length,str_rem_cs);
           CA_Sresp.add(ret_ComA);

         txnR.append("\nReported ECI CommareaLen: " + ca_len).append(
               "\tStrLen of CommareaLen: " + ret_ComA.length()).append(
               "\nReturning Commarea variable:ret_ComA: CP converted:").append("\nText\n");
          } else {
          txnR.append("\nReturned Container:");
          for (Container tmp_cn: reqChannel.getContainers()) {
            String tmp_cn_nm = tmp_cn.getName();
            if (tmp_cn.getType() == Container.ContainerType.BIT){
               byte[] data = tmp_cn.getBITData();
               hm_ctg_targ_CN_RP_Bit.put(tmp_cn_nm, Arrays.toString(data));
               txnR.append("\n" + tmp_cn.getName().trim() + ":BIT:");
             }
             if (tmp_cn.getType() == Container.ContainerType.CHAR){
               String data = tmp_cn.getCHARData();
               hm_ctg_targ_CN_RP_Char.put(tmp_cn_nm, data);
               txnR.append("\n" + tmp_cn.getName().trim() + ":CHAR:");
             }
             reqChannel.deleteContainer(tmp_cn.getName());
             }
        }
         Txn_resp.add(txnR.toString());
         System.out.println("Saved Txn details (" + use_ca_or_cNc + ") for iteration:" + (cur_repeat_cnt + 1));
         }
         if ((getrep_txn() > 0) && cur_repeat_cnt < getrep_txn()) {
             System.out.println("\nFinished Repeat Iteration #" +
                                (cur_repeat_cnt + 1) + " of " + (getrep_txn() + 1));
           if (getwt_txn() > 0) {
             System.out.println("\n\nSleeping " + (getwt_txn() / 1000) + " seconds...");
             EciSleep(getwt_txn());
           }
           System.out.println("____________________");
         }
  // end of repeat loop
         cur_repeat_cnt++;
         } while (cur_repeat_cnt <= getrep_txn());
         // issue SYNC if necessary
         if (getXtnd_txn() == 'Y') {
            eciRequestObject.Extend_Mode = ECIRequest.ECI_COMMIT;
            eciRequestObject.Call_Type = ECIRequest.ECI_SYNC;
            eciRequestObject.Program = null;
            javaGatewayObject.flow(eciRequestObject);
            }

         // Close the JavaGateway object before exiting
         if (javaGatewayObject.isOpen() == true) {
            javaGatewayObject.close();
         }
// end of tryit: first try..catch logic
      } catch (Exception e) {
         e.printStackTrace();
         rc = 8;
      }
      return rc;
   }

   // The flowRequest method flows data contained in the ECIRequest object to
   // the Gateway and determines whether it has been successful by checking the
   // return code. If an error has occurred, the return code string and abend
   // codes are printed to describe the error before the program exits.
   // Note: Security may be required for client connection to the server and
   //       not just for the ECI request. Refer to the security chapter in the
   //       CICS Transaction Gateway Administration book for further details.
      // remove static from below -
   private  boolean flowRequest(ECIRequest requestObject) {
      try {
         Date startDt = new Date();
         int iRc = javaGatewayObject.flow(requestObject);
         Date stopDt = new Date();
         // Checks for gateway errors and returns false if there are no errors
         System.out.println("\nReturn from Gateway");

         switch (requestObject.getCicsRc()) {
         case ECIRequest.ECI_NO_ERROR:
            if (iRc == 0) {
               TxnStDt.add(startDt);
               TxnSpDt.add(stopDt);
               return false; // when successful, we set 'retry' to false
            } else {
               System.out.println("\nError from Gateway ("
                                  + requestObject.getRcString()
                                  + "), correct and rerun this sample");
               if (javaGatewayObject.isOpen() == true) {
                  javaGatewayObject.close();
               }
               System.exit(0);
            }

         // Checks for security errors and returns true if validation has
         // failed on four or less occasions
         case ECIRequest.ECI_ERR_SECURITY_ERROR:
            if (iValidationFailed == 0) {
               return true;
            }
            System.out.print("\n\nValidation failed. ");
            if (iValidationFailed < this.getMaxFA()) {   // MaxFlowAttempts
               System.out.println("Try entering your details again.");
               return true;
            }
            break;

         // Checks for transaction abend errors where the user is authorised
         // to access the server but not run the EC01 program.
         // The sample should be rerun and a user ID and password with the
         // required authorisation entered.
         case ECIRequest.ECI_ERR_TRANSACTION_ABEND:
            System.out.println("\nYou are not authorised to run this transaction.");
            break;

         case ECIRequest.ECI_ERR_REQUEST_TIMEOUT:
            System.out.println("\nECI Transaction  TimeOut");
            break;

         }
         System.out.println("\nECI returned: "
                            + requestObject.getCicsRcString());
         System.out.println("Abend code was "
                            + requestObject.Abend_Code + "\n");
         if (javaGatewayObject.isOpen() == true) {
            javaGatewayObject.close();
         }
         System.exit(0);

      } catch (Exception e) {
         e.printStackTrace();
         System.exit(0);
      }
      return true;   // if we are here, then we want a 'retry'
   }
}
//
//         File Name     : EciB1e.java

package TestZOS;

import java.lang.*;
import java.util.*;
import java.text.*;
import java.io.*;
import java.nio.charset.*;
import java.util.Properties;
import java.util.concurrent.TimeUnit;
import java.lang.InterruptedException;
import java.math.*;

//import TestZOS.*;

import com.ibm.ctg.client.*;

public class EciB1e {
   final String RunEci_V = "EciB1e V1.1";
   // Declare objects for use in both methods
   private static JavaGateway javaGatewayObject;

   private static InputStreamReader isr = new InputStreamReader(System.in);
   private static BufferedReader input = new BufferedReader(isr);
   private static int iValidationFailed = 0;
   private static HashMap<String, String> ctg_targ = new HashMap<String, String>();
   private static ArrayList<byte[]> CA_bresp = new ArrayList<>();
   private static ArrayList<String> CA_Sresp = new ArrayList<>();
   private static ArrayList<String> Txn_resp = new ArrayList<>();
   private static ArrayList<Date> TxnStDt = new ArrayList<>();
   private static ArrayList<Date> TxnSpDt = new ArrayList<>();

   //Name of the CICS program to execute
   // private String ProgramName = "PONG";    // commarea only
   private String ProgramName = "UCEMPINR";
   public void PromptPN(String PN) {

     if (PN.equals("")) {
       PN = getPN();
     }
     System.out.println("Selected CICS Target Program:" + PN);
     System.out.print("Enter Different CICS Target Program:");
     try {
     PN = input.readLine().trim().toUpperCase();
     setPN(PN);
     } catch (IOException e) {
       System.out.println("Error. IOException reading Target Program. Using Default.");
      }
     System.out.println("\nUsing CICS Target Program:" + getPN());
     }
   public void setPN(String PN)
   {
     if ((PN.length() > 0) && (PN.length() < 9 )) {
       ProgramName = PN;
     }
   }
   public String getPN() {
       return ProgramName;
   }

   //Name of the CICS Transid to execute
   private String MyTransid = "UXXX";
   public void PromptTID(String TID) {
     if (TID.equals("")) {
       TID = getMyTID();
     }
     System.out.print("Enter Different TRANSID:" + TID);
     try {
     TID = input.readLine().trim().toUpperCase();
     if ((TID.length() > 0) && (TID.length() < 5)) {
       setMyTID(TID);
       }
      } catch (IOException e) {
       System.out.println("Error. IOException reading Target TRANSID. Using Default.");
     }
     System.out.print("\nUsing TRANSID:" + getMyTID());
    }
   public void setMyTID(String TID) {
     if ((TID.length() > 0) && (TID.length() < 5 )) {
       MyTransid = TID.toUpperCase();
       MyMirrorTransId = MyTransid;
     }
   }
   public String getMyTID() {
     return MyTransid;
   }
   //Name of the CICS Transid that mirror is to execute
   private String MyMirrorTransId = MyTransid;

//Maximum number of flow attempts
   private int MaxFlowAttempts = 3;
   public void PromptFA(int FA) {
     if ( FA == 0) {
       FA = getMaxFA();
     }
     System.out.println("Current FLOW Retry Setting:" + FA);
     System.out.print("Enter Different FLOW Setting:");
     try {
     FA  = Integer.parseInt( input.readLine().trim() );
     setMaxFA(FA);
     } catch (NumberFormatException e) {
      System.out.println("Error: NumberFormatException Reading FlowAttempts. Using Default.");
      } catch (IOException e) {
       System.out.println("Error. IOException reading FLOW Setting. Using Default.");
     }
     System.out.println("\nUsing FLOW Retry Setting:" + getMaxFA());
    }
   public void setMaxFA(int FA) {
     if ((FA > 0) && (FA < 5 )) {
       MaxFlowAttempts = FA;
     }
   }
   public int getMaxFA() {
       return MaxFlowAttempts;
   }

   // Set program to use CA or cNc
   private String use_ca_or_cNc = "CA";
   //private string use_ca_or_cNc = "cNc";
   public void PromptCnC(String use_ca_or_cNc) {
     if (use_ca_or_cNc.equals("")) {
       use_ca_or_cNc = "CA";
     }
     System.out.print("Select Data Model:\n'CA' for Commarea,\nor 'CnC' for Channel and Container(s):" + use_ca_or_cNc);
     try {
     use_ca_or_cNc = input.readLine().trim().toUpperCase();
     } catch (IOException e) {
       System.out.println("Error. IOException reading Data Model. Using Default.");
     }
     if (!(use_ca_or_cNc.equals("CA")) && !(use_ca_or_cNc.equals("CNC"))) {
       use_ca_or_cNc = "CA";
       }
    System.out.print("\nUsing Data Model:" +  use_ca_or_cNc);
    }

   public String getCnC() {
     return use_ca_or_cNc;
   }

   //Name of Channel to pass to EC03 program
   private String CHANNEL_NAME = "PONG_Channel";   // max 16
   public void PromptChanNm(String ChanNm) {
     if (ChanNm.equals("")) {
       ChanNm = CHANNEL_NAME;
     }
     System.out.print("Enter CHANNEL_NAME:" + ChanNm);
     try {
     ChanNm = input.readLine().trim();
     if ((ChanNm.length() > 0) && (ChanNm.length() < 17)) {
       CHANNEL_NAME = ChanNm;
       }
     } catch (IOException e) {
       System.out.println("Error. IOException reading CHANNEL_NAME. Using Default.");
     }
     System.out.print("\nUsing CHANNEL_NAME:" + CHANNEL_NAME);
    }

   //Name of Container to pass to EC03 program
   private String CONTAINER_NAME = "PONGCNCCONTNR";   //max 16
   public void PromptContNm(String ContNm) {
     if (ContNm == "") {
       ContNm = CONTAINER_NAME;
     }
     System.out.print("Enter CONTAINER_NAME:" + ContNm);
     try {
     ContNm = input.readLine().trim();
     if ((ContNm.length() > 0) && (ContNm.length() < 17)) {
       CONTAINER_NAME = ContNm;
       }
     } catch (IOException e) {
       System.out.println("Error. IOException reading CONTAINER_NAME. Using Default.");
     }
     System.out.print("\nUsing CONTAINER_NAME:" + CONTAINER_NAME);
    }

   //The size of the COMMAREA to send to the program - This can be 0 - 32400
   private int CAL = 4080;
   public void PromptCAL(int ca_len) {
     int h_ca_len;
     if ( ca_len == 0) {
       ca_len = getCAL();
     }
     h_ca_len = ca_len;
     System.out.println("Current CA Length Setting:" + ca_len);
     System.out.print("Enter Different CA Length Setting:");
      String s_ca_len = "";
     try {
      s_ca_len = input.readLine().trim();
      ca_len  = Integer.parseInt(s_ca_len);
      } catch (NumberFormatException e) {
        if ((s_ca_len.equals("=")) || (s_ca_len.equals(""))) {
          ca_len = h_ca_len;
        } else {
          System.out.println("Error: NumberFormatException Reading CAL. Using Default.");
          ca_len = getCAL();
        }
      } catch (IOException e) {
       System.out.println("Error. IOException reading FLOW Setting. Using Default.");
       ca_len = h_ca_len;
      } finally {
       setCAL(ca_len);
      }
     System.out.println("\nUsing CA Length Setting:" + getCAL());
    }
   public void setCAL(int ca_len) {
     if ((ca_len >= 0) && (ca_len <= 32400 )) {
       CAL = ca_len;
     }
   }
   public int getCAL() {
       return CAL;
   }

   //The size of the COMMAREA to send to the program
//   private String stdmyCA = "Ponged from JAVA EciB1e on my desktop!!";
   private String stdmyCA = "CEMT INQUIRE SYSTEM";
   private String CA = "CEMT INQUIRE TASK";
   private ArrayList<String> CA_aryL = new ArrayList<>();
   private ArrayList<Integer> CA_aryLen = new ArrayList<>();
   protected void setDfltCA() {
    CA_aryL.add(CA);
   }
   public void PromptGetCA(String tmp_ca) {
     String tCA = "";
     CA_aryL.clear();
     int repct = getrep_txn();
     char repDM = getDM();
     if (repDM == 'S') {
       PGetCA(stdmyCA);
       tCA = getMyCA();
       for (int i = 0; i <= repct; i++) {
         CA_aryL.add(tCA);
         CA_aryLen.add(tCA.length());
         }
       System.out.println("Data Mode 'S' Static CA set for all (" + (repct + 1) + ") iterations.");
       return;
     }
     if (repDM == 'E') {
       for (int i = 0; i <= repct; i++) {
         System.out.println("\nEnter CA for iteration:" + (i + 1));
         PGetCA(stdmyCA);
         tCA = getMyCA();
         CA_aryL.add(tCA);
         CA_aryLen.add(tCA.length());
         }
       System.out.println("Data Mode 'E' Each CA individually set. Total " + (repct + 1) + " iterations set.");
       return;
     }
     if (repDM == 'F') {
       String fin = DMDFN;
       int rdct = 0;
         FileInputStream fis = null;
         BufferedReader br = null;
         try {
         fis = new FileInputStream(fin);
         //Construct BufferedReader from InputStreamReader
         br =  new BufferedReader(new InputStreamReader(fis));
         String line = null;
         while ((line = br.readLine()) != null) {
          rdct++;
          tCA = line.trim();
          CA_aryL.add(tCA);
          CA_aryLen.add(tCA.length());
         }
         repct++;
         if (rdct < repct) {
         System.out.println("Repeat count:" + repct + " does not match command count from file:" +
         rdct + ". Reducing Repeat count.");
         setrep_txn(rdct - 1);
         }
         if (rdct > repct) {
         System.out.println("Repeat count:" + repct + " does not match command count from file:" +
         rdct + ". Commands greater than Repeat count ignored.");
         }
        System.out.println("Data Mode 'F' Each CA individually set for " + (getrep_txn() + 1) + " iterations.");
        br.close();
       } catch (IOException e) {
         System.out.println("Error. Could not read file with Commarea List. Goodbye!");
         e.printStackTrace();

       } finally {
         try {
           if (br != null) {
             br.close();
             }
           } catch (IOException e) {
           e.printStackTrace();
         }
       }
       return;
     }
   }

 public String PromptChoice(String Msg, String Inst, String opts) {
     String msgboxans = "";
     String dft_ans = "";
     String dft_hint = "";
     String ans = "";
     int optsl = opts.length();
     if (optsl == 0) {
       dft_ans = "";
       dft_hint = "Press anykey to Continue";
     } else {
       opts = opts.toUpperCase();
       dft_ans = opts.substring(0,1);
       dft_hint = "Valid Reponse is one of <" + opts + "> Default Response is<" + dft_ans + ">";
     }
     System.out.println("------------------------------------------------------");
     System.out.println(Msg);
     System.out.println("------------------------------------------------------");
     String tmp = "";
     do {
     System.out.print(Inst);
     try {
     tmp = input.readLine().trim().toUpperCase();
     if (optsl == 0) {
       return "";
     }
     if (tmp.length() > 0) {
       ans = tmp.substring(0,1);
       if (opts.contains(ans)) {
         return ans;
         }
       } else {
       ans = "";
       }
     System.out.println("Your response:'" + ans + "': is not an Option. Retry.");
     } catch (IOException e) {
      System.out.println("Error. IOException reading your response. Retry.");
      }
     System.out.print(dft_hint);
     ans = "";
   } while(msgboxans.equals(""));
   return ans;
   }

   public String getMyCA_L(int ca_num) {
     if ((ca_num < 0) || ca_num > CA_aryL.size()) {
       return "";
     }
     return CA_aryL.get(ca_num);
   }

   private void PGetCA(String tmp_ca) {
     if (tmp_ca.equals("")) {
       tmp_ca = stdmyCA;
     }
     String tmp1 = tmp_ca;
     String h_tmp_ca = tmp_ca;
     if (tmp_ca.length() > 70) {
       tmp1 = tmp_ca.substring(0,34) + ".." +  tmp_ca.substring(tmp_ca.length() - 34);
     }
     String ans = "";
     String opts = "NYD=";
     do {
     System.out.print("Enter Different Commarea:\n" + tmp1 +"\n");
     ans = "Y";
     try {
     tmp_ca = input.readLine().trim();
     int tmp_cal = tmp_ca.length();
     if (tmp_cal == 0) {
      ans = PromptChoice("CammArea data expected.\nYour Response was zero length. Default GA is\n",
                          "Select Y to use zero length CommArea\nOr N to retry\nOr '=' to use Default CA:",
                          opts);
      if (ans.equals("D") | ans.equals("=")) {
        ans = "Y";
        tmp_ca = getMyCA();
       }
     }
     if (ans.equals("Y")) {
     if (tmp_cal > 32400) {
       tmp_cal = 32400;
       tmp_ca = tmp_ca.substring(0,32399);
     }
     if (tmp_ca.equals("=")) {
       tmp_ca = h_tmp_ca;
     }

     setMyCA(tmp_ca);
     if (tmp_cal > getCAL()) {
         setCAL(tmp_cal);
       }
      }
     } catch (IOException e) {
      System.out.println("Error. IOException reading CommArea. Using Default.");
      }
     } while(ans.equals("N"));
    tmp1 = getMyCA();
    if (tmp1.length() > 70) {
       tmp1 = tmp1.substring(0,34) + ".." +  tmp1.substring(tmp1.length() - 34);
     }
    System.out.print("Commarea:\n" + tmp1 + "\n");
   }

   public void setMyCA(String tmp_ca) {
     int tmp_cal = tmp_ca.length();
     if (tmp_cal > 32400) {
       tmp_cal = 32400;
       tmp_ca = tmp_ca.substring(0,32399);
     }
     CA = tmp_ca;
     if (tmp_cal > getCAL()) {
         setCAL(tmp_cal);
       }
   }
   public String getMyCA() {
     return CA;
   }


   //Repeat Non/Xtended transaction 0-98 times, waiting 0-10000 ms between calls
   //private  int  rep_txn = 0; // 0 means NO repeats Itotal:1 executon)
   private int  rep_txn = 0;
   private int  min_rep_txn = 0, max_rep_txn = 98;
   public void PromptRepNum(int repnum) {
     if ( repnum == 0) {
       repnum = getrep_txn();
     }
     System.out.println("Current Repeat Transaction Count Setting:" + repnum);
     System.out.println("NOTE - Zero (0) Repeats implies Run once;\nOne (1) implies Run Twice,...");
     System.out.print("Enter Different Repeat Transaction Count Setting:");
     try {
     repnum  = Integer.parseInt( input.readLine().trim() );
     setrep_txn(repnum);
     } catch (NumberFormatException e) {
      System.out.println("Error: NumberFormatException Repeat Setting. Using Default.");
      } catch (IOException e) {
      System.out.println("Error. IOException reading Repeat Setting. Using Default.");
      }
     System.out.println("\nUsing Repeat Transaction Count Setting:" + getrep_txn());
    }
   public void setrep_txn(int repnum) {
     if ((repnum >= min_rep_txn) && (repnum <= max_rep_txn )) {
       rep_txn = repnum;
     }
   }
   public int getrep_txn() {
       return rep_txn;
   }

   // repeat txn datamode 'S' indicates static Datamodel on each eci flow
   //                     'P' indicates Prompt for each Datamodel contents for each iteration
   //                     'E' indicates Datamodel for each iteration setup prior to first iteration
   //                     'F' indicates a file provides the data for each iteration
   private char DMD = 'S';

   public void PromptRepDMD(char tmp) {
     System.out.print("Repeat Count is greater than 0. Choose a DataMode for the Datamodel" +
                        "\n'S' indicates static Datamodel on each eci flow" +
                        "\n'P' indicates Prompt for each Datamodel contents for each iteration" +
                        "\n'E' indicates Datamodel for each iteration setup prior to first iteration" +
                        "\n'F' indicates a file provides the data for each iteration" +
                        "\nMake a selection (default is 'S' static:");

//     Scanner s= new Scanner(System.in);
//     char xtnd = s.next().charAt(0);
//     xtnd = Character.toUpperCase(s.next().charAt(0));
     try {
     String Stmp = input.readLine().trim().toUpperCase();
     if (Stmp.length() > 0) {
       int i = setDM(Stmp.charAt(0));
       if (i > 0 ) {
         System.out.print("\nInvalid Data Mode selection: Using Default.");
       }
      }
     } catch (IOException e) {
      System.out.println("Error. IOException reading Data Mode Setting. Using Default.");
      }
    System.out.println("\nUsing DataMode:" + getDM());
    }
   public int setDM(char tmp) {
     tmp = Character.toUpperCase(tmp);
     if ((tmp == 'S') || (tmp == 'P') || (tmp == 'E') || (tmp == 'F') ) {
       DMD = tmp;
       return 0;
     } else {
       DMD = 'S';
       return 4;
       }
   }
   public char getDM() {
     return DMD;
   }

   private String DMDFN = "";
   protected void DMD_getFN() {
     String dmfn = "";
     do {
     System.out.print("Data Mode is File. Enter full filename for DataModel Data (or 'x' to Quit):");
     try {
     dmfn = input.readLine().trim();
     if (dmfn.equalsIgnoreCase("x")) {
       System.out.println("Quit Selected. Goodbye.");
       System.exit(8);
     }
     if ((dmfn.length() < 1) || (dmfn.length() > 240)) {
     System.out.println("\nError: file:" + dmfn + " is not correct length." +
       "\nRetry entry of filename for DataModel.");
       dmfn = "";
       }
     } catch (IOException e) {
      System.out.println("Error. IOException reading File Name for Data Mode. Using Default.");
      dmfn = "";
      }
     } while (dmfn.equals(""));

     File f = new File(dmfn);
     if (f.exists() && !f.isDirectory()) {
      DMDFN = dmfn;
      System.out.print("\nUsing file:" + DMDFN + " for Data Mode Data");
     } else {
      System.out.print("\nUsing file:" + dmfn + " is not found.\nChanging DataMode to 'S'");
      int i = setDM('S');
     }
   }

   //private int  wt_txn = 0; // 0 means no wait time between txn
   private long  wt_txn = 0;
   private static final long  min_wt_txn=0 * 1000, max_wt_txn = 99*1000;  // in millisec
   public void PromptWtInvl(long wtnum) {
     if ( wtnum == 0) {
       wtnum = getwt_txn();
     }
     System.out.println("Current Wait Between Transactions Setting (seconds):" + wtnum);
     System.out.print("Enter Different Wait Between Transactions Setting:");
     String S_ans = "";
     double ans = 0.00;
     Double FD_ans = ans;

     try {
      S_ans  = input.readLine().trim().toUpperCase();
      ans  = Double.parseDouble( S_ans);
      BigDecimal BD_ans = new BigDecimal(ans).setScale(2,BigDecimal.ROUND_HALF_UP);
      FD_ans= new Double(BD_ans.doubleValue());
    // now convert to long and make the long millesecs
       wtnum  = Math.round(FD_ans * 1000);
       setwt_txn(wtnum);
       } catch (NumberFormatException e) {
       System.out.println("Error: NumberFormatException Wait Interval. Using Default.");
       } catch (IOException e) {
       System.out.println("Error. IOException reading Wait Interval. Using Default.");
      }
     System.out.println("\nUsing Wait Between Transactions Setting (millisecs):" + getwt_txn());
      }
   public void setwt_txn(long wtnum) {
     if ((wtnum >= min_wt_txn) && (wtnum <= max_wt_txn )) {
       wt_txn = wtnum;
     }
   }
   public long getwt_txn() {
       return wt_txn;
   }

   private void EciSleep(long sleep_MS)
     throws InterruptedException {
   try {
     if ( sleep_MS < min_wt_txn ) {
        sleep_MS = min_wt_txn;
        System.out.println("Sleep Value too small: setting to:" + sleep_MS);
     } else {
        if ( sleep_MS > max_wt_txn ) {
        sleep_MS = max_wt_txn;
        System.out.println("Sleep Value too large: setting to:" + sleep_MS);
        }
     }
    TimeUnit.MILLISECONDS.sleep(sleep_MS);
   } catch (InterruptedException e) {
        System.out.print("Warning:EcioB1e:Sleep: Interrupted:");
        System.out.println(e.toString());
        assert false;
        //Handle exception
     }
   }

   //private char  Xtnd_txn = "N"; // "N" means individual txn in repeat cycle
   // "Y" means use LUW information for single LUW
   private char Xtnd_txn = 'N';

   public void PromptXtnd(char xtnd) {
     System.out.print("(This options requires CICS RRS=YES)\nEnter Extend Transaction Y or N:" + xtnd);
//     Scanner s= new Scanner(System.in);
//     char xtnd = s.next().charAt(0);
//     xtnd = Character.toUpperCase(s.next().charAt(0));
     try {
      String tmp = input.readLine().trim().toUpperCase();
      if (tmp.length() > 0) {
       xtnd = tmp.charAt(0);
      }
      setXtnd_txn(xtnd);
      } catch (IOException e) {
      System.out.println("Error:IOException getting Override Values. Using Default.");
      }
     System.out.print("\nUsing Extend Transaction:" + getXtnd_txn());
    }
   public void setXtnd_txn(char xtnd) {
     xtnd = Character.toUpperCase(xtnd);
     if ((xtnd == 'N') || (xtnd == 'Y')) {
       Xtnd_txn = xtnd;
     }
   }
   public char getXtnd_txn() {
     return Xtnd_txn;
   }

   private int eci_TO = 0;
   private static final int  min_TO=0 * 1000, max_TO = 99*1000;  // in millisec
   public void PromptEciTO(int TOnum) {
     if ( TOnum == 0) {
       TOnum = getEciTO();
     }
     System.out.println("Current ECI TimeOut Transactions Setting (seconds):" + TOnum);
     System.out.print("Enter Different ECI TimeOut Transaction Setting:");
     String S_ans = "";
     double ans = 0.00;
     Double FD_ans = ans;

     try {
      S_ans  = input.readLine().trim().toUpperCase();
      ans  = Double.parseDouble( S_ans);
      BigDecimal BD_ans = new BigDecimal(ans).setScale(2,BigDecimal.ROUND_HALF_UP);
      FD_ans= new Double(BD_ans.doubleValue());
    // now convert to long and make the long millesecs
       TOnum  = (int) Math.round(FD_ans * 1000);
       } catch (NumberFormatException e) {
       System.out.println("Error: NumberFormatException ECI TimeOut. Using Default.");
       } catch (IOException io) {
       System.out.println("Error: IOException ECI TimeOut. Using Default.");
       }
       setEciTO(TOnum);
       System.out.println("\nUsing ECI TimeOut Transaction Setting (millisecs):" + getEciTO());
      }
   public void setEciTO(int TOnum) {
     if ((TOnum >= min_TO) && (TOnum <= max_TO )) {
       eci_TO = TOnum;
     }
   }
   public int getEciTO() {
       return eci_TO;
   }

   private char chgdfY_N = 'N';
   public void PromptUseDft() {
     char ansY_N = 'N';
     System.out.println("------------------------------------------------------");
     System.out.println("Default settings:\nProgramName:" + ProgramName +
                        "\nTRANSID:" + MyTransid +
                        "\nData Model:" + use_ca_or_cNc +
                        "\nDefault CA:" + getMyCA() +
                        "\nDefault CA Length:" + getCAL() +
                        "\nMaxFlowAttempts:" + MaxFlowAttempts +
                        "\nRepeat Transaction:" + rep_txn +
                        "\nWait Between Trans:" + wt_txn +
                        "\nExtended Trans:" + Xtnd_txn +
                        "\nEci TimeOut:" + getEciTO());
     System.out.println("------------------------------------------------------");
     System.out.print("Press 'Y'<enter> to Change Values,\n\n Press anyotherkey<enter> to use Defaults," +
                      "\nOr 'Q' to Quit:");
//     Scanner s= new Scanner(System.in);
//     char xtnd = s.next().charAt(0);
     try {
     String tmp = input.readLine().trim().toUpperCase();
     if (tmp.length() > 0) {
       ansY_N = tmp.charAt(0);
     }

    if (ansY_N == 'Q') {
      System.out.println("CTG Selection was 'Q' (QUIT). GoodBye.");
      System.exit(4);
    }
     if (ansY_N == 'Y') {
     System.out.println("\nPrompting for Overrides to Defaults!");
     } else {
     System.out.println("\n(Entered:" + ansY_N + ") Using Defaults!");
     }
     setdfY_N(ansY_N);
     } catch (IOException e) {
     System.out.println("\nError (IOException).Entered:" + ansY_N + ") Using Defaults!");
     }
   }

   private void setdfY_N(char ansY_N) {
     if (ansY_N != 'Y') {
       ansY_N = 'N';
     }
     chgdfY_N = ansY_N;
   }
   public char getdfY_N() {
     return chgdfY_N;
   }
   // hld_pw - holds PW between iterations because cics nulls it out

   private String strMe = "";
   private String h_strMe = "";
   private String strMePW = "";
   private String h_strMePW = "";

//private boolean RetryInd = true;  // used to retry failed transaction FLOW
// true means retry up to retry attempts
   private boolean RetryInd = true;

   private void PromptGetNM_PW() {
     try {
        Console c = System.console();
        if (c == null) {
            System.out.println("\nEnter your CICS User ID:");
            strMe = input.readLine().trim();
            System.out.println("\nEnter your CICS Password:");
            strMePW = input.readLine().trim();
            } else {
            strMe = c.readLine("Enter your CICS User ID:");
            strMePW = new String (c.readPassword("Enter your CICS Password:"));
            }
         h_strMe = strMe;
         h_strMePW = strMePW;
         } catch (IOException e) {
         System.out.println("Error: CICS UserID and Password Required" );
         System.exit(12);
         }
     }

   private void PromptGetNM_PW_agn() {
     try {
        Console c = System.console();
        if (c == null) {
            System.out.println("\nEnter your CICS User ID \n or '=' to use same Userid\n or 'x' to exit:");

            strMe = input.readLine().trim();
             if (strMe.toUpperCase().equals("X")) {
               RetryInd = false;
               //break;
            }
            if (strMe.equals("=")) {
             strMe = h_strMe;
            }
            System.out.println("\nEnter your CICS Password\n or '=' to use same Password\n or 'x' to exit:");
            strMePW = input.readLine().trim();
            if (strMePW.toUpperCase().equals("X")) {
               RetryInd = false;
              // break;
            }
            if (strMePW.toUpperCase().equals("=")) {
             strMePW = h_strMePW;
            }
            } else {
            strMe = c.readLine("\nEnter your CICS User ID \n or '=' to use same Userid\n or 'x' to exit:");
            if (strMe.toUpperCase().equals("X")) {
               RetryInd = false;
              // break;
            }
            if (strMe.equals("=")) {
             strMe = h_strMe;
            }

            strMePW = new String (c.readPassword("\nEnter your CICS Password\n or '=' to use same Password\n or 'x' to exit:"));
            if (strMePW.toUpperCase().equals("X")) {
               RetryInd = false;
              // break;
            }
            if (strMePW.equals("=")) {
             strMePW = h_strMePW;
            }
        }
     } catch (IOException e) {
       System.out.println("Error: CICS UserID and Password Required" );
       System.exit(12);
       }
   }

   protected void fmtDt(Date stDt, Date spDt) {
     SimpleDateFormat formatter;  // Formats the date displayed
     formatter = new SimpleDateFormat ("EEE MMM yyyy dd kk:mm:ss.S", Locale.getDefault());
     String SD = formatter.format(stDt);
     String PD = formatter.format(spDt);
     long millis = spDt.getTime() - stDt.getTime();
     System.out.println("StartTime:" + SD + "\nStop Time:" + PD + "\nResponse (Millsec):" + millis);
     }

   //The size of the console dump display data
   private int OP_max_size = 1600; // 1600 is 100 16 bytes at a time
   // pnthex needs to be compiled to 'Y' if you want a dump of the CA byte array(s)
   private char pnthex = 'N';

   public void PromptPntHex() {
     System.out.print("Hex Dump " + OP_max_size + " bytes from DataMode Data (Y/N):" );
     String Stmp = "";
     do {
      try {
       Stmp = input.readLine().trim().toUpperCase();
       if (Stmp.length() > 0) {
         char tPH = Stmp.charAt(0);
         if ((tPH != 'Y' ) && (tPH != 'N')) {
          System.out.print("\nInvalid selection: Try Again." );
          Stmp = "";
         } else {
           pnthex = tPH;
         }
       }
      } catch (IOException e) {
      System.out.println("Error. Invalid Print Hex selection. Try Again'");
      Stmp = "";
      }
      System.out.println("\nUsing Hex Dump Selection response was:" + pnthex);
     } while (Stmp.equals(""));
    }
   private String Save2FN = "";
   protected String getSavFN() {
     return Save2FN;
   }

   public void SaveData() {
     File f = null;
     char t_save = '-';
     char tPH;
     String Stmp = "";
     System.out.println("Save DataMode Data to file?(N/Y/R/A):" );

     do {
     System.out.print("N - No\nY - Yes (both Raw and ASCII)\nR - Raw Data Only\nA - ASCII Data Only:");
     try {
     Stmp = input.readLine().trim().toUpperCase();
     if (Stmp.length() > 0) {
       tPH = Stmp.charAt(0);
       if ((tPH != 'Y' ) && (tPH != 'N') && (tPH != 'R' ) && (tPH != 'A')) {
         System.out.print("\nInvalid selection: Try Again or 'N' to bypass Save:" );
         } else {
         t_save = tPH;
         }
        }
       } catch (IOException e) {
         System.out.println("Error Response. Try again.");
       }
       } while (t_save == '-');

    if (t_save == 'N') {
      System.out.println("\nYou choose to Bypass Save to File." );
      return;
    }

   String tFN = "";
   do {
     try {
       System.out.print("\nEnter a new or existing path\filename (or 'x' to exit):" );
       tFN = input.readLine().trim();
       if (tFN.equalsIgnoreCase("x")) {
       return;
       }
     f = new File(tFN);
     if (f.isDirectory()) {
      System.out.println("\nYou choose A Directory. Tty Again.");
      } else {
      if (f.exists()) {
       System.out.println("\nFile Exists. Overwrite it (Y/N):" );
       Stmp = input.readLine().trim().toUpperCase();
       if (Stmp.length() > 0) {
        tPH = Stmp.charAt(0);
        if (tPH != 'Y' ) {
         System.out.print("\nYou Choose to NOT overwrite." );
         } else {
         Save2FN = tFN;
         }
        } else {
        System.out.print("\nInvalid Overwrite entry. try again." );
        }
       } else {
       Save2FN = tFN;
       }
      }
     } catch (IOException e) {
     System.out.println("Error Response. Try again.");
     }
    } while(Save2FN.equals(""));
       /**
     * Use FileWriter when number of write operations are less
     * @param data
     */

      //  File file = new File("/Users/pankaj/FileWriter.txt");
   BufferedOutputStream bos = null;
   try {
   //create an object of FileOutputStream
   //FileOutputStream fos = new FileOutputStream(new File(filename));
   FileOutputStream fos = new FileOutputStream(f);

   //create an object of BufferedOutputStream
   bos = new BufferedOutputStream(fos);

      if ((t_save == 'R') || (t_save == 'Y')) {
              int i = CA_bresp.size();
              for (int j = 0; j < i; j++) {
                bos.write(CA_bresp.get(j));
              }
            }
       if ((t_save == 'A') || (t_save == 'Y')) {
              int i = CA_Sresp.size();
              for (int j = 0; j < i; j++) {
                bos.write(CA_Sresp.get(j).getBytes());
              }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }finally{
            //close resources
            try {
                bos.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

   public void DispCA()
   {
         int Txn_ct = Txn_resp.size();
         int CA_ct = CA_Sresp.size();
         int j = CA_ct;
         Date stDt, spDt;
         String tCA = "";
         int tCA_Len = 0;
         DispHexCA d_h_ca = new DispHexCA();
         if (Txn_ct != CA_ct) {
           System.out.println("\nError: Txn count(" + Txn_ct +
                              ") does not match CA count(" + CA_ct + ")\n");
           if (CA_ct > Txn_ct) {
             j = Txn_ct;
           }
         }
         for (int i = 0; i < j; i++) {
           tCA = Txn_resp.get(i);
           tCA_Len = tCA.length();
           System.out.println("Printing CA for iteration:" + (i + 1) + "\nCA Length:" + tCA_Len );
           fmtDt( TxnStDt.get(i), TxnSpDt.get(i));
           System.out.print(tCA.trim());
           System.out.println(CA_Sresp.get(i).trim() +  ":txeT");

            PromptPntHex();
        if (pnthex == 'Y') {

// Use general window size of 80 shars
// format 6digits for offset (0-999990)
//        ^| 2 pos
//        groups of 4 hex chars (8digits) separated by 1 sp
//        | | 3 pos
//        16 chars
//        | 1 pos
// 12345 | 1234ABCD |01010101 01010101 01010101 01010101|123456789abcdef0|      74 chars?
           System.out.println("\nHEX Print of Commarea before CP Conversion : ");
           System.out.println("Variable:abytCommarea in Hex:");

           byte[] abytCommarea = CA_bresp.get(i);
           d_h_ca.dispit(abytCommarea,OP_max_size);

           System.out.println("\nHEX Print of Commarea after CP Conversion : ");
           d_h_ca.dispit(CA_Sresp.get(i).getBytes(), OP_max_size);

         }
         System.out.println("\n###########################################");
      }
   }
     /**
   Constructor.
   @param aFileName full name of an existing, readable file.
  */
//  public EciB1e(String rgnstr, String IPAdr, String IPSocket){
   public EciB1e(String kixport_target) {
    Scanner scanner = new Scanner(kixport_target);
    scanner.useDelimiter(",");
    if ( scanner.hasNext() ){
      try {
       while ( scanner.hasNext() ){
        ctg_targ.put("CTG",scanner.next());
        ctg_targ.put("IPAdr",scanner.next());
        ctg_targ.put("IPSocket",scanner.next());
        ctg_targ.put("JKS",scanner.next());
        ctg_targ.put("CTG_OS",scanner.next());
        ctg_targ.put("CTG_CP",scanner.next());
        ctg_targ.put("SSL",scanner.next());
          }
         } catch  (Exception e) {
         System.out.println("Error: EciB1e:Scanner kixport_line:" + e);
         System.exit(12);
        }
       }
       System.out.print("Local System CodePage Charset is:" );
       Charset cs_dft = Charset.defaultCharset();
       String lcl_cs = cs_dft.displayName();
       System.out.println(lcl_cs);
       Set s = cs_dft.aliases();
       Iterator j = s.iterator();
       String sep = "";
       while (j.hasNext()) {
            String a = (String) j.next();
            System.out.print(sep+a);
            sep=",";
         }
         System.out.println("\n____________________________" );
         PromptGetNM_PW();
         System.out.println("");
         String strUrl = ctg_targ.get("IPAdr");
         int iPort = Integer.parseInt(ctg_targ.get("IPSocket"));
         PromptUseDft();
/*
         try {
         PromptUseDft();
         } catch (IOException e) {
         System.out.println("Warning: IOException on System.in: Override Defaults Query failed.\n" +
                            "\nUsing Default Values. Proceed with that information, if you wish.");
         setdfY_N('N');
         }
*/
   }




/*
 * end of constructor
 *
*/

      public int tryit() {
         CA_bresp.clear();
         CA_Sresp.clear();
         Txn_resp.clear();
         TxnStDt.clear();
         TxnSpDt.clear();
         int rc = 0;
         String strChosenServer = null;  // used to select the target cics region
         String strInput = null;
         String strAns = null;
//
    //   String str_rem_cs = "cp1252";        // Windows CP
    //   String str_rem_cs = "cp1047";        // zOS CP
    //   String str_rem_cs = "cp819";                  // AIX CP

         String ctgrgn = ctg_targ.get("CTG");
         String strUrl = ctg_targ.get("IPAdr");
         String strFullUrl = null;
         int iPort = Integer.parseInt(ctg_targ.get("IPSocket"));
//         String rgnType = ctg_targ.get("RgnType");
         String useJKS = ctg_targ.get("JKS");        // derived jks setting
         String rgnOS = ctg_targ.get("CTG_OS");
         String str_rem_cs = ctg_targ.get("CTG_CP");        // from the kixports file
         String useSSL = ctg_targ.get("SSL");        // derived SSL setting


         int iECISvrct = 0;
         int iChoice = 0;
         // Display banner
         System.out.println("\nConnecting to Selected CTG:" + ctgrgn);
         String strServerNumber = null;
         String strSSLKeyring  = null;
         String strSSLPassword = null;

         // Process the command line arguments and display Gateway settings

        System.out.print("\nThe address of the Gateway has been set to ");
         System.out.println(strUrl + " Port:" + iPort + "\n");

         // Declare and initialize method variables and ECIRequest object n
    try {
         ECIRequest eciRequestObject = null;
         int EciNoXtnd = ECIRequest.ECI_NO_EXTEND;
         int EciXtnd = ECIRequest.ECI_EXTENDED;
         int i_eci_xtnd = EciNoXtnd;
         int i_eci_xLUW = 0;
         if (getrep_txn() > 0) {
           if (getXtnd_txn() == 'Y') {
             i_eci_xtnd = EciXtnd;
             i_eci_xLUW = ECIRequest.ECI_LUW_NEW;
           }
         }

         Properties sslProps = new Properties();
         if (useSSL.equals("Y")) {
           int SSLIndex = ctgrgn.indexOf("SSL");
           String ctgrgnX = ctgrgn.substring(0,SSLIndex);
           if (ctgrgnX.endsWith("D")) {
           System.out.print("\nThis Gateway request is using SSL and cacerts default jks:" + "\n");
           } else {
           strSSLKeyring = "/RunCtg/TestZOS/" + useJKS + ".jks";
           strSSLPassword = "CICSabcd";
         // Set the keyring and keyring password and then initialize
         // the JavaGateway object to flow data to the Gateway
           sslProps.setProperty(JavaGateway.SSL_PROP_KEYRING_CLASS, strSSLKeyring);
           sslProps.setProperty(JavaGateway.SSL_PROP_KEYRING_PW, strSSLPassword);
           System.out.print("\nThis Gateway request is using SSL jks:" + strSSLKeyring + "\n");
           }
           strFullUrl = "SSL://";
           strFullUrl = strFullUrl.concat(strUrl);
         } else {
           System.out.print("\nThis Gateway request is not using SSL\n");
           strFullUrl = "TCP://";
           strFullUrl = strFullUrl.concat(strUrl);
           }


         try {
            javaGatewayObject = new JavaGateway(strFullUrl, iPort, sslProps);
            } catch (Exception e) {
         e.printStackTrace();
         System.exit(30);
      }

         // Obtain a list of CICS servers defined

         // If an ECI_ERR_MORE_SYSTEMS error occurs this is because you have more servers
         // defined in your CICS TG configuration than the value stored in the iServerCount
         // variable. To solve this problem, increase the value assigned to iServerCount,
         // recompile and rerun this sample.
         int iServerCount = 460;
         eciRequestObject = ECIRequest.listSystems(iServerCount);
         System.out.println("MAX Servers count::" + iServerCount);
//         strAns = input.readLine().trim();
         flowRequest(eciRequestObject);

         // Ask for user to choose from the list of defined servers
         Set<String> ctg_targs = new HashSet<String>();
         do {
            if (eciRequestObject.SystemList.isEmpty() == true) {
               System.out.println("No CICS servers have been defined.");
               if (javaGatewayObject.isOpen() == true) {
                  javaGatewayObject.close();
               }
               System.exit(0);
            }
            iECISvrct = eciRequestObject.numServersReturned;
            System.out.println("ECI Servers count:" + iECISvrct);
            System.out.println("CICS Servers Defined:\n");
            for (int i = 0; i < eciRequestObject.numServersReturned; i++) {
               if (i < 9) {
                  strServerNumber = "\t " + (i + 1) + ". ";
               } else {
                  strServerNumber = "\t" + (i + 1) + ". ";
               }

               // Prints the name and description of the server as contained
               // in the SystemList vector
               String V = (String) eciRequestObject.SystemList.elementAt(2*i);
               ctg_targs.add(V);
               System.out.println
                (strServerNumber
                 + eciRequestObject.SystemList.elementAt(2*i) + " -"
                 + eciRequestObject.SystemList.elementAt((2*i)+1));
            }
            System.out.println("\n\nChoose Target Server (by number),"
                               + "a for ALL servers, or q to quit:");
            strInput = input.readLine().trim();
            if ((strInput).equalsIgnoreCase("q")) {
               if (javaGatewayObject.isOpen() == true) {
                  javaGatewayObject.close();
               }
               System.exit(0);
            }
            if ((strInput).equalsIgnoreCase("a")) {
              System.out.println("You Selected ALL CICS Regions.");
            }

            try {
               iChoice = java.lang.Integer.parseInt(strInput);
            } catch (java.lang.NumberFormatException e) {
               System.out.println("\n\nType the number of the "
                                  + "Server to connect to or q to quit\n");
               continue;
            }

            // Validate that the choice is in range using the
            // ECIRequest numServersReturned variable
            if (iChoice > 0 && iChoice <= eciRequestObject.numServersReturned)
            {  strChosenServer =
               (String)eciRequestObject.SystemList.elementAt(((iChoice-1)*2));
            } else {
               System.out.println("\n\nOut of Range\n");
            }
         } while (strChosenServer == null);


         System.out.println("\nServer::" + strChosenServer);

         String strProgram = getPN();
         String strTPNM = getMyTID();
         int iCommareaSize = getCAL();

         StringBuilder strComA = new StringBuilder(getMyCA());
         int n_l = iCommareaSize;
//         strComA.setLength(n_l);
         byte[] abytCommarea = new byte[iCommareaSize];
//         String SComA = strComA.toString();
//         System.out.println("CommareaLength>" + SComA.length());
//        System.out.println("Commarea>" + SComA);
 // Change #5 activate codepage conversion (ie  to and from zos)
 //      Use CP conversion when going to the zOS CICS
         String pnthex = "N";

 //
 // Top of the repeat loop
 //
     int cur_repeat_cnt = 0;
     int strComA_Len = 0;
     do {
         strComA.setLength(0);
         if (getDM() == 'P') {
          System.out.println("Iteration:" + (cur_repeat_cnt + 1) + ":DataMode is Prompt. Enter next " + getCnC());
          PGetCA(stdmyCA);
          strComA.append(getMyCA());
         } else {
         strComA.append(getMyCA_L(cur_repeat_cnt));
         }
         strComA_Len = strComA.length();
         strComA.setLength(n_l);
         String SComA = strComA.toString();
         System.out.println("True CommareaLength>" + strComA_Len +
                "\nSetting CommareaLength to>" + SComA.length());
         System.out.println("(True) Commarea>" + SComA.substring(0,strComA_Len) + '<');
         abytCommarea = SComA.getBytes(str_rem_cs);
         String aComStr = new String(abytCommarea);
         System.out.println("abytCommarea>" + aComStr.substring(0,strComA_Len) + '<');
         iCommareaSize = n_l;    // set above

         System.out.println("\nText from Commarea before flow (abytCommarea): "
                               + new String(abytCommarea).substring(0,strComA_Len) + '<');
 //        eciRequestObject =
 //        new ECIRequest(ECIRequest.ECI_SYNC_TPN,  //ECI_SYNC call type eci_tranid CSMI
 //                                                 // or use ECI_SYNC_TPN for eci_tpn
                                                    // uses the user transid
 //                       strChosenServer,          //CICS server
 //                       null,                     //CICS userid
 //                       null,                     //CICS password
 //                       strProgram,               //CICS program to be run
 //                       null,                     //CICS transid to be run
 //                       abytCommarea,             //Byte array containing the
 //                                                 // COMMAREA
 //                       iCommareaSize,            //COMMAREA length
 //                       ECIRequest.ECI_NO_EXTEND, //ECI extend mode
 //                       0);                       //ECI LUW token
/*
 * TPNName ECIRequest.Call_Type = ECI_SYNC_TPN or ECI_ASYNC_TPN
 *                                and ECIRequest.Transid
 * TranName ECIRequest.Call_Type = ECI_SYNC or ECI_ASYNC
 *                                and ECIRequest.Transid
 * note that TPNNAME specification will use the eci transid as the runtime txn (if specified else csmi)
 */

         if (cur_repeat_cnt == 0) {
         eciRequestObject =
         new ECIRequest(ECIRequest.ECI_SYNC_TPN,  //ECI call type
                        strChosenServer,          //CICS server
                        strMe,                     //CICS userid strMe or null
                        strMePW,                     //CICS password or null
                        strProgram,               //CICS program to be run
                        strTPNM,                  //CICS transid to be run strTPNM
                                                  // note that by setting ECI_SYNC_TPN, tells eci request
                                                  // that this is BOTH the TPNAME and TRANID
                        abytCommarea,             //Byte array containing the
                                                  // COMMAREA
                        iCommareaSize,            //COMMAREA length
                        i_eci_xtnd,               // getXtnd_txn() Y or N sets this value
//                        ECIRequest.ECI_NO_EXTEND, //ECI extend mode int value
                        i_eci_xLUW);               //ECI LUW token int
         //ECIRequest.ECI_EXTENDED ECIRequest.ECI_NO_EXTEND, //ECI extend mode
         // Call the flowRequest method and display returned data in hex and
         // ASCII format. If the method returns true a security error has
         // occurred and the user is prompted for a CICS user ID and password.
         } else {
           eciRequestObject.Commarea = abytCommarea;
           eciRequestObject.Commarea_Length = iCommareaSize;
         }

         short s_int = (short) getEciTO();

         eciRequestObject.setECITimeout(s_int);   // added 20120202
         // while condition here depends on the success of the flow request;
         //  flow request will return 'false' if it was successful
         //  so we would not enter this again unless the flow got a error response
// this is top of the flow loop - loop until we get good resp of MaxFlowAttempts
         while ((flowRequest(eciRequestObject) == true) && RetryInd){
           System.out.println("\nText from Commarea on retry (abytCommarea):\n "
                               + new String(abytCommarea));
           for (int q = 0; q < 200; q++) {
            System.out.print(Integer.toHexString(abytCommarea[q]));
         }
         h_strMe = strMe;
         h_strMePW = strMePW;

         PromptGetNM_PW_agn();

         eciRequestObject.Userid = strMe;
         eciRequestObject.Password = strMePW;
         iValidationFailed++;    // compare to MaxFlowAttempts
         }
         if ( RetryInd ) {
         int ca_len = eciRequestObject.Commarea_Length;
         CA_bresp.add(eciRequestObject.Commarea);

         String ret_ComA = new String(eciRequestObject.Commarea,0,eciRequestObject.Commarea_Length,str_rem_cs);
         CA_Sresp.add(ret_ComA);

         StringBuffer txnR = new StringBuffer();
         txnR.append("\nTransid>" + strTPNM + "< Userid>" + strMe).append(
               "\nProgram " + strProgram  + " returned with data.").append(
               "\nReported ECI CommareaLen: " + ca_len).append(
               "\tStrLen of CommareaLen: " + ret_ComA.length()).append(
               "\nReturning Commarea variable:ret_ComA: CP converted:").append("\nText\n");

         Txn_resp.add(txnR.toString());
         System.out.println("Saved Txn details and CA for iteration:" + (cur_repeat_cnt + 1));

 //        System.out.print("\nTransid>" + strTPNM + "< Userid>" + strMe);
 //        System.out.println("\nProgram " + strProgram + " returned with data:- \n");
 //        int ca_len = eciRequestObject.Commarea_Length;
 //      Use CP conversion when going to the zOS CICS
 //        String ret_ComA = new String(eciRequestObject.Commarea,0,eciRequestObject.Commarea_Length,str_rem_cs);
 //        String ret_ComA = new String(eciRequestObject.Commarea,0,eciRequestObject.Commarea_Length);
 //        System.out.print("\n\tReported ECI CommareaLen: " + ca_len);
 //        System.out.print("\tStrLen of CommareaLen: " + ret_ComA.length());
 //        System.out.print("\n\tReturning Commarea variable:ret_ComA: CP converted:");
 //        System.out.print("\nText:" + ret_ComA + ":txeT");
 /*       if (pnthex == "Y") {
           System.out.print("\nHEX Print of Commarea before CP Conversion : ");
           System.out.print("\n\tVariable:abytCommarea in Hex: ");
           for (int i_t: abytCommarea) {
             System.out.print(Integer.toHexString(i_t));
           }
           try {
            System.out.println("\n\nASCII text from Commarea before CP conversion (abytCommarea): "
                               + new String(abytCommarea, "ASCII"));
           } catch (UnsupportedEncodingException e) {
            System.out.println
            ("\tThe ASCII encoding scheme is not supported.");
           }
         }
         } else {
         System.out.println("Retry failed or Exit requested: Ending execution.");
         }
         */
         }
         if ((getrep_txn() > 0) && cur_repeat_cnt < getrep_txn()) {
             System.out.println("\nFinished Repeat Iteration #" +
                                (cur_repeat_cnt + 1) + " of " + (getrep_txn() + 1));
           if (getwt_txn() > 0) {
             System.out.println("\n\nSleeping " + (getwt_txn() / 1000) + " seconds...");
             EciSleep(getwt_txn());
           }
           System.out.println("____________________");
         }
  // end of repeat loop
         cur_repeat_cnt++;
         } while (cur_repeat_cnt <= getrep_txn());
         // issue SYNC if necessary
         if (getXtnd_txn() == 'Y') {
            eciRequestObject.Extend_Mode = ECIRequest.ECI_COMMIT;
            eciRequestObject.Call_Type = ECIRequest.ECI_SYNC;
            eciRequestObject.Program = null;
            javaGatewayObject.flow(eciRequestObject);
            }

         // Close the JavaGateway object before exiting
         if (javaGatewayObject.isOpen() == true) {
            javaGatewayObject.close();
         }
// end of tryit: first try..catch logic
      } catch (Exception e) {
         e.printStackTrace();
         rc = 8;
      }
      return rc;
   }

   // The flowRequest method flows data contained in the ECIRequest object to
   // the Gateway and determines whether it has been successful by checking the
   // return code. If an error has occurred, the return code string and abend
   // codes are printed to describe the error before the program exits.
   // Note: Security may be required for client connection to the server and
   //       not just for the ECI request. Refer to the security chapter in the
   //       CICS Transaction Gateway Administration book for further details.
      // remove static from below -
   private  boolean flowRequest(ECIRequest requestObject) {
      try {
         Date startDt = new Date();
         int iRc = javaGatewayObject.flow(requestObject);
         Date stopDt = new Date();
         // Checks for gateway errors and returns false if there are no errors
         System.out.println("\nReturn from Gateway");

         switch (requestObject.getCicsRc()) {
         case ECIRequest.ECI_NO_ERROR:
            if (iRc == 0) {
               TxnStDt.add(startDt);
               TxnSpDt.add(stopDt);
               return false; // when successful, we set 'retry' to false
            } else {
               System.out.println("\nError from Gateway ("
                                  + requestObject.getRcString()
                                  + "), correct and rerun this sample");
               if (javaGatewayObject.isOpen() == true) {
                  javaGatewayObject.close();
               }
               System.exit(0);
            }

         // Checks for security errors and returns true if validation has
         // failed on four or less occasions
         case ECIRequest.ECI_ERR_SECURITY_ERROR:
            if (iValidationFailed == 0) {
               return true;
            }
            System.out.print("\n\nValidation failed. ");
            if (iValidationFailed < this.getMaxFA()) {   // MaxFlowAttempts
               System.out.println("Try entering your details again.");
               return true;
            }
            break;

         // Checks for transaction abend errors where the user is authorised
         // to access the server but not run the EC01 program.
         // The sample should be rerun and a user ID and password with the
         // required authorisation entered.
         case ECIRequest.ECI_ERR_TRANSACTION_ABEND:
            System.out.println("\nYou are not authorised to run this transaction.");
            break;

         case ECIRequest.ECI_ERR_REQUEST_TIMEOUT:
            System.out.println("\nECI Transaction  TimeOut");
            break;

         }
         System.out.println("\nECI returned: "
                            + requestObject.getCicsRcString());
         System.out.println("Abend code was "
                            + requestObject.Abend_Code + "\n");
         if (javaGatewayObject.isOpen() == true) {
            javaGatewayObject.close();
         }
         System.exit(0);

      } catch (Exception e) {
         e.printStackTrace();
         System.exit(0);
      }
      return true;   // if we are here, then we want a 'retry'
   }
}
//
//         File Name     : EciB1e.java

package TestZOS;

import java.lang.*;
import java.util.*;
import java.text.*;
import java.io.*;
import java.nio.charset.*;
import java.util.Properties;
import java.util.concurrent.TimeUnit;
import java.lang.InterruptedException;
import java.math.*;

//import TestZOS.*;

import com.ibm.ctg.client.*;

public class EciB1e {
   final String RunEci_V = "EciB1e V1.1";
   // Declare objects for use in both methods
   private static JavaGateway javaGatewayObject;

   private static InputStreamReader isr = new InputStreamReader(System.in);
   private static BufferedReader input = new BufferedReader(isr);
   private static int iValidationFailed = 0;
   private static HashMap<String, String> ctg_targ = new HashMap<String, String>();
   private static ArrayList<byte[]> CA_bresp = new ArrayList<>();
   private static ArrayList<String> CA_Sresp = new ArrayList<>();
   private static ArrayList<String> Txn_resp = new ArrayList<>();
   private static ArrayList<Date> TxnStDt = new ArrayList<>();
   private static ArrayList<Date> TxnSpDt = new ArrayList<>();   
   
   //Name of the CICS program to execute
   // private String ProgramName = "PONG";    // commarea only
   private String ProgramName = "UCEMPINR";
   public void PromptPN(String PN) { 

     if (PN.equals("")) {
       PN = getPN();  
     } 
     System.out.println("Selected CICS Target Program:" + PN);
     System.out.print("Enter Different CICS Target Program:");
     try {
     PN = input.readLine().trim().toUpperCase();
     setPN(PN);
     } catch (IOException e) {
       System.out.println("Error. IOException reading Target Program. Using Default.");
      }
     System.out.println("\nUsing CICS Target Program:" + getPN());
     }
   public void setPN(String PN) 
   {
     if ((PN.length() > 0) && (PN.length() < 9 )) {
       ProgramName = PN;
     }
   }
   public String getPN() {
       return ProgramName;
   }
   
   //Name of the CICS Transid to execute
   private String MyTransid = "UXXX";
   public void PromptTID(String TID) {
     if (TID.equals("")) {
       TID = getMyTID();  
     } 
     System.out.print("Enter Different TRANSID:" + TID);
     try {                                      
     TID = input.readLine().trim().toUpperCase();
     if ((TID.length() > 0) && (TID.length() < 5)) {
       setMyTID(TID); 
       } 
      } catch (IOException e) {
       System.out.println("Error. IOException reading Target TRANSID. Using Default.");
     } 
     System.out.print("\nUsing TRANSID:" + getMyTID());
    }   
   public void setMyTID(String TID) {
     if ((TID.length() > 0) && (TID.length() < 5 )) {
       MyTransid = TID.toUpperCase();
       MyMirrorTransId = MyTransid;
     }
   }
   public String getMyTID() {
     return MyTransid;
   } 
   //Name of the CICS Transid that mirror is to execute
   private String MyMirrorTransId = MyTransid;
   
//Maximum number of flow attempts
   private int MaxFlowAttempts = 3;
   public void PromptFA(int FA) {
     if ( FA == 0) {
       FA = getMaxFA();  
     } 
     System.out.println("Current FLOW Retry Setting:" + FA);
     System.out.print("Enter Different FLOW Setting:");
     try {
     FA  = Integer.parseInt( input.readLine().trim() );
     setMaxFA(FA);
     } catch (NumberFormatException e) {
      System.out.println("Error: NumberFormatException Reading FlowAttempts. Using Default."); 
      } catch (IOException e) {
       System.out.println("Error. IOException reading FLOW Setting. Using Default.");
     } 
     System.out.println("\nUsing FLOW Retry Setting:" + getMaxFA());
    }   
   public void setMaxFA(int FA) {
     if ((FA > 0) && (FA < 5 )) {
       MaxFlowAttempts = FA;
     }
   }
   public int getMaxFA() {
       return MaxFlowAttempts;
   }     
        
   // Set program to use CA or cNc
   private String use_ca_or_cNc = "CA";
   //private string use_ca_or_cNc = "cNc";
   public void PromptCnC(String use_ca_or_cNc) {
     if (use_ca_or_cNc.equals("")) {
       use_ca_or_cNc = "CA";  
     } 
     System.out.print("Select Data Model:\n'CA' for Commarea,\nor 'CnC' for Channel and Container(s):" + use_ca_or_cNc);
     try {
     use_ca_or_cNc = input.readLine().trim().toUpperCase();
     } catch (IOException e) {
       System.out.println("Error. IOException reading Data Model. Using Default.");
     }  
     if (!(use_ca_or_cNc.equals("CA")) && !(use_ca_or_cNc.equals("CNC"))) {
       use_ca_or_cNc = "CA";  
       } 
    System.out.print("\nUsing Data Model:" +  use_ca_or_cNc);
    }

   public String getCnC() {
     return use_ca_or_cNc;
   }

   //Name of Channel to pass to EC03 program
   private String CHANNEL_NAME = "PONG_Channel";   // max 16
   public void PromptChanNm(String ChanNm) { 
     if (ChanNm.equals("")) {
       ChanNm = CHANNEL_NAME;  
     } 
     System.out.print("Enter CHANNEL_NAME:" + ChanNm);
     try {
     ChanNm = input.readLine().trim();
     if ((ChanNm.length() > 0) && (ChanNm.length() < 17)) {
       CHANNEL_NAME = ChanNm;  
       }
     } catch (IOException e) {
       System.out.println("Error. IOException reading CHANNEL_NAME. Using Default.");
     } 
     System.out.print("\nUsing CHANNEL_NAME:" + CHANNEL_NAME);
    }   

   //Name of Container to pass to EC03 program
   private String CONTAINER_NAME = "PONGCNCCONTNR";   //max 16
   public void PromptContNm(String ContNm) { 
     if (ContNm == "") {
       ContNm = CONTAINER_NAME;  
     } 
     System.out.print("Enter CONTAINER_NAME:" + ContNm);
     try {
     ContNm = input.readLine().trim();
     if ((ContNm.length() > 0) && (ContNm.length() < 17)) {
       CONTAINER_NAME = ContNm;  
       }
     } catch (IOException e) {
       System.out.println("Error. IOException reading CONTAINER_NAME. Using Default.");
     } 
     System.out.print("\nUsing CONTAINER_NAME:" + CONTAINER_NAME);
    } 
           
   //The size of the COMMAREA to send to the program - This can be 0 - 32400
   private int CAL = 4080;
   public void PromptCAL(int ca_len) { 
     int h_ca_len;
     if ( ca_len == 0) {
       ca_len = getCAL();  
     } 
     h_ca_len = ca_len; 
     System.out.println("Current CA Length Setting:" + ca_len);
     System.out.print("Enter Different CA Length Setting:");
      String s_ca_len = "";     
     try {
      s_ca_len = input.readLine().trim(); 
      ca_len  = Integer.parseInt(s_ca_len);
      } catch (NumberFormatException e) {
        if ((s_ca_len.equals("=")) || (s_ca_len.equals(""))) {
          ca_len = h_ca_len;
        } else {
          System.out.println("Error: NumberFormatException Reading CAL. Using Default.");          
          ca_len = getCAL();
        }
      } catch (IOException e) {
       System.out.println("Error. IOException reading FLOW Setting. Using Default.");
       ca_len = h_ca_len;       
      } finally {
       setCAL(ca_len);
      }
     System.out.println("\nUsing CA Length Setting:" + getCAL());
    }      
   public void setCAL(int ca_len) {
     if ((ca_len >= 0) && (ca_len <= 32400 )) {
       CAL = ca_len;
     }
   }
   public int getCAL() {
       return CAL;
   }     
        
   //The size of the COMMAREA to send to the program
//   private String stdmyCA = "Ponged from JAVA EciB1e on my desktop!!";
   private String stdmyCA = "CEMT INQUIRE SYSTEM";
   private String CA = "CEMT INQUIRE TASK";
   private ArrayList<String> CA_aryL = new ArrayList<>();
   private ArrayList<Integer> CA_aryLen = new ArrayList<>();
   protected void setDfltCA() {
    CA_aryL.add(CA);  
   }
   public void PromptGetCA(String tmp_ca) { 
     String tCA = "";
     CA_aryL.clear();
     int repct = getrep_txn();
     char repDM = getDM();
     if (repDM == 'S') {
       PGetCA(stdmyCA);
       tCA = getMyCA();
       for (int i = 0; i <= repct; i++) {
         CA_aryL.add(tCA);
         CA_aryLen.add(tCA.length());
         }
       System.out.println("Data Mode 'S' Static CA set for all (" + (repct + 1) + ") iterations.");
       return;
     }
     if (repDM == 'E') {
       for (int i = 0; i <= repct; i++) {
         System.out.println("\nEnter CA for iteration:" + (i + 1));
         PGetCA(stdmyCA); 
         tCA = getMyCA();         
         CA_aryL.add(tCA);
         CA_aryLen.add(tCA.length());         
         }
       System.out.println("Data Mode 'E' Each CA individually set. Total " + (repct + 1) + " iterations set.");
       return;
     }
     if (repDM == 'F') {
       String fin = DMDFN;
       int rdct = 0;
         FileInputStream fis = null;       
         BufferedReader br = null;
         try {
         fis = new FileInputStream(fin);
         //Construct BufferedReader from InputStreamReader
         br =  new BufferedReader(new InputStreamReader(fis));         
         String line = null;
         while ((line = br.readLine()) != null) {
          rdct++; 
          tCA = line.trim();
          CA_aryL.add(tCA);
          CA_aryLen.add(tCA.length());          
         }
         repct++;
         if (rdct < repct) {
         System.out.println("Repeat count:" + repct + " does not match command count from file:" +
         rdct + ". Reducing Repeat count.");
         setrep_txn(rdct - 1);
         }
         if (rdct > repct) {
         System.out.println("Repeat count:" + repct + " does not match command count from file:" +
         rdct + ". Commands greater than Repeat count ignored.");
         }
        System.out.println("Data Mode 'F' Each CA individually set for " + (getrep_txn() + 1) + " iterations.");
        br.close();
       } catch (IOException e) {
         System.out.println("Error. Could not read file with Commarea List. Goodbye!");
         e.printStackTrace();
         
       } finally {
         try {
           if (br != null) {
             br.close();
             }
           } catch (IOException e) {
           e.printStackTrace();
         }
       }
       return;
     }
   }
   
 public String PromptChoice(String Msg, String Inst, String opts) {
     String msgboxans = "";
     String dft_ans = "";
     String dft_hint = "";
     String ans = "";
     int optsl = opts.length();
     if (optsl == 0) {
       dft_ans = "";
       dft_hint = "Press anykey to Continue";
     } else {
       opts = opts.toUpperCase();
       dft_ans = opts.substring(0,1);
       dft_hint = "Valid Reponse is one of <" + opts + "> Default Response is<" + dft_ans + ">";
     }
     System.out.println("------------------------------------------------------");
     System.out.println(Msg);
     System.out.println("------------------------------------------------------");  
     String tmp = "";
     do {
     System.out.print(Inst);
     try {
     tmp = input.readLine().trim().toUpperCase();
     if (optsl == 0) {
       return "";
     }     
     if (tmp.length() > 0) {
       ans = tmp.substring(0,1);
       if (opts.contains(ans)) {
         return ans;
         }
       } else {
       ans = "";
       }
     System.out.println("Your response:'" + ans + "': is not an Option. Retry.");  
     } catch (IOException e) {
      System.out.println("Error. IOException reading your response. Retry.");
      }
     System.out.print(dft_hint); 
     ans = "";
   } while(msgboxans.equals("")); 
   return ans;
   }
     
   public String getMyCA_L(int ca_num) {
     if ((ca_num < 0) || ca_num > CA_aryL.size()) {
       return "";
     }
     return CA_aryL.get(ca_num);
   }
   
   private void PGetCA(String tmp_ca) {
     if (tmp_ca.equals("")) {
       tmp_ca = stdmyCA;  
     } 
     String tmp1 = tmp_ca;
     String h_tmp_ca = tmp_ca;
     if (tmp_ca.length() > 70) {
       tmp1 = tmp_ca.substring(0,34) + ".." +  tmp_ca.substring(tmp_ca.length() - 34);
     }      
     String ans = "";
     String opts = "NYD=";
     do { 
     System.out.print("Enter Different Commarea:\n" + tmp1 +"\n");
     ans = "Y";  
     try {
     tmp_ca = input.readLine().trim();
     int tmp_cal = tmp_ca.length();
     if (tmp_cal == 0) {
      ans = PromptChoice("CammArea data expected.\nYour Response was zero length. Default GA is\n",
                          "Select Y to use zero length CommArea\nOr N to retry\nOr '=' to use Default CA:",
                          opts);
      if (ans.equals("D") | ans.equals("=")) {
        ans = "Y";
        tmp_ca = getMyCA();
       }
     }
     if (ans.equals("Y")) {
     if (tmp_cal > 32400) {
       tmp_cal = 32400;
       tmp_ca = tmp_ca.substring(0,32399);
     }
     if (tmp_ca.equals("=")) {
       tmp_ca = h_tmp_ca;
     }
     
     setMyCA(tmp_ca);  
     if (tmp_cal > getCAL()) {
         setCAL(tmp_cal);
       }
      } 
     } catch (IOException e) {
      System.out.println("Error. IOException reading CommArea. Using Default.");
      }
     } while(ans.equals("N"));
    tmp1 = getMyCA();
    if (tmp1.length() > 70) {
       tmp1 = tmp1.substring(0,34) + ".." +  tmp1.substring(tmp1.length() - 34);
     }
    System.out.print("Commarea:\n" + tmp1 + "\n"); 
   }
   
   public void setMyCA(String tmp_ca) {
     int tmp_cal = tmp_ca.length();
     if (tmp_cal > 32400) {
       tmp_cal = 32400;
       tmp_ca = tmp_ca.substring(0,32399);
     }
     CA = tmp_ca;  
     if (tmp_cal > getCAL()) {
         setCAL(tmp_cal);
       }
   }
   public String getMyCA() {
     return CA;
   }
   

   //Repeat Non/Xtended transaction 0-98 times, waiting 0-10000 ms between calls
   //private  int  rep_txn = 0; // 0 means NO repeats Itotal:1 executon)
   private int  rep_txn = 0; 
   private int  min_rep_txn = 0, max_rep_txn = 98;
   public void PromptRepNum(int repnum) {
     if ( repnum == 0) {
       repnum = getrep_txn();  
     } 
     System.out.println("Current Repeat Transaction Count Setting:" + repnum);
     System.out.println("NOTE - Zero (0) Repeats implies Run once;\nOne (1) implies Run Twice,...");
     System.out.print("Enter Different Repeat Transaction Count Setting:");
     try {
     repnum  = Integer.parseInt( input.readLine().trim() );  
     setrep_txn(repnum);
     } catch (NumberFormatException e) {
      System.out.println("Error: NumberFormatException Repeat Setting. Using Default."); 
      } catch (IOException e) {
      System.out.println("Error. IOException reading Repeat Setting. Using Default.");
      }
     System.out.println("\nUsing Repeat Transaction Count Setting:" + getrep_txn());
    }      
   public void setrep_txn(int repnum) {
     if ((repnum >= min_rep_txn) && (repnum <= max_rep_txn )) {
       rep_txn = repnum;
     }
   }
   public int getrep_txn() {
       return rep_txn;
   }
   
   // repeat txn datamode 'S' indicates static Datamodel on each eci flow
   //                     'P' indicates Prompt for each Datamodel contents for each iteration
   //                     'E' indicates Datamodel for each iteration setup prior to first iteration
   //                     'F' indicates a file provides the data for each iteration
   private char DMD = 'S';

   public void PromptRepDMD(char tmp) { 
     System.out.print("Repeat Count is greater than 0. Choose a DataMode for the Datamodel" + 
                        "\n'S' indicates static Datamodel on each eci flow" +
                        "\n'P' indicates Prompt for each Datamodel contents for each iteration" +
                        "\n'E' indicates Datamodel for each iteration setup prior to first iteration" +
                        "\n'F' indicates a file provides the data for each iteration" +
                        "\nMake a selection (default is 'S' static:");

//     Scanner s= new Scanner(System.in);
//     char xtnd = s.next().charAt(0);
//     xtnd = Character.toUpperCase(s.next().charAt(0));
     try {
     String Stmp = input.readLine().trim().toUpperCase();
     if (Stmp.length() > 0) {
       int i = setDM(Stmp.charAt(0));
       if (i > 0 ) {
         System.out.print("\nInvalid Data Mode selection: Using Default.");
       } 
      }  
     } catch (IOException e) {
      System.out.println("Error. IOException reading Data Mode Setting. Using Default.");
      }
    System.out.println("\nUsing DataMode:" + getDM());
    }      
   public int setDM(char tmp) {
     tmp = Character.toUpperCase(tmp);
     if ((tmp == 'S') || (tmp == 'P') || (tmp == 'E') || (tmp == 'F') ) {
       DMD = tmp;
       return 0;
     } else {
       DMD = 'S';
       return 4;
       }
   }
   public char getDM() {
     return DMD;
   }   

   private String DMDFN = "";
   protected void DMD_getFN() { 
     String dmfn = "";
     do {
     System.out.print("Data Mode is File. Enter full filename for DataModel Data (or 'x' to Quit):");
     try {
     dmfn = input.readLine().trim();
     if (dmfn.equalsIgnoreCase("x")) {
       System.out.println("Quit Selected. Goodbye.");
       System.exit(8);
     }
     if ((dmfn.length() < 1) || (dmfn.length() > 240)) {
     System.out.println("\nError: file:" + dmfn + " is not correct length." +
       "\nRetry entry of filename for DataModel.");        
       dmfn = "";
       }
     } catch (IOException e) {
      System.out.println("Error. IOException reading File Name for Data Mode. Using Default.");
      dmfn = "";      
      }
     } while (dmfn.equals(""));

     File f = new File(dmfn);
     if (f.exists() && !f.isDirectory()) {
      DMDFN = dmfn; 
      System.out.print("\nUsing file:" + DMDFN + " for Data Mode Data");
     } else {
      System.out.print("\nUsing file:" + dmfn + " is not found.\nChanging DataMode to 'S'");  
      int i = setDM('S');
     }
   }
   
   //private int  wt_txn = 0; // 0 means no wait time between txn
   private long  wt_txn = 0;
   private static final long  min_wt_txn=0 * 1000, max_wt_txn = 99*1000;  // in millisec
   public void PromptWtInvl(long wtnum) { 
     if ( wtnum == 0) {
       wtnum = getwt_txn();  
     } 
     System.out.println("Current Wait Between Transactions Setting (seconds):" + wtnum);
     System.out.print("Enter Different Wait Between Transactions Setting:");
     String S_ans = "";
     double ans = 0.00;   
     Double FD_ans = ans;
     
     try {
      S_ans  = input.readLine().trim().toUpperCase();
      ans  = Double.parseDouble( S_ans);
      BigDecimal BD_ans = new BigDecimal(ans).setScale(2,BigDecimal.ROUND_HALF_UP);
      FD_ans= new Double(BD_ans.doubleValue()); 
    // now convert to long and make the long millesecs
       wtnum  = Math.round(FD_ans * 1000);
       setwt_txn(wtnum);       
       } catch (NumberFormatException e) {
       System.out.println("Error: NumberFormatException Wait Interval. Using Default."); 
       } catch (IOException e) {
       System.out.println("Error. IOException reading Wait Interval. Using Default.");
      }
     System.out.println("\nUsing Wait Between Transactions Setting (millisecs):" + getwt_txn());
      }      
   public void setwt_txn(long wtnum) {
     if ((wtnum >= min_wt_txn) && (wtnum <= max_wt_txn )) {
       wt_txn = wtnum;
     }
   }
   public long getwt_txn() {
       return wt_txn;
   }   
   
   private void EciSleep(long sleep_MS)
     throws InterruptedException {  
   try {
     if ( sleep_MS < min_wt_txn ) {
        sleep_MS = min_wt_txn;
        System.out.println("Sleep Value too small: setting to:" + sleep_MS);        
     } else {
        if ( sleep_MS > max_wt_txn ) {
        sleep_MS = max_wt_txn;
        System.out.println("Sleep Value too large: setting to:" + sleep_MS); 
        }
     }
    TimeUnit.MILLISECONDS.sleep(sleep_MS);
   } catch (InterruptedException e) {
        System.out.print("Warning:EcioB1e:Sleep: Interrupted:");
        System.out.println(e.toString());
        assert false;
        //Handle exception
     }         
   }
   
   //private char  Xtnd_txn = "N"; // "N" means individual txn in repeat cycle
   // "Y" means use LUW information for single LUW
   private char Xtnd_txn = 'N'; 

   public void PromptXtnd(char xtnd) {
     System.out.print("(This options requires CICS RRS=YES)\nEnter Extend Transaction Y or N:" + xtnd);
//     Scanner s= new Scanner(System.in);
//     char xtnd = s.next().charAt(0);
//     xtnd = Character.toUpperCase(s.next().charAt(0));
     try {
      String tmp = input.readLine().trim().toUpperCase();
      if (tmp.length() > 0) {
       xtnd = tmp.charAt(0);
      }
      setXtnd_txn(xtnd);  
      } catch (IOException e) {
      System.out.println("Error:IOException getting Override Values. Using Default.");       
      }
     System.out.print("\nUsing Extend Transaction:" + getXtnd_txn());     
    }      
   public void setXtnd_txn(char xtnd) {
     xtnd = Character.toUpperCase(xtnd);
     if ((xtnd == 'N') || (xtnd == 'Y')) {
       Xtnd_txn = xtnd;
     }
   }
   public char getXtnd_txn() {
     return Xtnd_txn;
   }   

   private int eci_TO = 0;
   private static final int  min_TO=0 * 1000, max_TO = 99*1000;  // in millisec
   public void PromptEciTO(int TOnum) {
     if ( TOnum == 0) {
       TOnum = getEciTO();  
     } 
     System.out.println("Current ECI TimeOut Transactions Setting (seconds):" + TOnum);
     System.out.print("Enter Different ECI TimeOut Transaction Setting:");
     String S_ans = "";
     double ans = 0.00;   
     Double FD_ans = ans;
     
     try {
      S_ans  = input.readLine().trim().toUpperCase();
      ans  = Double.parseDouble( S_ans);
      BigDecimal BD_ans = new BigDecimal(ans).setScale(2,BigDecimal.ROUND_HALF_UP);
      FD_ans= new Double(BD_ans.doubleValue()); 
    // now convert to long and make the long millesecs
       TOnum  = (int) Math.round(FD_ans * 1000);
       } catch (NumberFormatException e) {
       System.out.println("Error: NumberFormatException ECI TimeOut. Using Default."); 
       } catch (IOException io) {
       System.out.println("Error: IOException ECI TimeOut. Using Default."); 
       }
       setEciTO(TOnum);
       System.out.println("\nUsing ECI TimeOut Transaction Setting (millisecs):" + getEciTO());
      }        
   public void setEciTO(int TOnum) {
     if ((TOnum >= min_TO) && (TOnum <= max_TO )) {
       eci_TO = TOnum;
     }
   }
   public int getEciTO() {
       return eci_TO;
   }   
   
   private char chgdfY_N = 'N';
   public void PromptUseDft() { 
     char ansY_N = 'N';
     System.out.println("------------------------------------------------------");
     System.out.println("Default settings:\nProgramName:" + ProgramName +
                        "\nTRANSID:" + MyTransid +                        
                        "\nData Model:" + use_ca_or_cNc +
                        "\nDefault CA:" + getMyCA() +
                        "\nDefault CA Length:" + getCAL() +
                        "\nMaxFlowAttempts:" + MaxFlowAttempts +
                        "\nRepeat Transaction:" + rep_txn +
                        "\nWait Between Trans:" + wt_txn +
                        "\nExtended Trans:" + Xtnd_txn +
                        "\nEci TimeOut:" + getEciTO());
     System.out.println("------------------------------------------------------");     
     System.out.print("Press 'Y'<enter> to Change Values,\n\n Press anyotherkey<enter> to use Defaults," +
                      "\nOr 'Q' to Quit:");
//     Scanner s= new Scanner(System.in);
//     char xtnd = s.next().charAt(0);
     try {
     String tmp = input.readLine().trim().toUpperCase();
     if (tmp.length() > 0) {
       ansY_N = tmp.charAt(0);
     }

    if (ansY_N == 'Q') {
      System.out.println("CTG Selection was 'Q' (QUIT). GoodBye.");      
      System.exit(4);
    }                      
     if (ansY_N == 'Y') {  
     System.out.println("\nPrompting for Overrides to Defaults!");
     } else {
     System.out.println("\n(Entered:" + ansY_N + ") Using Defaults!");     
     }    
     setdfY_N(ansY_N);
     } catch (IOException e) {
     System.out.println("\nError (IOException).Entered:" + ansY_N + ") Using Defaults!"); 
     }
   }
   
   private void setdfY_N(char ansY_N) {
     if (ansY_N != 'Y') {
       ansY_N = 'N';
     }
     chgdfY_N = ansY_N;
   }
   public char getdfY_N() {
     return chgdfY_N;
   }
   // hld_pw - holds PW between iterations because cics nulls it out

   private String strMe = "";
   private String h_strMe = "";         
   private String strMePW = "";
   private String h_strMePW = "";         
  
//private boolean RetryInd = true;  // used to retry failed transaction FLOW
// true means retry up to retry attempts
   private boolean RetryInd = true; 
   
   private void PromptGetNM_PW() {
     try {
        Console c = System.console();
        if (c == null) {
            System.out.println("\nEnter your CICS User ID:");
            strMe = input.readLine().trim();
            System.out.println("\nEnter your CICS Password:");
            strMePW = input.readLine().trim();
            } else {
            strMe = c.readLine("Enter your CICS User ID:");
            strMePW = new String (c.readPassword("Enter your CICS Password:"));
            }
         h_strMe = strMe;
         h_strMePW = strMePW; 
         } catch (IOException e) {
         System.out.println("Error: CICS UserID and Password Required" ); 
         System.exit(12);
         }
     }
   
   private void PromptGetNM_PW_agn() {
     try {
        Console c = System.console();
        if (c == null) {
            System.out.println("\nEnter your CICS User ID \n or '=' to use same Userid\n or 'x' to exit:");

            strMe = input.readLine().trim();
             if (strMe.toUpperCase().equals("X")) {
               RetryInd = false;
               //break;
            }
            if (strMe.equals("=")) {
             strMe = h_strMe;
            }
            System.out.println("\nEnter your CICS Password\n or '=' to use same Password\n or 'x' to exit:");
            strMePW = input.readLine().trim();
            if (strMePW.toUpperCase().equals("X")) {
               RetryInd = false;
              // break;
            }
            if (strMePW.toUpperCase().equals("=")) {
             strMePW = h_strMePW;
            }
            } else {
            strMe = c.readLine("\nEnter your CICS User ID \n or '=' to use same Userid\n or 'x' to exit:");
            if (strMe.toUpperCase().equals("X")) {
               RetryInd = false;
              // break;
            }
            if (strMe.equals("=")) {
             strMe = h_strMe;
            }
            
            strMePW = new String (c.readPassword("\nEnter your CICS Password\n or '=' to use same Password\n or 'x' to exit:"));
            if (strMePW.toUpperCase().equals("X")) {
               RetryInd = false;
              // break;
            }
            if (strMePW.equals("=")) {
             strMePW = h_strMePW;
            }
        }
     } catch (IOException e) {
       System.out.println("Error: CICS UserID and Password Required" ); 
       System.exit(12);
       }
   }
   
   protected void fmtDt(Date stDt, Date spDt) {
     SimpleDateFormat formatter;  // Formats the date displayed
     formatter = new SimpleDateFormat ("EEE MMM yyyy dd kk:mm:ss.S", Locale.getDefault());
     String SD = formatter.format(stDt);
     String PD = formatter.format(spDt);
     long millis = spDt.getTime() - stDt.getTime();
     System.out.println("StartTime:" + SD + "\nStop Time:" + PD + "\nResponse (Millsec):" + millis);
     }
     
   //The size of the console dump display data
   private int OP_max_size = 1600; // 1600 is 100 16 bytes at a time
   // pnthex needs to be compiled to 'Y' if you want a dump of the CA byte array(s)
   private char pnthex = 'N';
 
   public void PromptPntHex() { 
     System.out.print("Hex Dump " + OP_max_size + " bytes from DataMode Data (Y/N):" );
     String Stmp = "";
     do {
      try {
       Stmp = input.readLine().trim().toUpperCase();
       if (Stmp.length() > 0) {
         char tPH = Stmp.charAt(0);
         if ((tPH != 'Y' ) && (tPH != 'N')) {
          System.out.print("\nInvalid selection: Try Again." );
          Stmp = "";
         } else {
           pnthex = tPH;
         }
       }
      } catch (IOException e) {
      System.out.println("Error. Invalid Print Hex selection. Try Again'");
      Stmp = "";
      }
      System.out.println("\nUsing Hex Dump Selection response was:" + pnthex);
     } while (Stmp.equals("")); 
    }
   private String Save2FN = "";
   protected String getSavFN() {
     return Save2FN;
   }
   
   public void SaveData() {
     File f = null;
     char t_save = '-';
     char tPH;
     String Stmp = "";
     System.out.println("Save DataMode Data to file?(N/Y/R/A):" );

     do {
     System.out.print("N - No\nY - Yes (both Raw and ASCII)\nR - Raw Data Only\nA - ASCII Data Only:");
     try {  
     Stmp = input.readLine().trim().toUpperCase();
     if (Stmp.length() > 0) {
       tPH = Stmp.charAt(0);
       if ((tPH != 'Y' ) && (tPH != 'N') && (tPH != 'R' ) && (tPH != 'A')) {
         System.out.print("\nInvalid selection: Try Again or 'N' to bypass Save:" );
         } else {
         t_save = tPH;
         }
        }
       } catch (IOException e) {
         System.out.println("Error Response. Try again.");
       }
       } while (t_save == '-');
    
    if (t_save == 'N') {
      System.out.println("\nYou choose to Bypass Save to File." );      
      return;
    }

   String tFN = "";
   do {
     try {
       System.out.print("\nEnter a new or existing path\filename (or 'x' to exit):" );        
       tFN = input.readLine().trim();
       if (tFN.equalsIgnoreCase("x")) {
       return;
       }
     f = new File(tFN);
     if (f.isDirectory()) { 
      System.out.println("\nYou choose A Directory. Tty Again.");      
      } else {
      if (f.exists()) {
       System.out.println("\nFile Exists. Overwrite it (Y/N):" ); 
       Stmp = input.readLine().trim().toUpperCase();
       if (Stmp.length() > 0) {
        tPH = Stmp.charAt(0);
        if (tPH != 'Y' ) {
         System.out.print("\nYou Choose to NOT overwrite." );
         } else {
         Save2FN = tFN;
         }
        } else {
        System.out.print("\nInvalid Overwrite entry. try again." );
        }
       } else {
       Save2FN = tFN;
       }
      }
     } catch (IOException e) {
     System.out.println("Error Response. Try again.");
     } 
    } while(Save2FN.equals("")); 
       /**
     * Use FileWriter when number of write operations are less
     * @param data
     */

      //  File file = new File("/Users/pankaj/FileWriter.txt");
   BufferedOutputStream bos = null;
   try {
   //create an object of FileOutputStream
   //FileOutputStream fos = new FileOutputStream(new File(filename));
   FileOutputStream fos = new FileOutputStream(f);

   //create an object of BufferedOutputStream
   bos = new BufferedOutputStream(fos);

      if ((t_save == 'R') || (t_save == 'Y')) {
              int i = CA_bresp.size();
              for (int j = 0; j < i; j++) {
                bos.write(CA_bresp.get(j));
              }
            }
       if ((t_save == 'A') || (t_save == 'Y')) {
              int i = CA_Sresp.size();
              for (int j = 0; j < i; j++) {
                bos.write(CA_Sresp.get(j).getBytes());
              }
            }            
        } catch (IOException e) {
            e.printStackTrace();
        }finally{
            //close resources
            try {
                bos.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
      
   public void DispCA() 
   {
         int Txn_ct = Txn_resp.size();
         int CA_ct = CA_Sresp.size();
         int j = CA_ct;
         Date stDt, spDt;
         String tCA = "";
         int tCA_Len = 0;
         DispHexCA d_h_ca = new DispHexCA();         
         if (Txn_ct != CA_ct) {
           System.out.println("\nError: Txn count(" + Txn_ct +
                              ") does not match CA count(" + CA_ct + ")\n");
           if (CA_ct > Txn_ct) {
             j = Txn_ct;
           }
         }
         for (int i = 0; i < j; i++) {
           tCA = Txn_resp.get(i);
           tCA_Len = tCA.length();           
           System.out.println("Printing CA for iteration:" + (i + 1) + "\nCA Length:" + tCA_Len );
           fmtDt( TxnStDt.get(i), TxnSpDt.get(i));
           System.out.print(tCA.trim());
           System.out.println(CA_Sresp.get(i).trim() +  ":txeT");

            PromptPntHex();  
        if (pnthex == 'Y') { 

// Use general window size of 80 shars
// format 6digits for offset (0-999990)
//        ^| 2 pos
//        groups of 4 hex chars (8digits) separated by 1 sp
//        | | 3 pos           
//        16 chars
//        | 1 pos            
// 12345 | 1234ABCD |01010101 01010101 01010101 01010101|123456789abcdef0|      74 chars?     
           System.out.println("\nHEX Print of Commarea before CP Conversion : ");
           System.out.println("Variable:abytCommarea in Hex:");
        
           byte[] abytCommarea = CA_bresp.get(i);
           d_h_ca.dispit(abytCommarea,OP_max_size); 
           
           System.out.println("\nHEX Print of Commarea after CP Conversion : ");              
           d_h_ca.dispit(CA_Sresp.get(i).getBytes(), OP_max_size);
           
         }  
         System.out.println("\n###########################################");
      }
   }
     /**
   Constructor.
   @param aFileName full name of an existing, readable file.
  */
//  public EciB1e(String rgnstr, String IPAdr, String IPSocket){
   public EciB1e(String kixport_target) {  
    Scanner scanner = new Scanner(kixport_target);
    scanner.useDelimiter(",");
    if ( scanner.hasNext() ){
      try {  
       while ( scanner.hasNext() ){
        ctg_targ.put("CTG",scanner.next());
        ctg_targ.put("IPAdr",scanner.next());
        ctg_targ.put("IPSocket",scanner.next());
        ctg_targ.put("JKS",scanner.next());
        ctg_targ.put("CTG_OS",scanner.next());
        ctg_targ.put("CTG_CP",scanner.next());        
        ctg_targ.put("SSL",scanner.next());
          } 
         } catch  (Exception e) {
         System.out.println("Error: EciB1e:Scanner kixport_line:" + e);
         System.exit(12);
        }  
       }
       System.out.print("Local System CodePage Charset is:" );  
       Charset cs_dft = Charset.defaultCharset();
       String lcl_cs = cs_dft.displayName();
       System.out.println(lcl_cs);
       Set s = cs_dft.aliases();
       Iterator j = s.iterator();
       String sep = "";
       while (j.hasNext()) {
            String a = (String) j.next();         
            System.out.print(sep+a);
            sep=",";
         }
         System.out.println("\n____________________________" );
         PromptGetNM_PW();
         System.out.println("");
         String strUrl = ctg_targ.get("IPAdr");
         int iPort = Integer.parseInt(ctg_targ.get("IPSocket"));
         PromptUseDft();  
/*         
         try {
         PromptUseDft();
         } catch (IOException e) {
         System.out.println("Warning: IOException on System.in: Override Defaults Query failed.\n" +
                            "\nUsing Default Values. Proceed with that information, if you wish."); 
         setdfY_N('N');
         }
*/         
   }
   
   
   
   
/*
 * end of constructor
 * 
*/
   
      public int tryit() {
         CA_bresp.clear();
         CA_Sresp.clear();
         Txn_resp.clear();
         TxnStDt.clear();   
         TxnSpDt.clear();   
         int rc = 0;
         String strChosenServer = null;  // used to select the target cics region
         String strInput = null;
         String strAns = null;
//         
    //   String str_rem_cs = "cp1252";        // Windows CP
    //   String str_rem_cs = "cp1047";        // zOS CP
    //   String str_rem_cs = "cp819";                  // AIX CP         

         String ctgrgn = ctg_targ.get("CTG");
         String strUrl = ctg_targ.get("IPAdr");
         String strFullUrl = null;
         int iPort = Integer.parseInt(ctg_targ.get("IPSocket"));
 //        String rgnType = ctg_targ.get("RgnType");
         String useJKS = ctg_targ.get("JKS");        // derived SSL setting         
         String rgnOS = ctg_targ.get("CTG_OS");
         String str_rem_cs = ctg_targ.get("CTG_CP");        // from the kixports file
         String useSSL = ctg_targ.get("SSL");        // derived SSL setting

         
         int iECISvrct = 0;
         int iChoice = 0;
         // Display banner
         System.out.println("\nConnecting to Selected CTG:" + ctgrgn);
         String strServerNumber = null;
         String strSSLKeyring  = null;
         String strSSLPassword = null;      
         
         // Process the command line arguments and display Gateway settings

        System.out.print("\nThe address of the Gateway has been set to ");
         System.out.println(strUrl + " Port:" + iPort + "\n");

         // Declare and initialize method variables and ECIRequest object n
    try {
         ECIRequest eciRequestObject = null;  
         int EciNoXtnd = ECIRequest.ECI_NO_EXTEND;
         int EciXtnd = ECIRequest.ECI_EXTENDED;
         int i_eci_xtnd = EciNoXtnd;
         int i_eci_xLUW = 0;
         if (getrep_txn() > 0) {
           if (getXtnd_txn() == 'Y') {
             i_eci_xtnd = EciXtnd;
             i_eci_xLUW = ECIRequest.ECI_LUW_NEW;
           }
         }
         
         Properties sslProps = new Properties();
         if (useSSL.equals("Y")) {
           int SSLIndex = ctgrgn.indexOf("SSL");
           String ctgrgnX = ctgrgn.substring(0,SSLIndex);
           if (ctgrgnX.endsWith("D")) {
           System.out.print("\nThis Gateway request is using SSL and cacerts default jks:" + "\n");             
           } else {
           strSSLKeyring = "/RunCtg/TestZOS/" + useJKS + ".jks";
           strSSLPassword = "CICSabcd";
         // Set the keyring and keyring password and then initialize
         // the JavaGateway object to flow data to the Gateway           
           sslProps.setProperty(JavaGateway.SSL_PROP_KEYRING_CLASS, strSSLKeyring);
           sslProps.setProperty(JavaGateway.SSL_PROP_KEYRING_PW, strSSLPassword);           
           System.out.print("\nThis Gateway request is using SSL jks:" + strSSLKeyring + "\n");
           }
           strFullUrl = "SSL://";
           strFullUrl = strFullUrl.concat(strUrl);
         } else {
           System.out.print("\nThis Gateway request is not using SSL\n");
           strFullUrl = "TCP://";
           strFullUrl = strFullUrl.concat(strUrl);
           }


         try {
            javaGatewayObject = new JavaGateway(strFullUrl, iPort, sslProps);
            } catch (Exception e) {
         e.printStackTrace();
         System.exit(30);    
      }
         
         // Obtain a list of CICS servers defined

         // If an ECI_ERR_MORE_SYSTEMS error occurs this is because you have more servers
         // defined in your CICS TG configuration than the value stored in the iServerCount
         // variable. To solve this problem, increase the value assigned to iServerCount,
         // recompile and rerun this sample.
         int iServerCount = 460;         
         eciRequestObject = ECIRequest.listSystems(iServerCount);
         System.out.println("MAX Servers count::" + iServerCount);
//         strAns = input.readLine().trim();
         flowRequest(eciRequestObject); 

         // Ask for user to choose from the list of defined servers
         Set<String> ctg_targs = new HashSet<String>();          
         do {
            if (eciRequestObject.SystemList.isEmpty() == true) {
               System.out.println("No CICS servers have been defined.");
               if (javaGatewayObject.isOpen() == true) {
                  javaGatewayObject.close();
               }
               System.exit(0);
            }
            iECISvrct = eciRequestObject.numServersReturned;
            System.out.println("ECI Servers count:" + iECISvrct);            
            System.out.println("CICS Servers Defined:\n");
            for (int i = 0; i < eciRequestObject.numServersReturned; i++) {
               if (i < 9) {
                  strServerNumber = "\t " + (i + 1) + ". ";
               } else {
                  strServerNumber = "\t" + (i + 1) + ". ";
               }

               // Prints the name and description of the server as contained
               // in the SystemList vector
               String V = (String) eciRequestObject.SystemList.elementAt(2*i);
               ctg_targs.add(V);
               System.out.println
                (strServerNumber
                 + eciRequestObject.SystemList.elementAt(2*i) + " -"
                 + eciRequestObject.SystemList.elementAt((2*i)+1));
            }
            System.out.println("\n\nChoose Target Server (by number),"
                               + "a for ALL servers, or q to quit:");
            strInput = input.readLine().trim();
            if ((strInput).equalsIgnoreCase("q")) {
               if (javaGatewayObject.isOpen() == true) {
                  javaGatewayObject.close();
               }
               System.exit(0);
            }
            if ((strInput).equalsIgnoreCase("a")) {
              System.out.println("You Selected ALL CICS Regions.");
            }

            try {
               iChoice = java.lang.Integer.parseInt(strInput);
            } catch (java.lang.NumberFormatException e) {
               System.out.println("\n\nType the number of the "
                                  + "Server to connect to or q to quit\n");
               continue;
            }

            // Validate that the choice is in range using the
            // ECIRequest numServersReturned variable
            if (iChoice > 0 && iChoice <= eciRequestObject.numServersReturned)
            {  strChosenServer =
               (String)eciRequestObject.SystemList.elementAt(((iChoice-1)*2));
            } else {
               System.out.println("\n\nOut of Range\n");
            }
         } while (strChosenServer == null);

         
         System.out.println("\nServer::" + strChosenServer);

         String strProgram = getPN();           
         String strTPNM = getMyTID();  
         int iCommareaSize = getCAL();

         StringBuilder strComA = new StringBuilder(getMyCA());         
         int n_l = iCommareaSize;
//         strComA.setLength(n_l);
         byte[] abytCommarea = new byte[iCommareaSize];         
//         String SComA = strComA.toString();
//         System.out.println("CommareaLength>" + SComA.length());
//        System.out.println("Commarea>" + SComA);
 // Change #5 activate codepage conversion (ie  to and from zos)
 //      Use CP conversion when going to the zOS CICS  
         String pnthex = "N";
         
 //        
 // Top of the repeat loop 
 //         
     int cur_repeat_cnt = 0;
     int strComA_Len = 0;
     do {
         strComA.setLength(0);
         if (getDM() == 'P') {
          System.out.println("Iteration:" + (cur_repeat_cnt + 1) + ":DataMode is Prompt. Enter next " + getCnC()); 
          PGetCA(stdmyCA);
          strComA.append(getMyCA());
         } else {
         strComA.append(getMyCA_L(cur_repeat_cnt));
         }
         strComA_Len = strComA.length();
         strComA.setLength(n_l);
         String SComA = strComA.toString();
         System.out.println("True CommareaLength>" + strComA_Len +
                "\nSetting CommareaLength to>" + SComA.length());
         System.out.println("(True) Commarea>" + SComA.substring(0,strComA_Len) + '<');
         abytCommarea = SComA.getBytes(str_rem_cs);
         String aComStr = new String(abytCommarea);
         System.out.println("abytCommarea>" + aComStr.substring(0,strComA_Len) + '<');
         iCommareaSize = n_l;    // set above
                 
         System.out.println("\nText from Commarea before flow (abytCommarea): "
                               + new String(abytCommarea).substring(0,strComA_Len) + '<');
 //        eciRequestObject =
 //        new ECIRequest(ECIRequest.ECI_SYNC_TPN,  //ECI_SYNC call type eci_tranid CSMI
 //                                                 // or use ECI_SYNC_TPN for eci_tpn 
                                                    // uses the user transid
 //                       strChosenServer,          //CICS server
 //                       null,                     //CICS userid
 //                       null,                     //CICS password
 //                       strProgram,               //CICS program to be run
 //                       null,                     //CICS transid to be run
 //                       abytCommarea,             //Byte array containing the
 //                                                 // COMMAREA
 //                       iCommareaSize,            //COMMAREA length
 //                       ECIRequest.ECI_NO_EXTEND, //ECI extend mode
 //                       0);                       //ECI LUW token
/*
 * TPNName ECIRequest.Call_Type = ECI_SYNC_TPN or ECI_ASYNC_TPN
 *                                and ECIRequest.Transid
 * TranName ECIRequest.Call_Type = ECI_SYNC or ECI_ASYNC
 *                                and ECIRequest.Transid
 * note that TPNNAME specification will use the eci transid as the runtime txn (if specified else csmi)
 */
         
         if (cur_repeat_cnt == 0) {
         eciRequestObject =
         new ECIRequest(ECIRequest.ECI_SYNC_TPN,  //ECI call type
                        strChosenServer,          //CICS server
                        strMe,                     //CICS userid strMe or null
                        strMePW,                     //CICS password or null
                        strProgram,               //CICS program to be run
                        strTPNM,                  //CICS transid to be run strTPNM
                                                  // note that by setting ECI_SYNC_TPN, tells eci request 
                                                  // that this is BOTH the TPNAME and TRANID
                        abytCommarea,             //Byte array containing the
                                                  // COMMAREA
                        iCommareaSize,            //COMMAREA length
                        i_eci_xtnd,               // getXtnd_txn() Y or N sets this value
//                        ECIRequest.ECI_NO_EXTEND, //ECI extend mode int value
                        i_eci_xLUW);               //ECI LUW token int 
         //ECIRequest.ECI_EXTENDED ECIRequest.ECI_NO_EXTEND, //ECI extend mode
         // Call the flowRequest method and display returned data in hex and
         // ASCII format. If the method returns true a security error has
         // occurred and the user is prompted for a CICS user ID and password.
         } else {
           eciRequestObject.Commarea = abytCommarea;
           eciRequestObject.Commarea_Length = iCommareaSize;
         }
           
         short s_int = (short) getEciTO();
         
         eciRequestObject.setECITimeout(s_int);   // added 20120202
         // while condition here depends on the success of the flow request;
         //  flow request will return 'false' if it was successful
         //  so we would not enter this again unless the flow got a error response 
// this is top of the flow loop - loop until we get good resp of MaxFlowAttempts         
         while ((flowRequest(eciRequestObject) == true) && RetryInd){
           System.out.println("\nText from Commarea on retry (abytCommarea):\n "
                               + new String(abytCommarea));
           for (int q = 0; q < 200; q++) {
            System.out.print(Integer.toHexString(abytCommarea[q]));
         }
         h_strMe = strMe;
         h_strMePW = strMePW;

         PromptGetNM_PW_agn();
         
         eciRequestObject.Userid = strMe;
         eciRequestObject.Password = strMePW;
         iValidationFailed++;    // compare to MaxFlowAttempts
         }
         if ( RetryInd ) {
         int ca_len = eciRequestObject.Commarea_Length;  
         CA_bresp.add(eciRequestObject.Commarea);

         String ret_ComA = new String(eciRequestObject.Commarea,0,eciRequestObject.Commarea_Length,str_rem_cs);
         CA_Sresp.add(ret_ComA);
         
         StringBuffer txnR = new StringBuffer();
         txnR.append("\nTransid>" + strTPNM + "< Userid>" + strMe).append(
               "\nProgram " + strProgram  + " returned with data.").append( 
               "\nReported ECI CommareaLen: " + ca_len).append(
               "\tStrLen of CommareaLen: " + ret_ComA.length()).append(
               "\nReturning Commarea variable:ret_ComA: CP converted:").append("\nText\n"); 
            
         Txn_resp.add(txnR.toString());
         System.out.println("Saved Txn details and CA for iteration:" + (cur_repeat_cnt + 1));
         
 //        System.out.print("\nTransid>" + strTPNM + "< Userid>" + strMe);
 //        System.out.println("\nProgram " + strProgram + " returned with data:- \n");
 //        int ca_len = eciRequestObject.Commarea_Length;
 //      Use CP conversion when going to the zOS CICS                
 //        String ret_ComA = new String(eciRequestObject.Commarea,0,eciRequestObject.Commarea_Length,str_rem_cs); 
 //        String ret_ComA = new String(eciRequestObject.Commarea,0,eciRequestObject.Commarea_Length);
 //        System.out.print("\n\tReported ECI CommareaLen: " + ca_len);                  
 //        System.out.print("\tStrLen of CommareaLen: " + ret_ComA.length());         
 //        System.out.print("\n\tReturning Commarea variable:ret_ComA: CP converted:");         
 //        System.out.print("\nText:" + ret_ComA + ":txeT");
 /*       if (pnthex == "Y") {     
           System.out.print("\nHEX Print of Commarea before CP Conversion : ");
           System.out.print("\n\tVariable:abytCommarea in Hex: ");
           for (int i_t: abytCommarea) {
             System.out.print(Integer.toHexString(i_t));
           }
           try {
            System.out.println("\n\nASCII text from Commarea before CP conversion (abytCommarea): "
                               + new String(abytCommarea, "ASCII"));
           } catch (UnsupportedEncodingException e) {
            System.out.println
            ("\tThe ASCII encoding scheme is not supported.");
           }
         } 
         } else {
         System.out.println("Retry failed or Exit requested: Ending execution.");
         }
         */
         }
         if ((getrep_txn() > 0) && cur_repeat_cnt < getrep_txn()) {
             System.out.println("\nFinished Repeat Iteration #" + 
                                (cur_repeat_cnt + 1) + " of " + (getrep_txn() + 1));         
           if (getwt_txn() > 0) {
             System.out.println("\n\nSleeping " + (getwt_txn() / 1000) + " seconds...");
             EciSleep(getwt_txn());
           }
           System.out.println("____________________");
         }
  // end of repeat loop
         cur_repeat_cnt++;
         } while (cur_repeat_cnt <= getrep_txn());
         // issue SYNC if necessary
         if (getXtnd_txn() == 'Y') {
            eciRequestObject.Extend_Mode = ECIRequest.ECI_COMMIT;
            eciRequestObject.Call_Type = ECIRequest.ECI_SYNC;
            eciRequestObject.Program = null;
            javaGatewayObject.flow(eciRequestObject);
            }

         // Close the JavaGateway object before exiting
         if (javaGatewayObject.isOpen() == true) {
            javaGatewayObject.close();
         }
// end of tryit: first try..catch logic
      } catch (Exception e) {
         e.printStackTrace();
         rc = 8;    
      }
      return rc;
   }

   // The flowRequest method flows data contained in the ECIRequest object to
   // the Gateway and determines whether it has been successful by checking the
   // return code. If an error has occurred, the return code string and abend
   // codes are printed to describe the error before the program exits.
   // Note: Security may be required for client connection to the server and
   //       not just for the ECI request. Refer to the security chapter in the
   //       CICS Transaction Gateway Administration book for further details.
      // remove static from below - 
   private  boolean flowRequest(ECIRequest requestObject) {
      try {
         Date startDt = new Date();
         int iRc = javaGatewayObject.flow(requestObject);
         Date stopDt = new Date();         
         // Checks for gateway errors and returns false if there are no errors
         System.out.println("\nReturn from Gateway");
         
         switch (requestObject.getCicsRc()) {
         case ECIRequest.ECI_NO_ERROR:
            if (iRc == 0) {
               TxnStDt.add(startDt);
               TxnSpDt.add(stopDt);
               return false; // when successful, we set 'retry' to false
            } else {
               System.out.println("\nError from Gateway ("
                                  + requestObject.getRcString()
                                  + "), correct and rerun this sample");
               if (javaGatewayObject.isOpen() == true) {
                  javaGatewayObject.close();
               }
               System.exit(0);
            }

         // Checks for security errors and returns true if validation has
         // failed on four or less occasions
         case ECIRequest.ECI_ERR_SECURITY_ERROR:
            if (iValidationFailed == 0) {
               return true;
            }
            System.out.print("\n\nValidation failed. ");
            if (iValidationFailed < this.getMaxFA()) {   // MaxFlowAttempts
               System.out.println("Try entering your details again.");
               return true;
            }
            break;

         // Checks for transaction abend errors where the user is authorised
         // to access the server but not run the EC01 program.
         // The sample should be rerun and a user ID and password with the
         // required authorisation entered.
         case ECIRequest.ECI_ERR_TRANSACTION_ABEND:
            System.out.println("\nYou are not authorised to run this transaction.");
            break;
            
         case ECIRequest.ECI_ERR_REQUEST_TIMEOUT: 
            System.out.println("\nECI Transaction  TimeOut");
            break;
         
         }
         System.out.println("\nECI returned: "
                            + requestObject.getCicsRcString());
         System.out.println("Abend code was "
                            + requestObject.Abend_Code + "\n");
         if (javaGatewayObject.isOpen() == true) {
            javaGatewayObject.close();
         }
         System.exit(0);

      } catch (Exception e) {
         e.printStackTrace();
         System.exit(0);
      }
      return true;   // if we are here, then we want a 'retry'
   }
}
//
//         File Name     : EciB1e.java

package TestZOS;

import java.lang.*;
import java.util.*;
import java.text.*;
import java.io.*;
import java.nio.charset.*;
import java.util.Properties;
import java.util.concurrent.TimeUnit;
import java.lang.InterruptedException;
import java.math.*;

//import TestZOS.*;

import com.ibm.ctg.client.*;

public class EciB1e {
   final String RunEci_V = "EciB1e V1.1";
   // Declare objects for use in both methods
   private static JavaGateway javaGatewayObject;

   private static InputStreamReader isr = new InputStreamReader(System.in);
   private static BufferedReader input = new BufferedReader(isr);
   private static int iValidationFailed = 0;
   private static HashMap<String, String> ctg_targ = new HashMap<String, String>();
   private static ArrayList<byte[]> CA_bresp = new ArrayList<>();
   private static ArrayList<String> CA_Sresp = new ArrayList<>();
   private static ArrayList<String> Txn_resp = new ArrayList<>();
   private static ArrayList<Date> TxnStDt = new ArrayList<>();
   private static ArrayList<Date> TxnSpDt = new ArrayList<>();   
   
   //Name of the CICS program to execute
   // private String ProgramName = "PONG";    // commarea only
   private String ProgramName = "UCEMPINR";
   public void PromptPN(String PN) { 

     if (PN.equals("")) {
       PN = getPN();  
     } 
     System.out.println("Selected CICS Target Program:" + PN);
     System.out.print("Enter Different CICS Target Program:");
     try {
     PN = input.readLine().trim().toUpperCase();
     setPN(PN);
     } catch (IOException e) {
       System.out.println("Error. IOException reading Target Program. Using Default.");
      }
     System.out.println("\nUsing CICS Target Program:" + getPN());
     }
   public void setPN(String PN) 
   {
     if ((PN.length() > 0) && (PN.length() < 9 )) {
       ProgramName = PN;
     }
   }
   public String getPN() {
       return ProgramName;
   }
   
   //Name of the CICS Transid to execute
   private String MyTransid = "UXXX";
   public void PromptTID(String TID) {
     if (TID.equals("")) {
       TID = getMyTID();  
     } 
     System.out.print("Enter Different TRANSID:" + TID);
     try {                                      
     TID = input.readLine().trim().toUpperCase();
     if ((TID.length() > 0) && (TID.length() < 5)) {
       setMyTID(TID); 
       } 
      } catch (IOException e) {
       System.out.println("Error. IOException reading Target TRANSID. Using Default.");
     } 
     System.out.print("\nUsing TRANSID:" + getMyTID());
    }   
   public void setMyTID(String TID) {
     if ((TID.length() > 0) && (TID.length() < 5 )) {
       MyTransid = TID.toUpperCase();
       MyMirrorTransId = MyTransid;
     }
   }
   public String getMyTID() {
     return MyTransid;
   } 
   //Name of the CICS Transid that mirror is to execute
   private String MyMirrorTransId = MyTransid;
   
//Maximum number of flow attempts
   private int MaxFlowAttempts = 3;
   public void PromptFA(int FA) {
     if ( FA == 0) {
       FA = getMaxFA();  
     } 
     System.out.println("Current FLOW Retry Setting:" + FA);
     System.out.print("Enter Different FLOW Setting:");
     try {
     FA  = Integer.parseInt( input.readLine().trim() );
     setMaxFA(FA);
     } catch (NumberFormatException e) {
      System.out.println("Error: NumberFormatException Reading FlowAttempts. Using Default."); 
      } catch (IOException e) {
       System.out.println("Error. IOException reading FLOW Setting. Using Default.");
     } 
     System.out.println("\nUsing FLOW Retry Setting:" + getMaxFA());
    }   
   public void setMaxFA(int FA) {
     if ((FA > 0) && (FA < 5 )) {
       MaxFlowAttempts = FA;
     }
   }
   public int getMaxFA() {
       return MaxFlowAttempts;
   }     
        
   // Set program to use CA or cNc
   private String use_ca_or_cNc = "CA";
   //private string use_ca_or_cNc = "cNc";
   public void PromptCnC(String use_ca_or_cNc) {
     if (use_ca_or_cNc.equals("")) {
       use_ca_or_cNc = "CA";  
     } 
     System.out.print("Select Data Model:\n'CA' for Commarea,\nor 'CnC' for Channel and Container(s):" + use_ca_or_cNc);
     try {
     use_ca_or_cNc = input.readLine().trim().toUpperCase();
     } catch (IOException e) {
       System.out.println("Error. IOException reading Data Model. Using Default.");
     }  
     if (!(use_ca_or_cNc.equals("CA")) && !(use_ca_or_cNc.equals("CNC"))) {
       use_ca_or_cNc = "CA";  
       } 
    System.out.print("\nUsing Data Model:" +  use_ca_or_cNc);
    }

   public String getCnC() {
     return use_ca_or_cNc;
   }

   //Name of Channel to pass to EC03 program
   private String CHANNEL_NAME = "PONG_Channel";   // max 16
   public void PromptChanNm(String ChanNm) { 
     if (ChanNm.equals("")) {
       ChanNm = CHANNEL_NAME;  
     } 
     System.out.print("Enter CHANNEL_NAME:" + ChanNm);
     try {
     ChanNm = input.readLine().trim();
     if ((ChanNm.length() > 0) && (ChanNm.length() < 17)) {
       CHANNEL_NAME = ChanNm;  
       }
     } catch (IOException e) {
       System.out.println("Error. IOException reading CHANNEL_NAME. Using Default.");
     } 
     System.out.print("\nUsing CHANNEL_NAME:" + CHANNEL_NAME);
    }   

   //Name of Container to pass to EC03 program
   private String CONTAINER_NAME = "PONGCNCCONTNR";   //max 16
   public void PromptContNm(String ContNm) { 
     if (ContNm == "") {
       ContNm = CONTAINER_NAME;  
     } 
     System.out.print("Enter CONTAINER_NAME:" + ContNm);
     try {
     ContNm = input.readLine().trim();
     if ((ContNm.length() > 0) && (ContNm.length() < 17)) {
       CONTAINER_NAME = ContNm;  
       }
     } catch (IOException e) {
       System.out.println("Error. IOException reading CONTAINER_NAME. Using Default.");
     } 
     System.out.print("\nUsing CONTAINER_NAME:" + CONTAINER_NAME);
    } 
           
   //The size of the COMMAREA to send to the program - This can be 0 - 32400
   private int CAL = 4080;
   public void PromptCAL(int ca_len) { 
     int h_ca_len;
     if ( ca_len == 0) {
       ca_len = getCAL();  
     } 
     h_ca_len = ca_len; 
     System.out.println("Current CA Length Setting:" + ca_len);
     System.out.print("Enter Different CA Length Setting:");
      String s_ca_len = "";     
     try {
      s_ca_len = input.readLine().trim(); 
      ca_len  = Integer.parseInt(s_ca_len);
      } catch (NumberFormatException e) {
        if ((s_ca_len.equals("=")) || (s_ca_len.equals(""))) {
          ca_len = h_ca_len;
        } else {
          System.out.println("Error: NumberFormatException Reading CAL. Using Default.");          
          ca_len = getCAL();
        }
      } catch (IOException e) {
       System.out.println("Error. IOException reading FLOW Setting. Using Default.");
       ca_len = h_ca_len;       
      } finally {
       setCAL(ca_len);
      }
     System.out.println("\nUsing CA Length Setting:" + getCAL());
    }      
   public void setCAL(int ca_len) {
     if ((ca_len >= 0) && (ca_len <= 32400 )) {
       CAL = ca_len;
     }
   }
   public int getCAL() {
       return CAL;
   }     
        
   //The size of the COMMAREA to send to the program
//   private String stdmyCA = "Ponged from JAVA EciB1e on my desktop!!";
   private String stdmyCA = "CEMT INQUIRE SYSTEM";
   private String CA = "CEMT INQUIRE TASK";
   private ArrayList<String> CA_aryL = new ArrayList<>();
   private ArrayList<Integer> CA_aryLen = new ArrayList<>();
   protected void setDfltCA() {
    CA_aryL.add(CA);  
   }
   public void PromptGetCA(String tmp_ca) { 
     String tCA = "";
     CA_aryL.clear();
     int repct = getrep_txn();
     char repDM = getDM();
     if (repDM == 'S') {
       PGetCA(stdmyCA);
       tCA = getMyCA();
       for (int i = 0; i <= repct; i++) {
         CA_aryL.add(tCA);
         CA_aryLen.add(tCA.length());
         }
       System.out.println("Data Mode 'S' Static CA set for all (" + (repct + 1) + ") iterations.");
       return;
     }
     if (repDM == 'E') {
       for (int i = 0; i <= repct; i++) {
         System.out.println("\nEnter CA for iteration:" + (i + 1));
         PGetCA(stdmyCA); 
         tCA = getMyCA();         
         CA_aryL.add(tCA);
         CA_aryLen.add(tCA.length());         
         }
       System.out.println("Data Mode 'E' Each CA individually set. Total " + (repct + 1) + " iterations set.");
       return;
     }
     if (repDM == 'F') {
       String fin = DMDFN;
       int rdct = 0;
         FileInputStream fis = null;       
         BufferedReader br = null;
         try {
         fis = new FileInputStream(fin);
         //Construct BufferedReader from InputStreamReader
         br =  new BufferedReader(new InputStreamReader(fis));         
         String line = null;
         while ((line = br.readLine()) != null) {
          rdct++; 
          tCA = line.trim();
          CA_aryL.add(tCA);
          CA_aryLen.add(tCA.length());          
         }
         repct++;
         if (rdct < repct) {
         System.out.println("Repeat count:" + repct + " does not match command count from file:" +
         rdct + ". Reducing Repeat count.");
         setrep_txn(rdct - 1);
         }
         if (rdct > repct) {
         System.out.println("Repeat count:" + repct + " does not match command count from file:" +
         rdct + ". Commands greater than Repeat count ignored.");
         }
        System.out.println("Data Mode 'F' Each CA individually set for " + (getrep_txn() + 1) + " iterations.");
        br.close();
       } catch (IOException e) {
         System.out.println("Error. Could not read file with Commarea List. Goodbye!");
         e.printStackTrace();
         
       } finally {
         try {
           if (br != null) {
             br.close();
             }
           } catch (IOException e) {
           e.printStackTrace();
         }
       }
       return;
     }
   }
   
 public String PromptChoice(String Msg, String Inst, String opts) {
     String msgboxans = "";
     String dft_ans = "";
     String dft_hint = "";
     String ans = "";
     int optsl = opts.length();
     if (optsl == 0) {
       dft_ans = "";
       dft_hint = "Press anykey to Continue";
     } else {
       opts = opts.toUpperCase();
       dft_ans = opts.substring(0,1);
       dft_hint = "Valid Reponse is one of <" + opts + "> Default Response is<" + dft_ans + ">";
     }
     System.out.println("------------------------------------------------------");
     System.out.println(Msg);
     System.out.println("------------------------------------------------------");  
     String tmp = "";
     do {
     System.out.print(Inst);
     try {
     tmp = input.readLine().trim().toUpperCase();
     if (optsl == 0) {
       return "";
     }     
     if (tmp.length() > 0) {
       ans = tmp.substring(0,1);
       if (opts.contains(ans)) {
         return ans;
         }
       } else {
       ans = "";
       }
     System.out.println("Your response:'" + ans + "': is not an Option. Retry.");  
     } catch (IOException e) {
      System.out.println("Error. IOException reading your response. Retry.");
      }
     System.out.print(dft_hint); 
     ans = "";
   } while(msgboxans.equals("")); 
   return ans;
   }
     
   public String getMyCA_L(int ca_num) {
     if ((ca_num < 0) || ca_num > CA_aryL.size()) {
       return "";
     }
     return CA_aryL.get(ca_num);
   }
   
   private void PGetCA(String tmp_ca) {
     if (tmp_ca.equals("")) {
       tmp_ca = stdmyCA;  
     } 
     String tmp1 = tmp_ca;
     String h_tmp_ca = tmp_ca;
     if (tmp_ca.length() > 70) {
       tmp1 = tmp_ca.substring(0,34) + ".." +  tmp_ca.substring(tmp_ca.length() - 34);
     }      
     String ans = "";
     String opts = "NYD=";
     do { 
     System.out.print("Enter Different Commarea:\n" + tmp1 +"\n");
     ans = "Y";  
     try {
     tmp_ca = input.readLine().trim();
     int tmp_cal = tmp_ca.length();
     if (tmp_cal == 0) {
      ans = PromptChoice("CammArea data expected.\nYour Response was zero length. Default GA is\n",
                          "Select Y to use zero length CommArea\nOr N to retry\nOr '=' to use Default CA:",
                          opts);
      if (ans.equals("D") | ans.equals("=")) {
        ans = "Y";
        tmp_ca = getMyCA();
       }
     }
     if (ans.equals("Y")) {
     if (tmp_cal > 32400) {
       tmp_cal = 32400;
       tmp_ca = tmp_ca.substring(0,32399);
     }
     if (tmp_ca.equals("=")) {
       tmp_ca = h_tmp_ca;
     }
     
     setMyCA(tmp_ca);  
     if (tmp_cal > getCAL()) {
         setCAL(tmp_cal);
       }
      } 
     } catch (IOException e) {
      System.out.println("Error. IOException reading CommArea. Using Default.");
      }
     } while(ans.equals("N"));
    tmp1 = getMyCA();
    if (tmp1.length() > 70) {
       tmp1 = tmp1.substring(0,34) + ".." +  tmp1.substring(tmp1.length() - 34);
     }
    System.out.print("Commarea:\n" + tmp1 + "\n"); 
   }
   
   public void setMyCA(String tmp_ca) {
     int tmp_cal = tmp_ca.length();
     if (tmp_cal > 32400) {
       tmp_cal = 32400;
       tmp_ca = tmp_ca.substring(0,32399);
     }
     CA = tmp_ca;  
     if (tmp_cal > getCAL()) {
         setCAL(tmp_cal);
       }
   }
   public String getMyCA() {
     return CA;
   }
   

   //Repeat Non/Xtended transaction 0-98 times, waiting 0-10000 ms between calls
   //private  int  rep_txn = 0; // 0 means NO repeats Itotal:1 executon)
   private int  rep_txn = 0; 
   private int  min_rep_txn = 0, max_rep_txn = 98;
   public void PromptRepNum(int repnum) {
     if ( repnum == 0) {
       repnum = getrep_txn();  
     } 
     System.out.println("Current Repeat Transaction Count Setting:" + repnum);
     System.out.println("NOTE - Zero (0) Repeats implies Run once;\nOne (1) implies Run Twice,...");
     System.out.print("Enter Different Repeat Transaction Count Setting:");
     try {
     repnum  = Integer.parseInt( input.readLine().trim() );  
     setrep_txn(repnum);
     } catch (NumberFormatException e) {
      System.out.println("Error: NumberFormatException Repeat Setting. Using Default."); 
      } catch (IOException e) {
      System.out.println("Error. IOException reading Repeat Setting. Using Default.");
      }
     System.out.println("\nUsing Repeat Transaction Count Setting:" + getrep_txn());
    }      
   public void setrep_txn(int repnum) {
     if ((repnum >= min_rep_txn) && (repnum <= max_rep_txn )) {
       rep_txn = repnum;
     }
   }
   public int getrep_txn() {
       return rep_txn;
   }
   
   // repeat txn datamode 'S' indicates static Datamodel on each eci flow
   //                     'P' indicates Prompt for each Datamodel contents for each iteration
   //                     'E' indicates Datamodel for each iteration setup prior to first iteration
   //                     'F' indicates a file provides the data for each iteration
   private char DMD = 'S';

   public void PromptRepDMD(char tmp) { 
     System.out.print("Repeat Count is greater than 0. Choose a DataMode for the Datamodel" + 
                        "\n'S' indicates static Datamodel on each eci flow" +
                        "\n'P' indicates Prompt for each Datamodel contents for each iteration" +
                        "\n'E' indicates Datamodel for each iteration setup prior to first iteration" +
                        "\n'F' indicates a file provides the data for each iteration" +
                        "\nMake a selection (default is 'S' static:");

//     Scanner s= new Scanner(System.in);
//     char xtnd = s.next().charAt(0);
//     xtnd = Character.toUpperCase(s.next().charAt(0));
     try {
     String Stmp = input.readLine().trim().toUpperCase();
     if (Stmp.length() > 0) {
       int i = setDM(Stmp.charAt(0));
       if (i > 0 ) {
         System.out.print("\nInvalid Data Mode selection: Using Default.");
       } 
      }  
     } catch (IOException e) {
      System.out.println("Error. IOException reading Data Mode Setting. Using Default.");
      }
    System.out.println("\nUsing DataMode:" + getDM());
    }      
   public int setDM(char tmp) {
     tmp = Character.toUpperCase(tmp);
     if ((tmp == 'S') || (tmp == 'P') || (tmp == 'E') || (tmp == 'F') ) {
       DMD = tmp;
       return 0;
     } else {
       DMD = 'S';
       return 4;
       }
   }
   public char getDM() {
     return DMD;
   }   

   private String DMDFN = "";
   protected void DMD_getFN() { 
     String dmfn = "";
     do {
     System.out.print("Data Mode is File. Enter full filename for DataModel Data (or 'x' to Quit):");
     try {
     dmfn = input.readLine().trim();
     if (dmfn.equalsIgnoreCase("x")) {
       System.out.println("Quit Selected. Goodbye.");
       System.exit(8);
     }
     if ((dmfn.length() < 1) || (dmfn.length() > 240)) {
     System.out.println("\nError: file:" + dmfn + " is not correct length." +
       "\nRetry entry of filename for DataModel.");        
       dmfn = "";
       }
     } catch (IOException e) {
      System.out.println("Error. IOException reading File Name for Data Mode. Using Default.");
      dmfn = "";      
      }
     } while (dmfn.equals(""));

     File f = new File(dmfn);
     if (f.exists() && !f.isDirectory()) {
      DMDFN = dmfn; 
      System.out.print("\nUsing file:" + DMDFN + " for Data Mode Data");
     } else {
      System.out.print("\nUsing file:" + dmfn + " is not found.\nChanging DataMode to 'S'");  
      int i = setDM('S');
     }
   }
   
   //private int  wt_txn = 0; // 0 means no wait time between txn
   private long  wt_txn = 0;
   private static final long  min_wt_txn=0 * 1000, max_wt_txn = 99*1000;  // in millisec
   public void PromptWtInvl(long wtnum) { 
     if ( wtnum == 0) {
       wtnum = getwt_txn();  
     } 
     System.out.println("Current Wait Between Transactions Setting (seconds):" + wtnum);
     System.out.print("Enter Different Wait Between Transactions Setting:");
     String S_ans = "";
     double ans = 0.00;   
     Double FD_ans = ans;
     
     try {
      S_ans  = input.readLine().trim().toUpperCase();
      ans  = Double.parseDouble( S_ans);
      BigDecimal BD_ans = new BigDecimal(ans).setScale(2,BigDecimal.ROUND_HALF_UP);
      FD_ans= new Double(BD_ans.doubleValue()); 
    // now convert to long and make the long millesecs
       wtnum  = Math.round(FD_ans * 1000);
       setwt_txn(wtnum);       
       } catch (NumberFormatException e) {
       System.out.println("Error: NumberFormatException Wait Interval. Using Default."); 
       } catch (IOException e) {
       System.out.println("Error. IOException reading Wait Interval. Using Default.");
      }
     System.out.println("\nUsing Wait Between Transactions Setting (millisecs):" + getwt_txn());
      }      
   public void setwt_txn(long wtnum) {
     if ((wtnum >= min_wt_txn) && (wtnum <= max_wt_txn )) {
       wt_txn = wtnum;
     }
   }
   public long getwt_txn() {
       return wt_txn;
   }   
   
   private void EciSleep(long sleep_MS)
     throws InterruptedException {  
   try {
     if ( sleep_MS < min_wt_txn ) {
        sleep_MS = min_wt_txn;
        System.out.println("Sleep Value too small: setting to:" + sleep_MS);        
     } else {
        if ( sleep_MS > max_wt_txn ) {
        sleep_MS = max_wt_txn;
        System.out.println("Sleep Value too large: setting to:" + sleep_MS); 
        }
     }
    TimeUnit.MILLISECONDS.sleep(sleep_MS);
   } catch (InterruptedException e) {
        System.out.print("Warning:EcioB1e:Sleep: Interrupted:");
        System.out.println(e.toString());
        assert false;
        //Handle exception
     }         
   }
   
   //private char  Xtnd_txn = "N"; // "N" means individual txn in repeat cycle
   // "Y" means use LUW information for single LUW
   private char Xtnd_txn = 'N'; 

   public void PromptXtnd(char xtnd) {
     System.out.print("(This options requires CICS RRS=YES)\nEnter Extend Transaction Y or N:" + xtnd);
//     Scanner s= new Scanner(System.in);
//     char xtnd = s.next().charAt(0);
//     xtnd = Character.toUpperCase(s.next().charAt(0));
     try {
      String tmp = input.readLine().trim().toUpperCase();
      if (tmp.length() > 0) {
       xtnd = tmp.charAt(0);
      }
      setXtnd_txn(xtnd);  
      } catch (IOException e) {
      System.out.println("Error:IOException getting Override Values. Using Default.");       
      }
     System.out.print("\nUsing Extend Transaction:" + getXtnd_txn());     
    }      
   public void setXtnd_txn(char xtnd) {
     xtnd = Character.toUpperCase(xtnd);
     if ((xtnd == 'N') || (xtnd == 'Y')) {
       Xtnd_txn = xtnd;
     }
   }
   public char getXtnd_txn() {
     return Xtnd_txn;
   }   

   private int eci_TO = 0;
   private static final int  min_TO=0 * 1000, max_TO = 99*1000;  // in millisec
   public void PromptEciTO(int TOnum) {
     if ( TOnum == 0) {
       TOnum = getEciTO();  
     } 
     System.out.println("Current ECI TimeOut Transactions Setting (seconds):" + TOnum);
     System.out.print("Enter Different ECI TimeOut Transaction Setting:");
     String S_ans = "";
     double ans = 0.00;   
     Double FD_ans = ans;
     
     try {
      S_ans  = input.readLine().trim().toUpperCase();
      ans  = Double.parseDouble( S_ans);
      BigDecimal BD_ans = new BigDecimal(ans).setScale(2,BigDecimal.ROUND_HALF_UP);
      FD_ans= new Double(BD_ans.doubleValue()); 
    // now convert to long and make the long millesecs
       TOnum  = (int) Math.round(FD_ans * 1000);
       } catch (NumberFormatException e) {
       System.out.println("Error: NumberFormatException ECI TimeOut. Using Default."); 
       } catch (IOException io) {
       System.out.println("Error: IOException ECI TimeOut. Using Default."); 
       }
       setEciTO(TOnum);
       System.out.println("\nUsing ECI TimeOut Transaction Setting (millisecs):" + getEciTO());
      }        
   public void setEciTO(int TOnum) {
     if ((TOnum >= min_TO) && (TOnum <= max_TO )) {
       eci_TO = TOnum;
     }
   }
   public int getEciTO() {
       return eci_TO;
   }   
   
   private char chgdfY_N = 'N';
   public void PromptUseDft() { 
     char ansY_N = 'N';
     System.out.println("------------------------------------------------------");
     System.out.println("Default settings:\nProgramName:" + ProgramName +
                        "\nTRANSID:" + MyTransid +                        
                        "\nData Model:" + use_ca_or_cNc +
                        "\nDefault CA:" + getMyCA() +
                        "\nDefault CA Length:" + getCAL() +
                        "\nMaxFlowAttempts:" + MaxFlowAttempts +
                        "\nRepeat Transaction:" + rep_txn +
                        "\nWait Between Trans:" + wt_txn +
                        "\nExtended Trans:" + Xtnd_txn +
                        "\nEci TimeOut:" + getEciTO());
     System.out.println("------------------------------------------------------");     
     System.out.print("Press 'Y'<enter> to Change Values,\n\n Press anyotherkey<enter> to use Defaults," +
                      "\nOr 'Q' to Quit:");
//     Scanner s= new Scanner(System.in);
//     char xtnd = s.next().charAt(0);
     try {
     String tmp = input.readLine().trim().toUpperCase();
     if (tmp.length() > 0) {
       ansY_N = tmp.charAt(0);
     }

    if (ansY_N == 'Q') {
      System.out.println("CTG Selection was 'Q' (QUIT). GoodBye.");      
      System.exit(4);
    }                      
     if (ansY_N == 'Y') {  
     System.out.println("\nPrompting for Overrides to Defaults!");
     } else {
     System.out.println("\n(Entered:" + ansY_N + ") Using Defaults!");     
     }    
     setdfY_N(ansY_N);
     } catch (IOException e) {
     System.out.println("\nError (IOException).Entered:" + ansY_N + ") Using Defaults!"); 
     }
   }
   
   private void setdfY_N(char ansY_N) {
     if (ansY_N != 'Y') {
       ansY_N = 'N';
     }
     chgdfY_N = ansY_N;
   }
   public char getdfY_N() {
     return chgdfY_N;
   }
   // hld_pw - holds PW between iterations because cics nulls it out

   private String strMe = "";
   private String h_strMe = "";         
   private String strMePW = "";
   private String h_strMePW = "";         
  
//private boolean RetryInd = true;  // used to retry failed transaction FLOW
// true means retry up to retry attempts
   private boolean RetryInd = true; 
   
   private void PromptGetNM_PW() {
     try {
        Console c = System.console();
        if (c == null) {
            System.out.println("\nEnter your CICS User ID:");
            strMe = input.readLine().trim();
            System.out.println("\nEnter your CICS Password:");
            strMePW = input.readLine().trim();
            } else {
            strMe = c.readLine("Enter your CICS User ID:");
            strMePW = new String (c.readPassword("Enter your CICS Password:"));
            }
         h_strMe = strMe;
         h_strMePW = strMePW; 
         } catch (IOException e) {
         System.out.println("Error: CICS UserID and Password Required" ); 
         System.exit(12);
         }
     }
   
   private void PromptGetNM_PW_agn() {
     try {
        Console c = System.console();
        if (c == null) {
            System.out.println("\nEnter your CICS User ID \n or '=' to use same Userid\n or 'x' to exit:");

            strMe = input.readLine().trim();
             if (strMe.toUpperCase().equals("X")) {
               RetryInd = false;
               //break;
            }
            if (strMe.equals("=")) {
             strMe = h_strMe;
            }
            System.out.println("\nEnter your CICS Password\n or '=' to use same Password\n or 'x' to exit:");
            strMePW = input.readLine().trim();
            if (strMePW.toUpperCase().equals("X")) {
               RetryInd = false;
              // break;
            }
            if (strMePW.toUpperCase().equals("=")) {
             strMePW = h_strMePW;
            }
            } else {
            strMe = c.readLine("\nEnter your CICS User ID \n or '=' to use same Userid\n or 'x' to exit:");
            if (strMe.toUpperCase().equals("X")) {
               RetryInd = false;
              // break;
            }
            if (strMe.equals("=")) {
             strMe = h_strMe;
            }
            
            strMePW = new String (c.readPassword("\nEnter your CICS Password\n or '=' to use same Password\n or 'x' to exit:"));
            if (strMePW.toUpperCase().equals("X")) {
               RetryInd = false;
              // break;
            }
            if (strMePW.equals("=")) {
             strMePW = h_strMePW;
            }
        }
     } catch (IOException e) {
       System.out.println("Error: CICS UserID and Password Required" ); 
       System.exit(12);
       }
   }
   
   protected void fmtDt(Date stDt, Date spDt) {
     SimpleDateFormat formatter;  // Formats the date displayed
     formatter = new SimpleDateFormat ("EEE MMM yyyy dd kk:mm:ss.S", Locale.getDefault());
     String SD = formatter.format(stDt);
     String PD = formatter.format(spDt);
     long millis = spDt.getTime() - stDt.getTime();
     System.out.println("StartTime:" + SD + "\nStop Time:" + PD + "\nResponse (Millsec):" + millis);
     }
     
   //The size of the console dump display data
   private int OP_max_size = 1600; // 1600 is 100 16 bytes at a time
   // pnthex needs to be compiled to 'Y' if you want a dump of the CA byte array(s)
   private char pnthex = 'N';
 
   public void PromptPntHex() { 
     System.out.print("Hex Dump " + OP_max_size + " bytes from DataMode Data (Y/N):" );
     String Stmp = "";
     do {
      try {
       Stmp = input.readLine().trim().toUpperCase();
       if (Stmp.length() > 0) {
         char tPH = Stmp.charAt(0);
         if ((tPH != 'Y' ) && (tPH != 'N')) {
          System.out.print("\nInvalid selection: Try Again." );
          Stmp = "";
         } else {
           pnthex = tPH;
         }
       }
      } catch (IOException e) {
      System.out.println("Error. Invalid Print Hex selection. Try Again'");
      Stmp = "";
      }
      System.out.println("\nUsing Hex Dump Selection response was:" + pnthex);
     } while (Stmp.equals("")); 
    }
   private String Save2FN = "";
   protected String getSavFN() {
     return Save2FN;
   }
   
   public void SaveData() {
     File f = null;
     char t_save = '-';
     char tPH;
     String Stmp = "";
     System.out.println("Save DataMode Data to file?(N/Y/R/A):" );

     do {
     System.out.print("N - No\nY - Yes (both Raw and ASCII)\nR - Raw Data Only\nA - ASCII Data Only:");
     try {  
     Stmp = input.readLine().trim().toUpperCase();
     if (Stmp.length() > 0) {
       tPH = Stmp.charAt(0);
       if ((tPH != 'Y' ) && (tPH != 'N') && (tPH != 'R' ) && (tPH != 'A')) {
         System.out.print("\nInvalid selection: Try Again or 'N' to bypass Save:" );
         } else {
         t_save = tPH;
         }
        }
       } catch (IOException e) {
         System.out.println("Error Response. Try again.");
       }
       } while (t_save == '-');
    
    if (t_save == 'N') {
      System.out.println("\nYou choose to Bypass Save to File." );      
      return;
    }

   String tFN = "";
   do {
     try {
       System.out.print("\nEnter a new or existing path\filename (or 'x' to exit):" );        
       tFN = input.readLine().trim();
       if (tFN.equalsIgnoreCase("x")) {
       return;
       }
     f = new File(tFN);
     if (f.isDirectory()) { 
      System.out.println("\nYou choose A Directory. Tty Again.");      
      } else {
      if (f.exists()) {
       System.out.println("\nFile Exists. Overwrite it (Y/N):" ); 
       Stmp = input.readLine().trim().toUpperCase();
       if (Stmp.length() > 0) {
        tPH = Stmp.charAt(0);
        if (tPH != 'Y' ) {
         System.out.print("\nYou Choose to NOT overwrite." );
         } else {
         Save2FN = tFN;
         }
        } else {
        System.out.print("\nInvalid Overwrite entry. try again." );
        }
       } else {
       Save2FN = tFN;
       }
      }
     } catch (IOException e) {
     System.out.println("Error Response. Try again.");
     } 
    } while(Save2FN.equals("")); 
       /**
     * Use FileWriter when number of write operations are less
     * @param data
     */

      //  File file = new File("/Users/pankaj/FileWriter.txt");
   BufferedOutputStream bos = null;
   try {
   //create an object of FileOutputStream
   //FileOutputStream fos = new FileOutputStream(new File(filename));
   FileOutputStream fos = new FileOutputStream(f);

   //create an object of BufferedOutputStream
   bos = new BufferedOutputStream(fos);

      if ((t_save == 'R') || (t_save == 'Y')) {
              int i = CA_bresp.size();
              for (int j = 0; j < i; j++) {
                bos.write(CA_bresp.get(j));
              }
            }
       if ((t_save == 'A') || (t_save == 'Y')) {
              int i = CA_Sresp.size();
              for (int j = 0; j < i; j++) {
                bos.write(CA_Sresp.get(j).getBytes());
              }
            }            
        } catch (IOException e) {
            e.printStackTrace();
        }finally{
            //close resources
            try {
                bos.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
      
   public void DispCA() 
   {
         int Txn_ct = Txn_resp.size();
         int CA_ct = CA_Sresp.size();
         int j = CA_ct;
         Date stDt, spDt;
         String tCA = "";
         int tCA_Len = 0;
         DispHexCA d_h_ca = new DispHexCA();         
         if (Txn_ct != CA_ct) {
           System.out.println("\nError: Txn count(" + Txn_ct +
                              ") does not match CA count(" + CA_ct + ")\n");
           if (CA_ct > Txn_ct) {
             j = Txn_ct;
           }
         }
         for (int i = 0; i < j; i++) {
           tCA = Txn_resp.get(i);
           tCA_Len = tCA.length();           
           System.out.println("Printing CA for iteration:" + (i + 1) + "\nCA Length:" + tCA_Len );
           fmtDt( TxnStDt.get(i), TxnSpDt.get(i));
           System.out.print(tCA.trim());
           System.out.println(CA_Sresp.get(i).trim() +  ":txeT");

            PromptPntHex();  
        if (pnthex == 'Y') { 

// Use general window size of 80 shars
// format 6digits for offset (0-999990)
//        ^| 2 pos
//        groups of 4 hex chars (8digits) separated by 1 sp
//        | | 3 pos           
//        16 chars
//        | 1 pos            
// 12345 | 1234ABCD |01010101 01010101 01010101 01010101|123456789abcdef0|      74 chars?     
           System.out.println("\nHEX Print of Commarea before CP Conversion : ");
           System.out.println("Variable:abytCommarea in Hex:");
        
           byte[] abytCommarea = CA_bresp.get(i);
           d_h_ca.dispit(abytCommarea,OP_max_size); 
           
           System.out.println("\nHEX Print of Commarea after CP Conversion : ");              
           d_h_ca.dispit(CA_Sresp.get(i).getBytes(), OP_max_size);
           
         }  
         System.out.println("\n###########################################");
      }
   }
     /**
   Constructor.
   @param aFileName full name of an existing, readable file.
  */
//  public EciB1e(String rgnstr, String IPAdr, String IPSocket){
   public EciB1e(String kixport_target) {  
    Scanner scanner = new Scanner(kixport_target);
    scanner.useDelimiter(",");
    if ( scanner.hasNext() ){
      try {  
       while ( scanner.hasNext() ){
        ctg_targ.put("CTG",scanner.next());
        ctg_targ.put("IPAdr",scanner.next());
        ctg_targ.put("IPSocket",scanner.next());
        ctg_targ.put("JKS",scanner.next());
        ctg_targ.put("CTG_OS",scanner.next());
        ctg_targ.put("CTG_CP",scanner.next());        
        ctg_targ.put("SSL",scanner.next());
          } 
         } catch  (Exception e) {
         System.out.println("Error: EciB1e:Scanner kixport_line:" + e);
         System.exit(12);
        }  
       }
       System.out.print("Local System CodePage Charset is:" );  
       Charset cs_dft = Charset.defaultCharset();
       String lcl_cs = cs_dft.displayName();
       System.out.println(lcl_cs);
       Set s = cs_dft.aliases();
       Iterator j = s.iterator();
       String sep = "";
       while (j.hasNext()) {
            String a = (String) j.next();         
            System.out.print(sep+a);
            sep=",";
         }
         System.out.println("\n____________________________" );
         PromptGetNM_PW();
         System.out.println("");
         String strUrl = ctg_targ.get("IPAdr");
         int iPort = Integer.parseInt(ctg_targ.get("IPSocket"));
         PromptUseDft();  
/*         
         try {
         PromptUseDft();
         } catch (IOException e) {
         System.out.println("Warning: IOException on System.in: Override Defaults Query failed.\n" +
                            "\nUsing Default Values. Proceed with that information, if you wish."); 
         setdfY_N('N');
         }
*/         
   }
   
   
   
   
/*
 * end of constructor
 * 
*/
   
      public int tryit() {
         CA_bresp.clear();
         CA_Sresp.clear();
         Txn_resp.clear();
         TxnStDt.clear();   
         TxnSpDt.clear();   
         int rc = 0;
         String strChosenServer = null;  // used to select the target cics region
         String strInput = null;
         String strAns = null;
//         
    //   String str_rem_cs = "cp1252";        // Windows CP
    //   String str_rem_cs = "cp1047";        // zOS CP
    //   String str_rem_cs = "cp819";                  // AIX CP         

         String ctgrgn = ctg_targ.get("CTG");
         String strUrl = ctg_targ.get("IPAdr");
         String strFullUrl = null;
         int iPort = Integer.parseInt(ctg_targ.get("IPSocket"));
 //        String rgnType = ctg_targ.get("RgnType");
         String useJKS = ctg_targ.get("JKS");        // derived SSL setting         
         String rgnOS = ctg_targ.get("CTG_OS");
         String str_rem_cs = ctg_targ.get("CTG_CP");        // from the kixports file
         String useSSL = ctg_targ.get("SSL");        // derived SSL setting

         
         int iECISvrct = 0;
         int iChoice = 0;
         // Display banner
         System.out.println("\nConnecting to Selected CTG:" + ctgrgn);
         String strServerNumber = null;
         String strSSLKeyring  = null;
         String strSSLPassword = null;      
         
         // Process the command line arguments and display Gateway settings

        System.out.print("\nThe address of the Gateway has been set to ");
         System.out.println(strUrl + " Port:" + iPort + "\n");

         // Declare and initialize method variables and ECIRequest object n
    try {
         ECIRequest eciRequestObject = null;  
         int EciNoXtnd = ECIRequest.ECI_NO_EXTEND;
         int EciXtnd = ECIRequest.ECI_EXTENDED;
         int i_eci_xtnd = EciNoXtnd;
         int i_eci_xLUW = 0;
         if (getrep_txn() > 0) {
           if (getXtnd_txn() == 'Y') {
             i_eci_xtnd = EciXtnd;
             i_eci_xLUW = ECIRequest.ECI_LUW_NEW;
           }
         }
         
         Properties sslProps = new Properties();
         if (useSSL.equals("Y")) {
           int SSLIndex = ctgrgn.indexOf("SSL");
           String ctgrgnX = ctgrgn.substring(0,SSLIndex);
           if (ctgrgnX.endsWith("D")) {
           System.out.print("\nThis Gateway request is using SSL and cacerts default jks:" + "\n");             
           } else {
           strSSLKeyring = "/RunCtg/TestZOS/" + useJKS + ".jks";
           strSSLPassword = "CICSabcd";
         // Set the keyring and keyring password and then initialize
         // the JavaGateway object to flow data to the Gateway           
           sslProps.setProperty(JavaGateway.SSL_PROP_KEYRING_CLASS, strSSLKeyring);
           sslProps.setProperty(JavaGateway.SSL_PROP_KEYRING_PW, strSSLPassword);           
           System.out.print("\nThis Gateway request is using SSL jks:" + strSSLKeyring + "\n");
           }
           strFullUrl = "SSL://";
           strFullUrl = strFullUrl.concat(strUrl);
         } else {
           System.out.print("\nThis Gateway request is not using SSL\n");
           strFullUrl = "TCP://";
           strFullUrl = strFullUrl.concat(strUrl);
           }


         try {
            javaGatewayObject = new JavaGateway(strFullUrl, iPort, sslProps);
            } catch (Exception e) {
         e.printStackTrace();
         System.exit(30);    
      }
         
         // Obtain a list of CICS servers defined

         // If an ECI_ERR_MORE_SYSTEMS error occurs this is because you have more servers
         // defined in your CICS TG configuration than the value stored in the iServerCount
         // variable. To solve this problem, increase the value assigned to iServerCount,
         // recompile and rerun this sample.
         int iServerCount = 460;         
         eciRequestObject = ECIRequest.listSystems(iServerCount);
         System.out.println("MAX Servers count::" + iServerCount);
//         strAns = input.readLine().trim();
         flowRequest(eciRequestObject); 

         // Ask for user to choose from the list of defined servers
         Set<String> ctg_targs = new HashSet<String>();          
         do {
            if (eciRequestObject.SystemList.isEmpty() == true) {
               System.out.println("No CICS servers have been defined.");
               if (javaGatewayObject.isOpen() == true) {
                  javaGatewayObject.close();
               }
               System.exit(0);
            }
            iECISvrct = eciRequestObject.numServersReturned;
            System.out.println("ECI Servers count:" + iECISvrct);            
            System.out.println("CICS Servers Defined:\n");
            for (int i = 0; i < eciRequestObject.numServersReturned; i++) {
               if (i < 9) {
                  strServerNumber = "\t " + (i + 1) + ". ";
               } else {
                  strServerNumber = "\t" + (i + 1) + ". ";
               }

               // Prints the name and description of the server as contained
               // in the SystemList vector
               String V = (String) eciRequestObject.SystemList.elementAt(2*i);
               ctg_targs.add(V);
               System.out.println
                (strServerNumber
                 + eciRequestObject.SystemList.elementAt(2*i) + " -"
                 + eciRequestObject.SystemList.elementAt((2*i)+1));
            }
            System.out.println("\n\nChoose Target Server (by number),"
                               + "a for ALL servers, or q to quit:");
            strInput = input.readLine().trim();
            if ((strInput).equalsIgnoreCase("q")) {
               if (javaGatewayObject.isOpen() == true) {
                  javaGatewayObject.close();
               }
               System.exit(0);
            }
            if ((strInput).equalsIgnoreCase("a")) {
              System.out.println("You Selected ALL CICS Regions.");
            }

            try {
               iChoice = java.lang.Integer.parseInt(strInput);
            } catch (java.lang.NumberFormatException e) {
               System.out.println("\n\nType the number of the "
                                  + "Server to connect to or q to quit\n");
               continue;
            }

            // Validate that the choice is in range using the
            // ECIRequest numServersReturned variable
            if (iChoice > 0 && iChoice <= eciRequestObject.numServersReturned)
            {  strChosenServer =
               (String)eciRequestObject.SystemList.elementAt(((iChoice-1)*2));
            } else {
               System.out.println("\n\nOut of Range\n");
            }
         } while (strChosenServer == null);

         
         System.out.println("\nServer::" + strChosenServer);

         String strProgram = getPN();           
         String strTPNM = getMyTID();  
         int iCommareaSize = getCAL();

         StringBuilder strComA = new StringBuilder(getMyCA());         
         int n_l = iCommareaSize;
//         strComA.setLength(n_l);
         byte[] abytCommarea = new byte[iCommareaSize];         
//         String SComA = strComA.toString();
//         System.out.println("CommareaLength>" + SComA.length());
//        System.out.println("Commarea>" + SComA);
 // Change #5 activate codepage conversion (ie  to and from zos)
 //      Use CP conversion when going to the zOS CICS  
         String pnthex = "N";
         
 //        
 // Top of the repeat loop 
 //         
     int cur_repeat_cnt = 0;
     int strComA_Len = 0;
     do {
         strComA.setLength(0);
         if (getDM() == 'P') {
          System.out.println("Iteration:" + (cur_repeat_cnt + 1) + ":DataMode is Prompt. Enter next " + getCnC()); 
          PGetCA(stdmyCA);
          strComA.append(getMyCA());
         } else {
         strComA.append(getMyCA_L(cur_repeat_cnt));
         }
         strComA_Len = strComA.length();
         strComA.setLength(n_l);
         String SComA = strComA.toString();
         System.out.println("True CommareaLength>" + strComA_Len +
                "\nSetting CommareaLength to>" + SComA.length());
         System.out.println("(True) Commarea>" + SComA.substring(0,strComA_Len) + '<');
         abytCommarea = SComA.getBytes(str_rem_cs);
         String aComStr = new String(abytCommarea);
         System.out.println("abytCommarea>" + aComStr.substring(0,strComA_Len) + '<');
         iCommareaSize = n_l;    // set above
                 
         System.out.println("\nText from Commarea before flow (abytCommarea): "
                               + new String(abytCommarea).substring(0,strComA_Len) + '<');
 //        eciRequestObject =
 //        new ECIRequest(ECIRequest.ECI_SYNC_TPN,  //ECI_SYNC call type eci_tranid CSMI
 //                                                 // or use ECI_SYNC_TPN for eci_tpn 
                                                    // uses the user transid
 //                       strChosenServer,          //CICS server
 //                       null,                     //CICS userid
 //                       null,                     //CICS password
 //                       strProgram,               //CICS program to be run
 //                       null,                     //CICS transid to be run
 //                       abytCommarea,             //Byte array containing the
 //                                                 // COMMAREA
 //                       iCommareaSize,            //COMMAREA length
 //                       ECIRequest.ECI_NO_EXTEND, //ECI extend mode
 //                       0);                       //ECI LUW token
/*
 * TPNName ECIRequest.Call_Type = ECI_SYNC_TPN or ECI_ASYNC_TPN
 *                                and ECIRequest.Transid
 * TranName ECIRequest.Call_Type = ECI_SYNC or ECI_ASYNC
 *                                and ECIRequest.Transid
 * note that TPNNAME specification will use the eci transid as the runtime txn (if specified else csmi)
 */
         
         if (cur_repeat_cnt == 0) {
         eciRequestObject =
         new ECIRequest(ECIRequest.ECI_SYNC_TPN,  //ECI call type
                        strChosenServer,          //CICS server
                        strMe,                     //CICS userid strMe or null
                        strMePW,                     //CICS password or null
                        strProgram,               //CICS program to be run
                        strTPNM,                  //CICS transid to be run strTPNM
                                                  // note that by setting ECI_SYNC_TPN, tells eci request 
                                                  // that this is BOTH the TPNAME and TRANID
                        abytCommarea,             //Byte array containing the
                                                  // COMMAREA
                        iCommareaSize,            //COMMAREA length
                        i_eci_xtnd,               // getXtnd_txn() Y or N sets this value
//                        ECIRequest.ECI_NO_EXTEND, //ECI extend mode int value
                        i_eci_xLUW);               //ECI LUW token int 
         //ECIRequest.ECI_EXTENDED ECIRequest.ECI_NO_EXTEND, //ECI extend mode
         // Call the flowRequest method and display returned data in hex and
         // ASCII format. If the method returns true a security error has
         // occurred and the user is prompted for a CICS user ID and password.
         } else {
           eciRequestObject.Commarea = abytCommarea;
           eciRequestObject.Commarea_Length = iCommareaSize;
         }
           
         short s_int = (short) getEciTO();
         
         eciRequestObject.setECITimeout(s_int);   // added 20120202
         // while condition here depends on the success of the flow request;
         //  flow request will return 'false' if it was successful
         //  so we would not enter this again unless the flow got a error response 
// this is top of the flow loop - loop until we get good resp of MaxFlowAttempts         
         while ((flowRequest(eciRequestObject) == true) && RetryInd){
           System.out.println("\nText from Commarea on retry (abytCommarea):\n "
                               + new String(abytCommarea));
           for (int q = 0; q < 200; q++) {
            System.out.print(Integer.toHexString(abytCommarea[q]));
         }
         h_strMe = strMe;
         h_strMePW = strMePW;

         PromptGetNM_PW_agn();
         
         eciRequestObject.Userid = strMe;
         eciRequestObject.Password = strMePW;
         iValidationFailed++;    // compare to MaxFlowAttempts
         }
         if ( RetryInd ) {
         int ca_len = eciRequestObject.Commarea_Length;  
         CA_bresp.add(eciRequestObject.Commarea);

         String ret_ComA = new String(eciRequestObject.Commarea,0,eciRequestObject.Commarea_Length,str_rem_cs);
         CA_Sresp.add(ret_ComA);
         
         StringBuffer txnR = new StringBuffer();
         txnR.append("\nTransid>" + strTPNM + "< Userid>" + strMe).append(
               "\nProgram " + strProgram  + " returned with data.").append( 
               "\nReported ECI CommareaLen: " + ca_len).append(
               "\tStrLen of CommareaLen: " + ret_ComA.length()).append(
               "\nReturning Commarea variable:ret_ComA: CP converted:").append("\nText\n"); 
            
         Txn_resp.add(txnR.toString());
         System.out.println("Saved Txn details and CA for iteration:" + (cur_repeat_cnt + 1));
         
 //        System.out.print("\nTransid>" + strTPNM + "< Userid>" + strMe);
 //        System.out.println("\nProgram " + strProgram + " returned with data:- \n");
 //        int ca_len = eciRequestObject.Commarea_Length;
 //      Use CP conversion when going to the zOS CICS                
 //        String ret_ComA = new String(eciRequestObject.Commarea,0,eciRequestObject.Commarea_Length,str_rem_cs); 
 //        String ret_ComA = new String(eciRequestObject.Commarea,0,eciRequestObject.Commarea_Length);
 //        System.out.print("\n\tReported ECI CommareaLen: " + ca_len);                  
 //        System.out.print("\tStrLen of CommareaLen: " + ret_ComA.length());         
 //        System.out.print("\n\tReturning Commarea variable:ret_ComA: CP converted:");         
 //        System.out.print("\nText:" + ret_ComA + ":txeT");
 /*       if (pnthex == "Y") {     
           System.out.print("\nHEX Print of Commarea before CP Conversion : ");
           System.out.print("\n\tVariable:abytCommarea in Hex: ");
           for (int i_t: abytCommarea) {
             System.out.print(Integer.toHexString(i_t));
           }
           try {
            System.out.println("\n\nASCII text from Commarea before CP conversion (abytCommarea): "
                               + new String(abytCommarea, "ASCII"));
           } catch (UnsupportedEncodingException e) {
            System.out.println
            ("\tThe ASCII encoding scheme is not supported.");
           }
         } 
         } else {
         System.out.println("Retry failed or Exit requested: Ending execution.");
         }
         */
         }
         if ((getrep_txn() > 0) && cur_repeat_cnt < getrep_txn()) {
             System.out.println("\nFinished Repeat Iteration #" + 
                                (cur_repeat_cnt + 1) + " of " + (getrep_txn() + 1));         
           if (getwt_txn() > 0) {
             System.out.println("\n\nSleeping " + (getwt_txn() / 1000) + " seconds...");
             EciSleep(getwt_txn());
           }
           System.out.println("____________________");
         }
  // end of repeat loop
         cur_repeat_cnt++;
         } while (cur_repeat_cnt <= getrep_txn());
         // issue SYNC if necessary
         if (getXtnd_txn() == 'Y') {
            eciRequestObject.Extend_Mode = ECIRequest.ECI_COMMIT;
            eciRequestObject.Call_Type = ECIRequest.ECI_SYNC;
            eciRequestObject.Program = null;
            javaGatewayObject.flow(eciRequestObject);
            }

         // Close the JavaGateway object before exiting
         if (javaGatewayObject.isOpen() == true) {
            javaGatewayObject.close();
         }
// end of tryit: first try..catch logic
      } catch (Exception e) {
         e.printStackTrace();
         rc = 8;    
      }
      return rc;
   }

   // The flowRequest method flows data contained in the ECIRequest object to
   // the Gateway and determines whether it has been successful by checking the
   // return code. If an error has occurred, the return code string and abend
   // codes are printed to describe the error before the program exits.
   // Note: Security may be required for client connection to the server and
   //       not just for the ECI request. Refer to the security chapter in the
   //       CICS Transaction Gateway Administration book for further details.
      // remove static from below - 
   private  boolean flowRequest(ECIRequest requestObject) {
      try {
         Date startDt = new Date();
         int iRc = javaGatewayObject.flow(requestObject);
         Date stopDt = new Date();         
         // Checks for gateway errors and returns false if there are no errors
         System.out.println("\nReturn from Gateway");
         
         switch (requestObject.getCicsRc()) {
         case ECIRequest.ECI_NO_ERROR:
            if (iRc == 0) {
               TxnStDt.add(startDt);
               TxnSpDt.add(stopDt);
               return false; // when successful, we set 'retry' to false
            } else {
               System.out.println("\nError from Gateway ("
                                  + requestObject.getRcString()
                                  + "), correct and rerun this sample");
               if (javaGatewayObject.isOpen() == true) {
                  javaGatewayObject.close();
               }
               System.exit(0);
            }

         // Checks for security errors and returns true if validation has
         // failed on four or less occasions
         case ECIRequest.ECI_ERR_SECURITY_ERROR:
            if (iValidationFailed == 0) {
               return true;
            }
            System.out.print("\n\nValidation failed. ");
            if (iValidationFailed < this.getMaxFA()) {   // MaxFlowAttempts
               System.out.println("Try entering your details again.");
               return true;
            }
            break;

         // Checks for transaction abend errors where the user is authorised
         // to access the server but not run the EC01 program.
         // The sample should be rerun and a user ID and password with the
         // required authorisation entered.
         case ECIRequest.ECI_ERR_TRANSACTION_ABEND:
            System.out.println("\nYou are not authorised to run this transaction.");
            break;
            
         case ECIRequest.ECI_ERR_REQUEST_TIMEOUT: 
            System.out.println("\nECI Transaction  TimeOut");
            break;
         
         }
         System.out.println("\nECI returned: "
                            + requestObject.getCicsRcString());
         System.out.println("Abend code was "
                            + requestObject.Abend_Code + "\n");
         if (javaGatewayObject.isOpen() == true) {
            javaGatewayObject.close();
         }
         System.exit(0);

      } catch (Exception e) {
         e.printStackTrace();
         System.exit(0);
      }
      return true;   // if we are here, then we want a 'retry'
   }
}
package TestZOS;

import java.io.*;
import java.util.*;
/*
 * import java.util.Set;
import java.util.HashSet;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
*/
import java.util.Scanner;

import TestZOS.*;

public class ReadPorts {
   final String RunEci_V = "ReadPorts V1.0";
  
  /**
   Constructor.
   @param aFileName full name of an existing, readable file.
  */
  public ReadPorts(String aFileName, String FN_src){
    int ctgport_ct = rd_ports(aFileName,FN_src);
 //   fFile = new File(aFileName);  
  //  logit_on();
  }
private ArrayList<String> ctgports_lns = new ArrayList<>();  // collect formated lines

private int  rd_ports (String FName, String FN_src) {
   InputStream stream = null;
   BufferedReader reader;
   reader = null;
   int i = 0;
     try {
     if (FN_src.equalsIgnoreCase("jar")) {
       stream = ReadPorts.class.getResourceAsStream(FName);
       reader = new BufferedReader(new InputStreamReader(stream));
       } else {
       File file = new File(FName);
       reader = new BufferedReader(new FileReader(file));
       }
    String line;
    while ((line = reader.readLine()) != null) {
//       System.out.println(line);
        ctgports_lns.add(line);
    }
            reader.close();
       i = ctgports_lns.size();     
     } catch (IOException e) {
       e.printStackTrace();
     } finally {
       if (reader != null) {
         try {
         reader.close();
         } catch (IOException e) {
         e.printStackTrace();
         }
       }
       
     }
     return i;
  }
  /** Template method that calls {@link #processLine(String)}.  */
  public final void processLineByLine()  {

    for (String mystr:ctgports_lns ){
       if (mystr.indexOf(",") > 0) {
         log(mystr);
        processLine( mystr );
       } else {
         log("Bypass:" + mystr);
       }
    }
}
  
  public void prntRgns() {
    String ipA, ipS, ipL;
    for (String rgnstr:Region) {
      ipA = this.getIPA(rgnstr);
      ipS = this.getSock(rgnstr); 
      ipL = this.getSSL(rgnstr); 
      log("Region Name:" + rgnstr + "\tAdr:" + ipA + "\tSock:" + ipS + "\tSSL:" + ipL);
        }
    }
 
  /*
  public Set<String> getRgns() {
    Set<String> rgnset = new HashSet<String>();
    rgnset.addAll(Region);
    return rgnset;
  }
  */
  
  public List<String> getRgns() {
    return  new ArrayList<String>(Region);
  }
  
  public String getIPA(String iprgn) {
    return Adr.get(iprgn);
  }
  
  public String getSock(String iprgn) {
    return Sock.get(iprgn);
  }
    
  public String getSSL(String iprgn) {
    return SSL.get(iprgn);
  }
   
    public String getJKS(String iprgn) {
    return JKS.get(iprgn);
  }
  public String getKixLine(String iprgn) {
    return kixport_line.get(iprgn);
  }
                           
  protected void processLine(String aLine)
   //         throws NoSuchElementException 
            {
    //use a second Scanner to parse the content of each line 
    Scanner scanner = new Scanner(aLine);
    scanner.useDelimiter(",");
    if ( scanner.hasNext() ){
      try {  
       while ( scanner.hasNext() ){
        String rgn = scanner.next();
        String ipadr = scanner.next();
        String ipsoc = scanner.next();
        String jks = scanner.next(); 
        String rgnos = scanner.next(); 
        String rgnCP = scanner.next();        
        String usesSSL = "";
        int SSLIndex = rgn.indexOf("SSL");
        if(SSLIndex == - 1){
          SSL.put(rgn,"N");
          usesSSL = ",N";
        } else {
//          rgn = rgn.substring(0,SSLIndex);
          SSL.put(rgn,"Y");
          usesSSL = ",Y";
          }        
        log("Region: " + quote(rgn.trim()) + "\n\tIPAddr: " + quote(ipadr.trim()) +
            "\tSocket:" + ipsoc + "\tCodePage:" + rgnCP + "\tUses SSL(y/n):" + SSL.get(rgn));
         Region.add(rgn);
         Adr.put(rgn,ipadr);
         Sock.put(rgn,ipsoc);
         JKS.put(rgn,jks);
         aLine = aLine.concat(usesSSL);
         kixport_line.put(rgn,aLine);       
          } 
         } catch  (Exception e) {
         log("Bypassing Line: " + aLine) ;
        }
//      log("Done processLine" );
    }
    else {
      log("Empty or invalid line. Unable to process.");
    }
    //no need to call scanner.close(), since the source is a String
  }
  
  // PRIVATE 
  private static boolean logit = true;
  private File fFile;
  private Map<String, String> kixport_line = new HashMap<String, String>();  
  private Map<String, String> Adr = new HashMap<String, String>();
  private Map<String, String> Sock = new HashMap<String, String>();
  private Map<String, String> SSL = new HashMap<String, String>();
  private Map<String, String> JKS = new HashMap<String, String>();
  private Set<String> Region = new LinkedHashSet<String>();

  public boolean get_logit_status() {
    return logit;
  }
  
  public void logit_on() {
    logit = true;
  }

  public void logit_off() {
    logit = false;
  }
  
  public static void log(Object aObject){
    if (logit) {
    System.out.println(String.valueOf(aObject));
    }
  }
  
  private String quote(String aText){
    String QUOTE = "'";
    return QUOTE + aText + QUOTE;
  }
} 

package TestZOS;
//
// use C:\RunCtg\add_javabin2path.bat to run addpth C:\old_d\jdk1.8.0_92\bin\
// C:\RunCtg>jar -cfe RunEci.jar TestZOS.RunEci TestZOS/*.class TestZOS/*.txt
// C:\RunCtg>jar -tvf RunEci.jar
// C:\RunCtg>java -cp C:/cics_trace/ctgZ800_classes/ctgclient.jar;c:/ctg_samp_code\RunEci.jar TestZOS.RunEci c:/mydoc/cics_doc/g2_test_ctgports.txt
//
//compile C:\>javac -cp C:/cics_trace/ctg602_classes/ctgclient.jar;c:/ctg_samp_code c:/ctg_samp_code/TestZOS/RunEci.java
//        C:\>javac -cp c:/ctg_samp_code c:/ctg_samp_code/TestZOS/RunEci.java
// or
//        C:\ctg_samp_code>javac TestZOS/RunEci.java
//
// To execute, you need to specify the cp for the appropriate ctgclient.jar
// If the target CTG is downlevel from the java cp specified, you will get a CTG_BACKLEVEL error
// execute:C:\>java -cp /ctg_samp_code;C:/cics_trace/ctgZ900_classes/ctgclient.jar TestZOS.RunEci c:/mydoc/cics_doc/g2_test_ctgports.txt
//             java -cp /ctg_samp_code;C:/cics_trace/#######_classes/ctgclient.jar TestZOS.RunEci c:/mydoc/cics_doc/g2_test_ctgports.txt
import java.io.*;
import java.util.*;
import java.io.Console;

//import TestZOS.*;

public class RunEci {
   private static InputStreamReader isr = new InputStreamReader(System.in);
   private static BufferedReader input = new BufferedReader(isr);



  public static void main(String... args)
        throws FileNotFoundException {
   final String RunEci_V = "RunEci V1.0";
   String JVM_LIB = System.getProperty("java.home");
   int ans = 0;
   String rgnstr;

     int i;
     String FName = "/TestZOS/G1_ctgports.txt";
     String FN_src = "jar";
     i = args.length;
     System.out.println(RunEci_V);
     if (i > 0) {
       System.out.println("Args #:" + i + "\nArg:");
        for (String s: args) {
            System.out.println(s);
        }
        if (args[0].equals("?")) {
          System.out.println("\tOne optional Parameter: drive/path/filename or ctgports.txt");
          return;
        }
        FN_src = "arg";
        FName = args[0];
     }
    System.out.println("Using CtgPorts file:" + FName);

    ReadPorts parser = new ReadPorts(FName, FN_src);
    parser.logit_off();
    parser.processLineByLine();
    parser.prntRgns();

/*
    Set<String> rgns = new HashSet<String>();
    rgns = parser.getRgns();
*/
    List<String> rgnList = new ArrayList<String>(parser.getRgns());
    //rgnList = parser.getRgns();
    String ipA, ipS, ipSSL, derrmsg, drgnmsg;
    int rgnct = rgnList.size();
    int rgnctr, rgnsel = 0;
    derrmsg = "";
    drgnmsg = "Enter # for target CTG\n\t or zero (0) to quit:";
    do {
//      Runtime.getRuntime().exec( "cmd /c cls");
//      rgnctr = 0;
      System.out.println(derrmsg + drgnmsg);
      System.out.println("Enter 0 (zero) to Quit");
    //for (String rgnstr:rgnList) {
    for (rgnctr = 0; rgnctr < rgnct; rgnctr++) {
//      rgnctr = rgnctr + 1;
      rgnstr = rgnList.get(rgnctr);
      ipA = parser.getIPA(rgnstr);
      ipS = parser.getSock(rgnstr);
      ipSSL = parser.getSSL(rgnstr);
      System.out.println("Region:" + (rgnctr+1) + " Name:" + rgnstr + "\tAdr:" + ipA + "\tSock:" + ipS +
                                    "\tSSL(y/n):" + ipSSL);
      }
    try {
    ans  = Integer.parseInt( input.readLine().trim() );
    } catch (IOException e) {
      System.out.println("Error: IOException Reading CTG Selection. GoodBye");
      System.exit(8);
    } catch (NumberFormatException e) {
      System.out.println("Error: NumberFormatException Reading CTG Selection. GoodBye");
      System.exit(8);
    }
//    ans=sc.nextInt();
    if (ans == 0) {
      System.out.println("CTG Selection was zero (QUIT). GoodBye.");
      rgnsel = -1;
      System.exit(4);
      }
    if (ans > rgnct) {
        derrmsg = "You entered an invalid Region #:" + ans + "\n";
        ans = 0;
      } else {
//        System.out.println("You selected Region #:" + ans);
        rgnsel = ans;
        }
    } while (rgnsel == 0 );
    rgnsel = rgnsel - 1;
   parser.log("Done.");
   rgnstr = rgnList.get(rgnsel);
   ipA = parser.getIPA(rgnstr);
   ipS = parser.getSock(rgnstr);
   ipSSL = parser.getSSL(rgnstr);
   System.out.println("You Selected:\nRegion Name:" + rgnstr + "\tIPAdr:" + ipA + "\tSocket:" + ipS +
                                    "\tUsing SSL(y/n):" + ipSSL);
  // String kixport_Line = parser.getKixLine(rgnstr);
   EciB1e myEci = new EciB1e(parser.getKixLine(rgnstr));
   if (((char)myEci.getdfY_N()) == 'Y') {
         System.out.println("Enter Override Values...");
 //        try {
           myEci.PromptPN("");
           myEci.PromptTID("");
           myEci.PromptCAorCnC("CA");
           if (myEci.getCAorCnC().equals("CA")) {
             myEci.PromptGetCA("");
             myEci.PromptCAL(2032);
           } else {
             myEci.PromptChanNm("MyCHnm");
             if (myEci.getChNm().equals("!")) {
               System.out.println("Abort selected on Channel Name. GoodBye.");
               System.exit(9);
             }                        
             int num_cn = 0;
             num_cn = myEci.Prompt4Containers("CEMTxxxx");
             if (num_cn < 0) {
               System.out.println("Abort selected on Container names. GoodBye.");
               System.exit(10);
             }       
           }           
           myEci.PromptRepNum(0);
           if ((myEci.getrep_txn() > 0) && (myEci.getCAorCnC().equals("CA"))) {
             myEci.PromptRepDMD('S');
             if (myEci.getDM() == 'F') {
               myEci.DMD_getFN();
             }
           } else {
            myEci.setDM('S'); 
           }
           myEci.PromptEciTO(0);
           myEci.PromptFA(3);

           myEci.PromptWtInvl(0);
           myEci.PromptXtnd('N');

     } else {
     myEci.setDfltCA();
     }
   Date SD, PD;
   SD = new Date();
   ans = myEci.tryit();
   PD = new Date();
   System.out.println("\n_________________\nRunEci Returned:" + ans);
   if (ans < 8) {
   myEci.fmtDt(SD, PD);
   System.out.println("\n_________________\n");
   myEci.DispCA();
   System.out.println("\n_________________\n");
 //  try {
     myEci.SaveData();
     System.out.println("Saved Data to file:" + myEci.getSavFN());
     /*
   } catch (IOException e) {
     System.out.println("Error Saving Data to file:" + myEci.getSavFN());
   }
   */
   } else {
     System.out.println("Error in processing. Nothing to Report or Save.");
   }
   System.out.println("\nFinished RunEci. GoodBye.");
  }
}
package TestZOS;
//
// use C:\RunCtg\add_javabin2path.bat to run addpth C:\old_d\jdk1.8.0_92\bin\
// C:\RunCtg>jar -cfe RunEci.jar TestZOS.RunEci TestZOS/*.class TestZOS/*.txt
// C:\RunCtg>jar -tvf RunEci.jar
// C:\RunCtg>java -cp C:/cics_trace/ctgZ800_classes/ctgclient.jar;c:/ctg_samp_code\RunEci.jar TestZOS.RunEci c:/mydoc/cics_doc/g2_test_ctgports.txt
//
//compile C:\>javac -cp C:/cics_trace/ctg602_classes/ctgclient.jar;c:/ctg_samp_code c:/ctg_samp_code/TestZOS/RunEci.java
//        C:\>javac -cp c:/ctg_samp_code c:/ctg_samp_code/TestZOS/RunEci.java
// or
//        C:\ctg_samp_code>javac TestZOS/RunEci.java
//
// To execute, you need to specify the cp for the appropriate ctgclient.jar
// If the target CTG is downlevel from the java cp specified, you will get a CTG_BACKLEVEL error
// execute:C:\>java -cp /ctg_samp_code;C:/cics_trace/ctgZ900_classes/ctgclient.jar TestZOS.RunEci c:/mydoc/cics_doc/g2_test_ctgports.txt
//             java -cp /ctg_samp_code;C:/cics_trace/#######_classes/ctgclient.jar TestZOS.RunEci c:/mydoc/cics_doc/g2_test_ctgports.txt
import java.io.*;
import java.util.*;
import java.io.Console;

//import TestZOS.*;

public class RunEci {
   private static InputStreamReader isr = new InputStreamReader(System.in);
   private static BufferedReader input = new BufferedReader(isr);



  public static void main(String... args)
        throws FileNotFoundException {
   final String RunEci_V = "RunEci V1.0";
   String JVM_LIB = System.getProperty("java.home");
   int ans = 0;
   String rgnstr;

     int i;
     String FName = "/TestZOS/G1_ctgports.txt";
     String FN_src = "jar";
     i = args.length;
     System.out.println(RunEci_V);
     if (i > 0) {
       System.out.println("Args #:" + i + "\nArg:");
        for (String s: args) {
            System.out.println(s);
        }
        if (args[0].equals("?")) {
          System.out.println("\tOne optional Parameter: drive/path/filename or ctgports.txt");
          return;
        }
        FN_src = "arg";
        FName = args[0];
     }
    System.out.println("Using CtgPorts file:" + FName);

    ReadPorts parser = new ReadPorts(FName, FN_src);
    parser.logit_off();
    parser.processLineByLine();
    parser.prntRgns();

/*
    Set<String> rgns = new HashSet<String>();
    rgns = parser.getRgns();
*/
    List<String> rgnList = new ArrayList<String>(parser.getRgns());
    //rgnList = parser.getRgns();
    String ipA, ipS, ipSSL, derrmsg, drgnmsg;
    int rgnct = rgnList.size();
    int rgnctr, rgnsel = 0;
    derrmsg = "";
    drgnmsg = "Enter # for target CTG\n\t or zero (0) to quit:";
    do {
//      Runtime.getRuntime().exec( "cmd /c cls");
//      rgnctr = 0;
      System.out.println(derrmsg + drgnmsg);
      System.out.println("Enter 0 (zero) to Quit");
    //for (String rgnstr:rgnList) {
    for (rgnctr = 0; rgnctr < rgnct; rgnctr++) {
//      rgnctr = rgnctr + 1;
      rgnstr = rgnList.get(rgnctr);
      ipA = parser.getIPA(rgnstr);
      ipS = parser.getSock(rgnstr);
      ipSSL = parser.getSSL(rgnstr);
      System.out.println("Region:" + (rgnctr+1) + " Name:" + rgnstr + "\tAdr:" + ipA + "\tSock:" + ipS +
                                    "\tSSL(y/n):" + ipSSL);
      }
    try {
    ans  = Integer.parseInt( input.readLine().trim() );
    } catch (IOException e) {
      System.out.println("Error: IOException Reading CTG Selection. GoodBye");
      System.exit(8);
    } catch (NumberFormatException e) {
      System.out.println("Error: NumberFormatException Reading CTG Selection. GoodBye");
      System.exit(8);
    }
//    ans=sc.nextInt();
    if (ans == 0) {
      System.out.println("CTG Selection was zero (QUIT). GoodBye.");
      rgnsel = -1;
      System.exit(4);
      }
    if (ans > rgnct) {
        derrmsg = "You entered an invalid Region #:" + ans + "\n";
        ans = 0;
      } else {
//        System.out.println("You selected Region #:" + ans);
        rgnsel = ans;
        }
    } while (rgnsel == 0 );
    rgnsel = rgnsel - 1;
   parser.log("Done.");
   rgnstr = rgnList.get(rgnsel);
   ipA = parser.getIPA(rgnstr);
   ipS = parser.getSock(rgnstr);
   ipSSL = parser.getSSL(rgnstr);
   System.out.println("You Selected:\nRegion Name:" + rgnstr + "\tIPAdr:" + ipA + "\tSocket:" + ipS +
                                    "\tUsing SSL(y/n):" + ipSSL);
  // String kixport_Line = parser.getKixLine(rgnstr);
   EciB1e myEci = new EciB1e(parser.getKixLine(rgnstr));
   if (((char)myEci.getdfY_N()) == 'Y') {
         System.out.println("Enter Override Values...");
 //        try {
           myEci.PromptPN("");
           myEci.PromptTID("");
           myEci.PromptRepNum(0);
           if (myEci.getrep_txn() > 0) {
             myEci.PromptRepDMD('S');
             if (myEci.getDM() == 'F') {
               myEci.DMD_getFN();
             }
           }
           myEci.PromptCnC("CA");
           if (myEci.getCnC().equals("CA")) {
             myEci.PromptGetCA("");
             myEci.PromptCAL(1008);
           } else {
             myEci.PromptChanNm("MyCHnm");
             boolean moreCN = true;
             while (moreCN) {
             myECI.PromptContNm("CEMTxxxx");

             }
           }
           myEci.PromptEciTO(0);
           myEci.PromptFA(3);

           myEci.PromptWtInvl(0);
           myEci.PromptXtnd('N');

     } else {
     myEci.setDfltCA();
     }
   Date SD, PD;
   SD = new Date();
   ans = myEci.tryit();
   PD = new Date();
   System.out.println("\n_________________\nRunEci Returned:" + ans);
   if (ans < 8) {
   myEci.fmtDt(SD, PD);
   System.out.println("\n_________________\n");
   myEci.DispCA();
   System.out.println("\n_________________\n");
 //  try {
     myEci.SaveData();
     System.out.println("Saved Data to file:" + myEci.getSavFN());
     /*
   } catch (IOException e) {
     System.out.println("Error Saving Data to file:" + myEci.getSavFN());
   }
   */
   } else {
     System.out.println("Error in processing. Nothing to Report or Save.");
   }
   System.out.println("\nFinished RunEci. GoodBye.");
  }
}
import java.util.*;
import java.io.*;
import java.util.Formatter;
import TestZOS.DispHexCA;

public class TestHex {
   private static InputStreamReader isr = new InputStreamReader(System.in);
   private static BufferedReader input = new BufferedReader(isr);
   
   public static String fmttr(int k) {
       Formatter f = new Formatter();
       return f.format("%08X",k).toString();
     }
  public static void main(String... args)
        throws FileNotFoundException, UnsupportedEncodingException {
   int ans = 0;
   StringBuilder sb = new StringBuilder();
   String rgnstr;
   String str_rem_cs = "cp1047";
   DispHexCA d_h_ca = new DispHexCA();
   String s1, tCA;
   ArrayList<String> CA_aryL = new ArrayList<>();
   ArrayList<String> tst_aryL = new ArrayList<>();
   ArrayList<Integer> CA_aryLen = new ArrayList<>();
   //  Scanner sc = new Scanner(System.in);
     int i, j = 0,rdct=0, repct=0;
     String fin = "c:\\mydoc\\cics_doc\\run_eci_data";
            try {
         FileInputStream fis = new FileInputStream(fin);
         //Construct BufferedReader from InputStreamReader
         BufferedReader br = new BufferedReader(new InputStreamReader(fis));         
         String line = null;
         
         while ((line = br.readLine()) != null) {
          rdct++; 
          tCA = line.trim();
          CA_aryL.add(tCA);
          CA_aryLen.add(tCA.length());          
         }
         repct++;
                br.close();
       } catch (IOException e) {
       } finally {

       }
     i = args.length;
     if (i > 0) {
     int k = 0;  
     String tst_s3;
     System.out.println(i);
        for (String s: args) {
          sb.setLength(0);
          j++;
          k = (j*1000) + j;
          String tst_s = d_h_ca.toHexString(Integer.toString(k).substring(1).getBytes());

          String tst_s2 = Integer.toHexString(k);
          Formatter f3 = new Formatter();
//          tst_s3 = f3.format("%14X",Integer.toString(k)).toString();
//          System.out.println(     f3.format("Here is an example of using format():  Part no: %s, Qnty: %d", "Widget", 23));
//          tst_s3=     f3.format("Here is an example of using format():  Part no: %s, Qnty: %d", "Widget", 23).toString();
          tst_s3 = f3.format("%08X",k).toString();
          String tst_s4 = fmttr(k);
          String tst_s5 = fmttr(k+1);
          System.out.println(k + " | " + tst_s + " | " + tst_s2 + " | " + tst_s3 + " | " + tst_s4 + " | " + tst_s5);
          sb.append(Integer.toString(j + 1000000).substring(1)).append(" | ").append(s).append(" |\n ");
          s1 = d_h_ca.toHexString(s.getBytes());
          sb.append(s1).append(" |\n");          
            //System.out.println(s1);
          s1 = d_h_ca.toHexString(s.getBytes(str_rem_cs));
            //System.out.println(s1);            
          sb.append(s1).append(" |\n");  
          System.out.println(sb.toString());
        }
       tst_aryL.add(sb.toString());
       System.out.println(tst_aryL.get(0));
       
     }
  }
}
