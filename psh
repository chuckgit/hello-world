function Get-MyFileHash {
    <#
        .SYNOPSIS
            Calculates the hash on a given file based on the seleced hash algorithm.

        .DESCRIPTION
            Calculates the hash on a given file based on the seleced hash algorithm. Multiple hashing 
            algorithms can be used with this command.

        .PARAMETER Path
            File or files that will be scanned for hashes.

        .PARAMETER Algorithm
            The type of algorithm that will be used to determine the hash of a file or files.
            Default hash algorithm used is SHA256. More then 1 algorithm type can be used.
            
            Available hash algorithms:

            MD5
            SHA1
            SHA256 (Default)
            SHA384
            SHA512
            RIPEM160

        .NOTES
            Name: Get-FileHash
            Author: Boe Prox
            Created: 18 March 2013
            Modified: 28 Jan 2014
                1.1 - Fixed bug with incorrect hash when using multiple algorithms

        .OUTPUTS
            System.IO.FileInfo.Hash

        .EXAMPLE
            Get-FileHash -Path Test2.txt
            Path                             SHA256
            ----                             ------
            C:\users\prox\desktop\TEST2.txt 5f8c58306e46b23ef45889494e991d6fc9244e5d78bc093f1712b0ce671acc15      
            
            Description
            -----------
            Displays the SHA256 hash for the text file.   

        .EXAMPLE
            Get-FileHash -Path .\TEST2.txt -Algorithm MD5,SHA256,RIPEMD160 | Format-List
            Path      : C:\users\prox\desktop\TEST2.txt
            MD5       : cb8e60205f5e8cae268af2b47a8e5a13
            SHA256    : 5f8c58306e46b23ef45889494e991d6fc9244e5d78bc093f1712b0ce671acc15
            RIPEMD160 : e64d1fa7b058e607319133b2aa4f69352a3fcbc3

            Description
            -----------
            Displays MD5,SHA256 and RIPEMD160 hashes for the text file.

        .EXAMPLE
            Get-ChildItem -Filter *.exe | Get-FileHash -Algorithm MD5
            Path                               MD5
            ----                               ---
            C:\users\prox\desktop\handle.exe  50c128c5b28237b3a01afbdf0e546245
            C:\users\prox\desktop\PortQry.exe c6ac67f4076ca431acc575912c194245
            C:\users\prox\desktop\procexp.exe b4caa7f3d726120e1b835d52fe358d3f
            C:\users\prox\desktop\Procmon.exe 9c85f494132cc6027762d8ddf1dd5a12
            C:\users\prox\desktop\PsExec.exe  aeee996fd3484f28e5cd85fe26b6bdcd
            C:\users\prox\desktop\pskill.exe  b5891462c9ca5bddfe63d3bae3c14e0b
            C:\users\prox\desktop\Tcpview.exe 485bc6763729511dcfd52ccb008f5c59

            Description
            -----------
            Uses pipeline input from Get-ChildItem to get MD5 hashes of executables.

    #>
        [CmdletBinding()]
        Param (
                [Parameter(Position = 0, Mandatory = $true, ValueFromPipelineByPropertyName = $true, ValueFromPipeline = $True)]
                [Alias("PSPath", "FullName")]
                [string[]]$Path,
                
                [Parameter(Position = 1)]
                [ValidateSet("MD5", "SHA1", "SHA256", "SHA384", "SHA512", "RIPEMD160")]
                [string[]]$Algorithm = "SHA256"
        )
        Process {
                ForEach ($item in $Path) {
                        try {
                                $item = (Resolve-Path $item).ProviderPath
                                If (-Not ([uri]$item).IsAbsoluteUri) {
                                        Write-Verbose ("{0} is not a full path, using current directory: {1}" -f $item, $pwd)
                                        $item = (Join-Path $pwd ($item -replace "\.\\", ""))
                                }
                                If (Test-Path $item -Type Container) {
                                        Write-Warning ("Cannot calculate hash for directory: {0}" -f $item)
                                        Return
                                }
                                $object = New-Object PSObject -Property @{
                                        Path = $item
                                }
                                #Open the Stream
                                $stream = ([IO.StreamReader]$item).BaseStream
                                foreach ($Type in $Algorithm) {
                                        [string]$hash = -join ([Security.Cryptography.HashAlgorithm]::Create($Type).ComputeHash($stream) |
                                        ForEach { "{0:x2}" -f $_ })
                                        $null = $stream.Seek(0, 0)
                                        #If multiple algorithms are used, then they will be added to existing object
                                        $object = Add-Member -InputObject $Object -MemberType NoteProperty -Name $Type -Value $Hash -PassThru
                                }
                                $object.pstypenames.insert(0, 'System.IO.FileInfo.Hash')
                                #Output an object with the hash, algorithm and path
                                Write-Output $object
                                
                                #Close the stream
                                $stream.Close()
                        } catch {
                                Write-Error -Message "Error: $($_.Exception.Message) - Line Number: $($_.InvocationInfo.ScriptLineNumber)"
                        }
                }
        }
}

function Copy-FileWithHashCheck {
    <#
    .SYNOPSIS
        This function copies a file and then verifies the copy was successful by comparing the source and destination
        file hash values.
    .EXAMPLE
        PS> Copy-FileWithHashCheck -SourceFilePath 'C:\Windows\file1.txt' -DestinationFolderPath '\\COMPUTER\c$\Windows\file2.txt'
    
        This example copied the file from C:\Windows\file1.txt to \\COMPUTER\c$\Windows and then checks the hash for the
        source file and destination file to ensure the copy was successful.
    .PARAMETER SourceFilePath
        The source file path
    .PARAMETER DestinationFolderPath
        The destination folder path
    .PARAMETER Force
        Overwrite the destination file if one exists
    #>
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true, ValueFromPipelineByPropertyName = $true, ValueFromPipeline = $True)]
        [Alias('Fullname')]
        [string]$SourceFilePath,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ Test-Path -Path $_ -PathType Container })]
        [string]$DestinationFolderPath,
        [Parameter()]
        [switch]$Force
    )
    begin {
        function Test-HashEqual ($FilePath1,$FilePath2) {
            $SourceHash = Get-MyFileHash -Path $FilePath1
            $DestHash = Get-MyFileHash -Path $FilePath2
            if ($SourceHash.SHA256 -ne $DestHash.SHA256) {
                $false
            } else {
                $true
            }
        }
    }
    process {
        try {
            $CopyParams = @{ 'Path' = $SourceFilePath; 'Destination' = $DestinationFolderPath }
            
            ## If the file is already there, check to see if it's the one we're copying in the first place
            $DestFilePath = "$DestinationFolderPath\$($SourceFilePath | Split-Path -Leaf)"
            if (Test-Path -Path $DestFilePath -PathType 'Leaf') {
                if (Test-HashEqual -FilePath1 $SourceFilePath -FilePath2 $DestFilePath) {
                    Write-Error -Message "The file $SourceFilePath is already in $DestinationFolderPath and is the same. No need to copy"
                    return $true
                } elseif (!$Force.IsPresent) {
                    throw "The file $SourceFilePath is already in $DestinationFolderPath but is not the same file being copied and -Force was not used."
                } else {
                    $CopyParams.Force = $true
                }
            }
            Write-Error -Message "Copying [$($CopyParams.Path)] to [[$($CopyParams.Destination)]...."
            Copy-Item @CopyParams
            if (Test-HashEqual -FilePath1 $SourceFilePath -FilePath2 $DestFilePath) {
                Write-Error -Message "The file $SourceFilePath was successfully copied to $DestinationFolderPath."
                return $true
            } else {
                throw "Attempted to copy the file $SourceFilePath to $DestinationFolderPath but failed the hash check"
            }
            
        } catch {
            Write-Error -Message "Error: $($_.Exception.Message) - Line Number: $($_.InvocationInfo.ScriptLineNumber)"
        }
    }
}PS C:\Windows\System32> get-service -name IBM* -computername wiwvsg296 | format-table -property MachineName, Status, Name, DisplayName -auto

get-service | where-object {$_.Status -eq "Running"}

get-service | where-object {$_.DependentServices} | format-list -property Name, DependentServices, @{Label="NoOfDependentServices"; Expression={$_.dependentservices.count}}


dir \scripts -file | where {$_.lastwritetime -ge '8/1/2014'}
dir c:\scripts -recurse | where {$_.psIsContainer}Invoke-Command -ComputerName  'boe-pc' -ScriptBlock  {Get-ChildItem Cert:\LocalMachine\My  | 
  Where {$_.NotAfter -lt  (Get-Date).AddDays(14)}} | ForEach {
  [pscustomobject]@{
  Computername =  $_.PSComputername
  Subject =  $_.Subject
  ExpiresOn =  $_.NotAfter
  DaysUntilExpired = Switch ((New-TimeSpan -End $_.NotAfter).Days) {
  {$_  -gt 0} {$_}
  Default  {'Expired'}
  }
  }
  } function Restart-ServiceEx {  
    [CmdletBinding( SupportsShouldProcess=$true, ConfirmImpact='High')]  
    param(  
    $computername = 'localhost',  
    $service = 'Spooler',  
    $credential = $null  
    )  
  
# create list of clear text error messages  
    $errorcode = 'Success,Not Supported,Access Denied,Dependent Services Running,Invalid Service Control'  
    $errorcode += ',Service Cannot Accept Control, Service Not Active, Service Request Timeout'  
    $errorcode += ',Unknown Failure, Path Not Found, Service Already Running, Service Database Locked'  
    $errorcode += ',Service Dependency Deleted, Service Dependency Failure, Service Disabled'  
    $errorcode += ',Service Logon Failure, Service Marked for Deletion, Service No Thread'  
    $errorcode += ',Status Circular Dependency, Status Duplicate Name, Status Invalid Name'  
    $errorcode += ',Status Invalid Parameter, Status Invalid Service Account, Status Service Exists'  
    $errorcode += ',Service Already Paused'  
  
    # if credential was specified, use it...  
    if ($credential) {  
        $service = Get-WmiObject Win32_Service -ComputerName $computername -Filter "name=""$service""" -Credential $credential  
    } else {  
        # else do not use this parameter:  
        $service = Get-WmiObject Win32_Service -ComputerName $computername -Filter "name=""$service"""   
    }  
  
    # if service was running already...  
    $servicename = $service.Caption  
    if ($service.started) {  
        # should action be executed?   
        if ($pscmdlet.ShouldProcess($computername, "Restarting Service '$servicename'")) {  
   # yes, stop service:  
            $rv = $service.StopService().ReturnValue  
            if ($rv -eq 0) {  
                # ...and if that worked, restart again  
                $rv = $service.StartService().ReturnValue  
            }  
   # return clear text error message:  
            $errorcode.Split(',')[$rv]  
        }   
    } else {  
        # else if service was not running yet, start it:  
        if ($pscmdlet.ShouldProcess($computername, "Starting Service '$servicename'")) {  
            $rv = $service.StartService().ReturnValue  
            $errorcode.Split(',')[$rv]  
        }   
    }  
} 
function Restart-ServiceEx {  
    [CmdletBinding( SupportsShouldProcess=$true, ConfirmImpact='High')]  
    param(  
    $computername = 'localhost',  
    $service = 'Spooler',  
    $credential = $null  
    )  
  
# create list of clear text error messages  
    $errorcode = 'Success,Not Supported,Access Denied,Dependent Services Running,Invalid Service Control'  
    $errorcode += ',Service Cannot Accept Control, Service Not Active, Service Request Timeout'  
    $errorcode += ',Unknown Failure, Path Not Found, Service Already Running, Service Database Locked'  
    $errorcode += ',Service Dependency Deleted, Service Dependency Failure, Service Disabled'  
    $errorcode += ',Service Logon Failure, Service Marked for Deletion, Service No Thread'  
    $errorcode += ',Status Circular Dependency, Status Duplicate Name, Status Invalid Name'  
    $errorcode += ',Status Invalid Parameter, Status Invalid Service Account, Status Service Exists'  
    $errorcode += ',Service Already Paused'  
  
    # if credential was specified, use it...  
    if ($credential) {  
        $service = Get-WmiObject Win32_Service -ComputerName $computername -Filter "name=""$service""" -Credential $credential  
    } else {  
        # else do not use this parameter:  
        $service = Get-WmiObject Win32_Service -ComputerName $computername -Filter "name=""$service"""   
    }  
  
    # if service was running already...  
    $servicename = $service.Caption  
    if ($service.started) {  
        # should action be executed?   
        if ($pscmdlet.ShouldProcess($computername, "Restarting Service '$servicename'")) {  
   # yes, stop service:  
            $rv = $service.StopService().ReturnValue  
            if ($rv -eq 0) {  
                # ...and if that worked, restart again  
                $rv = $service.StartService().ReturnValue  
            }  
   # return clear text error message:  
            $errorcode.Split(',')[$rv]  
        }   
    } else {  
        # else if service was not running yet, start it:  
        if ($pscmdlet.ShouldProcess($computername, "Starting Service '$servicename'")) {  
            $rv = $service.StartService().ReturnValue  
            $errorcode.Split(',')[$rv]  
        }   
    }  
} 
# setup certificate properties including the commonName (DNSName) property for Chrome 58+
$certificate = New-SelfSignedCertificate `
    -Subject localhost `
    -DnsName localhost `
    -KeyAlgorithm RSA `
    -KeyLength 2048 `
    -NotBefore (Get-Date) `
    -NotAfter (Get-Date).AddYears(2) `
    -CertStoreLocation "cert:CurrentUser\My" `
    -FriendlyName "Localhost Certificate for .NET Core" `
    -HashAlgorithm SHA256 `
    -KeyUsage DigitalSignature, KeyEncipherment, DataEncipherment `
    -TextExtension @("2.5.29.37={text}1.3.6.1.5.5.7.3.1") 
$certificatePath = 'Cert:\CurrentUser\My\' + ($certificate.ThumbPrint)  

# create temporary certificate path
$tmpPath = "C:\tmp"
If(!(test-path $tmpPath))
{
New-Item -ItemType Directory -Force -Path $tmpPath
}

# set certificate password here
$pfxPassword = ConvertTo-SecureString -String "YourSecurePassword" -Force -AsPlainText
$pfxFilePath = "c:\tmp\localhost.pfx"
$cerFilePath = "c:\tmp\localhost.cer"

# create pfx certificate
Export-PfxCertificate -Cert $certificatePath -FilePath $pfxFilePath -Password $pfxPassword
Export-Certificate -Cert $certificatePath -FilePath $cerFilePath

# import the pfx certificate
Import-PfxCertificate -FilePath $pfxFilePath Cert:\LocalMachine\My -Password $pfxPassword -Exportable

# trust the certificate by importing the pfx certificate into your trusted root
Import-Certificate -FilePath $cerFilePath -CertStoreLocation Cert:\CurrentUser\Root

# optionally delete the physical certificates (don’t delete the pfx file as you need to copy this to your app directory)
# Remove-Item $pfxFilePath
Remove-Item $cerFilePathIntroducing the Windows PowerShell ISE

Updated: October 17, 2013

Applies To: Windows PowerShell 2.0, Windows PowerShell 3.0, Windows PowerShell 4.0, Windows PowerShell 5.0

 The Windows PowerShell Integrated Scripting Environment (ISE) is a host application for Windows PowerShell. In Windows PowerShell ISE, you can run commands and write, test, and debug scripts in a single Windows-based graphic user interface with multiline editing, tab completion, syntax coloring, selective execution, context-sensitive help, and support for right-to-left languages. You can use menu items and keyboard shortcuts to perform many of the same tasks that you would perform in the Windows PowerShell console.  For example, when you debug a script in the Windows PowerShell ISE, to set a line breakpoint in a script, right-click the line of code, and then click Toggle Breakpoint.  

Try these features in Windows PowerShell ISE.

    Multiline editing: To insert a blank line under the current line in the Command pane, press SHIFT+ENTER.

    Selective execution: To run part of a script, select the text you want to run, and then click the Run Script button. Or, press F5.

    Context-sensitive help: Type Invoke-Item, and then press F1. The Help file opens to the Help topic for the Invoke-Item cmdlet.

The Windows PowerShell ISE lets you customize some aspects of its appearance. It also has its own Windows PowerShell profile, where you can store functions, aliases, variables, and commands you use in the Windows PowerShell ISE.
To start the Windows PowerShell ISE

    Do one of the following:
        Click Start, point to All Programs, point to Windows PowerShell V2, and then click Windows PowerShell ISE.

        In the Windows PowerShell console Cmd.exe, or in the Run box, type, powershell_ise.exe.

To get Help in the Windows PowerShell ISE

    On the Help menu, click Windows PowerShell Help. Or, press F1. The file that opens describes Windows PowerShell ISE and Windows PowerShell, including all of the help available from the Get-Help cmdlet.

PowerShell’s regular expression flavor
 
PowerShell is built upon Microsoft’s .NET framework. In regular expressions, as in much else, PowerShell uses the .NET implementation. And .NET in turn essentially uses Perl 5’s regular expression syntax, with a few added features such as named captures. For someone familiar with regular expressions, especially as they are implemented in .NET or Perl, the difficulty in using PowerShell is not in the syntax of regular expressions themselves, but rather in using regular expressions to do work. Because PowerShell is new, detailed documentation and examples are harder to find than for .NET or Perl.
 
Matching and replacing
 
PowerShell has -match and -replace operators that are roughly analogous to the m// and s/// operators in Perl. For example, start with the command
 

$greeting = "Hello world"
 
which would be legal PowerShell or Perl code. The PowerShell statement
 

$greeting -match "ello"
 
would return a Boolean true value just as the Perl statement
 

$greeting =~ m/ello/;
 
would return 1. Similarly, the PowerShell statement
 

$greeting -replace "world", "planet"
 
would return “Hello planet“, as would the statement
 

$greeting =~ s/world/planet/;
 
in Perl. However, the PowerShell statement returns a new string, leaving $greeting unchanged, while the corresponding  Perl statement changes the string $greeting in place.
 
Case-sensitivity
 
Perl modifies the behavior of the m// and s/// operators by adding characters to indicate such things as case-sensitivity. Both operators, like nearly everything else in Perl, are case-sensitive by default. Appending an ‘i‘ causes them to be case-insensitive.
 
PowerShell’s -match and -replace operators, like nearly everything else in PowerShell, are case-insensitive by default. PowerShell offers the highly recommended option of specifying -imatch and -ireplace to make case-insensitivity explicit. The case-sensitive counterparts are -cmatch and -creplace.
 
Retrieving single matches
 
After performing a match in Perl, the captured matches are stored in the variables $1, $2, etc. Similarly, after a match PowerShell creates an array $matches with $matches[n] corresponding to Perl’s $n.
 
Global matching and replacing
 
Perl
 
Perl uses a ‘g‘ option to specify global matches and replacements. The unmodified operator m// returns a Boolean value, but the modified operator m//g returns an array containing all substrings matching the specified pattern. Both the s/// and s///g operators modify their string in place. The unmodified s/// operator replaces only the first match in the string, while the modified s///g operator replaces all occurrences of the pattern.
 
For example, first set
 

$str = "Cookbook";
 
Then executing
 

$b = $str =~ m/(\woo\w)/;
 
sets $b to 1 (true) and populates $1 with “Cook“. Executing
 

@a = $str =~ m/(\woo\w)/g;
 
sets @a to the array containing “Cook” and “book”.
 
The statement
 

$str =~ s/oo/u/;
 
would convert “Cookbook” into “Cukbook“, while the statement
 

$str =~ s/oo/u/g;
 
would convert “Cookbook” into “Cukbuk“.
 
PowerShell
 
PowerShell’s -creplace and -ireplace work very much like the s///g and s///ig operators in Perl: all matches are replaced. PowerShell version 1.0 does not have a direct analog to Perl’s s/// and s///i operators without the ‘g‘ option.
 
Neither does PowerShell 1.0 have an analog to the m//g option in Perl, though Keith Hill has proposed that Microsoft add a -matches operator in a future release of PowerShell analogous to Perl’s m//g.
 
In order to have more fine control over match and replace operations in PowerShell, one must use the [regex] class rather than the -match and -replace operators. The following example shows how to do a global match in PowerShell.
 

$str = "Cookbook"
[regex]::matches($str, "\woo\w")
 
The last command returns a compound structure containing more information than just the matches. To fill an array $words with just the matches, use the command
 

$words = ([regex]::matches($str, "\woo\w") | %{$_.value})
 
which pipes the [regex]::matches output through the foreach operator % and selects the matched text.
 
The [regex] class in PowerShell is invoking the Regex class in .NET, and so all the options of the .NET class are available. For example, the .NET class library has a RegexOptions enumeration with useful values such as IgnoreCase, RightToLeft, etc. However, it is not obvious how one should translate from .NET to PowerShell syntax. You can’t write RegexOptions.IgnoreCase in PowerShell code the way you would in C#. It turns out the thing to do is to quote the option as a string. For example, the code
 

[regex]::matches($str, "[a-z]ook", "IgnoreCase")
 
will match “Cook” and “book“, whereas without the IgnoreCase option only “book” would match.
 
Replacing with captures
 
Often you want to replace a pattern not with a constant string but with a string based on the text that matched. For example, suppose you want to replace italicized words with double words. If $str contained “<i>big</i>” then after executing the Perl statement
 

$str =~ s{<i>(\w+)</i>}{$1 $1};
 
$str would contain “big big“. (This illustrates an alternative Perl syntax for s///. The s{}{} alternative prevents having to escape backslashes as in </i> above.)
 
The equivalent PowerShell code would be
 

$str = [regex]::Replace($str, "<i>(\w+)</i>", '$1 $1');
 
Notice the single quotes around the replacement pattern. This is to keep PowerShell from interpreting “$1” before passing passing it to the Regex class. We could use double quotes if we also put back ticks in front of the dollar signs to escape them.
//and the usage is pretty simple:

//[?] [vPodans] "www.inbox.lv","www.paypal.com","ib.dnb.lv" | Test-ServerSSLSupport

function Test-ServerSSLSupport {
[CmdletBinding()]
    param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ValidateNotNullOrEmpty()]
        [string]$HostName,
        [UInt16]$Port = 443
    )
    process {
        $RetValue = New-Object psobject -Property @{
            Host = $HostName
            Port = $Port
            SSLv2 = $false
            SSLv3 = $false
            TLSv1_0 = $false
            TLSv1_1 = $false
            TLSv1_2 = $false
            KeyExhange = $null
            HashAlgorithm = $null
        }
        "ssl2", "ssl3", "tls", "tls11", "tls12" | %{
            $TcpClient = New-Object Net.Sockets.TcpClient
            $TcpClient.Connect($RetValue.Host, $RetValue.Port)
            $SslStream = New-Object Net.Security.SslStream $TcpClient.GetStream(),
                $true,
                [System.Net.Security.RemoteCertificateValidationCallback]{ $true }
            $SslStream.ReadTimeout = 15000
            $SslStream.WriteTimeout = 15000
            try {
                $SslStream.AuthenticateAsClient($RetValue.Host,$null,$_,$false)
                $RetValue.KeyExhange = $SslStream.KeyExchangeAlgorithm
                $RetValue.HashAlgorithm = $SslStream.HashAlgorithm
                $status = $true
            } catch {
                $status = $false
            }
            switch ($_) {
                "ssl2" {$RetValue.SSLv2 = $status}
                "ssl3" {$RetValue.SSLv3 = $status}
                "tls" {$RetValue.TLSv1_0 = $status}
                "tls11" {$RetValue.TLSv1_1 = $status}
                "tls12" {$RetValue.TLSv1_2 = $status}
            }
            # dispose objects to prevent memory leaks
            $TcpClient.Dispose()
            $SslStream.Dispose()
        }
        $RetValue
    }
}
