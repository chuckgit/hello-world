TTED.TSK.D.TCEM.ASM
$$$BEG UCEMPINR
*ASM     XOPTS(NOPROLOG NOEPILOG)
         SYSSTATE ARCHLVL=OSREL
*
* TO FIND CICS TRANSLATE ERRORS, LOOK FOR DFH7   PREFIX
*        UCEMPINR!!!!!!!!!
* V1 - Original
* v1.1 - CHANGES TO FIX ASRA
* v1.2 - changes to add userids to restricted
*      - ALSO ALLOW (G5) REGION ID AS UID
* V1.3 - CEMT AND CEDA CMD NEED A DEFINED CMD AREA-CAN NOT BE NULLS
*      - USE SRST TO FIND FIRST NULL, OR USE DEFAULT 80 OR EIBCALEN
*      - TO DEFINE A VALID CMD AREA
* V1.4 - CEMT AND CEDA CMD - issue writeq cssl to reflect cmd  action
* V1.9 - LINK PROGRAM CMD - PASS COMMAND TO LINK TO PROGRAM WITH CA
* V2.0 - CHANNELS AND CONTAINERS FOR PING, CEMT, CEDA, LINK
*         WHERE CONTAINER REQUEST IS COPIED TO CA AND USED IN LEGACY
* V2.1 - COBOL RAND CALL TO UCEMRAN0 - PURE CNC
* V2.2 - FIX CN LOGIC TO DPL  WITH CN WHEN SYSID IS IN CN CMD
* V3.0 - UCEMPINR ADD LCNC CN - LCNCXXXX
*      -    WHICH IDENTIFIES VIA K=V PAIRS THE FOLLOWING KEY
*      -    AND THE RESPECTIVE CONTAINER NAMED BY THE VALUE
*      -      CN_LIST THE LIST OF ASSOCIATED CONTAINERS FOR THIS LINK
*      -      CN_PGM  THE PGM TO LINT TO
*      -      CN_SYSD THE SYSID TO DPL TO
*      - UCEMPINR ADD PLAY CN - LCNCXXXX
*      -    WHICH IDENTIFIES VIA K=V PAIRS THE FOLLOWING KEY
*      -    AND THE RESPECTIVE CONTAINER NAMED BY THE VALUE
*      -      CN_LIST THE LIST OF ASSOCIATED CONTAINERS FOR THIS LINK
*      -      CN_SYSD THE SYSID TO DPL TO
*      - PLAY AND LCNC BOTH ALLOW THE CMD CONTAINER TO SPECIFY
*      -    ANY OR ALL OF THE ABOVE WITH A STRING K=V PAir
*      -    AND BOTh DEFER TO ANOTHER CN
*      - EG - CONTAINER LCNC_ CONTAINS A STRING OF DATA
*      -    - LIST=(CEMTA,CEMTB),SYSID=AAAA,PGM=YYYYYYYY
* V3.1 - UCEMPINR ADD LOGIC TO AUTOMATICALLY CLONE THE CMD
*      -    CONTAINERS LISTED IN THE LIST REQUEST.
*      -    A RETURN CONTAINER IS CREATED AND NAMED:
*      -    'PLA#XXXXXXXXYYYY' WHERE
*      -    # CORRESPONDS TO THE PLAYLIST ENTRY 0 - 9
*      -    XXXXXXXXXXXX IS FIRST 8 CHARS OF THE EACH LIST CMD
*      -    YYYY IS THE LAST 4 CHARS OF EACH LIST CMD (IF NEEDED)
* V3.2 - LOOK FOR !20170720
*      -    FIX LINK TO PARSE TO FIND LAST NULL POS.
*      -    PROB WAS MVCL IN FND_LINK_SEP FORGOT TO ACCT FOR SEP CHAR
*      -    WHICH WAS CAUSING MVCL TO MOVE TOO MUCH SRC DATA TO CA
*      -    BEFORE EXECUTING A LINK WITH CA VIA A CNC LINK CMD
* V3.3 - LOOK FOR !20170802
*      -    return a list of cn on ch in container named:
*      -    RETURN_CN_LIST   container(CN_RET_CN_LIST)
*      -      container will contain prefix value
*      -      CN_RET_LIST_PFX DS CL22     SYSD(______CN_RESP_NM,
*      -        where ________ is this program name and _CN_RESP_NM
*      -         in which this cn is the log cn
*      -      and then the rest of the cn data is a list of cn
*      - note will begin with a sysid( and end with a ','
*      -    exci interface does not have a browse cn function
*      -    in order to facilitate the enumeration of cn on a channel
*      -    compile a list of cn on the orig channel into this new cn
*      -    ADD LCL_UID TO BASEMSG FOR NOCA
* V3.4 - LOOK FOR  20171002
*      -    if conn ck fails,check for ipconn before link with sysid:
*      -     on link to remote regions, we first check conn for valid
*      -     installed conn. before trying prod and test termid
*      -     regions, we must inq the ipconn for the sysid.
*      -    on receiving the inbound ipconn request, the SYSID=xxxx
*      -     sysid (IPCONN) may not match the usual (CONN) sysid. can
*      -     not determine final destination. so, the actual termid
*      -     is used to identify an ipconn session. the termid sess
*      -     prefix character is '/'. when we encounter this value
*      -     we can only process the request as a local request.
*      -     In other words, no chained IPCONN requests are valid.
*      -     this is because ipconn 4 char identifies are not related
*      -     to the sysid for the region, as is usually the case for
*      -     MRO, ISC, or EXCI DPL tasks. force the lcl_sysid to
*      -     the value provided on the sysid=xxxx and run the request
*      -     locally with no further sysid checks.
* V3.5 - LOOK FOR  20180604
*      -    allow ceda alter, move, rename commands
* UCEMPINR
*  Valid Functions are identified by CA pos 1-4 or containers
*   named in   pos 1-4 with command name, and data in CHAR cn with
*   respective request (identical to CA request)
*  valid commands must be in CAPS
*  associated command request is not evaluated for correct syntax
*  SYSID=(xxxx), or SYSID(xxxx), or SYSID=xxxx, - Prefixed request,
*   attempts to route the actual request to the identified xxxx SYSID
*   if the SYSID is not defined to the region, the pgm attempts
*   to use the UTRMUDT/P region to daisy chain the request
*  Note - CEDA requests CAN NOT be routed (internal reqtriction)
*
*  CEMT - execute the CEMT program
*       - INQUIRE xxxx
*       - SET xxxx
*  CEDA - execute the CEDA program
*         DISPLAY
*         ALTER
*         MOVE
*         RENAME
*         EXPAND
*         INSTALL
*         DEFINE
*         VIEW
*         view G(CEMLIB) lib(cemcics)
*  LINK - Link to the Program with commarea
*         data sent to program as commarea is remainder of CA
*           after commands
*  PING - run PING logic
*
*  CRND - Create cNc payload, by invoking UCEMRAN0 COBOL RAND fn
*         optionally provide SEED and NUMB parameters
*         via CRND container, as string data if format
*         SEED=N..NN,NUMB=YYYY
*         or by adding associated SEED and NUMB containers
*         with the appropriate values specified
*
*
*
*  PLAY and LCNC use same set of CN_LIST CN with K=V cmd string
*      - simple LIST=(x,y,..z) list of containers
*  LCNC - Link to the Program using container list  (Not Available)
*      - PLAYxxxx or
*      - LCNCxxxx can specify each of the following cn
*      -  COMMA SEPARATED KEY VALUE PAIRS:
*      - CN_LIST=zzzz_anyname specifies a CN, which has a list of
*          other CN which are data CN to use in link
*      - CN_PGM=yyyy_anyname  specifies a CN, which is link pgmname
*      - CN_SYSD=wwww_anyname specifies a CN, sysid to DPL (optional)
*      - aaaa ... zzzz are cn that are associated with the request
*      - xxxx aaaa ... zzzz cn anmes must NOT be a COMMAND
*      - The LCNC logic is as follows:
*        the LCNC COMMAND prefix is signals link with cnc
*        each LCNCxxxx must specify options as cn names (coma sep)
*          xxxx_CN_PGM to identify the link to pgm is required
*        optionally
*          xxxx_CN_SYSD specifies a SYSID for the link
*          xxxx_CN_LIST specifies a list of additional containers
*              to be included in the link channel
*          aaaa ... nnnn are the data cn identified in the CN_LIST
*              and will be added to the link to channel
*      - on return from the link, all cn returned on the link to
*        channel are moved to the initial (current) channel
*        (delete cn in your call to pgm, to elim that move)
*
*  PLAY - (CNC ONLY) RUN THE ASSOC SET OF FUNCTIONS
*
* for example: using CECI
*     &A           +00017   CEMT INQUIRE CONN
*     &B           +00019   CEMT INQUIRE SYSTEM
*     &C           +00017   CEMT INQUIRE TASK
*     &D           +00060   LIST=(CEMTA001,CEMT2,CEMT0A00)
*     &E           +00034   LIST=(CEMT0A00,CEMTA001,CEMT2)
*     &F           +00021   LIST=(CEMT2,CEMT0A00)
*
*     PUT  CONT(CEMTA001) CHAN(A)  FROM(&A) FL(17) CHAR
*     PUT  CONT(CEMT0A00) CHAN(A)  FROM(&C) FL(17) CHAR
*     PUT  CONT(CEMT2)    CHAN(A)  FROM(&B) FL(19) CHAR
*     PUT CONT(PLAY0001) CHAN(A) FROM(&D) FL(34) CHAR
*     PUT CONT(PLAY009A0) CHAN(A) FROM(&E) FL(34) CHAR
*     PUT CONT(PLAY00A0) CHAN(A) FROM(&F) FL(21) CHAR
*
*
*
*
*
*
*  TO FIND CNC CMD CA LOGIC USE CN_RET_FROM_OLD_CMD
*  TO FIND CNC CMD CN LOGIC USE CN_CMD_PROCESSED
*
*  IF NO COMMAREA, and NO cNc just WRITE BASEMSG TO CSSL AND RETURN
*
*  cNc - container name identifies the function
*      - other than play, results are shipped back in using the
*        source container name
*      - other than play, a single container for executes a single
*        function - CN name pos 1-4 must match the data req pos 1-4
*      - 1 - 100 different containers can be sent as function req
*      - logic captures container names pos 5-16, to differentiate
*        among multiple requests. this suffix data can also be used
*        to associate other, non cmd container names, with the a
*        respective cmd container
*      - 1 - 100 containers, non cmd containers (pos 1-4) can be
*        sent; used as associated containers for commands:
*         for example CRND0001 could have SEED0001 and NUMB0001
*
*      - PLAY function implies that multiple containers for each
*        valid function can be run.
*        one to multiple function groups can be specified
*        Each function group can have 1 to 9 name containers
*        FFFF000N - FFFF IS VALID FUNCT CONTAINER NAME WITH
*                   000N N IS 1 TO 9  APPENDED (GIVING 9 FUNCTIONS)
*                   AND THE ORDER IN THE PLAY LIST DETERMINES THE
*                   ACTUAL PLAY ORDER. E PLAY LIST DETERMINES THE
*       - the following WAIT and REPEAT is NOT available
*        PLAY container can have these valid key=value pairs
*             WAIT=nn specifies ICE wait for nn seconds between
*                  function commands
*             REPEAT=yy specifies repeating each 'first' function
*                  command yy times (0-99)
*                  0 implies run once, no repeats
*                  that is, the ffff0001 function container
*                  request is run repeatedly for yy iterations
*                  with wait. other containers in the function group
*                  run once.
*                  response data for the repeated function are
*                  sent back in new containers named ffff0001_nn
*       - the following SYSID is available
*             SYSID=ssss - run ALL commands, routing to ssss region
*                  (do not look at the individual function containers,
*                   but foward the full cNc set to the target region)
*
*      - each function container (except PLAY) contains the command
*        to be invoked.
*        FOR NOW, NEXT 4 CHARACTERS CAN BE LITERAL PING, OR
*        OR CEDA EXPAND ... (NOTE OTHER OPTIONS AVAILABLE)
*        OR CEMT INQUIRE ... (NOTE OTHER OPTIONS AVAILABLE)
*        OR LINK progname commarea
*        OR LCNC progname container with cNc containers
*
* !20170802 - V3.3
*  in order to facilitate a missing BROWSE CN function in the EXCI
*   interface, this program now create/replaces a new container
*   RETURN_CN_LIST
*   which is to be formatted
*   sysd(x..x,....)
*   where sysd is the cics sysid
*    followed by a list of containers returned in the orig channel
*
*
*  PING FUNCTION:
*  IF cNc, see below
*  IF COMMAREA, THEN USE ONE OF THE FOLLOWING TO FORMAT CA
*   CA MUST BE MINIMUM OF 2, UP TO 32400
*     REST OF CA WILL BE FILLED IN AS APPROPRIATE
*   FOR NOW, NEXT 4 CHARACTERS CAN BE LITERAL PING, OR
*       OR CEDA EXPAND ... (NOTE OTHER OPTIONS AVAILABLE)
*       OR CEMT INQUIRE ... (NOTE OTHER OPTIONS AVAILABLE)
*   ANY FUNCTION CAN BE PREFIXED WITH SYSID=____,
*            FOLLOWED BY  PING
*       OR/AND   FOLLOWED BY  CEDA EXPAND ...
*       OR/AND   FOLLOWED BY  CEMT INQUIRE ...
*   IF REMAINING CA IS AT LEAST 29, THEN RETURN START AND STOP TIME
*   EACH HOP WILL RETURN IT'S START AND STOP TIME
*   IF SPACE PERMITS, THEN EACH HOP WILL BE REFLECTED IN THE RETURN CA
*  ORIGINAL COMMAND IS NOT DISTURBED IN THE CA. RESPONSE IS TACKED
*   ONTO THE CA.  FIRST BYTE IN THE RETURNED AREA IS A READABLE RC
*      0 IS NORMAL
*      1 IS NORMAL, BUT PARTIAL DATA WOULD NOT FIT
*      2 IS NORMAL, BUT NON NULL TERMINATED STRING RETURNED
*      4 IS ERROR, SEE WTO
*      8 IS ERROR OR ABEND, NO MESSAGE
*
*GENERAL ASSEMBLER CONSIDERATIONS
*
* ON ENTRY, PRM OBEYS SYSTEM LINKAGE STDS
*  R1 POINTS TO PARM LIST W/ TWO ADDR (EIB AND COMM (OR ZERO))
*  R13 POINTS TO ADDR OF SAVE AREA
*  R14 POINTS TO ADDR OF RETURN PT
*  R15 POINTS TO ADDR OF ENTRY  PT
* FOR EACH EXEC CICS CALL MACRO EXPANDS TO
*  DFHECALL MACRO WHICH IS STD SYSTEM CALL
* DFHECALL BUILDS THE PARM LIST IN DYN STG FOR REENTRANCY
*  R0  UNDEFINED
*  R1  POINTS TO ADDR OF PARM LIST
*  R14 POINTS TO RETURN POINT IN YOUR PGM
*  R15 POINTS TO ADDR OF ENTRY  PT IN EXEC INTF
* DFHEAI MUST BE LINK EDITED WITH YOUR PGM FOR EXEC INTF RESOLUTION
* DFHEIENT NORMALLY INSERTED BY TRANSLATOR AFTER FIRST CSECT
*  INSTRUCT DFHEIENT CODEREG=(2,3,4),
*               DATAREG=(13,5),
*               EIBREG=6
* CODE YOUR OWN DFHEIENT FOR OVERRIDES (BASELESS CODE)
*  SPECIFY XOPTS(NOPROLOG)
*
* EXEC CICS RETURN WILL EXIT YOUR PGM OR DFHEIRET IS INSERTED BY
*  THE TRANSLATOR IF NO EXEC RETURN FOUND
* DFHEIRET INSERTED BY TRANSLATOR AT END OF PGM
*  THIS MACRO: RESTORES REGS
*              RETURNS VIA R14
* YOU CAN CODE YOU OWN DFHEIRET WITH OR WITHOUT PARM RCREG=N
*  SPECIFY XOPTS(NOEPILOG)
*
* SYMBOLIC REGISTER DFHEIPLR IS EQUATED TO THE FIRST DATAREG EITHER
*  EXPLICITLY SPECIFIED OR OBTAINED BY DEFAULT. THIS REG IS USED
*   BY DFHCALL MACRO. IF YOU USE THAT REG FOR OTHER PURPOSES, IT
*   NEEDS TO BE RESTORED FROM A SAVED COPY, BEFORE EXEC CICS CMD
*
* DFHEIENT  THIS MACRO: SAVES REGS
*              GETMAIN STG FOR DFHEISTG
*              SETS BASE REG (R3 DEFAULT)
*              SETS DYN STG REG (R13 DEFAULT)
*              SETS EIB REG (R11 DEFAULT)
* DFHEISTG INSERTED BY TRANSLATOR
*              DEFINES STG PARM LIST
*              DEFINES STG FOR REG SAVE AREA
*              INCLUDES YOUR VARS WHEN YOU CODE THE DFHEISTG MACRO
* DFHEIEND INSERTED BY TRANSLATOR TO ID END OF EIB SAVE AREA
* DFHEIBLK INSERTED BY TRANSLATOR DEFINES EIB DSECT
* MULTIPLE BASE REGS DEFINED BY DFHEIENT (CODEREG DATAREG EIBREG)
* DFHEIPLR IS THE REG VAR ASSIGNED TO FIRST EIBREG OR DEFAULT R13
*REG 1                      PASSED ADDR OF PARMS
*REG 10                     PTR TO DFHEISTG (SET BY DFHEIENT)
*REG 11                     STATIC STG FIRST   LITERALS IN CSECT
*REG 12                     STATIC STG SECOND
*REG 13                     DATAREG  WORKING STORAGE
*
*REG 2                      WK
*REG 3                      WK
*REG 4          WK
*REG 5          WK
*REG 6          CONTAINER STACK PTR
*REG 7          CONTAINER STACK ELEMENT PTR
*REG 8          WK
*REG 9          WK (USED FOR JAS JUMP TO SUBRTN)
*REG 15         WK
         REGSMAC
*
*
*    two of these stacks are set up - one for recognised
*     and one to hold unknown container names
*    each stack pointed to out of dyn stg
*    accululate the container names in the respective stack
*    then run the commands as ordered by the crowse cn order
*
*
CNC_CN   DSECT
CNC_CN_LIST_NXT DS F      ADDRESS OF NEXT INCREMENT OR ZERO
CNC_CN_LIST_LNG DS F      LNG OF THIS INCREMENT
CNC_CN_LIST_TYP DS F      TYP OF THIS INCREMENT 0,1,2,3
CNC_CN_LIST_ELEM_TOP DS F ADDRESS OF FIRST ELEMENT
CNC_CN_LIST_ELEM_LNG DS F LNG OF ELEMENT
CNC_CN_LIST_ELEM_MX_CT DS F MAX NUMBER OF ELEMENTS
CNC_CN_LIST_ELEM_CUR DS F ADDRESS OF MOST CURRENT T ELEMENT
CNC_CN_LIST_ELEM_CUR_CT DS F CUR COUNT OF OCCUPIED ELEMENTS
CNC_CN_SAA_L  EQU  *-CNC_CN_LIST_NXT  LNG OF ACCOUNTING AREA
*
CNC_CN_ELEM DSECT
CNC_CN_N DS    CL16       CONTAINER NAME
CNC_CN_L DS    F          CONTAINER LENGTH
CNC_CN_CP DS   F          CONTAINER CCSID (CODEPAGE IS CHAR;ZERO IF BIT
CNC_CN_X  DS    F         ADDRESS OF EXECUTABLE CMD FROM CMD_TBL
CNC_CN_RX DS    F         ADDRESS OF RTN LABEL FOR CMD FROM CMD_TBL
CNC_CN_A  DS    F          CONTAINER ADDRESS IN STG AREA
CNC_CN_ENT_L  EQU  *-CNC_CN_N    LNG OF ONE ENTRY
*
*
*
CMD_CA   DSECT
CA_START DS    0F
CA_RET_CD  DS  C      X'F0' X'F4' X'F8' ARE ONLY EXPECTED VALUES
CA_RET_STR_ST DS 0C
*
* PARS DSECT FOR UCEMPARS
* MYCOM_A IS THGE ANCHOR FOR THIS DSECT
         COPY PARSDSCT
*
SAVE     DFHEISTG DSECT
BEGOFEIS DS    CL8
SAVR1    DS    F
SAVR3    DS    F
SAV_RET_9  DS   F   GENERAL SAVE AREA
SAV_RET_9A DS   F  USED FOR RECURSIVE JAS R9 BASEMSG
SAV_RET_9B DS   F  USED FOR RECURSIVE JAS R9 WRITE TDQ
SAV_CN_MOVE_R9 DS F USED TO SAVE R9 IN MOVE CN SR
SAV_SEP_6  DS   F
SAV_4_SRST DS   F
SAV_CN_REGS4_7       DS  4F
SAV_CN_REGS5_8       DS  5F
SAV_LCNC_REGS4_8     DS  5F
SAV_FND_CNC_REGS_4_8 DS  5F
SAV_RET_CK_CMD_9 DS F
SAV_RET_FMT_TM_9 DS F
SAV_R9_GM_RET_ADR DS F
SAV_DEL_CH_R9   DS   F
SAV_CPY_CN_R9   DS   F
SAV_FND_CNC_ELEM_R9 DS F
*
SAV_CN_UKN4_7  DS    4F
SAV_CN_CMD_RET9 DS  F
SAV_CN_LCNC_RET9 DS  F
SAV_CN_UKN_RET9 DS  F
SAV_CN_PUT_RET9 DS  F
SAV_PLAY_REGS4_8     DS  5F
SAV_PLAY_SORT_R9     DS  F
SAV_PLAY_CMD_REG7 DS  F
SAV_PLAY_LIST_REGS2_3  DS 2F
SAV_GET_VAL_CNC_CHR_R9 DS 0F
FND_CMD_STK_PROCD   DS F
*
PARS_REG_SA DS   16F
*
GM_STG_ADR   DS  F
GM_STG_FL    DS  F
EXEC_CICS_FL DS  F        USED TO HOLD FLENGTH VALUES
EXEC_CICS_HL DS  H        USED TO HOLD LENGTH VALUES
FRESP        DS  F
FRESP2       DS  F
*
PUT_RESP_CN_OK DS XL1    VALUE 0 (RESP_CN_OK) AND 1 (RESP_CN_NOT CRE)
PUT_APND_PARMS DS 0F
PUT_APND_MSG_FL DS F     LNG OF APPEND MSG
PUT_APND_MSG_ADR DS F    ADDR OF APPEND MSG
*
DWORD    DS    D
$DBLWD   DS    D
D_ABSTIME DS   D
*
* GENERALIZED PARSER V 1.4?
PARS_CA_PARM_LIST DS  0F    EIB SECION
         ORG   *+CA_EQU_LENGTH
PARS_TST_ADR_RETURN DS F   PTR USED BY PARS TO RET FND ADDR OR NULL
*
* GENERALIZED PARSER V 1.2
*  REQUIRES A PARMAREA, 4 FW AND 2HW, ON FW BOUNDRY
*  (5 FW IN TOTAL PARMAREA)
*  OVERALL RETURN CODE IN R15
THEPARM  DS    4F
*
PARSE_EQ DS H
* SET FIND EQUAL TO H'00'
* SET FIND UNEQUAL TO H'FFFF'
PARSE_DIRECTN DS H
THEPARM_L EQU  *-THEPARM
*  END OF THEPARM AREA
PARMAREA DS    0F
         DS    H
PARMAL   DS    H
PARMA    DS    F
H_MAX_CMD_LEN DS H        USE TO HOLD DERIVED MAX CMD LNG
*
P4       DS    PL4
C8       DS    CL8
TDQ      DS    CL4
SEP      DS    CL1
*
sav_mbl_val ds  f        save number of bits for sha klmd
*
X2CX49   DS    6F
X2CX_PRM_ADR DS 0F
X_FROM_A DS    F
X_FROM_L_A DS  F
X_TO_A   DS    F
X_TO_L_A DS    F
*
FROM_HEX_STR_L  DS    H      hold lng of x src
TO_CHAR_STR_L   DS    H      hold lng od cx dest
*FROM_HEX_STR  DS    XL40
*TO_CHAR_STR   DS    XL80
*
EBCDCFLD DS    D         8 character x string used by x2cx
*
*
MYCHAR  DS XL9 CHAR DATA
*
MYXSTR  DS XL4  CHAR DATA
MYXSTR1 DS XL1
*
FOUR     DS    CL4,C
*
EIGHT    DS    CL8,C
*
FRC      DS    F         FW RC FOR CN PROCESSING
MXRC     DS    F         FW MAX RC FOR ALL CN
RC       DS    XL1
*
HLDSTR   DS    CL7
TASKNUM  DS    CL8
         ORG   *-5
TASK_NUM DS    CL5
*
TASK_EIBCAL DS    CL5
TRMNETID DS    CL8
TRMUSRNM DS    CL20
*
OPLIT00  DS    CL21     USED FOR CN RESP DT AND TIME
OPLITM09 DS    CL9      USED FOR THE PGM NAME + SPACE
OPLITM05 DS    CL5      USED FOR THE SYSID + SPACE
OPLITM06 DS    CL6      USED FOR THE TXN # + SPACE
OPLIT00_L_EQU EQU *-OPLIT00
         ORG   *-1
OPLIT1   DS    CL1
OPLIT    DS    CL212
OPLIT00_TOT_EQU EQU *-OPLIT00
*
RTE_TO_SYSID DS CL4            20171002
             DS CL4            20171002
*
P_OCA       DS    F   PTR TO ORIG CA
*
P_OCA_CURPOS DS   F   PTR INTO ORIG CA
P_OCA_LSTPOS DS   F   PTR TO LAST POS OF ORIG CA
*
*      GETMAIN A 32400 SCRATCH AREA TO MANIPULATE DATA
P_MOV_2_DATA DS   F    SCRATCH AREA TO SET UP STRING TO RETURN IN CA
P_MOV_2_DATA_CURPOS DS   F SCRATCH AREA CURPOS
MOV_2_DATAL     DS    F     LNG OF THE SCRATCH AREA
P_MOV_2_DATA_LST DS   F     LAST VALID POSITION IN SCRATCH AREA
*
P_DPL_CA    DS    F    PTR TO DPL CA (IF ANY)
*
F_DPL_CAL   DS    F     MAX FLNG FOR CA COMMAREA
            ORG *-2
H_DPL_CAL   DS    H     MAX LNG FOR DPL COMMAREA
H_DPL_RET_CAL   DS    H    DERIVED LNG INCL DELIMITING X'00'
*
P_CMD_A     DS    F    PTR TO CMD WORKING AREA
*
P_CMD_OP_A  DS    F    PTR TO CMD OUTPUT AREA
*
SAV_SEP_ADR DS    F
SAV_CAL      DS   H
SAV_CAL_REMN DS   H
SYSID_SUFXL  DS   H
PROGRAM_SUFXL DS  0H
H_L_PREFIX_DATA DS 0H
*
*CVDA DATAAREAS
PGMAPI   DS   F
TDQ_ENA  DS   F
TDQ_STAT DS   F
TDQ_RECFM DS  F
TDQ_RECLF DS  F
          ORG *-2
TDQ_RECLH DS  H
*
TDQ_RECL_REQ_LNG DS H
*
LCL_IPCN_SYSID   DS   CL4
LCL_SYSID   DS   CL4
LCL_APPLID  DS   CL8
LCL_NETNAME DS   CL8
INVKG_PROG DS   CL8
PGM_CUR    DS   CL9
FAC_3270   DS   XL1
ST_CD      DS   CL2
LCL_UID    DS   CL8
LCL_DEF_UID DS  CL8
LCL_UNAME  DS   CL20
*
PGM_CMD    DS   CL8
*
PGM_RMT    DS   CL8
*
TIMER_ENT_CN_JDT DS CL8
TIMER_ENT_CN_TOD DS CL8
*
TIMER_ENT_ST_JDT DS CL8
TIMER_ENT_ST_TOD DS CL8
TIMER_ENT_SP_JDT DS CL8
TIMER_ENT_SP_TOD DS CL8
*
TIMER_DPL_ST_JDT DS CL8
TIMER_DPL_ST_TOD DS CL8
TIMER_DPL_SP_JDT DS CL8
TIMER_DPL_SP_TOD DS CL8
TIMER_AREA_L     EQU  *-TIMER_ENT_CN_JDT
*
MYABSTM8 DS    PL8   FOR CNC GET TIME ROUTINE
MYABSTM  DS    PL8
MYABSTM1 DS    PL8
*
TMP_STR_33   DS CL33
L_TMP_STR_33   EQU *-TMP_STR_33
*
CH_NM       DS CL16       CHANNEL NAME ON ENTRY
CH_SYSID_NM DS CL16       CH NM FOR LINK SYSID
CH_DEL_NM    DS   CL16
CN_DEL_NM    DS   CL16
CN_DEL_BRS_TKN DS F
CH_COPY_NM_FROM DS CL16   CH NAME FOR COPY FROM 2 NEW CH
CH_COPY_NM_TO   DS CL16   CH NAME FOR COPY TO   2 NEW CH
CN_COPY_NM_FROM DS CL16   CH NAME FOR COPY FROM 2 NEW CH
CN_COPY_NM_TO   DS CL16   CH NAME FOR COPY TO   2 NEW CH
CH_MOVE_NM_FROM DS CL16   CH NAME FOR MOVE FROM 2 NEW CH
CH_MOVE_NM_TO   DS CL16   CH NAME FOR MOVE TO   2 NEW CH
CN_MOVE_NM      DS CL16       CN NAME FOR MOVE 2 CH
CN_MOVE_NM_17   DS CL1        EXTRA BYTE
CN_MOVE_ADR DS F          SAVE ADDRESS OF GM STG FOR GET/PUT CN
CN_PLAY_ADR DS F          SAVE ADDRESS OF GM STG FOR GET/PUT CN
CN_CT       DS F          COUNT OF CONTAINERS IN TOTAL
CN_NM       DS CL16       CONTAINER NAME
CN_CT_MX    DS F          MAX # ALL CONTAINERS
CN_LIST_GM_L DS F   LNG OF STK GM TO HOLD CN LIST
CN_GM_XEQ_CMD_STG DS F   LNG OF STK GM TO HOLD CN LIST
CN_GET_CN_ADR DS  F       ADR OF CUR CMD CN STG DATA
CN_BRS_TKN  DS F          BROWSE CONTAINER TOKEN
*
* PLAY LIST ENTRIES MAX 10 ENTRIES LAST (11TH) IS FFFFFFFF
CN_NM_PLAY_ANCH DS F       CONTAINER PLAY FND: STK ADR
CN_PLAY_LIST DS 10F
CN_PLAY_FF   DS F
* PLAY LIST END
*
         DS    0D
CNC_VAL_CHR_CUR_TBL_ENT DS F
LCNC_CLONE_PFX_ELEM_CT DS CL1
*
PLAY_CLONE_PFX_ELEM_CT DS CL1
PLAY_CLONE_CN  DS  CL16
         ORG *-L'PLAY_CLONE_CN
PLAY_CLONE_PFX DS  CL3
PLAY_CLONE_PFX_ELEM DS CL1
PLAY_CLONE_CMD_1_12 DS CL12
*
PLAY_ELM_CT          DS  F
PLAY_ELM_CT_LESS_1   DS  F
*
* PLAYLIST_TMP_GRP COMPOSED OF PLAYLIST_TMP_ELM PLAYLIST CN NAME
*                              PLAYLIST_TMP_ELM_CN PTR TO CN
* EACH ENTRY SET UP ALONG WITH  CN_NM_PLAY_ANCH LOGIC
PLAYLIST_GRP_ANCH   DS  F
             DS     0D
PLAYLIST_TMP_GRP     DS XL20
PLAYLIST_TBLGRP_L    EQU L'PLAYLIST_TMP_GRP
             ORG *-L'PLAYLIST_TMP_GRP
PLAYLIST_TMP_ELM     DS CL16
PLAYLIST_TBLENT_L    EQU L'PLAYLIST_TMP_ELM
*
PLAYLIST_TMP_ELM_CN  DS F
*
PLAYLIST_TBLBEG      DS 10XL20
PLAYLIST_TBL_TOT_L EQU *-PLAYLIST_TMP_ELM
PLAYLIST_TBLEND_FF   DS F
*
PLAY_LCNC_REQUEST    DS XL1      PLAY CALL DO_LCNC SET THIS TO X'FF'
*                                             ELSE             X'00'
PLAY_CLONE_SAV_CH_NM DS CL16
PLAY_CLONE_TMP_CH_NM DS CL16
*
* CNC LITERALS
PUT_APND_RESP_CN_FL DS F    USED TO HOLD RESP CN FLENGTH VALUES
TMP_CH     DS CL16 UCEMPINR_TMP_CHN      TMP CH TO HOLD RESP CONTAINER
TMP_CN_FL  DS F                          TMP FL FOR CN LNG
TMP_CN_CP  DS F                          TMP FL FOR CN LNG
CN_MOV_BRS_ERRCT DS F
CN_RESP_NM DS CL16 UCEMPINR_RS_          TMP CN TO HOLD RESP MSG
*
* !20170802
CN_RET_CN_LIST DS CL16
CN_RET_LIST_PFX DS CL22     SYSD(______CN_RESP_NM,
*
CN_CMD_ASSOCIATES DS CL16 SRCH FOR ASOCIATED CONTAINERS
LNK2CH_NM   DS  CL16
LNK2PGM_NM   DS  CL8
             DS  CL1
LNK2SYSD_NM  DS  CL4
*
PLAY_LIST_CN  DS   CL16
PLAY_PGM_CN   DS   CL16
PLAY_SYSD_CN  DS   CL16
PLAY_LIST_FL  DS   F
PLAY_LIST_ADR DS   F
*
*
LCNC_LIST_CN  DS   CL16
LCNC_PGM_CN   DS   CL16
LCNC_SYSD_CN  DS   CL16
LCNC_LIST_FL  DS   F
LCNC_LIST_ADR DS   F
*
*
CN_CUR_CN_ELEM DS  F      ADR OF CUR CMD CN STG DATA
CN_CUR_CN_UKNE DS  F      ADR OF CUR UKN CN STG DATA
CN_CA_SURROGATE DS F      ADDR OF SURROGATE CA FOR OLD CMDS
CN_CA_SURROGATE_L DS H    HW LNG OF SURROGATE_CA
CN_CA_SUR_L_MINUS2 DS H    HW LNG OF SURROGATE_CA
*
*  THE FOLLOWING PARMLIST IS USED BY CN_GM_STACK ROUTINE
CN_GM_PARM_LIST DS  0D
CN_GM_PARM_STK_LNG DS F  LNG OF GM REQ
CN_GM_PARM_STK_IND DS F  STK TYP (0=CMD, 1=UKN)
*   0 AND 2 ARE FOR KNOWN CN STACK
*   1 AND 3 ARE FOR UNKNOWN CN STACK
*     FOR WHICH SPECIAL PROCESSING ON INITIAL REQUEST:
*   0 AND 1 ARE FOR INITIAL STACK REQUEST
*   2 AND 3 ARE FOR NEXT STK REQUEST
CN_GM_PARM_STK_CUR_PTR DS F PTR TO CURRENT STACK 'NEXT' ADDRESS
CN_GM_PARM_LIST_LNG EQU  *-CN_GM_PARM_LIST
*
*
CN_GM_ELEM_CT_MX   DS F   MAX NUM OF ELEM IN STK AREA (BOTH TYPES)
CN_GM_ELEM_CT_INCR DS F   INCREMENT FOR NEW AREA
*
*    COMMAND GLOBALS
CN_GM_CMD_ANCH DS F       CONTAINER GM AREA ANCHOR (FIRST ENTRY))
*                          FOR KNOW CMDS
CN_GM_CMD_LAST_STK DS F   CONTAINER GM AREA LAST STK GM
CN_GM_CMD_CUR_CT DS F     COUNTER FOR EACH CN GM 1 - OR CN NAMES)
CN_GM_CMD_STK_PROCD DS F  COUNT OF CMD CN IN STK  PROCESSED
CN_GM_CMD_TOT_PROCD DS F  COUNT OF CMD CN IN TOT  PROCESSED
*
*    UNKNOWN GLOBALS
CN_GM_UKN_ANCH DS F       CONTAINER GM AREA ANCHOR (FIRST ENTRY))
*                          FOR UNKNOWN CONTAINER NAMES
CN_GM_UKN_LAST_STK DS F   CONTAINER GM AREA LAST STK GM
CN_GM_UKN_CUR_CT DS F     COUNTER FOR EACH CN GM 1 - OR CN NAMES)
CN_GM_UKN_STK_PROCD DS F  COUNT OF UKN CN IN STK  PROCESSED
CN_GM_UKN_TOT_PROCD DS F  COUNT OF UKN CN IN TOT  PROCESSED
*
CMD_TBL_X DS  F         EXECUTE CMD ADDRESS
CMD_TBL_RTN_X DS  F     RETURN FROM EXECUTE CMD ADDRESS
CMD_TBL  DS   XL(CMD_TBL_LIT_LNG)
*
         DS   0D
*
UR_RESP  DS   0CL(255)
UR_PGMID DS   CL(8)
         DS   CL(1)
UR_VER   DS   CL(4)
         DS   CL(1)
UR_APPLID DS   CL(8)
         DS   CL(1)
UR_TRNID DS   CL(4)
         DS   CL(1)
UR_TSKNO DS   CL(5)
         DS   CL(1)
UR_TRMID DS   CL(4)
         DS   CL(1)
UR_USERID DS   CL(8)
         DS   CL(1)
UR_ASK_DATE DS   CL(8)
         DS   CL(1)
UR_ASK_TIME DS   CL(8)
         DS   CL(1)
UR_CALEN DS  CL(5)
UR_COLON0 DS   CL(1)
UR_INVKPGM DS   CL(8)
UR_COLON1 DS   CL(1)
*  CURRENT POS 81, 255_81=172
UR_RESP_LEN EQU *-UR_RESP
UR_REST_LEN EQU L'UR_RESP-UR_RESP_LEN
UR_REST  DS   CL(UR_REST_LEN)
UR_REST_L DS  H
*
*  KRY parms
KRY_SAV_R0_R5 DS  6F SAVE AREA FOR GEN REGSN DATA IN STG
KRY_SAV_R9 DS  F
cn_msg_a   ds  f  HOLD THE ADDR OF THE CN DATA IN STG
cn_msg_l   ds  f  HOLD THE FLENGTH OF THE CN DATA
cn_msg_dt  ds  cl1 container datatype (for generating new cn name)
*
KLMDF1_parm ds 5f'-1'    parm area for sha-1 md 28 bytes or 224bits
KIMDF1_parml equ *-KLMDF1_parm
KLMDF1_mbl  ds 2f'0'     parm area for sha-1 mbr bitlength
*  20 bytes for iv value plus 8 bytes for msg bit lng area
KLMDF1_parml equ *-KLMDF1_parm
*                OUTPUT SHA VALUE
KLMDF1_x2cxl ds  cl(KIMDF1_parml*2)
*
KLMDF2_parm ds  8f'-1'    parm area for sha256md 40 bytes or 320bits
KIMDF2_parml equ *-KLMDF2_parm
KLMDF2_mbl  ds  2f'0'     parm area for sha256md mbr bit length
*  32 bytes for iv value plus 8 bytes for msg bit lng area
KLMDF2_parml equ *-KLMDF2_parm
*                OUTPUT SHA VALUE
KLMDF2_x2cxl ds  cl(KIMDF2_parml*2)
*
KLMDF3_parm ds 16f'-1'    parm area for sha512md 80 bytes or 640bits
KIMDF3_parml equ *-KLMDF3_parm
KLMDF3_mbl  ds  4f'0'     parm area for sha512md mbr bit length
*  64 bytes for iv value plus 16 bytes for msg bit lng area
KLMDF3_parml equ *-KLMDF3_parm
*                OUTPUT SHA VALUE
KLMDF3_x2cxl ds  cl(KIMDF3_parml*2)
*
*
ENDOFEIS DS    CL8
*
         DFHEIEND
*
UCEMPINR CSECT
UCEMPINR AMODE 31
UCEMPINR RMODE ANY
*UCEMPINR DFHEIENT CODEREG=(2,3)
   DFHEIENT DATAREG=13,EIBREG=10,STATREG=(11,12),STATIC=STATR,CODEREG=0

*        EXTRN CEMVALUE
         ZAP   MYABSTM,PZERO
         ZAP   MYABSTM1,PZERO
         MVC   OPLIT00(OPLIT00_TOT_EQU),SPACE255
         XC    P_OCA,P_OCA
         XC    P_OCA_CURPOS,P_OCA_CURPOS
         XC    P_OCA_LSTPOS,P_OCA_LSTPOS
         XC    SYSID_SUFXL,SYSID_SUFXL
         XC    TDQ_ENA,TDQ_ENA
         XC    TDQ_STAT,TDQ_STAT
         XC    TDQ_RECLF,TDQ_RECLF
         XC    TDQ_RECFM,TDQ_RECFM
*
*        XC    CN_NM_PLAY_ANCH,CN_NM_PLAY_ANCH
         XC    PLAYLIST_GRP_ANCH,PLAYLIST_GRP_ANCH
         XC    PLAY_ELM_CT,PLAY_ELM_CT
         XC    PLAYLIST_TMP_ELM,PLAYLIST_TMP_ELM
         MVC   PLAYLIST_TMP_ELM_CN,FMINUS1
* FORCE THE PLAYLIST_TBLBEG TO HIGH VALUES
         MVC   PLAYLIST_TBLBEG(PLAYLIST_TBL_TOT_L),PLAYLIST_TMP_ELM_CN
*
*        XC    CN_PLAY_LIST,CN_PLAY_LIST
*        MVC   CN_PLAY_FF,FMINUS1
         XC    PLAYLIST_TBLEND_FF,PLAYLIST_TBLEND_FF
         MVI   PLAY_CLONE_PFX_ELEM_CT,X'EF'  NEXT VAL IS X'F0'
         MVI   LCNC_CLONE_PFX_ELEM_CT,X'EF'  NEXT VAL IS X'F0'
         LA    R0,VAL_CNC_E1       START OF TBL
         ST    R0,CNC_VAL_CHR_CUR_TBL_ENT      SAVE IT AS CUR POS
         MVC   PLAY_CLONE_PFX,CMD_PLAY       'PLA'
         XC    PLAY_CLONE_SAV_CH_NM,PLAY_CLONE_SAV_CH_NM
         XC    PLAY_LCNC_REQUEST,PLAY_LCNC_REQUEST
*
         MVC   TIMER_ENT_CN_JDT(TIMER_AREA_L),SPACE255
         XC    H_DPL_RET_CAL,H_DPL_RET_CAL
         XC    P_MOV_2_DATA,P_MOV_2_DATA
         XC    P_MOV_2_DATA_CURPOS,P_MOV_2_DATA_CURPOS
         MVC   TDQ,=CL4'CSSL'
*
         MVC   LCL_IPCN_SYSID,SPACE255                     20171002
*
         MVC   UR_RESP,SPACE255
         MVC   UR_PGMID,PROGNAME
         MVC   PGM_CMD,PROGNAME
         MVC   PGM_CUR,SPACE255
         MVC   UR_VER,PROGVER
         MVC   LNK2PGM_NM(9),SPACE255  FORCE EXTRA SPACE IN FILLER
         MVC   UR_TRNID,EIBTRNID
         UNPK  TASKNUM,EIBTASKN
         OI    TASKNUM+7,X'F0'
         MVC   UR_TSKNO,TASKNUM+3
         MVC   UR_TRNID,EIBTRNID
         MVC   UR_TRMID,EIBTRMID
         LH    R15,EIBCALEN
         CVD   R15,DWORD
         UNPK   TASK_EIBCAL,DWORD+5(3)
         OI    TASK_EIBCAL+4,X'F0'
         MVC   UR_CALEN,TASK_EIBCAL
         MVI   UR_COLON0,C':'
         MVI   UR_COLON1,C':'
         MVC   UR_REST(4),PROGNAME+4
*
         EXEC CICS INQUIRE TDQUEUE(TDQ)                                *
               ENABLESTATUS(TDQ_ENA)                                   *
               OPENSTATUS(TDQ_STAT)                                    *
               RECORDFORMAT(TDQ_RECFM)                                 *
               RECORDLENGTH(TDQ_RECLF)                                 *
               RESP(FRESP)                                             *
               RESP2(FRESP2)
         CLC   TDQ_RECFM,DFHVALUE(VARIABLE)  INQ TDQ
         JNE   NOT_VARQ
         LH    R15,TDQ_RECLH
         AHI   R15,-4
         STH   R15,TDQ_RECLH
NOT_VARQ DS 0H
         CLC   FRESP,DFHRESP(NORMAL)
         JNE   NO_TDQ
         CLC   TDQ_ENA,DFHVALUE(ENABLED)
         JNE   NO_TDQ
         CLC   TDQ_STAT,DFHVALUE(OPEN)
         JE    OK_TDQ
NO_TDQ   DS 0H
         MVC  TDQ_ENA,DFHVALUE(DISABLED)     SET ONE INDICATOR
OK_TDQ   DS 0H
*
         JAS   R9,GET_FORMAT_TIME
         MVC   TIMER_ENT_ST_JDT,TIMER_ENT_CN_JDT
         MVC   TIMER_ENT_ST_TOD,TIMER_ENT_CN_TOD
*
         MVC   MOV_2_DATAL,F32400
         LH    R15,H32400
         LA    R15,1(R15)
         ST    R15,MOV_2_DATAL
         XC    P_MOV_2_DATA_LST,P_MOV_2_DATA_LST   ZERO FINAL LEN
* GET A SCRATCH AREA FOR THIS PROGRAM TO USE IN CREATING A REPLY
*  WITHOUT NEEDING TO KEEP CHECKING OCA LENGTH
         MVC   GM_STG_FL,MOV_2_DATAL
         JAS   R9,GM_STG
         LT    R6,GM_STG_ADR
         JZ    BAD_START
*
         ST    R6,P_MOV_2_DATA
         LR    R15,R6
         A     R15,MOV_2_DATAL
         BCTR  R15,0
         ST    R15,P_MOV_2_DATA_LST  SAVE LAST POSN IN THE SCRATCH
         MVI   0(R15),X'15' MARK THE ULTIMATE LAST POSN
*
         MVI   0(R6),C'0'
         LA    R6,1(R6)         THIS IS THE RETURN CODE SET TO ZERO
         ST    R6,P_MOV_2_DATA_CURPOS
*
         MVC   BEGOFEIS,=C'BEGOFEIS0<<'
         MVC   ENDOFEIS,=C'ENDOFEIS0<<'
         MVC   HLDSTR,SPACE255
         ST    R1,SAVR1          SAVE R1 FOR REFERENCE TO PARMLIST
         MVC   PARMAL,H16        INTERNAL PARS PARM LIST
         LA    R1,THEPARM        ADDRESS OF THE NEEDLE AND STACK
         ST    R1,PARMA            ADDRESSES
         MVC   PARSE_DIRECTN,H1   FWD DIRECTION
         XC    PARSE_EQ,PARSE_EQ  TEST EQUAL
         MVI   RC,C'0'
         XC    FRC,FRC
         XC    MXRC,MXRC
*
         EXEC CICS ASSIGN SYSID(LCL_SYSID)                             *
               APPLID(LCL_APPLID)                                      *
               INVOKINGPROG(INVKG_PROG)                                *
               PROGRAM(PGM_CUR)                                        *
               STARTCODE(ST_CD)                                        *
               USERID(LCL_UID)                                         *
               RESP(FRESP)                                             *
               RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)     ASG LCL_SYSID
         JNE   CANT_DO_IT
*   CREATE A REMOTE CHANNEL NAME
         CLI   PGM_CUR,C' '
         JNE   ARND_DFT_RMT
         MVC   PGM_CUR,PROGNAME
ARND_DFT_RMT DS 0H
         MVC   PGM_RMT,PGM_CUR
         MVC   CH_SYSID_NM,SPACE255
         MVC   TMP_CH,SPACE255
         MVC   CN_RESP_NM,SPACE255
         MVC   CN_RET_CN_LIST,SPACE255
* MVST - TEST CHAR IN SRC FOR DELIM IN R0 (SRC HAS GOT TO HAVE DELIM)
*      - IF NOT EQ DELIM, MOVE SRC BYTE TO TGT
*      -  INCREMENT SRC: TRY NEXT
*      - ELSE DELIM BYTE FND IN TGT, SO RESTORE SRC REG
*      -  RETURN TGT REG PT TO NEXT AVAIL BYTE IN TGT
         IILF  R0,X'40'
         LA    R6,PGM_CUR
         LA    R5,CH_SYSID_NM
         MVST  R5,R6
         MVI   0(R5),C'_'
         MVC   1(4,R5),LCL_SYSID
*
         LA    R5,TMP_CH
         MVST  R5,R6
         MVI   0(R5),C'_'
         MVC   1(7,R5),=C'TMP_CHN'
*
         LA    R5,CN_RESP_NM
         MVST  R5,R6
         MVI   0(R5),C'_'
         MVC   1(7,R5),=C'RESP_CN'
*
*              CN NAME RETURN_CN_LIST
         LA    R5,CN_RET_CN_LIST
         MVC   0(LIT_RET_CN_LIST_L,R5),LIT_RET_CN_LIST
*
         MVC   CN_RET_LIST_PFX,LCL_SYSID
         MVI   CN_RET_LIST_PFX+4,C'('
*
         MVC   UR_PGMID,PGM_CUR
         MVC   UR_REST(4),PGM_CUR+4
         MVC   OPLITM09(8),PGM_CUR
         MVC   OPLITM05(4),LCL_SYSID
         MVC   OPLITM06(5),UR_TSKNO
*
         EXEC CICS ASSIGN  USERNAME(LCL_UNAME)                         *
               RESP(FRESP)                                             *
               RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)     ASG USERNM
         JNE   NOT_OK_AOR
*
OK_TOR_USE EQU *
         CLC   ST_CD,LIT_TERM_TD
         JNE   BYP_ASGN_NET
*
         EXEC CICS ASSIGN NETNAME(LCL_NETNAME)                         *
               DS3270(FAC_3270)                                        *
               RESP(FRESP)                                             *
               RESP2(FRESP2)
         CLC   FRESP,DFHRESP(NORMAL)     ASG NETNM
         JNE   CANT_DO_IT
*
NOT_OK_AOR  EQU *
BYP_ASGN_NET EQU *
         MVC   RTE_TO_SYSID(8),SPACE255      20171002
         XC    SAV_SEP_ADR,SAV_SEP_ADR
*
         L     R6,P_MOV_2_DATA_CURPOS
         MVI   0(R6),C'<'
         MVC   1(4,R6),LCL_SYSID
         MVC   5(7,R6),=C'(ENTRY:'
         MVC   12(8,R6),TIMER_ENT_ST_JDT
         MVC   21(8,R6),TIMER_ENT_ST_TOD
         MVI   29(R6),C')'
         LA    R6,30(R6)
         ST    R6,P_MOV_2_DATA_CURPOS
*
         MVC   UR_APPLID,LCL_APPLID
         MVC   UR_INVKPGM,INVKG_PROG
         MVC   UR_USERID,LCL_UID
         MVC   UR_ASK_DATE,TIMER_ENT_ST_JDT
         MVC   UR_ASK_TIME,TIMER_ENT_ST_TOD
*
*  INITIALIZE CMD_TBL
         MVC   CMD_TBL,CMD_TBL_LIT
*
*  check for commarea or cNc
         LH    R15,EIBCALEN
         STH   R15,SAV_CAL_REMN
         STH   R15,SAV_CAL       OCA EIBCALEN - NEVER ALTERED IN
         MVC   CH_NM,SPACE255
*
* based on examination of cics trace, the cics code looks for
*  a cnc before looking for a commarea..... so we will too.
*
         EXEC CICS ASSIGN CHANNEL(CH_NM)                               *
             RESP(FRESP)                                               *
             RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)   ASG CHANNM
         JNE   NO_CH_FND   go to check for commarea
*
         CLC   CH_NM,SPACE255
         JE    NO_CH_FND       goto check ca if hannel name is spaces
*
* US CH_NM AS INDICATOR OF CNC
*
* SET UP A NEW CHANNEL AND RESP CONTAINER, IN ORDER TO ACCUMULATE
*     PROCESSING LOG NOTES, AND
*     RETURN CODE DATA FOR EACH CONTAINER PROCESSED
*
         MVI   PUT_RESP_CN_OK,X'0'  USE RESP CONTAINER
         MVI   OPLIT00+1,C'@'
         MVC   OPLIT00+2(8),TIMER_ENT_ST_JDT
         MVC   OPLIT00+12(8),TIMER_ENT_ST_TOD
         MVC   OPLIT(L'CN_STRTB_MSG),CN_STRTB_MSG
         MVC   OPLIT+52(16),CH_NM
         IILF  R0,L'CN_STRTB_MSG
         ALFI  R0,OPLIT00_L_EQU
         ST    R0,EXEC_CICS_FL
         EXEC CICS PUT CONTAINER(CN_RESP_NM)        CHANNEL(TMP_CH)    *
               FROM(OPLIT00)      FLENGTH(EXEC_CICS_FL)                *
               CHAR                                                    *
               RESP(FRESP)                                             *
               RESP2(FRESP2)
         CLC   FRESP,DFHRESP(NORMAL)    PUT RESP CN
*
         MVC   OPLIT,SPACE255
         JE    CN_PUT_RESP_CN_CREATED
         MVI   PUT_RESP_CN_OK,X'1'   CAN'T USE RESP CONTAINER
CN_PUT_RESP_CN_CREATED DS 0H
*
* SET CONTAINER STACK AREA MAX AND NCREMENTS:BOTH SET AS 100
*  THE INCR COULD BE LESS THAN THE MX. FOR NOW, EQUAL.
*
         L     R9,F100               MAX CN COUNT
         ST    R9,CN_GM_ELEM_CT_INCR         INCR ELEM FOR NEW STK GM
* MX   DOES NOT HAVE TO BE SAME AS INCR
         ST    R9,CN_GM_ELEM_CT_MX           MAX ELEM IN STK AREA
         AR    R9,R9                    DBL IT FOR CMD AND UKN STK
         ST    R9,CN_CT_MX              MAX FOR ALL CN
*
         XC    CN_GM_CMD_ANCH,CN_GM_CMD_ANCH     CMD STACK ANCH
         XC    CN_GM_CMD_LAST_STK,CN_GM_CMD_LAST_STK LAST STACK AREA
         XC    CN_GM_CMD_CUR_CT,CN_GM_CMD_CUR_CT  CT OF CMD CN
         XC    CN_GM_CMD_STK_PROCD,CN_GM_CMD_STK_PROCD CT OF CMD PROC
         XC    CN_GM_CMD_TOT_PROCD,CN_GM_CMD_TOT_PROCD TOT CMD PROC
         XC    CN_GM_UKN_ANCH,CN_GM_UKN_ANCH     UKN STACK ANCH
         XC    CN_GM_UKN_LAST_STK,CN_GM_UKN_LAST_STK LAST STACK AREA
         XC    CN_GM_UKN_CUR_CT,CN_GM_UKN_CUR_CT  CT OF UKN CN
         XC    CN_GM_UKN_STK_PROCD,CN_GM_UKN_STK_PROCD CT OF UKN PROC
         XC    CN_GM_UKN_TOT_PROCD,CN_GM_UKN_TOT_PROCD TOT UKN PROC
*
*                DETERMINE LENGTH OF ONE STACK AREA FOR GM
         XR    R8,R8             SET UP FOR MULT
         IILF  R9,CNC_CN_ENT_L   (EQU) LENGTH OF ELEMENT
         M     R8,CN_GM_ELEM_CT_INCR    EACH STK HOLDS INCR ELEM
         AHI   R9,CNC_CN_SAA_L          ADD SAA PREFIX
         ST    R9,CN_LIST_GM_L     GM LEN OF STACK ALLOC
*                                  CMD AND UKN SAME LENGTH
         XC    CN_BRS_TKN,CN_BRS_TKN
*
         EXEC CICS STARTBROWSE CONTAINER                               *
         CHANNEL(CH_NM)                                                *
         BROWSETOKEN(CN_BRS_TKN)                                       *
         RESP(FRESP)                                                   *
         RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)    CH STBR
         JNE   BAD_START_BRS   JUMP THERE AND QUIT
*
*  set up the stack area for containers
*      cmd stack is for known container names
*      ukn stack if for unknown containers
*      first time, set the anchor pointers in dyn stg
*      USE CN_GM_PARM_LIST TO SET UP GETMAIN REQUEST
*
*                           SET TYP TO INIT CMD X'0'
         XC    CN_GM_PARM_STK_IND,CN_GM_PARM_STK_IND
         LA    R9,CN_GM_CMD_ANCH     POINT TO CMD ANCH
         ST    R9,CN_GM_PARM_STK_CUR_PTR POINT TO ANCH INITIALLY
         MVC   CN_GM_PARM_STK_LNG,CN_LIST_GM_L
         JAS   R9,GM_CN_STACK
*        LTR   R15,R15
         MVC   CN_GM_CMD_LAST_STK,CN_GM_PARM_STK_CUR_PTR
         CIJNE R15,0,BAD_START_CMD_GM   JUMP THERE AND QUIT
*        JNZ   BAD_START_CN
*
         IILF  R9,1                 SET TYPE TO INIT UKN
         ST    R9,CN_GM_PARM_STK_IND SET TO ONE  FOR INITIAL UKN
         LA    R9,CN_GM_UKN_ANCH     POINT TO UKN ANCH
         ST    R9,CN_GM_PARM_STK_CUR_PTR
         MVC   CN_GM_PARM_STK_LNG,CN_LIST_GM_L
         JAS   R9,GM_CN_STACK
*        LTR   R15,R15
         MVC   CN_GM_UKN_LAST_STK,CN_GM_PARM_STK_CUR_PTR
         CIJNE R15,0,BAD_START_UKN_GM   JUMP THERE AND QUIT
*        JNZ   BAD_START_CN
         J     TOP_CN_BRWS
*                           RESET ON EVERY GM
TOP_CN_BRWS DS 0H
*     SET UP USING OF R6 AS THE DSECT FOR A STACK AREA
*        BOTH CMD AND UNK HAVE SAME DSECT, SO
*          MAKE SURE R6 POINTS TO DESIRED STACK TYPE
*     SET UP USING OF R7 AS THE DSECT FOR A cn element entry
*        BOTH CMD AND UNK HAVE SAME DSECT, SO
*          MAKE SURE R7 POINTS TO current element entry
         USING CNC_CN,R6
         USING CNC_CN_ELEM,R7
*
         EXEC CICS GETNEXT CONTAINER(CN_NM)                            *
          BROWSETOKEN(CN_BRS_TKN)                                      *
          RESP(FRESP)                                                  *
          RESP2(FRESP2)
*
         XR    R15,R15              GET NXT CN
         CLC   FRESP,DFHRESP(END)
         JE    GOT_ALL_CN
*
         CLC   FRESP,DFHRESP(NORMAL)
         JNE   CN_BRS_GETN_ERR
*
*  SET UP OPLIT TO APPEND TO RESP CONTAINER
         MVC   OPLIT(16),CN_NM
         MVI   OPLIT+16,C'<'
         MVI   OPLIT+24,C'>'
*
         L     R9,CN_CT
         AHI   R9,1
         ST    R9,CN_CT
         C     R9,CN_CT_MX
         JH    CN_TOO_MANY_TOT
*
         LA    R9,CMD_TBL
SRCH_4_CMD DS 0H
         CLC   CN_NM(4),0(R9)
         JE    CN_GOT_CMD
         CLC   0(4,R9),CMD_END    CMD_END LIT IS X0 AS IS END OF TBL
         JE    CN_NOT_CMD
         AHI   R9,CMD_TBL_ENT_LNG
         J     SRCH_4_CMD
*
CN_GOT_CMD  DS 0H
         MVC   CMD_TBL_X,4(R9)   SAVE THE BR ADDR OF CMD SUBRTN
         MVC   CMD_TBL_RTN_X,8(R9)   SAVE RETURN ADDR OF CMD SUBRTN
*
*
         MVC   OPLIT+17(L'CN_CMD_LIT),CN_CMD_LIT
         MVC   OPLIT+25(2),=C':<'
         MVC   OPLIT+27(4),CN_NM
         MVC   OPLIT+31(2),=C'>>'
         IILF  R0,33
         ST    R0,PUT_APND_MSG_FL
         JAS   R9,PUT_APND_RESP_CN
*
         L     R9,CN_GM_CMD_CUR_CT   KEEP COUNT OF TOTAL CMDS
         AHI   R9,1
         C     R9,CN_GM_ELEM_CT_MX   MAX NUMBER OF CN FOR ALL TYPES
         JH    CN_TOO_MANY_CMD       200? out of here
         ST    R9,CN_GM_CMD_CUR_CT   UPDATE THE GLOBAL CT
         L     R6,CN_GM_CMD_LAST_STK   GET ADR OF THE LAST STK GM
*                                      MAKES THE USING R6 VALID
         L     R9,CNC_CN_LIST_ELEM_CUR_CT  KEEP TRACK OF NUM OF ELEM
         AHI   R9,1                        ENTRIES IN THIS STACK
         C     R9,CNC_CN_LIST_ELEM_MX_CT   MAKE SURE IT FITS IN GM
         JNH   CN_CONT_CMD_CN              FITS; JUMP
*                  DOESNOT FIT, SO GET NEXT
         XC    CN_GM_PARM_STK_IND,CN_GM_PARM_STK_IND
         ST    R6,CN_GM_PARM_STK_CUR_PTR    STACK AREA. SAV R6
         MVC   CN_GM_PARM_STK_LNG,CN_LIST_GM_L
         JAS   R9,GM_CN_STACK               JMP TO GM
*              UPDATE THE PTR TO THE LAST STK
         MVC   CN_GM_CMD_LAST_STK,CN_GM_PARM_STK_CUR_PTR
         CIJNE R15,0,CN_GM_NXT_STK_FAIL JUMP THERE AND QUIT
*
         LHI   R9,1                  SET UP CT  OF ELEM TO FIRST(ONE)
*
*    CHECK IS CN_NM IS PLAY; SAVE ELEM ADDR FOR PLAY PROCESSING
*    NOTE-ONLY 1 (I.E. LAST) PLAY CN IS VALID; OTHERS IGNORED
CN_CONT_CMD_CN DS 0H
         J     CN_GET_NODATA
*
CN_NOT_CMD  DS 0H
         MVC   CMD_TBL_X,F0      INDICATE NO CMD FND
*
         MVC   OPLIT+17(L'CN_CMD_LIT),CN_UKN_LIT
         MVC   OPLIT+25(2),=C':<'
         MVC   OPLIT+27(4),CN_NM
         MVC   OPLIT+31(2),=C'>>'
         IILF  R0,33
         ST    R0,PUT_APND_MSG_FL
         JAS   R9,PUT_APND_RESP_CN
*
         L     R9,CN_GM_UKN_CUR_CT     KEEP CT OF UKN CN TOTAL
         AHI   R9,1
         C     R9,CN_GM_ELEM_CT_MX     IF TOTAL ALL IS TOO HIGH
         JH    CN_TOO_MANY_UKN         WE AS DONE
         ST    R9,CN_GM_UKN_CUR_CT
         L     R6,CN_GM_UKN_LAST_STK     SET UP USING R6
         L     R9,CNC_CN_LIST_ELEM_CUR_CT
         AHI   R9,1
         C     R9,CNC_CN_LIST_ELEM_MX_CT   SEE IF WE NEED NEW STK
         JNH   CN_CONT_UNK_CN           NO
         IILF  R9,1
         ST    R9,CN_GM_PARM_STK_IND
         ST    R6,CN_GM_PARM_STK_CUR_PTR
         MVC   CN_GM_PARM_STK_LNG,CN_LIST_GM_L
         JAS   R9,GM_CN_STACK           GET NEW UKN STK
*        LTR   R15,R15
*        JNZ   CN_GM_NXT_STK_FAIL
         MVC   CN_GM_UKN_LAST_STK,CN_GM_PARM_STK_CUR_PTR
         CIJNE R15,0,CN_GM_NXT_STK_FAIL JUMP THERE AND QUIT
*
         LHI   R9,1            SET UP CT  OF ELEM TO FIRST(ONE)
CN_CONT_UNK_CN DS 0H
         J     CN_GET_NODATA
*
* AT THIS POINT, R6 POINTS AT THE CUR CMD OR UKN STK
*    AND USING R6 ALREADY SET UP
CN_GET_NODATA  DS  0H
         ST    R9,CNC_CN_LIST_ELEM_CUR_CT   UPDATE THE STK CTR
*
         L     R7,CNC_CN_LIST_ELEM_CUR   ADDR OF LAST STK ELEM
         A     R7,CNC_CN_LIST_ELEM_LNG
         ST    R7,CNC_CN_LIST_ELEM_CUR   ADDR OF NEW AVAILABLE
*           R7 UPDATED TO POINT AT NEWEST ELEMENT
*              FOR USING R7
         ST    R7,CN_CUR_CN_ELEM         STORE INTO TEMP
* @PLAY
*    THIS TEST IS ONLY VALID FOR PLAY CMDS; UKN WILL ALWAY JMP
         CLC   CMD_PLAY,CN_NM        IF THIS IS 'PLAY' CMD, THEN
         JNE   CN_GET_CONT           WE WILL SAVE THIS ENTRY ADDR
         LT    R15,PLAYLIST_GRP_ANCH
         JNZ   CN_GOT_PLAY_ANCH
         LA    R15,PLAYLIST_TBLBEG    GET START OF TBLENT
         J     CN_NXT_PLAY_ANCH
CN_GOT_PLAY_ANCH DS 0H                BUMP TO NEXT
         AHI   R15,PLAYLIST_TBLGRP_L      ENT 2 - 10
CN_NXT_PLAY_ANCH DS 0H
         CLC   F0,0(R15)             MORE THAN 10, WE ARE IN
         JE    CN_GET_PLAY_ERR         PLAYLIST_TBLEND_FF, SO ERR
         ST    R15,PLAYLIST_GRP_ANCH
         MVC   0(PLAYLIST_TBLENT_L,R15),CN_NM
         MVC   PLAYLIST_TBLENT_L(4,R15),CNC_CN_LIST_ELEM_CUR
         L     R1,PLAY_ELM_CT
         LA    R1,1(R1)
         ST    R1,PLAY_ELM_CT
         J     CN_GET_CONT
*                                    ONLY THE LAST PLAY ENTRY IS USED
CN_GET_PLAY_ERR DS 0H
         MVC   OPLIT(L'PLAY_TOO_MANY),PLAY_TOO_MANY
         MVC   OPLIT+13(16),CN_NM
*
         IILF  R0,L'PLAY_TOO_MANY
         ST    R0,PUT_APND_MSG_FL
         JAS   R9,PUT_APND_RESP_CN
*                                    ONLY THE LAST PLAY ENTRY IS USED
CN_GET_CONT DS 0H
         MVC   CNC_CN_N,CN_NM         SAVE CN NAME
         MVC   CNC_CN_X,CMD_TBL_X     THE CMD SUBRTN ADR OR ZERO
         MVC   CNC_CN_RX,CMD_TBL_RTN_X THE CMD SUBRTN ADR OR ZERO
*
         EXEC CICS GET CONTAINER(CNC_CN_N) CHANNEL(CH_NM)              *
              NOCONVERT                                                *
              CCSID(CNC_CN_CP)                                         *
              NODATA FLENGTH(CNC_CN_L)                                 *
              RESP(FRESP)                                              *
              RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)    GET CN
         JE    CN_GET_CN_NODATA_OK
*   GET CN NODATA FAILED - NOT TERRIBLE, BUT PUT A MSG
         MVC   OPLIT(L'BAD_GET_NODA_MSG),BAD_GET_NODA_MSG
         MVC   OPLIT+78(L'CNC_CN_N),CNC_CN_N
         L     R15,FRESP
         JAS   R9,B2C
         MVC   OPLIT+45(5),HLDSTR+3
         L     R15,FRESP2
         JAS   R9,B2C
         MVC   OPLIT+59(5),HLDSTR+3
*
         IILF  R0,L'BAD_GET_NODA_MSG
         ST    R0,PUT_APND_MSG_FL
         JAS   R9,PUT_APND_RESP_CN
         MVC   CNC_CN_L,F0   PLACE ZERO IN LNG TO INDICATE NO CONT
         MVC   CNC_CN_X,F0   PLACE ZERO IN LNG TO INDICATE NO CONT
*
CN_GET_CN_NODATA_OK DS 0H
         J     TOP_CN_BRWS
*
*  CN FAILURE ROUTINES
*
*
* GM FOR CN STK FAILED; WE ARE DONE    RC16
CN_GM_NXT_STK_FAIL DS 0H
         MVC   OPLIT(L'BAD_GM_STK_MSG),BAD_GM_STK_MSG
         CLC   CN_GM_PARM_STK_IND,F0
         JNE   CN_GM_NXT_STK_UKN
         MVC   OPLIT+32(L'CN_CMD_LIT),CN_CMD_LIT
         J     CN_GM_NXT_STK_FAIL_CONT
CN_GM_NXT_STK_UKN    DS 0H
         MVC   OPLIT+32(L'CN_UKN_LIT),CN_UKN_LIT
CN_GM_NXT_STK_FAIL_CONT DS 0H
         L     R15,CN_GM_CMD_CUR_CT
         JAS   R9,B2C
         MVC   OPLIT+70(5),HLDSTR+3
         IILF  R0,L'BAD_GM_STK_MSG
         ST    R0,PUT_APND_MSG_FL
         JAS   R9,PUT_APND_RESP_CN
*        DROP R6
         IILF  R15,16               RET CODE 16
         J     GOT_ALL_CN
*
*   BROWSE CN GETNEXT FAILED - WE ARE DONE
CN_BRS_GETN_ERR DS 0H   BAD_GETN_BRS_MSG
         MVC   OPLIT(L'BAD_GETN_BRS_MSG),BAD_GETN_BRS_MSG
         L     R15,FRESP
         JAS   R9,B2C
         MVC   OPLIT+45(5),HLDSTR+3
         L     R15,FRESP2
         JAS   R9,B2C
         MVC   OPLIT+58(5),HLDSTR+3
*
         IILF  R0,L'BAD_GETN_BRS_MSG
         ST    R0,PUT_APND_MSG_FL
         JAS   R9,PUT_APND_RESP_CN
*
         IILF  R15,20              RET CODE 20
         J     GOT_ALL_CN          JUMP THERE AND QUIT
*
*  CHECK TO SEE IF ENDBRS REQ - IF SO DO IT
*  CHECK RC FROM CONTAINER DISCOVERY PROCESS - IF GT ZERO QUIT
GOT_ALL_CN DS  0H
         ST    R15,FRC
         C     R15,MXRC
         JL    GOT_ALL_CN_CONT
         ST    R15,MXRC
*
GOT_ALL_CN_CONT DS 0H
         CLC   CN_BRS_TKN,F0
         JE    ARND_ENDBR
         EXEC CICS ENDBROWSE CONTAINER                                 *
            BROWSETOKEN(CN_BRS_TKN)                                    *
            RESP(FRESP)                                                *
            RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)    ENDBR CH
         JE    ARND_ENDBR
*
         MVC   OPLIT(L'BAD_END_BRS_MSG),BAD_END_BRS_MSG
         L     R15,FRESP
         JAS   R9,B2C
         MVC   OPLIT+45(5),HLDSTR+3
         L     R15,FRESP2
         JAS   R9,B2C
         MVC   OPLIT+58(5),HLDSTR+3
*
         IILF  R0,L'BAD_END_BRS_MSG
         ST    R0,PUT_APND_MSG_FL
         JAS   R9,PUT_APND_RESP_CN
*
ARND_ENDBR DS 0H
* R15 WAS SET PRIOR TO JUMPNG TO GOT_ALL_CN
*  SO NOW IF IT IS GT 0, THEN WE ABORT PROCESSING
         LT    R15,MXRC
         JH    CN_ERROR_ABORT     WE ARE DONE DUE TO RC>0
*
*  %HERE WE GO CNC - START WITH ANCH FOR CMDS
*  %HERE WE GO CNC - FIRST CHECK FOR PLAY LIST ANCH NON ZERO
*  %HERE WE GO CNC -  IF SO THEN ONLY PROCESS PLAY LIST CN ENTRIES
         XC    CN_CA_SURROGATE,CN_CA_SURROGATE       CA ADDR
         XC    CN_CA_SURROGATE_L,CN_CA_SURROGATE_L   CA LNG
*
* PLAY LIST PROCESSING JUMPS TO THAT SECTION OF CODE
         LT    R7,PLAYLIST_GRP_ANCH
         JZ    GOT_ALL_NO_PLAY   LEAVE PLAY ANCH AS 0;IND NO PLAY
* SORT THE PLAY LIST ENTRIES AS RECORDED IN PLAYLIST_TBLBEG
         JAS   R9,SORT_PLAYLIST_TBL
*
         LA    R7,PLAYLIST_TBLBEG  LOAD THE FIRST PLAY LIST ENTRY
         ST    R7,PLAYLIST_GRP_ANCH
*                       PLAYLIST_TBLENT_L IS OFFSET TO CNC_CN_ELEM
         L     R7,PLAYLIST_TBLENT_L(R7)  PLAY LIST CNC_CN_ELEM ADR
         L     R6,CN_GM_CMD_ANCH    PTR TO FIRST CN STK
         MVC   PLAYLIST_TBLEND_FF,FMINUS1    INSURE WE CAN FIND END
         J     DO_PLAY
*
GOT_ALL_NO_PLAY DS 0H
         LT    R6,CN_GM_CMD_ANCH    PTR TO FIRST CN STK
         JZ    CN_NO_CMDS
* FOR CMDS THAT USE A CA, WE WILL SET ONE UP,
*  AND REUSE IT FOR ALL CMDS
*
*        USING CNC_CN,R6           R6 IS THE STK ANCH - USING SET
         L     R7,CNC_CN_LIST_ELEM_TOP    CUR STK, FIRST ELEM ADR
         ST    R7,CN_CUR_CN_ELEM          SAVE THE CUR ELEM ENTRY
*        USING CNC_CN_ELEM,R7      R7 IS THE ELEM ADR - USING SET
*
GO_ALL_CMDS     DS 0H
TOP_OF_CN_LIST DS 0H
PLAY_CMD_INTERCEPT DS 0H
         L     R9,CNC_CN_L             LNG OF THE CN
         CIJE  R9,0,CN_CMD_NO_CONT     NO DATA CONT LENGTH IS ZERO
*    FOR NOW: CMD CN MUST BE A CHAR CONTAINER.
         L     R9,CNC_CN_CP            CAN BE BIT OR CHAR
         CIJE  R9,0,CN_CMD_NOT_CHAR    SO, TEST CMD CODEPAGE GT 0
         L     R5,CNC_CN_X             PTR TO CMD ENTRY, OR ZERO
         CIJE  R5,0,CN_CMD_NOT_IMPL    CMD TBL SUBRTN NOT IMPLEMENTD
*
*   crnd and lcnc cmds do not need to read the actual cmd cn
*   into stg used as a CA by legacy cmds
*   so we jump around
         CLC   CMD_CRND,CNC_CN_N       TEST CN NAME FOR CRND
         JE    BYP_CN_GET
         CLC   CMD_LCNC,CNC_CN_N       TEST CN NAME FOR LCNC
         JE    BYP_CN_GET
*        CLC   CMD_PLAY,CNC_CN_N       TEST CN NAME FOR PLAY
*        JE    DO_PLAYGET
*    GM STG TO HOLD CN - FLENGTH FND DURING CM BROWSE LOOP
         LT    R8,CNC_CN_A    SAV THIS STG ADR USED BY GET CN
         JNZ   CLONE_BYP_GET_CN_DATA
*
         MVC   GM_STG_FL,CNC_CN_L
         JAS   R9,GM_STG
         LT    R8,GM_STG_ADR
         JZ    CN_STG_EXEC_FAIL
*
         ST    R8,CNC_CN_A    SAV THIS STG ADR USED BY GET CN
*  THERE IS NO CHAR OR BIT ON GET CONTAINER -
*        CLC   CNC_CN_CP,F0   CHAR OR BIT CN FROM BRWS LOOP
*        JNE   CN_GET_CHAR
         EXEC CICS GET CONTAINER(CNC_CN_N) CHANNEL(CH_NM)              *
              INTO(0(,R8))    FLENGTH(CNC_CN_L)                        *
              INTOCODEPAGE('IBM037')                                   *
              RESP(FRESP)                                              *
              RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)  GET CN
         JNE   CN_GET_CMD_CN_FAIL
* CLONE LOGIC
*
CLONE_BYP_GET_CN_DATA DS 0H
* CLONE LOGIC END
         ST    R8,CN_GET_CN_ADR     THIS CONT STG ADR OF CUR CMD
*        J     CN_GOT_CONT
*
* EXECUTE THE COMMAND
*
BYP_CN_GET  DS 0H
CN_GOT_CONT DS 0H
         MVC   CN_NM,CNC_CN_N   SAVE CUR CN ELEM NAME IN WK AREA
*    reset link to pgm name back to initial due to
*        MULTIPLE CEMT, CEDA, LINK PGM_CMD VALUE CHANGED
*        NEED TO INSURE THAT SYSID DPL PROCESSING LINKS TO INITIAL
*        IN LOCAL DPL AND UPON ATTACH IN REMOTES
*        I.E. AFTER LOCAL CEMT, REMOTE CEMT WILL LINK TO DSFHEMTA
*             CAUSING AREA. WE NEED TO RESET TO INITIAL PROGNAME
         MVC   PGM_CMD,PROGNAME  reset link to pgm name back to initl
         STM   R5,R8,SAV_CN_REGS5_8
         L     R9,CNC_CN_RX  SAVE THE ADDR OF RET LBL FOR CMD
         BR    R5        JMP TO CMD SUB RTN IN R5
*        BASR  R9,R5     JMP TO CMD SUB RTN IN R5, SAVE RTN INST IN R9
*
* EXECUTE THE COMMAND
*
* RETURN HERE FOR CN
*     R15 SHOULD HAVE RC FROM CMD EXECUTION
CN_RET_FROM_OLD_CMD DS 0H
         LM    R5,R8,SAV_CN_REGS5_8
*     ON RETURN FROM CA BASED COMMANDS:
*        R5 WK REG WITH ADDR OF LAST EXEC CMD
*        R6 HAS CN STACK ADDR
*        R7 HAS CUR ELEM IN STACK ADDR
*        R8 POINTS TO THE STG GM FOR GET CN
*
         CIJE  R15,0,CN_CMD_OK        R15 HAS RC  0
*
         C     R15,MXRC
         JL    CN_RET_GOT_RC
         ST    R15,MXRC
CN_RET_GOT_RC DS 0H
         MVC   OPLIT(L'CN_CMD_XEQ_FAIL_MSG),CN_CMD_XEQ_FAIL_MSG
         MVC   OPLIT+4(16),CNC_CN_N
*
*        LTR   R15,R15   SET BY CMD RC - SO CVT IT TO CHAR
         JAS   R9,B2C
         MVC   OPLIT+61(2),HLDSTR+5
         IILF  R0,L'CN_CMD_XEQ_FAIL_MSG
         ST    R0,PUT_APND_MSG_FL
         JAS   R9,PUT_APND_RESP_CN
         XR    R15,R15        RESET
         J     CN_PUT_CN_DONE
*
*
CN_CMD_OK DS 0H
*
* WE HAVE THE CMD RESULT IN CN_CA_SURROGATE
* WE WANT TO TRIM THE EXTRA X'00' FROM THE CN_CA_SURROGATE
*  SO WE ARE USING PARS TO DO THIS
*  SEARCHING BACKWARDS FROM END OF CN_CA_SURROGATE
         LA    R9,PARS_CA_PARM_LIST
         USING MYCOM_A,R9
         LA    R15,H0                IMITIMG IS X'00'
         ST    R15,CA_ADR_NEEDLE
         LA    R15,H1
         ST    R15,CA_ADR_NEEDLEL
         L     R15,CN_CA_SURROGATE   GET ADDR OF HAYSTACK
         ST    R15,CA_ADR_HAYSTACK
* THIS IS A CNC RESPONSE, WE ARE GOING TO REDUCE THE HAYSTACKL
*  by 2 - because we act appended x'1500' at end of 32k surrogate CS
*  and a lot of unnecessary x'00' falls between the end of a resp
*  and the end of this ca
*        CLC   CH_NM,SPACE255
*        JE    LINK_PARSE_ARND_CNC
         LH    R15,CN_CA_SURROGATE_L
         AHI   R15,-2               MAKE PARSE START AT POINT SHY OF
         STH   R15,CN_CA_SUR_L_MINUS2
*                                    the x'1500'
LINK_PARSE_ARND_CNC DS 0H
         LA    R15,CN_CA_SUR_L_MINUS2
         ST    R15,CA_ADR_HAYSTACKL
         LA    R15,LIT_DECENDING
         ST    R15,CA_ADR_DIRECTION
         LA    R15,LIT_UNEQUAL      X'1' INDICATES UNEQ
         ST    R15,CA_ADR_EQ_NE
         LA    R15,PARS_TST_ADR_RETURN
         ST    R15,CA_ADR_RETURN
         XC    PARS_TST_ADR_RETURN,PARS_TST_ADR_RETURN
         IILF  R0,CA_EQU_LENGTH
         STH   R0,EXEC_CICS_HL
*
         EXEC CICS LINK PROGRAM(LIT_UCEMPARS)                          *
             COMMAREA(MYCOM_A) LENGTH(EXEC_CICS_HL)                    *
             RESP(FRESP)                                               *
             RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)    LINK PARS
         JNE   CN_CA_USE_ALL          IF WE HAVE AN ERROR, JUST USE ALL
         LT    R9,PARS_TST_ADR_RETURN   TRIM POS
         JZ    CN_CA_USE_ALL
*
         L     R15,P_OCA_LSTPOS         !20170720
         SR    R15,R9                   !20170720
         JNP   CN_CA_USE_ALL            !20170720
*
         LA    R9,1(R9)                 !20170720
         MVI   0(R9),X'15'              !20170720
*
         S     R9,CN_CA_SURROGATE   ADR IN HAYS MINUS START ADR=POS
         AHI   R9,1       (ADD 1 BACK E.G 1-1=0 ADD 1 BACK=LENGTH OF 1)
         J     CN_PUT_CA_SURRROGATE
CN_CA_USE_ALL DS 0H
         LH    R9,CN_CA_SURROGATE_L
CN_PUT_CA_SURRROGATE DS 0H
         DROP  R9        DROP USING TO PARS PARM LIST
         ST    R9,EXEC_CICS_FL   THIS IS THE LNG OF TRIMMED CA
         L     R9,CN_CA_SURROGATE   ADR OF CA IN CN_CA_SURROGATE
*                                    NOT THE ACTUAL CA DATA
*  IF THE CN DATATYPE NEEDS TO BE CHANGED BIT TO CHAR OR
*            CHAR TO BIT, THEN THE CN MUST BE DELETED, AND THEN
*            PUT AS A NEW CN WITH RESPECTIVE DATATYPE.
*
*  SO, WE ARE NOT SPECIFYING THE DATATYPE ON THE PUT (REWRITE)
*  CLONE LOGIC NOTE: THE CH_NM CHANNEL NAME IS A TMP CHANNEL
*   THAT WE CREATED IN THE PLAY LOGIC, TO USE CLONED CMDS
*   SO WE ARE NOT DESTROYING THE ORIG CN IN THE ORIG CH
*  CLONE LOGIC END
         EXEC CICS PUT CONTAINER(CNC_CN_N) CHANNEL(CH_NM)              *
               FROM(0(,R9))          FLENGTH(EXEC_CICS_FL)             *
               RESP(FRESP)                                             *
               RESP2(FRESP2)
         CLC   FRESP,DFHRESP(NORMAL)   PUT REPLACE SMD CN
         JE    CN_CMD_PROC_GOOD
*
         MVC   OPLIT(L'CN_CMD_PUT_FAIL_MSG),CN_CMD_PUT_FAIL_MSG
         MVC   OPLIT+19(16),CNC_CN_N
         L     R15,FRESP
         JAS   R9,B2C
         MVC   OPLIT+53(3),HLDSTR+4
         L     R15,FRESP2
         JAS   R9,B2C
         MVC   OPLIT+64(3),HLDSTR+4
*
         IILF  R0,L'CN_CMD_PUT_FAIL_MSG
         ST    R0,PUT_APND_MSG_FL
         JAS   R9,PUT_APND_RESP_CN
*
         J     CN_PUT_CN_DONE
*
CN_CMD_PROC_GOOD DS 0H
         MVC   OPLIT(L'CN_CMD_PUT_GOOD_MSG),CN_CMD_PUT_GOOD_MSG
         MVC   OPLIT+19(16),CNC_CN_N
         L     R15,EXEC_CICS_FL
         JAS   R9,B2C
         MVC   OPLIT+67(5),HLDSTR+2
*
         IILF  R0,L'CN_CMD_PUT_GOOD_MSG
         ST    R0,PUT_APND_MSG_FL
         JAS   R9,PUT_APND_RESP_CN
*
         J     CN_PUT_CN_DONE
*
CN_PUT_CN_DONE DS 0H
* CLONE LOGIC NOTE
*   R8 IS STG WHICH WE GM IN THE PLAY LOGIC FOR THIS CN
*   WE CAN FREE IT HERE
* CLONE LOGIC NOTE
         LT    R8,CNC_CN_A     FREE CN STG
         JZ    CN_CMD_PROCESSED
*
         EXEC CICS FREEMAIN DATAPOINTER(R8)                            *
               RESP(FRESP)                                             *
               RESP2(FRESP2)
*         DON'T CARE ABOUT FM RESP  - FOR NOW
         CLC   FRESP,DFHRESP(NORMAL)     FM CN STG
         JE    CN_CMD_PROCESSED
*
CN_FM_STG_RESP_FAIL DS 0H
*           BUT WE DON'T CARE IF FM FAILS???
         J     CN_CMD_PROCESSED
*
CN_CMD_NOT_CHAR DS 0H   CMD IS NOT IMPLEMENTED - JUST BYP FOR NOW
         MVC   OPLIT(L'CN_CMD_NOT_CHAR_MSG),CN_CMD_NOT_CHAR_MSG
         MVC   OPLIT+4(16),CNC_CN_N
*
         IILF  R0,L'CN_CMD_NOT_CHAR_MSG
         ST    R0,PUT_APND_MSG_FL
         JAS   R9,PUT_APND_RESP_CN
*
         J     CN_CMD_PROCESSED
*
*
CN_CMD_NOT_IMPL DS 0H   CMD IS NOT IMPLEMENTED - JUST BYP FOR NOW
         MVC   OPLIT(L'CN_CMD_NOT_IMPL_MSG),CN_CMD_NOT_IMPL_MSG
         MVC   OPLIT+4(16),CNC_CN_N
*
         IILF  R0,L'CN_CMD_NOT_IMPL_MSG
         ST    R0,PUT_APND_MSG_FL
         JAS   R9,PUT_APND_RESP_CN
*
         J     CN_CMD_PROCESSED
*
*
CN_CMD_NO_CONT  DS 0H   GET CONT NODATA FAILED - SO BYPASS
         MVC   OPLIT(L'CN_CMD_NO_CONT_MSG),CN_CMD_NO_CONT_MSG
         MVC   OPLIT+4(16),CNC_CN_N
*
         IILF  R0,L'CN_CMD_NO_CONT_MSG
         ST    R0,PUT_APND_MSG_FL
         JAS   R9,PUT_APND_RESP_CN
*
         J     CN_CMD_PROCESSED
*
*
CN_GET_CMD_CN_FAIL DS 0H
         MVC   OPLIT(L'CN_GET_CMD_CN_FAIL_M),CN_GET_CMD_CN_FAIL_M
         MVC   OPLIT+24(16),CNC_CN_N
         L     R15,FRESP
         JAS   R9,B2C
         MVC   OPLIT+54(3),HLDSTR+4
         L     R15,FRESP2
         JAS   R9,B2C
         MVC   OPLIT+65(3),HLDSTR+4
*
         IILF  R0,L'CN_GET_CMD_CN_FAIL_M
         ST    R0,PUT_APND_MSG_FL
         JAS   R9,PUT_APND_RESP_CN
*
         J     CN_CMD_PROCESSED
*
*
CN_CMD_PROCESSED  DS 0H
         L     R9,CN_GM_CMD_TOT_PROCD
         AHI   R9,1
         ST    R9,CN_GM_CMD_TOT_PROCD
*
         CLC   PLAYLIST_GRP_ANCH,F0
         JNE   PLAY_INTERCEPT_RTN
*
         C     R9,CN_GM_CMD_CUR_CT       ALL CMDS PROCESSED?
         JNL   CN_FIN_CMD_ELEM           YES , WE ARE DONE
*
         L     R9,CN_GM_CMD_STK_PROCD    HOW MANY ELEM FROM THIS STAK
         AHI   R9,1                      WERE PROCESSED. AT MAX?
         C     R9,CNC_CN_LIST_ELEM_CUR_CT
         JNL   CN_PROCESS_NXT_STK        YES SO GO TO GET NXT STK
         ST    R9,CN_GM_CMD_STK_PROCD
         AHI   R7,CNC_CN_ENT_L   STILL IN ELEM LIST ON CUR STK
         J     TOP_OF_CN_LIST       SO ADD LNG OF ELEM TO GET NEXT ELEM
*
CN_PROCESS_NXT_STK DS  0H    GET THE NEXT STACK AREA
*    STILL HAVE:USING CNC_CN,R6
*               USING CNC_CN_ELEM,R7
*                  ZERO STK ELEM COUNTER
         XC    CN_GM_CMD_STK_PROCD,CN_GM_CMD_STK_PROCD
         L     R6,CNC_CN_LIST_NXT       PT TO NXT STK
         CIJE  R6,0,CN_FIN_CMD_ELEM     MAKE SURE IT EXISTS
*                 IF NXT IS ZEROS, THEN NO MORE STK
*                 IF IT DOES, THEN AT LEAST ONE CMD IN NXT STK
*                  SO SET UP FOR FIRST ELEM
         L     R7,CNC_CN_LIST_ELEM_TOP    CUR STK, FIRST ELEM ADR
         C     R9,CNC_CN_LIST_ELEM_CUR_CT
         CIJE  R6,0,CN_FIN_CMD_ELEM     IF NOT > 0 THEN JUMP DONE
         J     TOP_OF_CN_LIST         AT LEAST ONE
*
CN_FIN_CMD_ELEM DS  0H    NO MORE CMD ELEMENTS TO PROCESS
         MVC   OPLIT(L'CN_FIN_ALL_CMDS),CN_FIN_ALL_CMDS
         L     R15,MXRC
         JAS   R9,B2C
         MVC   OPLIT+38(2),HLDSTR+5
         L     R15,CN_GM_CMD_CUR_CT
         JAS   R9,B2C
         MVC   OPLIT+59(3),HLDSTR+4
         L     R15,CN_GM_UKN_CUR_CT
         JAS   R9,B2C
         MVC   OPLIT+68(3),HLDSTR+4
         L     R15,CN_CT
         JAS   R9,B2C
         MVC   OPLIT+80(3),HLDSTR+4
*
         IILF  R0,L'CN_FIN_ALL_CMDS
         ST    R0,PUT_APND_MSG_FL
         JAS   R9,PUT_APND_RESP_CN
         J     CN_FIN_IT
*
*  FINISHED PROCESSING ALL ON CMD STK, SO WE ARE FINISHED
*
*  CNC SUBROUTINES AND ERROR HANDLERS
*
* APPEND DATA TO RESPONSE CONTAINER
PUT_APND_RESP_CN DS 0H
         CLI   PUT_RESP_CN_OK,X'0'
         JNE   PUT_APND_CN_RET
         ST    R9,SAV_CN_PUT_RET9
         STM   R4,R7,SAV_CN_REGS4_7
*   TEST TO SEE IF MSG IS IN OPLIT.. IF SO USE IT ELSE MOVE TO OPLIT
         L     R7,PUT_APND_MSG_FL
         LT    R6,PUT_APND_MSG_ADR  THE ADR OF THE MSG IN PARM
         JNZ   PUT_RESP_CN_NOMVC
*
         JAS   R9,GET_FORMAT_TIME
         MVI   OPLIT00,X'15'
         MVI   OPLIT00+1,C'@'
         MVC   OPLIT00+2(8),TIMER_ENT_CN_JDT
         MVC   OPLIT00+11(8),TIMER_ENT_CN_TOD
         LA    R6,OPLIT00
         ALFI  R7,OPLIT00_L_EQU
*
PUT_RESP_CN_NOMVC DS 0H
         ST    R7,PUT_APND_RESP_CN_FL   MOVE FLENGTH FOR PUT
*
         EXEC CICS PUT CONTAINER(CN_RESP_NM)        CHANNEL(TMP_CH)    *
               FROM(0(0,R6))      FLENGTH(PUT_APND_RESP_CN_FL)         *
               CHAR APPEND                                             *
               RESP(FRESP)                                             *
               RESP2(FRESP2)
*
         MVC   OPLIT,SPACE255          PUT APND RESP CN
         CLC   FRESP,DFHRESP(NORMAL)
         JE    PUT_RESP_CN_APNDED
         MVI   PUT_RESP_CN_OK,X'1'    TURN OFF RESP CONTAINER
*
PUT_RESP_CN_APNDED  DS 0H
         XC    PUT_APND_MSG_ADR,PUT_APND_MSG_ADR
         LM    R4,R7,SAV_CN_REGS4_7
         L     R9,SAV_CN_PUT_RET9
PUT_APND_CN_RET DS 0H
         BR    R9
*
*
CN_NO_CMDS DS 0H
         MVC   OPLIT(L'CN_NO_CMDS_MSG),CN_NO_CMDS_MSG
         L     R15,CN_CT
         JAS   R9,B2C
         MVC   OPLIT+67(3),HLDSTR+4
*
         IILF  R0,L'CN_NO_CMDS_MSG
         ST    R0,PUT_APND_MSG_FL
         JAS   R9,PUT_APND_RESP_CN
         MVC   MXRC,F8
         J     CN_FIN_IT
*
*
CN_ERROR_ABORT DS 0H
         MVC   OPLIT(L'CN_ERR_ABT_MSG),CN_ERR_ABT_MSG
         L     R15,MXRC
         JAS   R9,B2C
         MVC   OPLIT+29(2),HLDSTR+5
*
         IILF  R0,L'CN_ERR_ABT_MSG
         ST    R0,PUT_APND_MSG_FL
         JAS   R9,PUT_APND_RESP_CN
         J     CN_FIN_IT
*
*
* GETMAIN FAILURE FOR STACK STORAGE
CN_STG_STACK_FAIL DS 0H
         MVC   HLDSTR,CN_STK_LIT
         J     CN_STG_GM_FAIL
*
* GETMAIN FAILURE FOR EXEC COMMAND (COMMAREA???) STORAGE
CN_STG_EXEC_FAIL DS 0H
         MVC   HLDSTR,CN_EXE_LIT
         J     CN_STG_GM_FAIL
*
CN_STG_GM_FAIL DS 0H
         MVC   OPLIT(L'CN_STG_GM_FAIL_MSG),CN_STG_GM_FAIL_MSG
         MVC   OPLIT+16(7),HLDSTR
         L     R15,FRESP
         JAS   R9,B2C
         MVC   OPLIT+45(3),HLDSTR+4
         L     R15,FRESP2
         JAS   R9,B2C
         MVC   OPLIT+58(3),HLDSTR+4
*
         IILF  R0,L'CN_STG_GM_FAIL_MSG
         ST    R0,PUT_APND_MSG_FL
         JAS   R9,PUT_APND_RESP_CN
         J     CN_FIN_IT
*
* CRND COMMAND CNTAINER MUST BE CHAR
*
BAD_START_BRS DS 0H
         MVC   OPLIT(L'BAD_START_BRS_MSG),BAD_START_BRS_MSG
         L     R15,FRESP
         JAS   R9,B2C
         MVC   OPLIT+45(5),HLDSTR+3
         L     R15,FRESP2
         JAS   R9,B2C
         MVC   OPLIT+58(5),HLDSTR+3
*
         IILF  R0,L'BAD_START_BRS_MSG
         ST    R0,PUT_APND_MSG_FL
         JAS   R9,PUT_APND_RESP_CN
         J     CN_FIN_IT
*
* TOO MANY COMMAND ELEMENTS - SO WE JUST END
CN_TOO_MANY_TOT DS  0H
         MVC   HLDSTR,CN_TOT_LIT
         J     CN_TOO_MANY_CN
*
CN_TOO_MANY_CMD DS  0H
         MVC   HLDSTR,CN_CMD_LIT
         J     CN_TOO_MANY_CN
*
CN_TOO_MANY_UKN DS  0H
         MVC   HLDSTR,CN_UKN_LIT
*
CN_TOO_MANY_CN  DS  0H
         MVC   OPLIT(L'TOO_MANY_UKN_MSG),TOO_MANY_UKN_MSG
         MVC   OPLIT+17(7),HLDSTR
*
         L     R15,CN_CT
         JAS   R9,B2C
         MVC   OPLIT+12(4),HLDSTR+3
         L     R15,CN_GM_ELEM_CT_MX
         JAS   R9,B2C
         MVC   OPLIT+57(5),HLDSTR+2
         IILF  R0,L'TOO_MANY_UKN_MSG
         ST    R0,PUT_APND_MSG_FL
         JAS   R9,PUT_APND_RESP_CN
*
         IILF  R15,24              RET CODE 20
         J     GOT_ALL_CN          WE COULD PROCESS WHAT WE HAVE
*                                  BY MAKING THIS RC=0

*        WE ARE DONE WITH ALL CMDS; WRITE TDQ AND RETURN
CN_FIN_IT DS  0H
         CLI   PUT_RESP_CN_OK,X'0'
         JNE   CN_FIN_IT_DO_TDQ
*
* !20170802 V3.3
* CREATE THE RET_CN_LIST CONTAINER
         MVC   CN_RET_LIST_PFX+5(16),CN_RESP_NM
         MVI   CN_RET_LIST_PFX+5+16,C','
         IILF  R0,L'CN_RET_LIST_PFX
         ST    R0,EXEC_CICS_FL
         EXEC CICS PUT CONTAINER(CN_RET_CN_LIST) CHANNEL(TMP_CH)       *
               FROM(CN_RET_LIST_PFX) FLENGTH(EXEC_CICS_FL)             *
               CHAR                                                    *
               RESP(FRESP)                                             *
               RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)
         JNE   CN_FIN_IT_PUT_RETCN_ERR
*
         EXEC CICS STARTBROWSE CONTAINER                               *
         CHANNEL(CH_NM)                                                *
         BROWSETOKEN(CN_BRS_TKN)                                       *
         RESP(FRESP)                                                   *
         RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)    CH STBR
         JNE   CN_FIN_IT_ST_BRWS_ERR
*
         LA    R7,CN_MOVE_NM
*
CN_FIN_IT_GETNEXT DS 0H
         MVC CN_MOVE_NM(L'CN_MOVE_NM+1),SPACE255
         EXEC CICS GETNEXT CONTAINER(CN_MOVE_NM)                       *
          BROWSETOKEN(CN_BRS_TKN)                                      *
          RESP(FRESP)                                                  *
          RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(END)
         JE    CN_FIN_IT_DONE_BRS
*
         CLC   FRESP,DFHRESP(NORMAL)
         JNE   CN_FIN_IT_GETNEXT_ERR
*                       TRIM SPACES FROM CN_MOVE_NM
         LA    R8,1(0,R7)             START AT POS 2 IN CN_MOVE_NM
         IILF  R9,2                   R9 WILL PTR TO SP IN CN_MOVE_NM
*         MVI   CN_MOVE_NM_17,C' '     FORCE SP CN_MOVE_NM+1
*                                       CN_MOVE_NM_17
CN_FIN_IT_TRIM_CN_NM DS 0H
         CLI   0(R8),X'40'
         JE    CN_FIN_IT_GOT_CN_NM
         LA    R8,1(R8)
         LA    R9,1(R9)
         CIJNH R9,16,CN_FIN_IT_TRIM_CN_NM   AT 17,R8 PTS TO SP AT END
*
CN_FIN_IT_GOT_CN_NM DS 0H
         MVI   0(R8),C','             R8 PTS TO FIRST SP IN CN NM
         ST    R9,EXEC_CICS_FL        MAKE IT A COMMA;INCL IN PUT
         EXEC CICS PUT CONTAINER(CN_RET_CN_LIST) CHANNEL(TMP_CH)       *
               FROM(CN_MOVE_NM)      FLENGTH(EXEC_CICS_FL)             *
               CHAR                                                    *
               APPEND                                                  *
               RESP(FRESP)                                             *
               RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)
         JE    CN_FIN_IT_GETNEXT
*
CN_FIN_IT_GETNEXT_ERR DS 0H
CN_FIN_IT_DONE_BRS DS 0H
         EXEC CICS ENDBROWSE CONTAINER                                 *
            BROWSETOKEN(CN_BRS_TKN)                                    *
            NOHANDLE
*
         EXEC CICS MOVE CONTAINER(CN_RET_CN_LIST)   CHANNEL(TMP_CH)    *
               AS(CN_RET_CN_LIST)                                      *
               TOCHANNEL(CH_NM)                                        *
               RESP(FRESP)                                             *
               RESP2(FRESP2)
*
CN_FIN_IT_PUT_RETCN_ERR DS 0H     FRESP IS STILL SET
CN_FIN_IT_ST_BRWS_ERR DS 0H          NOT NORMAL FROM ABOVE
         MVC   OPLIT(L'RET_CN_LIST_MSG),RET_CN_LIST_MSG
         MVC   OPLIT+35(16),CN_RET_CN_LIST
*
         CLC   FRESP,DFHRESP(NORMAL)
         JE    CN_FIN_IT_RET_MSG
*
         MVC   OPLIT+4(3),=C'UN'
*
CN_FIN_IT_RET_MSG DS 0H
*
         IILF  R0,L'RET_CN_LIST_MSG
         AHI   R0,16
         ST    R0,PUT_APND_MSG_FL
         JAS   R9,PUT_APND_RESP_CN
* !20170802 V3.3
*
         EXEC CICS MOVE CONTAINER(CN_RESP_NM)       CHANNEL(TMP_CH)    *
               AS(CN_RESP_NM)                                          *
               TOCHANNEL(CH_NM)                                        *
               RESP(FRESP)                                             *
               RESP2(FRESP2)
*
CN_FIN_IT_DO_TDQ DS 0H
         MVC   OPLIT,OPLIT1    MV RESP CN TO CH
*
         MVC   OPLIT(L'CN_WRIT_TDQ_MSG),CN_WRIT_TDQ_MSG
         L     R15,MXRC
         JAS   R9,B2C
         MVC   OPLIT+44(2),HLDSTR+5
         L     R15,CN_CT
         JAS   R9,B2C
         MVC   OPLIT+58(3),HLDSTR+4
         MVC   OPLIT+84(16),CH_NM
         MVC   UR_RESP,OPLIT00
         JAS   R9,WRIT_CMD_2_TDQ
         J     DO_FIN_CN_RETURN
*
*
GET_FORMAT_TIME DS 0H
         ST   R9,SAV_RET_FMT_TM_9
         ZAP   MYABSTM,PZERO       GET_FORMAT_TIME
         EXEC CICS ASKTIME ABSTIME(MYABSTM)
         EXEC CICS FORMATTIME ABSTIME(MYABSTM)                         *
              YYYYDDD(TIMER_ENT_CN_JDT) DATESEP('-')                   *
              TIME(TIMER_ENT_CN_TOD) TIMESEP(':')
*
         L    R9,SAV_RET_FMT_TM_9
         BR    R9
*
* COMMAREA PROCESSING STARTS HERE
* COMMAREA PROCESSING STARTS HERE
* COMMAREA PROCESSING STARTS HERE
*
*
* OLD LOGIC EXPECTS A COMMAREA OF SOME SIZE; WE USE 32400
*     SO SET UP R5 WITH 'COMMAREA'
*    AND SET UP R15 WITH 'COMMAREA' LENGTH
DO_JRND DS 0H
*        LARL  R9,CN_CMD_PROCESSED
*   R9 SET BY CMD_TBL RETU ADDR FOR CN
         ST    R9,SAV_CN_CMD_RET9
         BR    R9           JUST RETURN FOR THE NEXT CN CMD
*
MVC_2_OPLIT MVC  OPLIT+29(0),0(R9)
*
DO_PLAY DS 0H
         ST    R7,SAV_PLAY_CMD_REG7  SAVE PLAY CNC_CN_ELEM ENT
         STM   R4,R8,SAV_PLAY_REGS4_8
* PLAY LIST PROCESSING OPERATES FROM THIS CODE SECTION
** THE PRESENCE OF NON ZERO IN THE CN_NM_PLAY_ANCH VAR
*  THE PRESENCE OF NON ZERO IN THE PLAYLIST_GRP_ANCHA VAR
**  SENDS PROCESSING HERE. CN_NM_PLAY_ANCH POINTS TO ELEMENTS IN
*   SENDS PROCESSING HERE. PLAYLIST_GRP_ANCH POINTS TO ELEMENTS IN
**  THE CN_PLAY_LIST ARRAY. EACH ARY ELEM IS A PTR TO A PLAY CMD
*   THE PLAYLIST_TBLBEG ARRAY. EACH ARY ELEM IS A PTR TO A PLAY CMD
*   CNC_CN_ELEM ENTRY (WHICH IS A LOCATOR TO THE PLAY CMD CN). EACH
**  CN_PLAY_LIST ARRAY CMD IS  EXECUTED FROM THIS SECTION OF CODE.
*   PLAYLIST_TBLBEG ARRAY CMD IS  EXECUTED FROM THIS SECTION OF CODE.
**  FOR EACH CN_PLAY_LIST ARRAY, THE PLAY_LIST CMD CN IS PROCESSED.
*   FOR EACH PLAYLIST_TBLBEG ARRAY, THE PLAY_LIST CMD CN IS PROCESSED.
*   THE PLAY_LIST CN IS SENT TO EKTRMPOS TO DEVELOP K/V PAIRS
*   WHICH ARE RETURNED IN CONTAINERS NAMED BY THE KEY:
*    CN_LIST OR LIST IS REQUIRED. CN_LIST IDENTIFIES A SECONDARY CN
*     CONTAINING THE ACTUAL LIST OF CMD CN, OR LIST IS A STRING OF
*     CN NAMES, SPECIFING THE ACTUAL LIST OF CMD CN
*    CN_SYSID OR SYSID SPECIFIES A CN WITH THE TARGET SYSID, OR THE
*     ACTUAL TERGET SYSID.
*   IF WE GET A SYSID: THEN JUST MOVE ALL ASSOCIATED CN TO THE
*    TEMP DPL CHANNEL; AND DPL TO THE SYSID FOR EXECUTION (THIS PGM)
*   IF THERE IS NO SYSID: THEN PROCESS THE LIST OF CMDS. EXECUTION
*    JUMPS THE THE LABEL PLAY_INTERCEPT, AND RUNS AS A NORMAL CN
*    THE CMD RETURNS TO THE LABEL BELOW: PLAY_INTERCEPT_RTN, AND LOOPS
*    TO RUN THE NEXT CMD.
*   WHEN ALL PLAY_LIST ENTRIES ARE FINISHED, WE END THIS PROGRAM
*
* STILL HAVE:USING CNC_CN,R6
*            USING CNC_CN_ELEM,R7
*    SAVE THESE TWO
*     BUT DO NOT DROP USING
*    USE THE SET OF VARS TO CONTROL PROCESSING THE PLAY LISTS:
**    CN_NM_PLAY_ANCH - POINTS TO THE 'CURRENT' PLAY LIST
*     PLAYLIST_GRP_ANCH POINTS TO THE 'CURRENT' PLAY LIST
**    CN_PLAY_LIST    - ARRAY OF 10 PLAY CMD CNC_CN_ELEM ENTRIES
*     PLAYLIST_TBLBEG - ARRAY OF 10 PLAY CMD
*                     - FIRST 16 CHARS ARE THE PLAYLIST CN_NM
*                     - AND THE FW ADDR OF THE CNC_CN_ELEM ENTRY
*                     - OR X'FF' TO INDICATE END OF PLAY ENTRIES
**    CN_PLAY_FF      - AT THIS POINT, X'FF' TO FORCE  END OF ARRAY
*     PLAYLIST_TBLEND_FF - AT THIS POINT, X'FF' TO FORCE  END OF ARRAY
*    ON ENTRY, WE HAVE ADDR TO THE FIRST PLAY CNC_CN_ELEM IN R7
*     (WHICH IS ALSO POINTED TO BY THE PLAY_LIST_ANCH VAR.
*     AS EACH PLAY CMD FINISHED, THE ANCH IS BUMPED TO THE NEXT
*     PLAY ENTRY (IF ANY), R7 IS LOADED FOR THIS CNC_CN_ELEM,
*     AND PLAY_LIST_ANCH IS UPDATED TO POINT AT THIS A
**   WE USE THE CN_NM_PLAY_ANCH TO GET THE PTR TO EACH PLAY CMD CN
*    WE USE THE PLAYLIST_GRP_ANCH TO GET THE PTR TO EACH PLAY CMD CN
**     ON THE CN_PLAY_LIST (TO GRAB SOME USEFUL INFORMATION),
*      ON THE PLAYLIST_TBLBEG (TO GRAB SOME USEFUL INFORMATION),
*     THEN
*     WE WILL BE SETTING R7 TO THE INDIVIDUAL CNC_CN_ELEM
*      AS WE PROCESS EACH ASSICIATED CMD_CN
*      IN WHICH CASE NO OTHER PLAY SPECIFIC PROCESSING NEEDS TO
*      BE INSERTED IN THE CMD LOGIC
*     (R7 NOT DISTURBED, BUT NOT RELEVENT FOR PLAY LOGIC)
*
*  ON ENTRY TO DO_PLAY, R7 PTS TO THE FIRST PLAYLIST CNC_CN_ELEM
*   THE CNC_CN_RX FLD FOR THE PLAY ENTRY, HOLDS THE RETURN ADDRESS:
*   WHICH FOR PLAY, IS CN_FIN_CMD_ELEM
*   FROM THERE WE WILL CLEAN UP AND END THE PROGRAM
*
*    WE SAVED STM   R5,R8,SAV_CN_REGS5_8
*    THEN DID BASR TO ONE OF THESE ADDR
*     NOT GOING TO USE THE REG9 CONTENTS SET IN BASR
*     THE LEGACY RETURN LABEL   IS CN_RET_FROM_OLD_CMD
*     THE RETURN LABEL FOR LCNC IS CN_CMD_PROCESSED
*      SO WE ARE GOING TO SAVE IT IN SAV_CN_CMD_RET9
*
*  CLONE LOGIC
*    SAVE THE orig CH_NM - restore from this value on each
*     ITERATION OF A NEW PLAYLIST, AND AT END
*    CH_NM WILL BE ALTERED IN PLAY LOGIC, TO POINT AT TMP CHANNELS
*  WHILE IN PLAY, WE NEED TO COPY ALL CMD CN ON LIST TO TMP CH
*   WE SAVE THE ORIG CUR CH NM TO A SAVE AREA, REPLACING WITH A
*   TMP CH NM. WE CAN NOW COPY THE ORIG CN TO THE TMP CH
*   AND RUN EACH CMD USING THE TMP CH AND COPIED CN
*   ON RETURN, WE WILL MOVE EACH RETURNED CMD CN FROM THE TMP CH
*   TO THE ORIG CUR CH, BUT REPLACING EACH CN WITH A NEW CN
*   WHICH ADDS A PREFIX PLA# TO THE REAL CN NM (1-12)
*  THE ACTUAL ORIG CMD CN ARE NOT DISTURBED ON ORIG CH
*  THUS, THEY CAN BE REUSED ON OTHER PLAY LISTS
* AT THE END OF ALL PLAYLISTS, THE CH_NM CHANNEL NAME IS
*  RESET TO THE ORIGINAL CH_NM (FROM PLAY_CLONE_SAV_CH_NM)
         MVC   PLAY_CLONE_SAV_CH_NM,CH_NM
         MVC   PLAY_CLONE_TMP_CH_NM,SPACE255
         MVC   PLAY_CLONE_TMP_CH_NM(4),CMD_PLAY
         MVI   PLAY_CLONE_TMP_CH_NM+4,C'@'
* MAKE SURE THE REAL CH_NM IS NOT A CONFLICT WITH THIS TMP
         CLC   CH_NM(4),CMD_PLAY
         JNE   PLAY_TMP_CH_BYP_ADJ
*   FORCE Y IN PLAY TO Z (PLAZ) SO THERE IS NO CONFLICT
         MVI   PLAY_CLONE_TMP_CH_NM+3,C'Z'
*
PLAY_TMP_CH_BYP_ADJ DS 0H
*
*NEW TMP CHANNEL NAME FOR PLAY PROCESSING
         MVC   PLAY_CLONE_TMP_CH_NM+5(11),PLAY_CLONE_SAV_CH_NM
*
*  CLONE LOGIC END
*
PLAY_CMD_LIST_TOP DS 0H
         XR    R15,R15
         MVC   CH_NM,PLAY_CLONE_SAV_CH_NM
*
*   MOVE THE DEFAULT play (LCNC) ERROR MSG PREFIX NOW.
*     THEN MOVE EACH REASON TO POS 38 IN THE OPLIT
*
         MVC   OPLIT(L'DO_LCNC_ERR),DO_LCNC_ERR
         MVC   OPLIT+4(4),CMD_PLAY
*
         MVC   LNK2CH_NM,SPACE255
         CLC   CNC_CN_CP,F0   BIT CN ARE CP=0 CHAR IS NOT 0
         JE    PLAY_ERR_1
*
* THE CONTAINER STORAGE INFORMATION IS THE CURRENT ELEMENT
* PLAY CONTENTS REQUIRE KEY=VALUE PAIRS
*
*      CN_LIST=zzzz_anyname identifies a CN holding a list of cmd cn
*     or  LIST=zzzz,zzzz1,...,zzzzn is a string of CMD container names
*      CN_SYSID=wwww_anyname identifies a CN with SYSID for DPL
*     or  SYSID=wwww is a string identifing a SYSID for DPL
*      on DPL, all  CNs will be MOVEd to the DPL channel
* Use program EKTRMPOS to parse the LCNCxxxx CN, returning K/V
*      data in a CN
         MVC   LNK2PGM_NM,SPACE255
         MVC   LNK2PGM_NM(L'LIT_EKTRMPOS),LIT_EKTRMPOS
* CREATE A NEW CHANNEL FOR EXTRMPOS
         XC    PLAY_LIST_ADR,PLAY_LIST_ADR
         XC    CN_MOVE_ADR,CN_MOVE_ADR
         MVC   LNK2CH_NM(8),LIT_EKTRMPOS
         MVC   LNK2CH_NM+8(5),=C'_PLAY'
*
* CLONE LOGIC
*   FOR EACH NEW PLAYLIST, WE BUMP THE COUNT
         MVI   LCNC_CLONE_PFX_ELEM_CT,X'EF'  RESET INSIDE PLAYLIST
         LA    R0,VAL_CNC_E1       START OF TBL
         ST    R0,CNC_VAL_CHR_CUR_TBL_ENT      SAVE IT AS CUR POS
         IC    R15,PLAY_CLONE_PFX_ELEM_CT  EF-F8
         LA    R15,1(R15)                  MAKING
         STC   R15,PLAY_CLONE_PFX_ELEM_CT  F0-F9
* CLONE LOGIC END
*    COPY THE ORIG LCNC CN TO THE NEW CHANNEL
         MVC   CN_MOVE_NM,SPACE255    CN_COPY
         MVC   GM_STG_FL,CNC_CN_L    THEN THE EXTRA BYTE IS SP FILLED
         JAS   R9,GM_STG           BY THE GET CN CMD
         LT    R9,GM_STG_ADR
         JZ    PLAY_ERR_1A
         ST    R9,CN_PLAY_ADR      SAVE CONTENT ADR FOR RELOAD
*
         MVC   EXEC_CICS_FL,CNC_CN_L
         EXEC CICS GET CONTAINER(CNC_CN_N)                             *
             CHANNEL(CH_NM)                                            *
             INTO(0(0,R9))                                             *
             FLENGTH(EXEC_CICS_FL)                                     *
             RESP(FRESP)                                               *
             RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)
         JNE   PLAY_ERR_1B
*
*  WE HAVE READ THE PLAY LIST INTO STG - EXEC_CICS_FL LENGTH
*   WRITE THE CONTENTS TO TDQ AND THE CN_RESP CONTAINER
*   (INSURE EXEC_CICS_FL WILL FIT INTO TDQ MSG AREA)
         MVC   OPLIT,SPACE255
         MVC   OPLIT(L'PLAY_LS_MSG),PLAY_LS_MSG
         MVC   OPLIT+7(16),CNC_CN_N
         IILF  R15,L'OPLIT-L'PLAY_LS_MSG    GET LNG AVAIL FOR PLAY LIST
         C     R15,EXEC_CICS_FL             COMP TO ACTUAL LNG
         JL    PLAY_USE_OPLIT_L             IF LNG AVAIL IS LOW-USE IT
         L     R15,EXEC_CICS_FL             ELSE USE PLAY LIST LNG
*
PLAY_USE_OPLIT_L DS 0H
         BCTR  R15,0
         EXRL  R15,MVC_2_OPLIT              MOVE USING R9 AS SRC
         AHI   R15,L'PLAY_LS_MSG+1          TOTAL LNG FOR CN_RESP
         ST    R15,PUT_APND_MSG_FL
         JAS   R9,WRIT_CMD_2_TDQ_OPLIT
         JAS   R9,PUT_APND_RESP_CN
         L     R9,CN_PLAY_ADR     RELOAD STG ADDR DESTROYED BY JAS
*
         MVC   OPLIT(L'DO_LCNC_ERR),DO_LCNC_ERR
         MVC   OPLIT+4(4),CMD_PLAY
*
         EXEC CICS PUT  CONTAINER(CNC_CN_N)                            *
              CHANNEL(LNK2CH_NM)                                       *
              FROM(0(0,R9))                                            *
              FLENGTH(EXEC_CICS_FL)                                    *
              RESP(FRESP)                                              *
              RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)  GET CN
         JNE   PLAY_ERR_2
*
PLAY_DO_EKTRMPOS DS 0H
         EXEC CICS LINK PROGRAM(LNK2PGM_NM)                            *
             CHANNEL(LNK2CH_NM)                                        *
             RESP(FRESP)                                               *
             RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)
         JNE   PLAY_ERR_3
*
* PROCESS THE EXPECTED CN (K=V PAIRS) ON THE CHANNEL
*  EXPECT CN NAMED: CN_LIST OR LIST
*        (OPTIONAL) CN_SYSID OR SYSID
*   CN_LIST AND CN_SYSID IDENTIFIES A SECONDARY CN, HOLDING
*   THE RESPECTIVE VALUE.
*   LIST AND SYSID HOLDS THE ACTUAL RESPECTIVE VALUES
*
         XC    PLAY_LIST_ADR,PLAY_LIST_ADR
         MVC   PLAY_LIST_CN,SPACE255
         MVC   EXEC_CICS_FL,F16
         MVC   CN_MOVE_NM,SPACE255
         MVC   CN_MOVE_NM(L'LIT_CN_LIST),LIT_CN_LIST
         EXEC CICS GET CONTAINER(CN_MOVE_NM)                           *
             CHANNEL(LNK2CH_NM)                                        *
             INTO(PLAY_LIST_CN)                                        *
             FLENGTH(EXEC_CICS_FL)                                     *
             RESP(FRESP)                                               *
             RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)
         JE    PLAY_GOT_CN_LIST0
*
         CLC   FRESP,DFHRESP(CONTAINERERR)
         JNE   PLAY_ERR_4A
*
         IILF  R15,L'LIT_LIST
         LA    R2,LIT_LIST
         JE    PLAY_GOT_CN_LIST1
*
PLAY_GOT_CN_LIST0 DS 0H
         L     R15,EXEC_CICS_FL
         LA    R2,PLAY_LIST_CN
*
PLAY_GOT_CN_LIST1 DS 0H
         BCTR  R15,0
         MVC   CN_MOVE_NM,SPACE255
         LA    R1,CN_MOVE_NM
         EXRL  R15,MVC_CN_NM_R1_R2
*
         EXEC CICS GET CONTAINER(CN_MOVE_NM)                           *
             CHANNEL(LNK2CH_NM)                                        *
             NODATA                                                    *
             FLENGTH(EXEC_CICS_FL)                                     *
             RESP(FRESP)                                               *
             RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)
         JNE   PLAY_ERR_4B
*
         MVC   PLAY_LIST_FL,EXEC_CICS_FL
         L     R15,EXEC_CICS_FL
         LA    R15,1(R15)        ADD 1 EXTRA BYTE FOR X'40' DELIM
         ST    R15,EXEC_CICS_FL    WHEN GET CN IS GT REAL LNG
         ST    R15,GM_STG_FL       THEN THE EXTRA BYTE IS SP FILLED
         JAS   R9,GM_STG           BY THE GET CN CMD
         LT    R9,GM_STG_ADR
         JZ    PLAY_ERR_5
*
         ST    R9,PLAY_LIST_ADR
         EXEC CICS GET CONTAINER(CN_MOVE_NM)                           *
             CHANNEL(LNK2CH_NM)                                        *
             INTO(0(0,R9))                                             *
             FLENGTH(EXEC_CICS_FL)                                     *
             RESP(FRESP)                                               *
             RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)
         JNE   PLAY_ERR_4D
*
         MVI   PLAY_LIST_CN,C'@'
*
PLAY_GOT_CN_LIST DS 0H
         MVC   LNK2SYSD_NM,SPACE255   ALLOW FOR LCNC THIS SYSID
         MVC   PLAY_SYSD_CN,SPACE255
         MVC   EXEC_CICS_FL,F16
         MVC   CN_MOVE_NM,SPACE255
         MVC   CN_MOVE_NM(L'LIT_CN_SYSID),LIT_CN_SYSID
         EXEC CICS GET CONTAINER(CN_MOVE_NM)                           *
             CHANNEL(LNK2CH_NM)                                        *
             INTO(PLAY_SYSD_CN)                                        *
             FLENGTH(EXEC_CICS_FL)                                     *
             RESP(FRESP)                                               *
             RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)
         JE    PLAY_GOT_SYSID0
*
         CLC   FRESP,DFHRESP(CONTAINERERR)
         JNE   PLAY_NO_SYSD
*
         IILF  R15,L'LIT_SYSID
         LA    R2,LIT_SYSID
         JE    PLAY_GOT_SYSID1
*
PLAY_GOT_SYSID0 DS 0H
         L     R15,EXEC_CICS_FL
         LA    R2,PLAY_SYSD_CN
*
PLAY_GOT_SYSID1 DS 0H
         BCTR  R15,0
         MVC   CN_MOVE_NM,SPACE255
         LA    R1,CN_MOVE_NM
         EXRL  R15,MVC_CN_NM_R1_R2
*
         MVC  EXEC_CICS_FL,F4
         EXEC CICS GET CONTAINER(CN_MOVE_NM)                           *
             CHANNEL(LNK2CH_NM)                                        *
             INTO(LNK2SYSD_NM)                                         *
             FLENGTH(EXEC_CICS_FL)                                     *
             RESP(FRESP)                                               *
             RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)
         JNE   PLAY_NO_SYSD
*
         MVI  PLAY_SYSD_CN,C'@'
*
PLAY_NO_SYSD DS 0H
         CLC  LNK2SYSD_NM,SPACE255
         JNE  PLAY_GOT_SYSD
         MVC   LNK2SYSD_NM,LCL_SYSID
*
PLAY_GOT_SYSD DS 0H
* ?CREATE NEW CHANNEL NAME FOR PLAY LOGIC
*    PROGNAME_SYSID IS NEW CH NAME
*        MVC   LNK2PGM_NM,SPACE255
*        MVC   LNK2PGM_NM(L'PROGNAME),PROGNAME
*        IILF  R0,X'40'        SET UP FOR MVST
*        MVC   LNK2CH_NM,SPACE255
*        LA    R9,LNK2CH_NM
*        LA    R15,LNK2PGM_NM
*        MVST  R9,R15
*        MVI   0(R9),C'_'
*        MVC   1(4,R9),LCL_SYSID
*
*    NOW SET CH_NM TO TMP NAME - WHERE WE WILL CLONE OUR
*       CMD CNS IN ORDER TO PRESERVE THE ORIGINAL CMD
*       AND OTHER REFERENCES THE 'CH_NM' CHANNEL; SO NO CHG
*       OTHER THAN THE LOGIC IS WORLKING WITH THE CLONE
*       CMD WHICH EXISTS ON THE TMP CHANNEL
         MVC   CH_NM,PLAY_CLONE_TMP_CH_NM
*
* CLONE LOGIC END
*   DELETE ALL CN IN THE TEMP CHANNEL BECAUSE WE GOT INFO
         MVC   CH_DEL_NM,SPACE255
         MVC   CH_DEL_NM(8),LIT_EKTRMPOS
         MVC   CH_DEL_NM+8(5),=C'_PLAY'
         JAS   R9,CN_DEL_CH
*
         L     R2,PLAY_LIST_ADR
         L     R3,PLAY_LIST_FL
         AR    R3,R2
         MVI   0(R3),X'00'
         STM   R2,R3,SAV_PLAY_LIST_REGS2_3
*
*  START PLAY LIST PROCESSING
*
*   EACH CN NAMED ON PLAY LIST IS IDENTIFIED
*   AND DEALT WITH ACCORDING TO LCL OR SYSID
PLAY_CMD_ENT_TOP DS 0H
         LA    R4,CN_MOVE_NM        RESET ST OF TGT FLD ADR
         MVC   CN_MOVE_NM,SPACE255  SET TO SPACES
         XR    R5,R5                CNT OF BYTES FOR CN LNG
PLAY_CMD_ENT_NXT_CHR DS 0H
         CLI   0(R2),C' '
         JE    PLAY_CMD_ENT_GOT_DLM
         CLI   0(R2),C';'
         JE    PLAY_CMD_ENT_GOT_DLM
         CLI   0(R2),C','
         JE    PLAY_CMD_ENT_GOT_DLM
         LA    R5,1(R5)            TST CN NM 1-16 CHAR
         CHI   R5,16
         JH    PLAY_CMD_ENT_BYP    TOO MANY, SO DON'T MOVE
         MVC   0(1,R4),0(R2)       OK, MOVE CN BYTE
         LA    R4,1(R4)         BUMP TGT
PLAY_CMD_ENT_BYP DS 0H
         LA    R2,1(R2)         BUMP SRC
         CR    R2,R3            TST END
         JL    PLAY_CMD_ENT_NXT_CHR
*
PLAY_CMD_ENT_GOT_DLM DS 0H
         STM   R2,R3,SAV_PLAY_LIST_REGS2_3     PRESERVE INCASE LCNC
         LTR   R5,R5
         JZ    PLAY_CMD_ENT_EMPTY
*        MVI   0(R2),X'00'     FORCE DELIM TO X'00'
*
* FOR EACH CN NOW FOUND IN THE PLAY LIST, GET THE CNC_CN_ELEM
         CLC   CN_MOVE_NM(4),CMD_PLAY
         JE    PLAY_CMD_ENT_INV    CAN NOT HAVE PLAY IN PLAY LIST
*
*   NEED TO FIND THE CMD ON THE CNC_CN_ELEM LIST
*    FIND ELEM BY CN NAME - CN_MOVE_NM HOLDS CN TO BE FND
*    RTN PTR TO THIS ELEM IN R15 OR ZERO (NOT FND)
         JAS   R9,FND_CNC_ELEM_BY_CN
         LTR   R15,R15               R15 PTS TO CMD CNC_CN_ELEM
*        JNZ   PLAY_GOT_CNC_ELEM_ADR
*
         JZ    PLAY_ERR_11A
*
PLAY_GOT_CNC_ELEM_ADR  DS  0H
*        ST    R7,SAV_PLAY_CMD_REG7    SAVE  PTR TO PLAY CNC_CN_ELEM
         LR    R7,R15    ACTIVE USING ON R7 STILL PTS AT CNC_CN_ELEM
*                        NOW PTS TO THE CMD CNC_CN_ELEM
* SYSID OPTION ON PLAY LIST WILL JUST MOVE THIS PLAYLIST CN TO
*  CHANNEL ASSOC WITH THE SYSID REQUEST. THEN DPL PLAYLIST CMD
*  AND ALL ASSOC CN TO THE SYSID. FOR NOW; UCEMPINR IS ONLY PGM.
         CLC   LNK2SYSD_NM,LCL_SYSID
         JNE   PLAY_CMD_SYSID
*
*  NOT SYSID - EXECUTE THIS CMD IN THIS TRN
*   CLONE LOGIC - COPY THE CMD CN FROM THE REAL TO A TMP
*    WHERE THE REAL IS NOW POINTED TO BY THE PLAY_CLONE_SAV_CH_NM
*    AND WE ARE MAKING A COPY TO THE PLAY_CLONE_TMP_CH_NM
*    WHICH IS ALSO THE 'CH_NM' NAME
*    ALLOWING THE OLD CODE TO REMAIN UNCHANGED, BUT USES A COPY
*    OF THE CMD CN
*
         MVC   CN_COPY_NM_FROM,CN_MOVE_NM
         MVC   CN_COPY_NM_TO,CN_MOVE_NM
         MVC   CH_COPY_NM_FROM,PLAY_CLONE_SAV_CH_NM
         MVC   CH_COPY_NM_TO,PLAY_CLONE_TMP_CH_NM
         L     R15,CNC_CN_L
         JAS   R9,CN_COPY       SINGLE CN COPIED
         LTR   R15,R15
         JM    PLAY_ERR_11C
*
* ADD LOGIC FOR LCNC (HAS ASSOCIATED CONTAINERS)
         CLC   CMD_LCNC,CN_MOVE_NM
         JNE   PLAY_LCL_CMD_NOT_LCNC
* WE HAVE LCNC - HAVE TO MOVE ALL ASSOC CN TO TMP_CH
*      USE LOGIC ALREADY IN DO_LCNC TO GET CN LIST AND COPY
*      ALL ASSOC CN ON LCNC LIST TO PLAY_TMP CHANNEL
*    NOTE: WE HAVE R7 ALREADY POINTING AT THE LCNC CN
*          PLAY_CLONE_SAV_CH_NM IS TESTED IN DO_LCNC TO
*          RELOAD CH_NM FOR THIS WORK - THRN RESTORE CH_NM TO TMP
         OI    PLAY_LCNC_REQUEST,X'FF'
         JAS   R9,DO_LCNC
         XC    PLAY_LCNC_REQUEST,PLAY_LCNC_REQUEST
         LM    R2,R3,SAV_PLAY_LIST_REGS2_3
         LTR   R15,R15
         JM    PLAY_ERR_11C
* END LOGIC FOR LCNC (HAS ASSOCIATED CONTAINERS)
*  CLONE LOGIC END
*
PLAY_LCL_CMD_NOT_LCNC DS 0H
         ZAP   MYABSTM,PZERO
         EXEC CICS ASKTIME ABSTIME(MYABSTM) NOHANDLE
*  NOTE    RETURN TO PLAY_INTERCEPT_RTN
         J     PLAY_CMD_INTERCEPT
*
*
*                 SYSID LOGIC
*                 SYSID LOGIC
*                 SYSID LOGIC
*
PLAY_CMD_SYSID DS 0H
*   CLONE LOGIC - COPY THE CMD CN FROM THE ORIG TO A TMP
*    WHERE THE ORIG IS NOW POINTED TO BY THE PLAY_CLONE_SAV_CH_NM
*    AND WE ARE MAKING A COPY TO THE PLAY_CLONE_TMP_CH_NM
*    NOTE: CH_NM WAS SET TO THE PLAY TMP ABOVE -
*    ALLOWING THE OLD CODE TO REMAIN UNCHANGED, BUT USES A COPY
*    OF THE CMD CN
*
* WE ARE COPYING EACH CMD AS WE FIND IT IN THE PLAYLIST
         MVC   CN_COPY_NM_FROM,CN_MOVE_NM
         MVC   CN_COPY_NM_TO,CN_MOVE_NM
         MVC   CH_COPY_NM_FROM,PLAY_CLONE_SAV_CH_NM
         MVC   CH_COPY_NM_TO,PLAY_CLONE_TMP_CH_NM
         L     R15,CNC_CN_L
         JAS   R9,CN_COPY       SINGLE CN COPY OF ACTUAL CMD
         LTR   R15,R15
         JM    PLAY_ERR_11C
* ADD LOGIC FOR LCNC (HAS ASSOCIATED CONTAINERS)
         CLC   CMD_LCNC,CN_MOVE_NM
         JNE   PLAY_CMD_NOT_LCNC
*
* WE HAVE LCNC - HAVE TO MOVE ALL ASSOC CN TO TMP_CH
*      USE LOGIC ALREADY IN DO_LCNC TO GET CN LIST AND COPY
*      ALL ASSOC CN ON LCNC LIST TO PLAY_TMP CHANNEL
*    NOTE: WE HAVE R7 ALREADY POINTING AT THE LCNC CN
*          PLAY_CLONE_SAV_CH_NM IS TESTED IN DO_LCNC TO
*          RELOAD CH_NM FOR THIS WORK - THRN RESTORE CH_NM TO TMP
         OI    PLAY_LCNC_REQUEST,X'FF'
         JAS   R9,DO_LCNC
         XC    PLAY_LCNC_REQUEST,PLAY_LCNC_REQUEST
         LM    R2,R3,SAV_PLAY_LIST_REGS2_3
         LTR   R15,R15          ERROR IN DO_LCNC MOVE CN
         JM    PLAY_ERR_11C
* END LOGIC FOR LCNC (HAS ASSOCIATED CONTAINERS)
         L     R7,SAV_PLAY_CMD_REG7    RESTORE PTR TO PLAYLIST CN
*                                    SO IT IS NOT LOST
* CLONE LOGIC END
*
PLAY_CMD_NOT_LCNC DS 0H
         LA    R2,1(R2)         BUMP PAST DLM
         CR    R2,R3            TST END
         JL    PLAY_CMD_ENT_TOP
*
*  OK; ALL CMD ON PLAY LIST MOVED TO SYSID CH
*  COPY THE CN HOLDING THE PLAYLIST CN  TO SYSID CH
* WE ARE COPYING EACH CMD AS WE FIND IT IN THE PLAYLIST
         L     R7,SAV_PLAY_CMD_REG7    RESTORE PTR TO PLAY CNC_CN_ELEM
         MVC   CN_COPY_NM_FROM,CNC_CN_N
         MVC   CN_COPY_NM_TO,CNC_CN_N
         MVC   CH_COPY_NM_FROM,PLAY_CLONE_SAV_CH_NM
         MVC   CH_COPY_NM_TO,PLAY_CLONE_TMP_CH_NM
         L     R15,CNC_CN_L
         JAS   R9,CN_COPY     COPY SINGLE CN OF PLAY LIST CND
         LTR   R15,R15
         JM    PLAY_ERR_11D
*
         ZAP   MYABSTM,PZERO
         EXEC CICS ASKTIME ABSTIME(MYABSTM) NOHANDLE
*
*  DEFAULT UCEMPINR AS THE LINK TO PGM ON SYSID
         MVC   LNK2PGM_NM,SPACE255
         MVC   LNK2PGM_NM(L'PROGNAME),PROGNAME
*
         EXEC CICS LINK PROGRAM(LNK2PGM_NM)                            *
             CHANNEL(PLAY_CLONE_TMP_CH_NM)                             *
             SYSID(LNK2SYSD_NM)                                        *
             RESP(FRESP)                                               *
             RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)
         JNE   PLAY_ERR_12
*
         ZAP   MYABSTM1,PZERO
         EXEC CICS ASKTIME ABSTIME(MYABSTM1) NOHANDLE
*
         XR   R15,R15
         OI   PLAY_LCNC_REQUEST,X'FF'
         MVC  CH_MOVE_NM_FROM,PLAY_CLONE_TMP_CH_NM
         MVC  CH_MOVE_NM_TO,PLAY_CLONE_SAV_CH_NM
         JAS  R9,CN_MOVE_2_CUR_CH     MOVE ALL CN TO ORIG CH
         XC   PLAY_LCNC_REQUEST,PLAY_LCNC_REQUEST
         LTR  R15,R15
         JNZ  PLAY_ERR_13
*
         EXEC CICS FORMATTIME ABSTIME(MYABSTM)                         *
              YYYYDDD(TIMER_DPL_ST_JDT)  DATESEP('-')                  *
              TIME(TIMER_DPL_ST_TOD)  TIMESEP(':')
         EXEC CICS FORMATTIME ABSTIME(MYABSTM1)                        *
              YYYYDDD(TIMER_DPL_SP_JDT)  DATESEP('-')                  *
              TIME(TIMER_DPL_SP_TOD)  TIMESEP(':')
*
         MVC   OPLIT(L'DO_LCNC_MSG),DO_LCNC_MSG
         MVC   OPLIT+4(4),CMD_PLAY
         MVC   OPLIT+9(8),TIMER_DPL_ST_TOD
         MVC   OPLIT+22(8),LNK2PGM_NM
         MVC   OPLIT+36(8),PLAY_CLONE_TMP_CH_NM
         MVC   OPLIT+59(4),LNK2SYSD_NM
         MVC   OPLIT+68(8),TIMER_DPL_SP_TOD
         IILF  R0,L'DO_LCNC_MSG
         ST    R0,PUT_APND_MSG_FL
         JAS   R9,WRIT_CMD_2_TDQ_OPLIT
         JAS   R9,PUT_APND_RESP_CN
         J     PLAY_NXT_PLAY_LIST
*
*  RESTORE R2 AND R3 LIST OF CMDS IN THIS PLAY LIST
*   AND RESTORE R7 (PTR TO THE CNC_CN_ELEM) POINT BACK TO PLAY LIST CN
*
PLAY_INTERCEPT_RTN  DS 0H
* CLONE LOGIC
*  UPON RETURN HERE: THE REPONSE CN HAS BEEN WRITTEN TO THE
*   TMP CH NM IN PLAY_CLONE_TMP_CH_NM (ALSO IN CH_NM)
*  WE NEED TO CREATE A UNIQUE CONT NAME FOR THIS CMD RESP, AND THEN
*   MOVE ALL  CN FROM THE TMP CH BACK TO THE REAL CN WHOSE NAME IS
*   SAVED IN THE PLAY_CLONE_SAV_CH_NM
*
         XC   PLAY_LCNC_REQUEST,PLAY_LCNC_REQUEST
         XR   R15,R15
         OI   PLAY_LCNC_REQUEST,X'FF'
         MVC  CH_MOVE_NM_FROM,PLAY_CLONE_TMP_CH_NM
         MVC  CH_MOVE_NM_TO,PLAY_CLONE_SAV_CH_NM
         JAS  R9,CN_MOVE_2_CUR_CH
         XC   PLAY_LCNC_REQUEST,PLAY_LCNC_REQUEST
         LTR  R15,R15
         JNZ  PLAY_ERR_11C
*
* CLONE LOGIC END
         ZAP   MYABSTM1,PZERO
         EXEC CICS ASKTIME ABSTIME(MYABSTM1) NOHANDLE
*
         EXEC CICS FORMATTIME ABSTIME(MYABSTM1)                        *
              YYYYDDD(TIMER_DPL_SP_JDT)  DATESEP('-')                  *
              TIME(TIMER_DPL_SP_TOD)  TIMESEP(':')
*
         MVC   OPLIT(L'DO_LCNC_MSG),DO_LCNC_MSG
         MVC   OPLIT+4(4),CMD_PLAY
         MVC   OPLIT+9(8),TIMER_DPL_ST_TOD
         MVC   OPLIT+22(16),CNC_CN_N
         MVC   OPLIT+59(4),SPACE255
         MVC   OPLIT+68(8),TIMER_DPL_SP_TOD
         IILF  R0,L'DO_LCNC_MSG
         ST    R0,PUT_APND_MSG_FL
         JAS   R9,PUT_APND_RESP_CN
*
         LM    R2,R3,SAV_PLAY_LIST_REGS2_3  RESTORE PTR IN PLAY LIST
         L     R7,SAV_PLAY_CMD_REG7    RESTORE PTR TO PLAY CNC_CN_ELEM
*
         J     PLAY_GET_NXT_CMD
*
PLAY_CMD_ENT_EMPTY DS 0H
         MVC   OPLIT(L'PLAY_ERR_INVD),PLAY_ERR_INVD
         J     PLAY_CMD_ENT_ERR
*
PLAY_CMD_ENT_INV DS 0H
         MVC   OPLIT(L'PLAY_ERR_INVD),PLAY_ERR_INVD
         MVC   OPLIT+22(16),CN_MOVE_NM
         J     PLAY_CMD_ENT_ERR
*
PLAY_CMD_ENT_ERR DS 0H
         IILF  R0,L'PLAY_ERR_INVD
         ST    R0,PUT_APND_MSG_FL
         JAS   R9,PUT_APND_RESP_CN
         J     PLAY_GET_NXT_CMD
*
PLAY_GET_NXT_CMD   DS 0H
         LA    R2,1(R2)         BUMP PAST DLM
         CR    R2,R3            TST END
         JL    PLAY_CMD_ENT_TOP
         J     PLAY_NXT_PLAY_LIST
*
*
PLAY_ERR_DONE1 DS 0H
         MVC   OPLIT+50(4),CMD_PLAY
         AHI   R0,L'DO_LCNC_ERR
         ST    R0,PUT_APND_MSG_FL
         JAS   R9,PUT_APND_RESP_CN
         J     PLAY_NXT_PLAY_LIST
*
*
PLAY_NXT_PLAY_LIST DS 0H
*
PLAY_NXT_PLAY_LIST_FM0 DS 0H
         LT    R9,PLAY_LIST_ADR
         JZ    PLAY_NXT_PLAY_LIST_FM1
*
         EXEC CICS FREEMAIN DATAPOINTER(R9)                            *
               NOHANDLE
*
PLAY_NXT_PLAY_LIST_FM1 DS 0H
         LT    R9,CN_PLAY_ADR
         JZ    PLAY_NXT_PLAY_LIST_FM2
*
         EXEC CICS FREEMAIN DATAPOINTER(R9)                            *
               NOHANDLE
*
PLAY_NXT_PLAY_LIST_FM2 DS 0H
         MVC   CH_NM,PLAY_CLONE_SAV_CH_NM  RESTORE ORIG CH_NM
         L     R7,PLAYLIST_GRP_ANCH GET PLAY ANCH PTS TO PLAY CMD LIST
         LA    R7,PLAYLIST_TBLGRP_L(R7)   BUMP TO NEXT
         ST    R7,PLAYLIST_GRP_ANCH SAVE IT BACK
         L     R7,PLAYLIST_TBLENT_L(R7)
         C     R7,FMINUS1
         JNE   PLAY_CMD_LIST_TOP
*
* ALL PLAY ENTRIES IN THE PLAY LIST ARRAY HAVE BEEN PROCESSED
*   RESTORE PTR OF LAST PLAY ENTRY IN THE CNC_CN_ELEM STACK
*   IN ORDER TO ACCESSS THE RETURN ADDRESS THAT IS SET FOR PLAY CMDS
*
         ZAP   MYABSTM1,PZERO
         EXEC CICS ASKTIME ABSTIME(MYABSTM1) NOHANDLE
*
         EXEC CICS FORMATTIME ABSTIME(MYABSTM1)                        *
              YYYYDDD(TIMER_DPL_SP_JDT)  DATESEP('-')                  *
              TIME(TIMER_DPL_SP_TOD)  TIMESEP(':')
*
         MVC   OPLIT(L'FINPLAY_CMD_MSG),FINPLAY_CMD_MSG
         MVC   OPLIT+32(8),TIMER_DPL_SP_TOD
         IILF  R0,L'FINPLAY_CMD_MSG
         ST    R0,PUT_APND_MSG_FL
         JAS   R9,PUT_APND_RESP_CN
         J     PLAY_FIN2
*
PLAY_ERR_1    DS 0H        NOT CHAR CN
         MVC  OPLIT+38(L'LCNC_ERR_CP),LCNC_ERR_CP
         MVC  OPLIT+63(16),CNC_CN_N
         IILF  R0,L'LCNC_ERR_CP
         J     PLAY_ERR_DONE1
*
PLAY_ERR_1A   DS 0H        GM FAIL FOR COPY PLAY CN FOR EKTRNPOS
         MVC  OPLIT+38(L'LCNC_ERR_GMCN),LCNC_ERR_GMCN
         MVC  OPLIT+63(16),CNC_CN_N
         IILF  R0,L'LCNC_ERR_GMCN
         J     PLAY_ERR_DONE1
*
PLAY_ERR_1B   DS 0H        GET CN PRIM CN FAIL FOR EKTRMPOS
         MVC  OPLIT+38(L'LCNC_ERR_GPCN),LCNC_ERR_GPCN
         MVC  OPLIT+63(16),CNC_CN_N
         IILF  R0,L'LCNC_ERR_GPCN
         J     PLAY_ERR_DONE1
*
PLAY_ERR_2    DS 0H        PUT CN PRIM CN FAIL FOR EKTRMPOS
         MVC  OPLIT+38(L'LCNC_ERR_PPCN),LCNC_ERR_PPCN
         MVC  OPLIT+63(16),CNC_CN_N
         IILF  R0,L'LCNC_ERR_PPCN
         J     PLAY_ERR_DONE1
*
PLAY_ERR_3    DS 0H        LINK TO EKTRMPOS
         MVC  OPLIT+38(L'LCNC_ERR_LKV),LCNC_ERR_LKV
         MVC  OPLIT+63(16),CNC_CN_N
         IILF  R0,L'LCNC_ERR_LKV
         J     PLAY_ERR_DONE1
*
PLAY_ERR_4A   DS 0H         GET K/V FOR CN_LIST
         MVC  OPLIT+38(L'LCNC_ERR_GKVL),LCNC_ERR_GKVL
         IILF  R0,L'LCNC_ERR_GKVL
         J     PLAY_ERR_DONE1
*
PLAY_ERR_4B   DS 0H         GET K/V FOR    LIST
         MVC  OPLIT+38(L'LCNC_ERR_GKVL),LCNC_ERR_GKVL
         MVI  OPLIT+40,C'B'
         MVC  OPLIT+61(2),=C'ND '
         MVC  OPLIT+63(3),SPACE255
         IILF  R0,L'LCNC_ERR_GKVL
         J     PLAY_ERR_DONE1
*
PLAY_ERR_4D   DS 0H
         MVC  OPLIT+38(L'LCNC_ERR_LSTE),LCNC_ERR_LSTE
         MVI  OPLIT+40,C'D'
         MVC  OPLIT+63(3),SPACE255
         IILF  R0,L'LCNC_ERR_LSTE
         J     PLAY_ERR_DONE1
*
PLAY_ERR_5    DS 0H
         MVC  OPLIT+38(L'LCNC_ERR_GMLV),LCNC_ERR_GMLV
         MVC  OPLIT+63(3),SPACE255     LIST CN
         IILF  R0,L'LCNC_ERR_GMLV
         J     PLAY_ERR_DONE1
*
PLAY_ERR_6    DS 0H
         MVC  OPLIT+38(L'LCNC_ERR_GKVS),LCNC_ERR_GKVS
         MVC  OPLIT+63(16),PLAY_SYSD_CN
         IILF  R0,L'LCNC_ERR_GKVS
         J     PLAY_ERR_DONE1
*
PLAY_ERR_7A   DS 0H
         MVC  OPLIT+38(L'LCNC_ERR_GLST),LCNC_ERR_GLST
         MVC  OPLIT+63(16),PLAY_LIST_CN
         MVI  OPLIT+39,C'7'
         MVI  OPLIT+40,C'A'
         IILF  R0,L'LCNC_ERR_GLST
         J     PLAY_ERR_DONE1
*
PLAY_ERR_7B   DS 0H
         MVC  OPLIT+38(L'LCNC_ERR_GMLV),LCNC_ERR_GMLV
         MVI  OPLIT+39,C'7'
         MVI  OPLIT+40,C'B'
         MVC  OPLIT+63(16),PLAY_LIST_CN
         IILF  R0,L'LCNC_ERR_GMLV
         J     PLAY_ERR_DONE1
*
PLAY_ERR_7C   DS 0H
         MVC  OPLIT+38(L'LCNC_ERR_GLST),LCNC_ERR_GLST
         MVI  OPLIT+39,C'7'
         MVI  OPLIT+40,C'C'
         MVC  OPLIT+50(4),CMD_PLAY
         MVC  OPLIT+63(16),PLAY_LIST_CN
         IILF  R0,L'LCNC_ERR_GLST
         J     PLAY_ERR_DONE1
*
PLAY_ERR_11A  DS 0H
         MVC  OPLIT+38(L'LCNC_ERR_FDCN),LCNC_ERR_FDCN
         MVC  OPLIT+63(16),CN_MOVE_NM
         IILF  R0,L'LCNC_ERR_FDCN
         J     PLAY_ERR_DONE1
*
PLAY_ERR_11B  DS 0H
         MVC  OPLIT+63(16),CN_MOVE_NM
         J    PLAY_ERR_11B2
PLAY_ERR_11C  DS 0H
         MVC  OPLIT+38(L'PLAY_ERR_CLON),PLAY_ERR_CLON
         MVC  OPLIT+63(16),PLAY_LIST_CN
         MVC  OPLIT+80(16),CN_MOVE_NM
         J    PLAY_ERR_11B2
PLAY_ERR_11D  DS 0H
         MVC  OPLIT+63(16),CNC_CN_N
PLAY_ERR_11B1 DS 0H
         MVC  OPLIT+38(L'LCNC_ERR_M2CH),LCNC_ERR_M2CH
PLAY_ERR_11B2 DS 0H
         IILF  R0,L'LCNC_ERR_M2CH
         J     PLAY_ERR_DONE1
*
PLAY_ERR_12   DS 0H
         MVC  OPLIT+38(L'LCNC_ERR_LINK),LCNC_ERR_LINK
         MVC  OPLIT+63(8),LNK2PGM_NM
         IILF  R0,L'LCNC_ERR_LINK
         J     PLAY_ERR_DONE1
*
PLAY_ERR_13   DS 0H
         MVC  OPLIT+38(L'LCNC_ERR_MBAK),LCNC_ERR_MBAK
         IILF  R0,L'LCNC_ERR_MBAK
         J     PLAY_ERR_DONE1
*
* RESTORE THE REGS SAVE BEFORE BASR AT  CN_RET_FROM_OLD_CMD
*  AND USE THE RETURN ADDR SAVED FOR RETURN TO  CN_CMD_PROCESSED
*  BYPASSING LEGACY CODE TO COPY CA BACK TO CN
*
PLAY_FIN2 DS 0H
         L     R7,SAV_PLAY_CMD_REG7    RELOAD PTR TO PLAY CNC_CN_ELEM
*
         MVC   CH_NM,PLAY_CLONE_SAV_CH_NM   RESTORE ORIG CH_NM
*
         LM    R4,R8,SAV_PLAY_REGS4_8
         L     R9,CNC_CN_RX   RETN ADR FOR PLAY LIST PROCESSING
         BR    R9                    AS SPECIFIED BY CMD TBLE
*
*
*       EXRL FOR MOVING CN NAMES
MVC_CN_NM_R1_R2 MVC 0(0,R1),0(R2)
*
*  START_LCNC
*
DO_LCNC DS 0H      BEG LCNC @@@@@@
         ST    R9,SAV_CN_LCNC_RET9        CN_CMD_PROCESSED
         STM   R4,R8,SAV_LCNC_REGS4_8
         XR    R15,R15
*  NOTE  LARL  R9,CN_CMD_PROCESSED
*   R9 SET BY CMD_TBL RETU ADDR FOR CN
*
*    WE SAVED STM   R5,R8,SAV_CN_REGS5_8
*    THEN DID BASR TO ONE OF THESE ADDR
*     NOT GOING TO USE THE REG9 CONTENTS SET IN BASR
*     THE LEGACY RETURN LABEL   IS CN_RET_FROM_OLD_CMD
*     THE RETURN LABEL FOR LCNC IS CN_CMD_PROCESSED
*      SO WE ARE GOING TO SAVE IT IN SAV_CN_CMD_RET9
*
         MVC   LNK2CH_NM,SPACE255
         CLC   CNC_CN_CP,F0   BIT CN ARE CP=0 CHAR IS NOT 0
         JE    LCNC_ERR_1
*
* THE CONTAINER STORAGE INFORMATION IS THE CURRENT ELEMENT
* LCNC CONTENTS REQUIRE KEY=VALUE PAIRS
*      CN_PGM=yyyy_anyname  identifies a CN with the link to pgmname
*      CN_LIST=zzzz_anyname identifies a CN holding a list of other
*        CN, which will be MOVEd to the DPL channel
*      CN_SYSID=wwww_anyname identifies a CN with SYSID for DPL
* Use program EKTRMPOS to parse the LCNCxxxx CN, returning K/V
*      data in a CN
         MVC   LNK2PGM_NM,SPACE255
         MVC   LNK2PGM_NM(L'LIT_EKTRMPOS),LIT_EKTRMPOS
* CREATE A NEW CHANNEL FOR EXTRMPOS
         XC    LCNC_LIST_ADR,LCNC_LIST_ADR
         XC    CN_MOVE_ADR,CN_MOVE_ADR
         MVC   LNK2CH_NM(8),LIT_EKTRMPOS
         MVC   LNK2CH_NM+8(5),=C'_LCNC'
*
*    COPY THE ORIG LCNC CN TO THE NEW CHANNEL
         MVC   CN_MOVE_NM,SPACE255
         MVC   GM_STG_FL,CNC_CN_L    THEN THE EXTRA BYTE IS SP FILLED
         JAS   R9,GM_STG           BY THE GET CN CMD
         LT    R9,GM_STG_ADR
         JZ    LCNC_ERR_1A
         ST    R9,CN_MOVE_ADR
*
         MVC   EXEC_CICS_FL,CNC_CN_L
         EXEC CICS GET CONTAINER(CNC_CN_N)                             *
             CHANNEL(CH_NM)                                            *
             INTO(0(0,R9))                                             *
             FLENGTH(EXEC_CICS_FL)                                     *
             RESP(FRESP)                                               *
             RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)
         JNE   LCNC_ERR_1B
*
         MVC   OPLIT,SPACE255
         MVC   OPLIT(L'PLAY_LS_MSG),PLAY_LS_MSG
         MVC   OPLIT+7(16),CNC_CN_N
         IILF  R15,L'OPLIT-L'PLAY_LS_MSG
         C     R15,EXEC_CICS_FL
         JL    LCNC_USE_OPLIT_L
         L     R15,EXEC_CICS_FL
*
LCNC_USE_OPLIT_L DS 0H
         BCTR  R15,0
         EXRL  R15,MVC_2_OPLIT
         AHI   R15,L'PLAY_LS_MSG+1
         ST    R15,PUT_APND_MSG_FL
         JAS   R9,WRIT_CMD_2_TDQ_OPLIT
         JAS   R9,PUT_APND_RESP_CN
         L     R9,CN_MOVE_ADR    RELOAD STG ADDR
*
*   MOVE THE DEFAULT LCNC ERROR MSG PREFIX NOW.
*     THEN MOVE EACH REASON TO POS 38 IN THE OPLIT
*
         MVC   OPLIT(L'DO_LCNC_ERR),DO_LCNC_ERR
*
         EXEC CICS PUT  CONTAINER(CNC_CN_N)                            *
              CHANNEL(LNK2CH_NM)                                       *
              FROM(0(0,R9))                                            *
              FLENGTH(EXEC_CICS_FL)                                    *
              RESP(FRESP)                                              *
              RESP2(FRESP2)
*
*
         CLC   FRESP,DFHRESP(NORMAL)  GET CN
         JNE   LCNC_ERR_2
*
LCNC_DO_EKTRMPOS DS 0H
         EXEC CICS LINK PROGRAM(LNK2PGM_NM)                            *
             CHANNEL(LNK2CH_NM)                                        *
             RESP(FRESP)                                               *
             RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)
         JNE   LCNC_ERR_3
*
* PROCESS THE EXPECTED CN (K=V PAIRS) ON THE CHANNEL
*  EXPECT CN NAMED: CN_LIST; CN_PGM; (OPT) CN_SYSID
*   IN WHICH EACH RESPECTIVE VALUE IS A CN
*   IT IS THIS RESPECTIVE VALUE, WHICH IDENTIFIES A SECOND CN
*   WHICH PROVIDES THE RESPECTIVE VALUE
*
         XC   LCNC_LIST_ADR,LCNC_LIST_ADR
         MVC  LCNC_LIST_CN,SPACE255
         MVC  EXEC_CICS_FL,F16
         MVC   CN_MOVE_NM,SPACE255
         MVC   CN_MOVE_NM(L'LIT_CN_LIST),LIT_CN_LIST
         EXEC CICS GET CONTAINER(CN_MOVE_NM)                           *
             CHANNEL(LNK2CH_NM)                                        *
             INTO(LCNC_LIST_CN)                                        *
             FLENGTH(EXEC_CICS_FL)                                     *
             RESP(FRESP)                                               *
             RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)
         JE    LCNC_GOT_CN_LIST0
*
         CLC   FRESP,DFHRESP(CONTAINERERR)
         JNE   LCNC_ERR_4A
*
         IILF  R15,L'LIT_LIST
         LA    R2,LIT_LIST
         JE    LCNC_GOT_CN_LIST1
*
LCNC_GOT_CN_LIST0 DS 0H
         L     R15,EXEC_CICS_FL
         LA    R2,LCNC_LIST_CN
*
LCNC_GOT_CN_LIST1 DS 0H
         BCTR  R15,0
         MVC   CN_MOVE_NM,SPACE255
         LA    R1,CN_MOVE_NM
         EXRL  R15,MVC_CN_NM_R1_R2
*
         EXEC CICS GET CONTAINER(CN_MOVE_NM)                           *
             CHANNEL(LNK2CH_NM)                                        *
             NODATA                                                    *
             FLENGTH(EXEC_CICS_FL)                                     *
             RESP(FRESP)                                               *
             RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)
         JNE   LCNC_ERR_4B
*
         MVC   LCNC_LIST_FL,EXEC_CICS_FL
         L     R15,EXEC_CICS_FL
         LA    R15,1(R15)        ADD 1 EXTRA BYTE FOR X'40' DELIM
         ST    R15,EXEC_CICS_FL    WHEN GET CN IS GT REAL LNG
         ST    R15,GM_STG_FL       THEN THE EXTRA BYTE IS SP FILLED
         JAS   R9,GM_STG           BY THE GET CN CMD
         LT    R9,GM_STG_ADR
         JZ    LCNC_ERR_4C
*
         ST    R9,LCNC_LIST_ADR
         EXEC CICS GET CONTAINER(CN_MOVE_NM)                           *
             CHANNEL(LNK2CH_NM)                                        *
             INTO(0(0,R9))                                             *
             FLENGTH(EXEC_CICS_FL)                                     *
             RESP(FRESP)                                               *
             RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)
         JNE   LCNC_ERR_4D
*
         MVI   LCNC_LIST_CN,C'@'
* TEST PLAY_CLONE_SAV_CH_NM - IF NOT X'00' JUMP TO LCNC_IN_PLAYLIST
*  BYPASS SYSID AND PROGRAM LCLC PROCESSING WHEN PLAYING LCNC
*  WE JUST WANT TO COPY THE CN IN THE LCNC LIST TO TMP CHANNEL
         CLI   PLAY_LCNC_REQUEST,X'00'
         JE    LCNC_GOT_CN_LIST
* END  PLAY_CLONE_SAV_CH_NM - IF NOT X'00' JUMP TO LCNC_IN_PLAYLIST
*
         MVC   CH_NM,PLAY_CLONE_SAV_CH_NM       SOURCE OF COPY
         MVC   LNK2CH_NM,PLAY_CLONE_TMP_CH_NM   DEST OF COPY
         J     LCNC_IN_PLAYLIST
*
* NOT A PLAYLIST REQUEST, NORMAL LCNC REQUEST
LCNC_GOT_CN_LIST DS 0H
         MVC   LNK2SYSD_NM,SPACE255
         MVC   LCNC_SYSD_CN,SPACE255
         MVC   EXEC_CICS_FL,F16
         MVC   CN_MOVE_NM,SPACE255
         MVC   CN_MOVE_NM(L'LIT_CN_SYSID),LIT_CN_SYSID
         EXEC CICS GET CONTAINER(CN_MOVE_NM)                           *
             CHANNEL(LNK2CH_NM)                                        *
             INTO(LCNC_SYSD_CN)                                        *
             FLENGTH(EXEC_CICS_FL)                                     *
             RESP(FRESP)                                               *
             RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)
         JE    LCNC_GOT_SYSID0
*
         CLC   FRESP,DFHRESP(CONTAINERERR)
         JNE   LCNC_NO_SYSD
*
         IILF  R15,L'LIT_SYSID
         LA    R2,LIT_SYSID
         JE    LCNC_GOT_SYSID1
*
LCNC_GOT_SYSID0 DS 0H
         L     R15,EXEC_CICS_FL
         LA    R2,LCNC_SYSD_CN
*
LCNC_GOT_SYSID1 DS 0H
         BCTR  R15,0
         MVC   CN_MOVE_NM,SPACE255
         LA    R1,CN_MOVE_NM
         EXRL  R15,MVC_CN_NM_R1_R2
*
         MVC   EXEC_CICS_FL,F4
         EXEC CICS GET CONTAINER(CN_MOVE_NM)                           *
             CHANNEL(LNK2CH_NM)                                        *
             INTO(LNK2SYSD_NM)                                         *
             FLENGTH(EXEC_CICS_FL)                                     *
             RESP(FRESP)                                               *
             RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)
         JNE   LCNC_NO_SYSD
*
         MVI  LCNC_SYSD_CN,C'@'
*
LCNC_NO_SYSD DS 0H
         CLC  LNK2SYSD_NM,SPACE255
         JNE  LCNC_GOT_SYSD
         MVC  LNK2SYSD_NM,LCL_SYSID  ALLOW FOR LCNC THIS SYSID
*
LCNC_GOT_SYSD DS 0H
         MVC   LNK2PGM_NM,SPACE255
         MVC   LCNC_PGM_CN,SPACE255
         MVC   EXEC_CICS_FL,F16
         MVC   CN_MOVE_NM,SPACE255
         MVC   CN_MOVE_NM(L'LIT_CN_PGM),LIT_CN_PGM
         EXEC CICS GET CONTAINER(CN_MOVE_NM)                           *
             CHANNEL(LNK2CH_NM)                                        *
             INTO(LCNC_PGM_CN)                                         *
             FLENGTH(EXEC_CICS_FL)                                     *
             RESP(FRESP)                                               *
             RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)
         JE    LCNC_GOT_PGM0
*
         CLC   FRESP,DFHRESP(CONTAINERERR)
         JNE   LCNC_NO_PGM
*
         IILF  R15,L'LIT_PGM
         LA    R2,LIT_PGM
         JE    LCNC_GOT_PGM1
*
LCNC_GOT_PGM0 DS 0H
         L     R15,EXEC_CICS_FL
         LA    R2,LCNC_PGM_CN
*
LCNC_GOT_PGM1 DS 0H
         BCTR  R15,0
         MVC   CN_MOVE_NM,SPACE255
         LA    R1,CN_MOVE_NM
         EXRL  R15,MVC_CN_NM_R1_R2
*
         MVC   EXEC_CICS_FL,F8
         EXEC CICS GET CONTAINER(CN_MOVE_NM)                           *
             CHANNEL(LNK2CH_NM)                                        *
             INTO(LNK2PGM_NM)                                          *
             FLENGTH(EXEC_CICS_FL)                                     *
             RESP(FRESP)                                               *
             RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)
         JNE   LCNC_NO_PGM
*
         MVI   LCNC_PGM_CN,C'@'
*
LCNC_NO_PGM DS 0H
         CLC   LNK2PGM_NM,SPACE255
         JNE   LCNC_GOT_PGM
         MVC   LNK2PGM_NM(L'PROGNAME),PROGNAME
*
LCNC_GOT_PGM DS 0H
         IILF  R0,X'40'
         MVC   LNK2CH_NM,SPACE255
         LA    R9,LNK2CH_NM
         LA    R15,LNK2PGM_NM
         MVST  R9,R15
         MVI   0(R9),C'_'
         MVC   1(4,R9),LCL_SYSID
*
*
* JUMP HERE WHEN PLAY_LCNC_REQUEST    IS NOT X00  - HAVE LCNC CN LIST
*   INDICATES THAT WE ARE PROCESSING LCNC FOR PLAYLIST
*   WE HAVE TO MOVE ALL CN FOR LCNC TO THE PLAY_CLONE_TMP_CH_NM
*   ONCE MOVED, WE RET TO PLAY LOGIC
* ALREADY SET LNK2CH_NM ABOVE WITH THE DEST CHANNEL NAME
* ALREADY SET CH_NM AS THE SOURCE CHANNEL
LCNC_IN_PLAYLIST DS 0H
*   DELETE ALL CN IN THE TEMP CHANNEL BECAUSE WE GOT INFO
         MVC   CH_DEL_NM,SPACE255
         MVC   CH_DEL_NM(8),LIT_EKTRMPOS
         MVC   CH_DEL_NM+8(5),=C'_LCNC'
         JAS   R9,CN_DEL_CH
*
         L     R2,LCNC_LIST_ADR
         L     R3,LCNC_LIST_FL
         AR    R3,R2
         MVI   0(R3),X'00'
*
LCNC_MOVE_CN2NEWCH DS 0H
         LA    R4,CN_MOVE_NM        RESET ST OF TGT FLD ADR
         MVC   CN_MOVE_NM,SPACE255  SET TO SPACES
         XR    R5,R5                CNT OF BYTES FOR CN LNG
LCNC_MOVE_CN_CHR DS 0H
         CLI   0(R2),C' '
         JE    LCNC_MOVE_GOT_DLM
         CLI   0(R2),C','
         JE    LCNC_MOVE_GOT_DLM
         LA    R5,1(R5)            TST CN NM 1-16 CHAR
         CHI   R5,16
         JH    LCNC_MOVE_BYP       TOO MANY, SO DON'T MOVE
         MVC   0(1,R4),0(R2)       OK, MOVE CN BYTE
LCNC_MOVE_BYP DS 0H
         LA    R4,1(R4)         BUMP TGT
         LA    R2,1(R2)         BUMP SRC
         CR    R2,R3            TST END
         JL    LCNC_MOVE_CN_CHR
*
LCNC_MOVE_GOT_DLM DS 0H
         LTR   R5,R5
         JZ    LCNC_MOVE_BYP_EMPTY
         MVI   0(R2),X'00'     FORCE DELIM TO X'00'
* COPY THE CN FROM THE SOURCE CH TO THE DEST CH
*  NOTE THE FROM/TO CH FOR PLAY LCNC CMD INITIALIZED CH_NM/LNK2CH_NM
         MVC   CN_COPY_NM_FROM,CN_MOVE_NM
         MVC   CN_COPY_NM_TO,CN_MOVE_NM
         MVC   CH_COPY_NM_FROM,CH_NM
         MVC   CH_COPY_NM_TO,LNK2CH_NM
         XR    R15,R15
         JAS   R9,CN_COPY     COPY SINGLE CN
         LTR   R15,R15
         JM    LCNC_ERR_11
*
*
LCNC_MOVE_BYP_EMPTY DS 0H
         LA    R2,1(R2)         BUMP PAST DLM
         CR    R2,R3            TST END
         JL    LCNC_MOVE_CN2NEWCH
*
* JUMP BACK TO THE PLAY LOGIC
* TEST PLAY_CLONE_SAV_CH_NM - IF NOT NULL, JUMP TO  LCNC_FIN0
         CLI   PLAY_LCNC_REQUEST,X'00'
         JE    LCNC_NOT_CN_LIST
*
         MVC   CH_NM,PLAY_CLONE_TMP_CH_NM  RESET CN_NM TO PLAY TMP CH
         J     LCNC_FIN0
*
LCNC_NOT_CN_LIST DS 0H
         ZAP   MYABSTM,PZERO
         EXEC CICS ASKTIME ABSTIME(MYABSTM) NOHANDLE
*
         EXEC CICS LINK PROGRAM(LNK2PGM_NM)                            *
             CHANNEL(LNK2CH_NM)                                        *
             SYSID(LNK2SYSD_NM)                                        *
             RESP(FRESP)                                               *
             RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)
         JNE   LCNC_ERR_12
*
         ZAP   MYABSTM,PZERO
         EXEC CICS ASKTIME ABSTIME(MYABSTM1) NOHANDLE
*
* %%%%
         JAS   R9,CNC_GET_CN_CHR
*        IC    R15,LCNC_CLONE_PFX_ELEM_CT  EF-F8
*        LA    R15,1(R15)                  MAKING
*        STC   R15,LCNC_CLONE_PFX_ELEM_CT  F0-F9
*
         XR   R15,R15
         MVC  CH_MOVE_NM_FROM,LNK2CH_NM
         MVC  CH_MOVE_NM_TO,CH_NM
         JAS  R9,CN_MOVE_2_CUR_CH
         LTR  R15,R15
         JP   LCNC_ERR_13
* %%%%
         EXEC CICS FORMATTIME ABSTIME(MYABSTM)                         *
              YYYYDDD(TIMER_DPL_ST_JDT)  DATESEP('-')                  *
              TIME(TIMER_DPL_ST_TOD)  TIMESEP(':')
         EXEC CICS FORMATTIME ABSTIME(MYABSTM1)                        *
              YYYYDDD(TIMER_DPL_SP_JDT)  DATESEP('-')                  *
              TIME(TIMER_DPL_SP_TOD)  TIMESEP(':')
*
         MVC   OPLIT(L'DO_LCNC_MSG),DO_LCNC_MSG
         MVC   OPLIT+9(8),TIMER_DPL_ST_TOD
         MVC   OPLIT+22(8),LNK2PGM_NM
         MVC   OPLIT+36(8),LNK2CH_NM
         MVC   OPLIT+59(4),LNK2SYSD_NM
         MVC   OPLIT+68(8),TIMER_DPL_SP_TOD
         J     LCNC_DONE
*
LCNC_ERR_1    DS 0H
         MVC  OPLIT+38(L'LCNC_ERR_CP),LCNC_ERR_CP
         J     LCNC_DONE
*
LCNC_ERR_1A   DS 0H
         MVC  OPLIT+38(L'LCNC_ERR_GMCN),LCNC_ERR_GMCN
         MVC  OPLIT+63(16),CNC_CN_N
         MVI  OPLIT+79,C':'
         J     LCNC_DONE
*
LCNC_ERR_1B   DS 0H
         MVC  OPLIT+38(L'LCNC_ERR_GPCN),LCNC_ERR_GPCN
         MVC  OPLIT+63(16),CNC_CN_N
         MVI  OPLIT+79,C':'
         J     LCNC_DONE
*
LCNC_ERR_2    DS 0H
         MVC  OPLIT+38(L'LCNC_ERR_PPCN),LCNC_ERR_PPCN
         MVC  OPLIT+63(16),CNC_CN_N
         J     LCNC_DONE
*
LCNC_ERR_3    DS 0H
         MVC  OPLIT+38(L'LCNC_ERR_LKV),LCNC_ERR_LKV
         J     LCNC_DONE
*
LCNC_ERR_4A   DS 0H      CN_LIST
         MVC  OPLIT+38(L'LCNC_ERR_GKVL),LCNC_ERR_GKVL
         MVI  OPLIT+38+2,C'A'
         J     LCNC_DONE
*
LCNC_ERR_4B   DS 0H         LIST
         MVC  OPLIT+38(L'LCNC_ERR_GKVL),LCNC_ERR_GKVL
         MVI  OPLIT+38+2,C'B'
         MVC  OPLIT+38+26(3),=C'ND '
         MVC  OPLIT+63(3),SPACE255
         J     LCNC_DONE
*
LCNC_ERR_4C   DS 0H
         MVC  OPLIT+38(L'LCNC_ERR_LSTE),LCNC_ERR_LSTE
         MVI  OPLIT+38+2,C'C'
         MVC  OPLIT+63(16),LCNC_LIST_CN
         MVI  OPLIT+79,C':'
         J     LCNC_DONE
*
LCNC_ERR_4D   DS 0H
         MVC  OPLIT+38(L'LCNC_ERR_LSTE),LCNC_ERR_LSTE
         MVI  OPLIT+38+2,C'D'
         MVC  OPLIT+63(16),LCNC_LIST_CN
         MVI  OPLIT+79,C':'
         J     LCNC_DONE
*
LCNC_ERR_5    DS 0H
         MVC  OPLIT+38(L'LCNC_ERR_GKVP),LCNC_ERR_GKVP
         J     LCNC_DONE
*
LCNC_ERR_6    DS 0H
         MVC  OPLIT+38(L'LCNC_ERR_GKVS),LCNC_ERR_GKVS
         J     LCNC_DONE
*
LCNC_ERR_7    DS 0H
         MVC  OPLIT+38(L'LCNC_ERR_GPGM),LCNC_ERR_GPGM
         MVC  OPLIT+63(8),LNK2PGM_NM
         MVI  OPLIT+72,C':'
         J     LCNC_DONE
*
LCNC_ERR_8    DS 0H
         MVC  OPLIT+38(L'LCNC_ERR_GSYD),LCNC_ERR_GSYD
         MVC  OPLIT+63(4),LNK2SYSD_NM
         MVI  OPLIT+68,C':'
         J     LCNC_DONE
*
LCNC_ERR_9    DS 0H
         MVC  OPLIT+38(L'LCNC_ERR_GLST),LCNC_ERR_GLST
         MVC  OPLIT+63(16),LCNC_LIST_CN
         MVI  OPLIT+79,C':'
         J     LCNC_DONE
*
LCNC_ERR_10   DS 0H
         MVC  OPLIT+38(L'LCNC_ERR_LSTE),LCNC_ERR_LSTE
         MVC  OPLIT+63(16),LCNC_LIST_CN
         MVI  OPLIT+79,C':'
         J     LCNC_DONE
*
LCNC_ERR_11   DS 0H
         MVC  OPLIT+38(L'LCNC_ERR_M2CH),LCNC_ERR_M2CH
         MVC  OPLIT+63(16),CN_MOVE_NM
         MVI  OPLIT+79,C':'
         J     LCNC_DONE
*
LCNC_ERR_12   DS 0H
         MVC  OPLIT+38(L'LCNC_ERR_LINK),LCNC_ERR_LINK
         MVC  OPLIT+63(8),LNK2PGM_NM
         MVI  OPLIT+72,C':'
         J     LCNC_DONE
*
LCNC_ERR_13   DS 0H
         MVC  OPLIT+38(L'LCNC_ERR_MBAK),LCNC_ERR_MBAK
         J     LCNC_DONE
LCNC_DONE DS  0H
         IILF  R0,80
         ST    R0,PUT_APND_MSG_FL
         JAS   R9,WRIT_CMD_2_TDQ_OPLIT
         JAS   R9,PUT_APND_RESP_CN
         J     LCNC_FIN
* RESTORE THE REGS SAVE BEFORE BASR AT  CN_RET_FROM_OLD_CMD
*  AND USE THE RETURN ADDR SAVED FOR RETURN TO  CN_CMD_PROCESSED
*  BYPASSING LEGACY CODE TO COPY CA BACK TO CN
*
LCNC_FIN DS 0H
LCNC_FIN0 DS 0H
         LT    R9,LCNC_LIST_ADR
         JZ    LCNC_FIN1
*
         EXEC CICS FREEMAIN DATAPOINTER(R9)                            *
               NOHANDLE
         XC    LCNC_LIST_ADR,LCNC_LIST_ADR
*
LCNC_FIN1 DS 0H
         LT    R9,CN_MOVE_ADR
         JZ    LCNC_FIN2
*
         EXEC CICS FREEMAIN DATAPOINTER(R9)                            *
               NOHANDLE
         XC    CN_MOVE_ADR,CN_MOVE_ADR
*
LCNC_FIN2 DS 0H
         LM    R4,R8,SAV_LCNC_REGS4_8
         L     R9,SAV_CN_LCNC_RET9       CN_CMD_PROCESSED
         BR    R9
*
*
* END LCNC @@@@@@
*
* LINK TO COBOL RAND NUMBER GEN WITH CHANNEL NM(UCEMPINR________)
*  WHERE ________ IS THE FIRST 8 CHAR OF THE CRND CONTAINER
*
DO_CRND DS 0H
*    WE SAVED STM   R5,R8,SAV_CN_REGS5_8
*    THEN DID BASR TO ONE OF THESE ADDR
*     NOT GOING TO USE THE REG9 CONTENTS SET IN BASR
*     THE LEGACY RETURN LABEL   IS CN_RET_FROM_OLD_CMD
*     THE RETURN LABEL FOR CRND IS CN_CMD_PROCESSED
*      SO WE ARE GOING TO SAVE IT IN SAV_CN_CMD_RET9
*
*        LARL  R9,CN_CMD_PROCESSED
*   R9 SET BY CMD_TBL RETU ADDR FOR CN
         ST    R9,SAV_CN_CMD_RET9
         XR    R15,R15
* THE CONTAINER STORAGE INFORMATION IS THE CURRENT ELEMENT
*  CHECK THE COMMAND LENGTH.
*  FOR CRND THE LENGTH MUST BE > 0 AND < 26
* CAN BE ANY DATA ALONG WITH SEED AND NUMB CONTAINERS
*  SEEDNNNN CONTAINER WHERE NNNN IS THE CRNDNNNN SUFFIX
*   CONTENTS IS CHAR CONTAINER SEED=DDDDDDDDDD  (1-10 DEC NUMBERS)
*               BIT  CONTAINER XXXX  (FW BIN VALUE)
*  NUMBNNNN CONTAINER WHERE NNNN IS THE CRNDNNNN SUFFIX
*   CONTENTS IS CHAR CONTAINER NUMB=DDDDD       (1-5 DEC NUMBERS)
*               BIT  CONTAINER XXXX  (FW BIN VALUE)
*
*  OR CAN BE THE ONLY CHAR CONTAINER IN FORM:
*  SEED=DDDDDDDDDD,NUMB=DDDDD
*
         CLC   CNC_CN_CP,F0   BIT CN ARE CP=0 CHAR IS NOT 0
         JE    CRND_NOT_CHAR
*
         MVC   CN_CMD_ASSOCIATES,CNC_CN_N   PRESERVE CMD CN
         MVC   LNK2PGM_NM,LIT_UCEMRAN0      GET THE LINK TO PGM
         MVC   LNK2CH_NM(8),LNK2PGM_NM      CREATE NEW CHANNEL NM
         MVC   LNK2CH_NM+8(8),CN_NM
*
*  NEW LOGIC - COPY JUST THE POSSIBLE SEEDXXXX AND OR NUMBXXXX
*   CONTAINERS (IF THEY EXIST)
*  THE UCEMRAN0 PROGRAM LOOKS FOR THEM ON THE (NEW) CHANNEL
         MVC   CH_COPY_NM_FROM,CH_NM
         MVC   CH_COPY_NM_TO,LNK2CH_NM
         MVC   CN_COPY_NM_FROM,CNC_CN_N
         MVC   CN_COPY_NM_FROM(4),LIT_SEED
         MVC   CN_COPY_NM_TO,CN_COPY_NM_FROM
         XR    R15,R15          CLEAR R15 - NO CN LNG
         JAS   R9,CN_COPY
         MVC   CN_COPY_NM_FROM(4),LIT_NUMB
         MVC   CN_COPY_NM_TO,CN_COPY_NM_FROM
         XR    R15,R15          CLEAR R15 - NO CN LNG
         JAS   R9,CN_COPY
* BYPASS THE FOLLOWING - NOT NEEDED - REMOVE WHEN TESTED
*   get all ukn cn and move them to a new channel
*   for crnd, the cmd cn name pos 5-16 are matched to ukn
*    cn. when they match, we look for seed and numb prefix cn names
*    which are associated with the crnd cmd cn.
*        JAS   R9,CN_MV_UKN_CN        GET THE ASSOC UKN CNS IF ANY
*
*        CIJNE R15,0,CRND_MOV_ERR     PROBLEM WITH A MOVE UKN CN
* BYPASS THE ABOVE   G - NOT NEEDED - REMOVE WHEN TESTED
*
*    MOVE THE ORIG CN  TO THE NEW CHANNEL
         EXEC CICS MOVE CONTAINER(CNC_CN_N) CHANNEL(CH_NM)             *
              AS(CNC_CN_N) TOCHANNEL(LNK2CH_NM)                        *
              RESP(FRESP)                                              *
              RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)  GET CN
         JNE   CRND_MOV_ERR
*
CRNC_DO_LINK DS 0H
         EXEC CICS LINK PROGRAM(LNK2PGM_NM)                            *
             CHANNEL(LNK2CH_NM)                                        *
             RESP(FRESP)                                               *
             RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)    LINK PARS
         JE    CRND_DO_SHA
*
         MVC   OPLIT(L'CN_CRND_LNK_FAIL_MSG),CN_CRND_LNK_FAIL_MSG
         L     R15,FRESP
         JAS   R9,B2C
         MVC   OPLIT+42(4),HLDSTR+3
         L     R15,FRESP2
         JAS   R9,B2C
         MVC   OPLIT+53(4),HLDSTR+3
         IILF  R0,L'CN_CRND_LNK_FAIL_MSG
         ST    R0,PUT_APND_MSG_FL
         JAS   R9,PUT_APND_RESP_CN
         J     CRND_MOV_NEWCH2OLDCH
*
CRND_DO_SHA DS 0H
*    MOVE THE new  CN  TO THE orig CHANNEL
         EXEC CICS MOVE CONTAINER(CNC_CN_N) CHANNEL(LNK2CH_NM)         *
              AS(CNC_CN_N) TOCHANNEL(CH_NM)                            *
              RESP(FRESP)                                              *
              RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)
         JNE   CRND_CN_MOVCRND_ERR
*
         EXEC CICS GET CONTAINER(CNC_CN_N) CHANNEL(CH_NM)              *
              SET(R9)         FLENGTH(CNC_CN_L)                        *
              RESP(FRESP)                                              *
              RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)  GET CN
         JNE   CRND_NO_RESP
*
         MVC   OPLIT(L'CN_CRND_OK_RESP_MSG),CN_CRND_OK_RESP_MSG
         MVC   OPLIT+4(16),CNC_CN_N
         L     R15,CNC_CN_L
         IILF  R2,L'OPLIT
         AHI   R2,-24
         CRJL  R15,R2,CRND_USE_CN_L
         LR    R15,R2
CRND_USE_CN_L DS 0H
         LA    R2,OPLIT+25
         BCTR  R15,0
         EXRL  R15,CRND2OPLIT
*
         IILF  R0,L'CN_CRND_OK_RESP_MSG
         ST    R0,PUT_APND_MSG_FL
         JAS   R9,WRIT_CMD_2_TDQ_OPLIT
         JAS   R9,PUT_APND_RESP_CN
*
         J     CRND_MOV_NEWCH2OLDCH
*
CRND2OPLIT MVC   0(0,R2),0(R9)
*
* WE HAVE TO MOVE THE RETURNED CONTAINERS FROM THE NEW CHANNEL
*  BACK TO THE OLD CHANNEL. DO THIS WITH A BROWSE AND MOVE.
*
CRND_MOV_NEWCH2OLDCH DS 0H
         EXEC CICS STARTBROWSE CONTAINER CHANNEL(LNK2CH_NM)            *
         BROWSETOKEN(CN_BRS_TKN)                                       *
         RESP(FRESP)                                                   *
         RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)    CH STBR
         JNE   CRND_BAD_START_BRS   JUMP THERE AND QUIT
*
CRND_TOP_MV_CN2CURRCH DS 0H
         EXEC CICS GETNEXT CONTAINER(CN_CMD_ASSOCIATES)                *
          BROWSETOKEN(CN_BRS_TKN)                                      *
          RESP(FRESP)                                                  *
          RESP2(FRESP2)
*
         XR    R15,R15              GET NXT CN
         CLC   FRESP,DFHRESP(END)
         JE    CRND_GOT_ALL_CN
*
         CLC   FRESP,DFHRESP(NORMAL)
         JNE   CRND_CN_BRS_GETN_ERR
*
         CLC   LIT_SEED,CN_CMD_ASSOCIATES
         JE    CRND_TOP_MV_CN2CURRCH
*
         CLC   LIT_NUMB,CN_CMD_ASSOCIATES
         JE    CRND_TOP_MV_CN2CURRCH
*
*  MOVE CN FROM TEMP CH TO CUR CH CONTAINER
         EXEC CICS MOVE CONTAINER(CN_CMD_ASSOCIATES)                   *
          CHANNEL(LNK2CH_NM) AS(CN_CMD_ASSOCIATES)                     *
          TOCHANNEL(CH_NM)                                             *
          RESP(FRESP)                                                  *
          RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)
         JNE   CRND_CN_MOV2CURR_ERR
*  DERIVE THE SHA VALUES, WRIT TO TDQ AND
*    CREATE RETURN CN FOR EACH SHA
         CLC   CN_CMD_ASSOCIATES(4),LIT_BRAN
         JE    CRND_GOT_RAND_CN
         CLC   CN_CMD_ASSOCIATES(4),LIT_CRAN
         JNE   CRND_TOP_MV_CN2CURRCH
*
CRND_GOT_RAND_CN DS 0H
         EXEC CICS GET  CONTAINER(CN_CMD_ASSOCIATES)                   *
          CHANNEL(CH_NM)                                               *
          SET(R9)  FLENGTH(CN_MSG_L)                                   *
          RESP(FRESP)                                                  *
          RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)
         JNE   CRND_CN_GET4SH_ERR
*
         ST    R9,CN_MSG_A
         JAS   R9,DO_CRYING
*
* PUT CONTAINER SHA1
*  CREATE THE X2CX STRING FROM THE SHA X VALUES
         IILF  R15,KIMDF1_PARML      THE LNG OF THE INPUT SHA
         AR    R15,R15               DBL IT FOR X2CX OUTPUT LNG
         ST    R15,EXEC_CICS_FL
*  KLMDF1_X2CXL HAS THE X2CX STRING
         MVC   CN_CMD_ASSOCIATES,CN_CMD_ASSOCIATES
         MVC   CN_CMD_ASSOCIATES+1(3),LIT_SHA
         EXEC CICS PUT CONTAINER(CN_CMD_ASSOCIATES) CHANNEL(CH_NM)     *
              FROM(KLMDF1_X2CXL) FLENGTH(EXEC_CICS_FL)                 *
              CHAR                                                     *
              RESP(FRESP)                                              *
              RESP2(FRESP2)
         CLC   FRESP,DFHRESP(NORMAL)    PUT RESP CN
         JNE   CRND_CN_PUT_SHA_ERR
*
         MVC   OPLIT,SPACE255
         MVC   OPLIT(4),CN_CMD_ASSOCIATES
         MVI   OPLIT+4,C':'
         LA    R9,KLMDF1_X2CXL      SRC OF SHA X2CX
         LA    R2,OPLIT+5           DEST IN OPLIT
         L     R15,EXEC_CICS_FL     LNG OF THIS MVC
         BCTR  R15,0
         EXRL  R15,CRND2OPLIT
*
         LA    R15,6(,R15)
         ST    R15,PUT_APND_MSG_FL
         JAS   R9,WRIT_CMD_2_TDQ_OPLIT
         JAS   R9,PUT_APND_RESP_CN
*
* PUT CONTAINER SHA256
*  CREATE THE X2CX STRING FROM THE SHA X VALUES
         IILF  R15,KIMDF2_PARML      THE LNG OF THE INPUT SHA
         AR    R15,R15               DBL IT FOR X2CX OUTPUT LNG
         ST    R15,EXEC_CICS_FL
*  KLMDF2_X2CXL HAS THE X2CX STRING
         MVC   CN_CMD_ASSOCIATES+1(3),LIT_SHA256
         EXEC CICS PUT CONTAINER(CN_CMD_ASSOCIATES) CHANNEL(CH_NM)     *
              FROM(KLMDF2_X2CXL) FLENGTH(EXEC_CICS_FL)                 *
              CHAR                                                     *
              RESP(FRESP)                                              *
              RESP2(FRESP2)
         CLC   FRESP,DFHRESP(NORMAL)    PUT RESP CN
         JNE   CRND_CN_PUT_SHA_ERR
*
         MVC   OPLIT,SPACE255
         MVC   OPLIT(4),CN_CMD_ASSOCIATES
         MVI   OPLIT+4,C':'
         LA    R9,KLMDF2_X2CXL      SRC OF SHA X2CX
         LA    R2,OPLIT+5           DEST IN OPLIT
         L     R15,EXEC_CICS_FL     LNG OF THIS MVC
         BCTR  R15,0
         EXRL  R15,CRND2OPLIT
*
         LA    R15,6(,R15)
         ST    R15,PUT_APND_MSG_FL
         JAS   R9,WRIT_CMD_2_TDQ_OPLIT
         JAS   R9,PUT_APND_RESP_CN
*
* PUT CONTAINER SHA512
*  CREATE THE X2CX STRING FROM THE SHA X VALUES
         IILF  R15,KIMDF3_PARML      THE LNG OF THE INPUT SHA
         AR    R15,R15               DBL IT FOR X2CX OUTPUT LNG
         ST    R15,EXEC_CICS_FL
*  KLMDF3_X2CXL HAS THE X2CX STRING
         MVC   CN_CMD_ASSOCIATES+1(3),LIT_SHA512
         EXEC CICS PUT CONTAINER(CN_CMD_ASSOCIATES) CHANNEL(CH_NM)     *
              FROM(KLMDF3_X2CXL) FLENGTH(EXEC_CICS_FL)                 *
              CHAR                                                     *
              RESP(FRESP)                                              *
              RESP2(FRESP2)
         CLC   FRESP,DFHRESP(NORMAL)    PUT RESP CN
         JNE   CRND_CN_PUT_SHA_ERR
*
         MVC   OPLIT,SPACE255
         MVC   OPLIT(4),CN_CMD_ASSOCIATES
         MVI   OPLIT+4,C':'
         LA    R9,KLMDF3_X2CXL      SRC OF SHA X2CX
         LA    R2,OPLIT+5           DEST IN OPLIT
         L     R15,EXEC_CICS_FL     LNG OF THIS MVC
         BCTR  R15,0
         EXRL  R15,CRND2OPLIT
*
         LA    R15,6(,R15)
         ST    R15,PUT_APND_MSG_FL
         JAS   R9,WRIT_CMD_2_TDQ_OPLIT
         JAS   R9,PUT_APND_RESP_CN
*
         J     CRND_TOP_MV_CN2CURRCH
*
CRND_CN_PUT_SHA_ERR DS 0H
         MVC   OPLIT(L'CRND_CN_PUT_SHA_MSG),CRND_CN_PUT_SHA_MSG
         MVC   OPLIT+12(16),CN_CMD_ASSOCIATES
         L     R15,FRESP
         JAS   R9,B2C
         MVC   OPLIT+64(5),HLDSTR+3
         L     R15,FRESP2
         JAS   R9,B2C
         MVC   OPLIT+76(5),HLDSTR+3
*
         IILF  R0,L'CRND_CN_PUT_SHA_MSG
         ST    R0,PUT_APND_MSG_FL
         JAS   R9,PUT_APND_RESP_CN
*
         J     CRND_TOP_MV_CN2CURRCH
*
CRND_CN_GET4SH_ERR DS 0H
         MVC   OPLIT(L'CRND_CN_GET4SH_MSG),CRND_CN_GET4SH_MSG
         MVC   OPLIT+12(16),CN_CMD_ASSOCIATES
         L     R15,FRESP
         JAS   R9,B2C
         MVC   OPLIT+64(5),HLDSTR+3
         L     R15,FRESP2
         JAS   R9,B2C
         MVC   OPLIT+76(5),HLDSTR+3
*
         IILF  R0,L'CRND_CN_GET4SH_MSG
         ST    R0,PUT_APND_MSG_FL
         JAS   R9,PUT_APND_RESP_CN
*
         J     CRND_TOP_MV_CN2CURRCH
*
CRND_CN_MOVCRND_ERR DS 0H
         MVC   OPLIT(L'CRND_CN_MOV2CURR_MSG),CRND_CN_MOV2CURR_MSG
         L     R15,FRESP
         JAS   R9,B2C
         MVC   OPLIT+64(5),HLDSTR+3
         L     R15,FRESP2
         JAS   R9,B2C
         MVC   OPLIT+76(5),HLDSTR+3
*
         IILF  R0,L'CRND_CN_MOV2CURR_MSG
         ST    R0,PUT_APND_MSG_FL
         JAS   R9,PUT_APND_RESP_CN
*
         J     CRND_MOV_NEWCH2OLDCH
*
*
CRND_CN_MOV2CURR_ERR DS 0H
         MVC   OPLIT(L'CRND_CN_MOV2CURR_MSG),CRND_CN_MOV2CURR_MSG
         L     R15,FRESP
         JAS   R9,B2C
         MVC   OPLIT+64(5),HLDSTR+3
         L     R15,FRESP2
         JAS   R9,B2C
         MVC   OPLIT+76(5),HLDSTR+3
*
         IILF  R0,L'CRND_CN_MOV2CURR_MSG
         ST    R0,PUT_APND_MSG_FL
         JAS   R9,PUT_APND_RESP_CN
*
         J     CRND_TOP_MV_CN2CURRCH
*
CRND_GOT_ALL_CN DS 0H
         EXEC CICS ENDBROWSE CONTAINER                                 *
            BROWSETOKEN(CN_BRS_TKN)                                    *
            RESP(FRESP)                                                *
            RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)    ENDBR CH
         JE    CRND_ARND_ENDBR
*
         MVC   OPLIT(L'BAD_END_BRS_MSG),BAD_END_BRS_MSG
         L     R15,FRESP
         JAS   R9,B2C
         MVC   OPLIT+45(5),HLDSTR+3
         L     R15,FRESP2
         JAS   R9,B2C
         MVC   OPLIT+58(5),HLDSTR+3
*
         IILF  R0,L'BAD_END_BRS_MSG
         ST    R0,PUT_APND_MSG_FL
         JAS   R9,PUT_APND_RESP_CN
*
CRND_ARND_ENDBR DS 0H
         MVC   CH_DEL_NM,LNK2CH_NM
         JAS   R9,CN_DEL_CH
         J     CRND_FIN
*
*   BROWSE CN GETNEXT FAILED - WE ARE DONE
CRND_CN_BRS_GETN_ERR DS 0H   BAD_GETN_BRS_MSG
         MVC   OPLIT(L'BAD_GETN_BRS_MSG),BAD_GETN_BRS_MSG
         L     R15,FRESP
         JAS   R9,B2C
         MVC   OPLIT+45(5),HLDSTR+3
         L     R15,FRESP2
         JAS   R9,B2C
         MVC   OPLIT+58(5),HLDSTR+3
*
         IILF  R0,L'BAD_GETN_BRS_MSG
         ST    R0,PUT_APND_MSG_FL
         JAS   R9,PUT_APND_RESP_CN
*
         J     CRND_FIN            JUMP THERE AND QUIT
CRND_BAD_START_BRS DS 0H
         MVC   OPLIT(L'BAD_START_BRS_MSG),BAD_START_BRS_MSG
         L     R15,FRESP
         JAS   R9,B2C
         MVC   OPLIT+45(5),HLDSTR+3
         L     R15,FRESP2
         JAS   R9,B2C
         MVC   OPLIT+58(5),HLDSTR+3
*
         IILF  R0,L'BAD_START_BRS_MSG
         ST    R0,PUT_APND_MSG_FL
         JAS   R9,PUT_APND_RESP_CN
         J     CRND_FIN
*
CRND_MOV_ERR DS 0H
         MVC   OPLIT(L'MOV_UKN_FAIL_MSG),MOV_UKN_FAIL_MSG
         MVC   OPLIT+73(16),LNK2CH_NM
         MVC   OPLIT+99(16),CN_CMD_ASSOCIATES
         IILF  R0,L'MOV_UKN_FAIL_MSG
         ST    R0,PUT_APND_MSG_FL
         JAS   R9,PUT_APND_RESP_CN
         J     CRND_FIN
*
CRND_NOT_CHAR  DS 0H
         MVC   OPLIT(L'CN_CRND_BIT_MSG),CN_CRND_BIT_MSG
         MVC   OPLIT+40(16),CNC_CN_N
         IILF  R0,L'CN_CRND_BIT_MSG
         ST    R0,PUT_APND_MSG_FL
         JAS   R9,PUT_APND_RESP_CN
         J     CRND_FIN
*
CRND_NO_RESP   DS 0H
         MVC   OPLIT(L'CN_CRND_NO_RESP_MSG),CN_CRND_NO_RESP_MSG
         MVC   OPLIT+4(16),CNC_CN_N
         L     R15,FRESP 1
         JAS   R9,B2C
         MVC   OPLIT+57(4),HLDSTR+3
         L     R15,FRESP2
         JAS   R9,B2C
         MVC   OPLIT+69(4),HLDSTR+3
         IILF  R0,L'CN_CRND_NO_RESP_MSG
         ST    R0,PUT_APND_MSG_FL
         JAS   R9,PUT_APND_RESP_CN
         J     CRND_FIN
*
* RESTORE THE REGS SAVE BEFORE BASR AT  CN_RET_FROM_OLD_CMD
*  AND USE THE RETURN ADDR SAVED FOR RETURN TO  CN_CMD_PROCESSED
*  BYPASSING LEGACY CODE TO COPY CA BACK TO CN
*
CRND_FIN DS 0H
         LM    R5,R8,SAV_CN_REGS5_8
         L     R9,SAV_CN_CMD_RET9        CN_CMD_PROCESSED
         BR    R9
*
* BASED ON THE CMD CN NAME IN CN_CMD_ASSOCIATES, SEARCH FOR ALL
*  ASSOCIATED UNKNOWN CN, AND MOVE THE CN AS THE SAME NAME TO
*  THE NEW CHANNEL NAME IN LNK2CH_NM
* EG:MVC   CN_CMD_ASSOCIATES,CN_NM
*    MVC   LNK2CH_NM(8),LIT_UCEMRAN0
*    MVC   LNK2CH_NM+8(8),CN_NM
*
CN_MV_UKN_CN   DS 0H
         ST    R9,SAV_CN_UKN_RET9
         STM   R4,R7,SAV_CN_UKN4_7
         XR    R15,R15
*  %HERE WE GO CNC - LOOK FOR ASSOCIATED CN TO CMD CN_NM
*   FIRST FOUR CHARACTERS ARE DIFFERENT, BUT SUFFIX IS SAME
         L     R6,CN_GM_UKN_ANCH    PTR TO FIRST CN STK
*        LTR   R6,R6
*        JZ    CN_NO_UKNS          USING R6,
         CIJE  R6,0,CN_NO_UKNS      ANCH IS ZEROS; NO UKNS
*
*        USING CNC_CN,R6           R6 IS THE STK ANCH - USING SET
         L     R7,CNC_CN_LIST_ELEM_TOP    CUR STK, FIRST ELEM ADR
         ST    R7,CN_CUR_CN_UKNE          SAVE THE CUR ELEM ENTRY
*        USING CNC_CN_ELEM,R7      R7 IS THE ELEM ADR - USING SET
CN_SRCH_UKN_ETOP  DS 0H
         CLC   CN_CMD_ASSOCIATES+4(12),CNC_CN_N+4
         JNE   CN_PROCUKN_NXT_STK
* GOT AN ASSOCIATE UNK CN
         EXEC CICS MOVE CONTAINER(CNC_CN_N) CHANNEL(CH_NM)             *
              AS(CNC_CN_N) TOCHANNEL(LNK2CH_NM)                        *
              RESP(FRESP)                                              *
              RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)  GET CN
         JNE   CN_MOVE_UNK_CN_FAIL
*
         L     R9,CN_GM_UKN_TOT_PROCD
         AHI   R9,1
         ST    R9,CN_GM_UKN_TOT_PROCD
         C     R9,CN_GM_UKN_CUR_CT       ALL CMDS PROCESSED?
         JNL   CN_FIN_UKN_ELEM           YES , WE ARE DONE
         L     R9,CN_GM_UKN_STK_PROCD    HOW MANY ELEM FROM THIS STAK
         AHI   R9,1                      WERE PROCESSED. AT MAX?
         C     R9,CNC_CN_LIST_ELEM_CUR_CT
         JNL   CN_PROCUKN_NXT_STK        YES SO GO TO GET NXT STK
         ST    R9,CN_GM_UKN_STK_PROCD
         AHI   R7,CNC_CN_ENT_L   STILL IN ELEM LIST ON CUR STK
         J     CN_SRCH_UKN_ETOP     SO ADD LNG OF ELEM TO GET NEXT ELEM
*
CN_PROCUKN_NXT_STK DS  0H    GET THE NEXT STACK AREA
*    STILL HAVE:USING CNC_CN,R6
*               USING CNC_CN_ELEM,R7
*                  ZERO STK ELEM COUNTER
         XC    CN_GM_UKN_STK_PROCD,CN_GM_UKN_STK_PROCD
         L     R6,CNC_CN_LIST_NXT       PT TO NXT STK
         CIJE  R6,0,CN_FIN_UKN_ELEM     MAKE SURE IT EXISTS
*                 IF NXT IS ZEROS, THEN NO MORE STK
*                 IF IT DOES, THEN AT LEAST ONE CMD IN NXT STK
*                  SO SET UP FOR FIRST ELEM
         L     R7,CNC_CN_LIST_ELEM_TOP    CUR STK, FIRST ELEM ADR
         C     R9,CNC_CN_LIST_ELEM_CUR_CT
         CIJE  R6,0,CN_FIN_UKN_ELEM     IF NOT > 0 THEN JUMP DONE
         J     CN_SRCH_UKN_ETOP       AT LEAST ONE
*
CN_MOVE_UNK_CN_FAIL DS 0H
         MVC   CN_CMD_ASSOCIATES,CNC_CN_N
         L     R15,FRESP
         J     CN_MV_UKN_CN_FIN
*
CN_NO_UKNS DS 0H
CN_FIN_UKN_ELEM DS  0H    NO MORE UNK ELEMENTS TO PROCESS
CN_MV_UKN_CN_FIN DS 0H
         L     R9,SAV_CN_UKN_RET9
         LM    R4,R7,SAV_CN_UKN4_7
         BR    R9
*
* EXECUTE THE COMMAND
*
*     R15 SHOULD HAVE RC FROM CMD EXECUTION
* CN_RET_FROM_CRNDCMD DS 0H
*
*
DO_PING DS 0H
DO_LINK DS 0H
DO_CEMT DS 0H
DO_CEDA DS 0H
*    WE DID BASR TO ONE OF THESE ADDR
*     NEED TO SAVE RET ADDR OF BASR, WHICH IS IN R9
*     THE RETURN LABEL IS CN_RET_FROM_OLD_CMD
*
         ST    R9,SAV_CN_CMD_RET9
         STM   R4,R7,SAV_CN_REGS4_7
         XR    R15,R15
* THE CONTAINER STORAGE IS NOT APPROPRIATE FOR EXECUTING THE
*  RESPECTIVE COMMAND. SO FOR NOW, WE JUST GET A CA LENGTH AREA
*  WHICH COULD BE CHANGED TO OTHER SIZED STG (JRND OR CRND)
* THIS STG AREA IS PASSED AS A SURROGATE FOR CA AS NEEDED
*
         L     R15,CNC_CN_L         MOVE THE CN DATA LNG
         JAS   R9,B2C                 TO THE TDQ MSG
         MVC   UR_CALEN,HLDSTR+2      REPLACING EIBCALEN
*
GOT_PING_USE_CAL DS 0H
         LT    R4,CN_CA_SURROGATE     DOES CN CA SURR ALREADY EXIST
         JH    DO_OLD_CMD_GOT_OLD_CA
*
         MVC   GM_STG_FL,F32400
         JAS   R9,GM_STG
         LT    R4,GM_STG_ADR
         JZ    CN_STG_EXEC_FAIL
*
         ST    R4,CN_CA_SURROGATE
         MVC   CN_CA_SURROGATE_L,H32400
         J     CN_STG_EXEC_CONT
*
DO_OLD_CMD_GOT_OLD_CA DS 0H
         LH    R5,CN_CA_SURROGATE_L
         XR    R2,R2             ZERO SRC
         XR    R3,R3             ZERO PAD BYTE AND SRC LNG
         MVCL  R4,R2        MOVE X'00' TO   OLD CN CA SURROGATE
         L     R4,CN_CA_SURROGATE
*
CN_STG_EXEC_CONT DS 0H
         L     R5,F32400            LNG OF THIS CA STG
         L     R3,CNC_CN_L
         CRJL  R5,R3,CN_STG_MV2CA   MOVE LESSER OF 32400 OR CN LNG
         LR    R5,R3                R7 CN LNG IS LT 32400
CN_STG_MV2CA DS 0H
         L     R2,CN_GET_CN_ADR     ADR OF THE CN STG
         MVCL  R4,R2                MOVE CN TO CA SURR
*
         L     R5,CN_CA_SURROGATE   TO BE USED AS SURR FOR DFHEICAP
*   R4 HAS ADR OF SURROGATE CA
         L     R15,F32400            LNG OF STG
         STH   R15,SAV_CAL_REMN
         STH   R15,SAV_CAL       OCA EIBCALEN - NEVER ALTERED IN
         J     CN_XEQ_CMD
*
* NOTE - WE ARE JUMPING INTO OLD CODE
* NOTE - WE ARE JUMPING INTO OLD CODE
*        AT THE END OF THE COMMAND, WE WILL CHECK THE CN_NM
*        AND IF NOT SPACES, WE L R9 FROM THE SAV_CN_CMD_RET9
*        SO WE CAN BRANCH BACK TO THE CN CMD LOOP
*
NO_CH_FND DS 0H
*  START OF OLD CODE
         L     R5,DFHEICAP
*
CN_XEQ_CMD DS 0H
         ST    R5,P_OCA           REAL CA OR THE CN_SURR_CA
         ST    R5,P_OCA_CURPOS
*
         LH    R15,SAV_CAL        RETRIEVE EIBCALEN FROM SAV_CAL
         ARK   R9,R15,R5          GET LAST POSN IN OCA
         BCTR  R9,0
         ST    R9,P_OCA_LSTPOS
*
*        CHI   R15,X'4'   FOUR IS MIN COMMAND LENGTH FOR
*        JL    NOCA
         CIJL  R15,4,NOCA
*
         LA    R9,L'UR_REST
         STH   R9,UR_REST_L
*        CR    R15,R9
*        JH    USE_ALL_UR
         CRJH  R15,R9,USE_ALL_UR
         STH   R15,UR_REST_L
         LR    R9,R15     USE THE CAL, SMALLER THAN UR_REST
USE_ALL_UR DS 0H
*
         BCTR  R9,0
         EXRL  R9,MVC_UR_REST
*
         ST    R5,SAV_SEP_ADR    PRESET CA ADDR
*                 PREFER  1      SYSID(AAAA)
*                         2      SYSID=AAAA
*                         3      SYSID=(AAAA)
         LH    R15,SAV_CAL
*
*        CHI   R15,7                CHECK FOR A MINIMUM SYSID=X
*        JL    NOT_SYSID            CHECK ONLY FOR LCL COMMAND
         CIJL  R15,7,NOT_SYSID            CHECK ONLY FOR LCL COMMAND
         CLC   0(5,R5),LIT_SYSID_EP  SYSID
         JNE   NOT_SYSID
*
         MVI   SEP,C')'          USE ')' AS SEPARATOR
         LA    R15,2
         STH   R15,SYSID_SUFXL
         CLI   5(R5),C'('            SYSID(
         JE    OK_SYSID6
*
         CLI   5(R5),C'='            SYSID=
         JNE   NOT_SYSID
*
         CLI   6(R5),C'('            SYSID=(
         JE    OK_SYSID7
*                               DEFINITELY HAVE SYSID=_
         MVI   SEP,C','             USE COMMA AS SEPARATOR
         LA    R15,1
         STH   R15,SYSID_SUFXL
*
OK_SYSID6 EQU   *
         LA    R15,6           PRESERVE LNG SYSID= OR SYSID(
         J     CK_CA_LNG
*
MVC_UR_REST MVC UR_REST(0),0(R5)
*
OK_SYSID7 EQU   *
         LA    R15,7           PRESERVE LNG SYSID=(
         J     CK_CA_LNG
*
CK_CA_LNG EQU  *
         LA    R5,0(R15,R5)    POINT BEYOND SYSID.?
         ST    R5,P_OCA_CURPOS
         LH    R1,SAV_CAL_REMN
         SR    R1,R15
         STH   R1,SAV_CAL_REMN
*        CHI   R1,5
*        JL    OK_LSYSID
         CIJL  R1,5,OK_LSYSID
*
         LA    R1,5            ADD 5 TO LNG FOR COMPARE TO SEP
OK_LSYSID EQU  *
         LA    R1,0(R5,R1)     POINT TO LAST SEARCH POSN
* FIND THE FIRST OCCURANCE OF ENDING CHAR
*              R5 HAS ADDR OF FIRST CHAR Following SYSID.?
*              R1 HAS ADDR OF LAST SEARCH POS (SEARCH FOR SEP CHAR)
*   SRST R0 56-63 HAS BYTE TO SEARCH FOR
*        R1 (FIRST REG) HAS THE ENDING ADDR
*        R2 (2ND   REG) HAS THE STARTING ADDR
*   CHK  JC    MASK,JUMP_TO_REL_ADDR
*        CC  0 8    NOT DEFINED
*            1 4    FOUND, R1 UPDATED WITH BYTE FOUND,R2 UNCHGD
*            2 2    NOT FOUND, R1 AND R2 UNCHANGED
*            3 1    SPIN SEARCH, R1 UNCHGD, R2 POINTS TO NEXT SRCH ADR
*              + THIS IS THE VALUE TO USE IN THE JC INSTR
RETRY_SYSID_SRST DS 0H
         LR    R8,R1     RESET LAST POS TO SEARCH OCA
*              WHICH IS POINT AFTER SYSID(|SYSID=|SYSID=(
         LR    R9,R5     RESET TO CURPOS IN OCA
         XR    R0,R0
         IC    R0,SEP    PLACE SEP CHAR INTO BIT 24-31
RET_SRST_SYSID SRST R8,R9
         JC    4,FND_SYSID_SEP
         JC    1,RET_SRST_SYSID  RE-DRIVE
*              NOTE FIRST PASS, SEP IS EITHER ')' OR ','
         CLI   SEP,C','       DID NOT FIND IT, SO WE WILL SEE IF
         JNE   ERR_CA_STR      WE ARE ON FIRST OR SECOND PASS
*                              FIRST PASS, SO RPLACE SEP TO USE SPACE
         MVI   SEP,X'40'         BUT WE WILL TAKE A SPACE AS THE
         LA    R15,1
         STH   R15,PROGRAM_SUFXL
         J     RETRY_SYSID_SRST
*
*
FND_SYSID_SEP  EQU   *
         LR    R15,R8     R8 POINTS AT THE SEP CHAR
         ST    R15,SAV_SEP_ADR SAVE ADDR
         AH    R15,SYSID_SUFXL     ADJUST BY SEP LNG 1 OR 2
         ST    R15,P_OCA_CURPOS    FIRST POS IN CMD
         SR    R8,R5          BEG SYSID MINUS END POSTN GIVES LNG
         LH    R15,SAV_CAL_REMN   GET REMAINING CA LEN
         SR    R15,R8         SUB SYSID LNG TO GET NEW REM CA LNG
         STH   R15,SAV_CAL_REMN SAVE IT
*
GOT_SYSID EQU  *
         LR    R9,R8
         BCTR  R9,0             REDUCE BY 1 FOR EXECUTE
         LA    R15,RTE_TO_SYSID  GET READY FOR EXECUTE
*
*MVC_DST_R15_SRC_R5 MVC 0(0,R15),0(R5)
         EXRL  R9,MVC_DST_R15_SRC_R5   MOVE VIA EXECUTE
*
         MVC   LCL_IPCN_SYSID,RTE_TO_SYSID             20171002
*
         CLC   RTE_TO_SYSID,LCL_SYSID
         JE    CHK_CMD
*
RE_DIRECT_ROUTE_QRY EQU *
         EXEC CICS INQUIRE CONNECTION(RTE_TO_SYSID)                    *
               RESP(FRESP)                                             *
               RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)
         JE    DO_DPL
*                                                       20171002
         EXEC CICS INQUIRE IPCONN(RTE_TO_SYSID)                        *
               RESP(FRESP)                                             *
               RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)                    20171002
         JE    DO_DPL                                   20171002
*
*  20171002 IF THE TERMID STARTS WITH '/', (USUALLY) INDICATING
*   WE GOT HERE VIA A DPL OVER IPIC; THEN WE JUST FORCE THE
*   INCOMING SYSID TO THE LCL_SYSID AND RUN LOCALLY.
*
         CLI   EIBTRMID,C'/'                           20171002
         JNE   BYP_ALT_SYSID                           20171002
         MVC   RTE_TO_SYSID,LCL_SYSID                  20171002
         J     CHK_CMD
*
BYP_ALT_SYSID DS 0H
         CLC   FRESP,DFHRESP(SYSIDERR)
         JNE   BAD_SYSID_RESP
*
         CLC   LCL_SYSID,LIT_PTERMSVR
         JE    BAD_SYSID_RESP
*
         CLC   LCL_SYSID,LIT_TTERMSVR
         JE    BAD_SYSID_RESP
*
         CLC   RTE_TO_SYSID,LIT_PTERMSVR
         JE    TRY_TTERM
         CLC   RTE_TO_SYSID,LIT_TTERMSVR
         JE    BAD_SYSID_RESP
         MVC   RTE_TO_SYSID,LIT_PTERMSVR
         J     RE_DIRECT_ROUTE_QRY
*
TRY_TTERM EQU  *
         MVC   RTE_TO_SYSID,LIT_TTERMSVR
         J     RE_DIRECT_ROUTE_QRY
*
CHK_CN_CMD_DATA DS 0H
*        BEFORE GOING TO EXECUTE ANY COMMANDS, TEST TO INSURE
*         THAT THE CONTAINER NAME PREFIX MATCHES THE COMMAND
*         REQUEST IN FIRST 4 CHAR IN THE CN DATA
*  R5 WAS LOADED WITH CN_CA_SURROGATE, OR P_OCA_CURPOS WHEN SYSID
*   PREFIX WAS FOUND: IN WHICH CASE THAT IS THE_CURPOS WHEN SYSID
*   OR SIMPLY THE BEGINNING OF THE CA
         ST    R9,SAV_RET_CK_CMD_9
         XR    R15,R15                   SET RC TO ZERO
         L     R9,CN_CA_SURROGATE        GET PTR TO CN (CA)
         CLC   0(4,R9),CN_NM
         JE    CHK_CN_CMD_OK_DATA         CN_NM MATCH DATA?
*                                         NO
         MVI   SEP,C','                   SEP CHAR ALWAYS ','
         CLC   LIT_SYSID_,0(R9)           CN HAS SYSID LIT?
         JNE   CHK_CN_CMD_DATA_ERR        NO, SO BAD
CHK_CN_CMD_SYSID DS 0H
*  WE JUST WANT TO BUMP PAST THE SYSID PREFIX, TO FIND THE
*    COMA SEP CHAR. THEN WE CAN BUMP 1, AND COMPARE THE CMD IN DATA
*    WITH THE CN_NM. MAX OFFSET FROM END SYSID
*                    =1234,  =(1234), (1234),  IS 8
         IIHF  R9,8        HIGH R9       MAX OFFSET FROM END SYSID
         LA    R9,5(R9)    LOW R9        BUMP PAST SYSID LIT
*
CHK_CN_CMD_SYSID_TOP DS 0H
         CLC   SEP,0(R9)       LOOK FOR SEP CHAR DETERMINED ABOVE
         JE    CHK_CN_CMD_SYSID_FND    WITHIN FIRST 5 CHAR
         LA    R9,1(R9)        BUMP LOW R9 TO NEXT ADDR
         BRCTH R9,CHK_CN_CMD_SYSID_TOP  LOWER CT IN HIGH R9
         J     CHK_CN_CMD_DATA_ERR        NOT FOUND????
*
CHK_CN_CMD_SYSID_FND DS 0H
         LA    R9,1(R9)      FND, SO RETRY THE CN NAME MATCH
         CLC   0(4,R9),CN_NM
         LGFI  R9,0            ZERO BOTH HIGH AND LOW R15
         JE    CHK_CN_CMD_OK_DATA   OK, GOT IT
*
CHK_CN_CMD_DATA_ERR DS 0H
         MVC   OPLIT(L'CN_CMD_NOT_DATA_MSG),CN_CMD_NOT_DATA_MSG
         MVC   OPLIT+4(16),CNC_CN_N
*
         MVC   OPLIT+65(4),0(R5)
         IILF  R0,L'CN_CMD_NOT_DATA_MSG
         ST    R0,PUT_APND_MSG_FL
* PUT APPEND ERROR MSG TO CONTAINER
         ST    R0,EXEC_CICS_FL
         EXEC CICS PUT CONTAINER(CN_NM)    CHANNEL(CH_NM)              *
               FROM(OPLIT)  FLENGTH(EXEC_CICS_FL) APPEND               *
               RESP(FRESP)                                             *
               RESP2(FRESP2)
*
         JAS   R9,PUT_APND_RESP_CN
         IILF  R15,12
         ST    R15,FRC
         STC   R15,RC
*
CHK_CN_CMD_OK_DATA DS 0H
         L     R9,SAV_RET_CK_CMD_9
         BR    R9
*
DO_DPL   DS 0H
         XC    P_DPL_CA,P_DPL_CA
         CLC   CH_NM,SPACE255
         JNE   DO_DPL_USE_CN
DO_DPL_USE_CA DS 0H
DO_DPL_GO     DS 0H
         MVC   F_DPL_CAL,F32400
*
         MVC   GM_STG_FL,F32400
         JAS   R9,GM_STG
         LT    R8,GM_STG_ADR
         JZ    BAD_DPL_STG
*
         ST    R8,P_DPL_CA
*        LH    R9,SAV_CAL               REM%%%
         LH    R7,SAV_CAL
         LR    R9,R7                    ADD%%%
*        L     R6,DFHEICAP
         L     R6,P_OCA       MOVE THE CONTENTS INCL SYSID=XXXX,
         MVCL  R8,R6          MOVE REMN E ORIG CA TO NEW CA FOR DPL
*
         L     R8,P_DPL_CA
         USING CMD_CA,R8
         ZAP   MYABSTM,PZERO
         EXEC CICS ASKTIME ABSTIME(MYABSTM)
*
         EXEC CICS LINK PROGRAM(PGM_CMD)                               *
               SYSID(RTE_TO_SYSID)                                     *
               COMMAREA(CMD_CA)                                        *
               LENGTH(H_DPL_CAL)                                       *
               DATALENGTH(SAV_CAL)                                     *
               RESP(FRESP)                                             *
               RESP2(FRESP2)
*
         DROP  R8
*
*  20171002 IF THE TERMID STARTS WITH '/', (USUALLY) INDICATING
*   WE GOT HERE VIA A DPL OVER IPIC; THEN WE JUST FORCE THE
*   INCOMING SYSID TO THE LCL_SYSID AND RUN LOCALLY.
*
         CLI   EIBTRMID,C'/'                           20171002
         JNE   BYP_ALT_SYSID2                          20171002
         MVC   RTE_TO_SYSID,LCL_IPCN_SYSID             20171002
*
BYP_ALT_SYSID2 DS 0H
         CLC   FRESP,DFHRESP(NORMAL)
         JNE   BAD_DPL
*
         ZAP   MYABSTM1,PZERO
         EXEC CICS ASKTIME ABSTIME(MYABSTM1)
*
         EXEC CICS FORMATTIME ABSTIME(MYABSTM)                         *
              YYYYDDD(TIMER_DPL_ST_JDT)  DATESEP('-')                  *
              TIME(TIMER_DPL_ST_TOD)  TIMESEP(':')
         EXEC CICS FORMATTIME ABSTIME(MYABSTM1)                        *
              YYYYDDD(TIMER_DPL_SP_JDT)  DATESEP('-')                  *
              TIME(TIMER_DPL_SP_TOD)  TIMESEP(':')
*
         MVC   OPLIT(L'DO_DPL_MSG),DO_DPL_MSG
         MVC   OPLIT+8(8),TIMER_DPL_ST_TOD
         MVC   OPLIT+29(8),PGM_CMD
         MVC   OPLIT+44(4),RTE_TO_SYSID
         MVC   OPLIT+53(8),TIMER_DPL_SP_TOD
         MVC   OPLIT+62(2),=C'CA'
         MVC   OPLIT+64(16),=C'----COMMAREA----'
         J     DONE_DPL
*
* V2.2 ADD LOGIC FOR LINK WITH CNC TO UCEMPINR WITH SYSID
*
DO_DPL_USE_CN DS 0H
*        L     R5,P_OCA_CURPOS
         JAS   R9,CHK_CN_CMD_DATA
         CIJNE R15,0,BAD_DPL_CN_DATA
*
         EXEC CICS MOVE CONTAINER(CN_NM) CHANNEL(CH_NM)                *
              TOCHANNEL(CH_SYSID_NM) AS(CN_NM)                         *
              RESP(FRESP)                                              *
              RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)  MOVE CN
         JNE   DO_DPL_MOV_CN_FAIL
         ZAP   MYABSTM,PZERO
         EXEC CICS ASKTIME ABSTIME(MYABSTM) NOHANDLE
*
         EXEC CICS LINK PROGRAM(PGM_RMT)                               *
               SYSID(RTE_TO_SYSID)                                     *
               CHANNEL(CH_SYSID_NM)                                    *
               RESP(FRESP)                                             *
               RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)
         JNE   BAD_DPL
*
         ZAP   MYABSTM1,PZERO
         EXEC CICS ASKTIME ABSTIME(MYABSTM1)
* %%%%
         MVC  CH_MOVE_NM_FROM,CH_SYSID_NM
         MVC  CH_MOVE_NM_TO,CH_NM
         JAS  R9,CN_MOVE_2_CUR_CH
* %%%%
         EXEC CICS FORMATTIME ABSTIME(MYABSTM)                         *
              YYYYDDD(TIMER_DPL_ST_JDT)  DATESEP('-')                  *
              TIME(TIMER_DPL_ST_TOD)  TIMESEP(':')
         EXEC CICS FORMATTIME ABSTIME(MYABSTM1)                        *
              YYYYDDD(TIMER_DPL_SP_JDT)  DATESEP('-')                  *
              TIME(TIMER_DPL_SP_TOD)  TIMESEP(':')
*
         MVC   OPLIT(L'DO_DPL_MSG),DO_DPL_MSG
         MVC   OPLIT+8(8),TIMER_DPL_ST_TOD
         MVC   OPLIT+29(8),PGM_CMD
         MVC   OPLIT+44(4),RTE_TO_SYSID
         MVC   OPLIT+53(8),TIMER_DPL_SP_TOD
         MVC   OPLIT+62(2),=C'CN'
         MVC   OPLIT+65(16),CN_NM
         MVI   OPLIT+82,C':'
         J     DONE_DPL
*
*
DO_DPL_MOV_CN_FAIL DS 0H
BAD_DPL_CN_DATA DS 0H
BAD_DPL_STG EQU   *
BAD_DPL  EQU   *
BAD_CA_RET EQU   *
*
         MVI   RC,C'8'
         MVC   FRC,F8
         L     R6,P_MOV_2_DATA  GET PTR TO SCRATCH
         MVI   0(R6),C'8'       RESET THE RC TO 8
         L     R6,P_MOV_2_DATA_CURPOS GET PTR TO CURPOS SCRATCH
*                               NOW MOVE THE ERROR MESSAGE
         CLC   FRESP,DFHRESP(SYSIDERR)
         JNE   NOT_SYSID_ERR
         LA    R15,28
         C     R15,FRESP2
         JNE   CHK_SYSID_BUSY
         MVC   0(L'CA_RET_SRL_LIT,R6),CA_RET_SRL_LIT
         LA    R15,L'CA_RET_SRL_LIT
         J     MOV_RST_BAD_DPL
CHK_SYSID_BUSY EQU *
         LA    R15,29
         C     R15,FRESP2
         JNE   NOT_SYSID_ERR
         MVC   0(L'CA_RET_SBZ_LIT,R6),CA_RET_SBZ_LIT
         LA    R15,L'CA_RET_SBZ_LIT
         J     MOV_RST_BAD_DPL
BAD_DPL_ALL_SP DS 0H
         MVC   0(L'LIT_BAD_DPL_ALL_SP,R6),LIT_BAD_DPL_ALL_SP
         MVC   40(4,R6),RTE_TO_SYSID
         LA    R15,L'LIT_BAD_DPL_ALL_SP
         J     MOV_RST_BAD_DPL
NOT_SYSID_ERR EQU *
         MVC   0(L'CA_RET_BAD_LIT,R6),CA_RET_BAD_LIT
         LA    R15,L'CA_RET_BAD_LIT
         J     MOV_RST_BAD_DPL
MOV_RST_BAD_DPL EQU *
         LA    R15,1(R15)
         AR    R6,R15
         MVI   0(R6),C'*'
         ST    R6,P_MOV_2_DATA_CURPOS
         J     DONE_DPL_STP_ERR
*
*              NOTE- WE WILL DEAL WITH MOVING THE RESULTANT DPL CA
*                    TO THE SCRATCH AREA GM AT BEGINNING OF PGM.
*                    BOTH AREAS ARE THE SAME LENGTH.
DONE_DPL EQU   *
*              NOTE- SETUP THE RESPONSE PREFIX DATA
*                    THEN APPEND THE DPL CA DATA
*                    FINALLY, RESPONSE SUFFIX DATA
*                    IF THE OCA IS SMALLER THAN THE DPL CA
*                    (USUALLY IS), THEN WE WANT AS MUCH AS WE CAN
*                    WHICH SHOULD HAVE BOTH THE RESPONSE PREFIX
*                    FOLLOWED BY AS MUCH OF THE DPL CA DATA
*                    BUT PRESERVE THE REPONSE SUFFIX DATA
* RESPONSE PREFIX DATA
*              NOTE- WE ALREADY HAVE THE 1 BYTE RC IN POS 0
*                    SO WE ARE STARTING A POS 1
*
         IILF  R0,L'DO_DPL_MSG
         ST    R0,PUT_APND_MSG_FL
*
         JAS   R9,PUT_APND_RESP_CN
*
         L     R6,P_MOV_2_DATA_CURPOS       CURPOS IN SCRATCH IS 1
         MVC   0(34,R6),SPACE255
         MVC   0(5,R6),=C'<DPL('
         MVC   5(4,R6),RTE_TO_SYSID
         MVC   9(7,R6),=C'(ENTRY:'
         MVC   16(8,R6),TIMER_DPL_ST_JDT
         MVC   25(8,R6),TIMER_DPL_ST_TOD
         MVI   33(R6),C'{'
         LA    R6,34(R6)
         ST    R6,P_MOV_2_DATA_CURPOS
*
         CLC   CH_NM,SPACE255
         JNE   DPL_CN_DATA
*
* DPL CA DATA
*   SRST R0 56-63 HAS BYTE TO SEARCH FOR
*        R1 (FIRST REG) HAS THE ENDING ADDR
*        R2 (2ND   REG) HAS THE STARTING ADDR
*   CHK  JC    MASK,JUMP_TO_REL_ADDR
*        CC  0 8    NOT DEFINED
*            1 4    FOUND, R1 UPDATED WITH BYTE FOUND,R2 UNCHGD
*            2 2    NOT FOUND, R1 AND R2 UNCHANGED
*            3 1    SPIN SEARCH, R1 UNCHGD, R2 POINTS TO NEXT SRCH ADR
*              + MASK IS THE VALUE TO USE IN THE JC INSTR
         L     R9,F_DPL_CAL   DPL CA AND SCRATCH GM ARE SAME SIZE
         AHI   R9,-34         REMOVE THE ABOVE 34 CHARS FROM CALC
*        STH   R9,H_MAX_CMD_LNG    SAVE THIS AS THE DEFAUL LENGTH
         AR    R9,R8          THIS IS MAX SEARCH LENGTH
         XR    R0,R0
         ST    R8,SAV_4_SRST    SAVE BEG ADDR
*
RET_SRST_DPL  SRST R9,R8      SRCH DPL CA FOR FIRST NULL
*
         JC    2,SRST_NOTFND_DPL_SEP
         JC    1,RET_SRST_DPL   RE-DRIVE
*              NOTE- WE DID NOT FIND A NULL CHAR IN THE CA RETURNED
*                    FROM THE DPL. SINCE SRST DOES NOT CHG THE
*                    BEG OR END POS IF STRING NOT FOUND, WE CAN JUST
*                    GO ONTO PARS.
*              NOTE- IF WE DID FIND THE FIRST NULL, WE WILL BE
*                    ONE BEYOND LAST SIGIFCANT CHAR.
*              EITHER FOUND OR NOT FOUND, REDUCE THE LAST POSN BY 1
         L     R8,SAV_4_SRST    RESTORE BEG ADDR
         SRK   R15,R9,R8        R8 IS FIRST NULL MINUS BEGIN ADDR
         STH   R15,H_MAX_CMD_LEN      GIVES A LENGTH
         J     SRST_NOTFND_DPL_SEP1
*
SRST_NOTFND_DPL_SEP DS 0H
         L     R8,SAV_4_SRST    RESTORE BEG ADDR
         BCTR  R9,0      NULL NOT FND, SO REDUCE END PTR
*
SRST_NOTFND_DPL_SEP1 DS 0H
*              NOTE- R9 DPL CA PTR TO FIRST NULL ADDR OR END ADDR
*                    R6 PTR TO DPL CA START ADDR
*                    H_MAX_CMD_LEN HOLDS LENGTH
         MVC   PARSE_DIRECTN,HMINUS1   SEARCH BACKWARDS
         MVC   PARSE_EQ,HMINUS1        FIND UNEQUAL
         LA    R1,THEPARM
         ST    R8,8(R1)                ST ADDR OF THE HAYSTAK
         LA    R15,H_MAX_CMD_LEN        MAX COMMAND LENGTH IS 80 !!
         ST    R15,12(R1)              ST ADDR OF HAYSTAK LENGTH
         LA    R15,SP1
         ST    R15,0(R1)               ST ADDR OF NEEDLE
         LARL  R15,H1
         ST    R15,4(R1)               ST ADDR OF NEEDLE LENGTH
* FIND FIRST NON SPACE STARTING FROM END OF DPL CA
         XR    R15,R15
         JAS   R9,PARS
         LTR   R15,R15
         JZ    BAD_DPL_ALL_SP          NO CMD IN CAL_REMN
*
         SRK   R9,R15,R8      KEEPING R8 AS FIRST CHAR IN DPL CA
*                             R9 IS THE LAST NON SP ADDR. GET LENGTH
         LR    R7,R9
         L     R6,P_MOV_2_DATA_CURPOS       CURPOS IN SCRATCH
         MVCL  R6,R8          MOVE DPL CA TO SCRATCH
         ST    R6,P_MOV_2_DATA_CURPOS       CURPOS IN SCRATCH ADV
         L     R9,P_MOV_2_DATA_LST
DONE_DPL_STP_ERR DS 0H
         L     R8,P_DPL_CA
         CIJE  R8,0,DONE_DPL_FM_DPLCA
*
         EXEC CICS FREEMAIN DATAPOINTER(R8)                            *
               NOHANDLE
         J     DONE_DPL_FM_DPLCA
*
DPL_CN_DATA DS 0H    $
         L     R6,P_MOV_2_DATA_CURPOS       CURPOS IN SCRATCH
         MVC   0(L'LIT_DPL_WITH_CN,R6),LIT_DPL_WITH_CN
         LA    R6,L'LIT_DPL_WITH_CN(R6)
         MVC   0(16,R6),CH_SYSID_NM
         LA    R6,16(R6)
         MVC   0(L'LIT_DPL_CN_SYSID,R6),LIT_DPL_CN_SYSID
         LA    R6,L'LIT_DPL_CN_SYSID(R6)
         MVC   0(4,R6),RTE_TO_SYSID
         LA    R6,4(R6)
         MVI   0(R6),C'>'
         MVI   1(R6),C'>'
         LA    R6,2(R6)
         ST    R6,P_MOV_2_DATA_CURPOS       CURPOS IN SCRATCH ADV
         J     CN_CMD_PROC_GOOD
*
DONE_DPL_FM_DPLCA DS  0H
         CRJL  R9,R6,DPL_FIN_0
         SR    R9,R6
         CIJL  R9,L_TMP_STR_33,OK_DPL_STP
         LA    R9,L_TMP_STR_33
OK_DPL_STP DS 0H
         L     R6,P_MOV_2_DATA_CURPOS       CURPOS IN SCRATCH
         MVC   TMP_STR_33,SPACE255
         LA    R8,TMP_STR_33         MOVE THE SUFFIX DATA
         MVC   0(8,R8),=C'}RETURN:'       TO POS IN OCA MARKED
         MVC   10(8,R8),TIMER_DPL_SP_JDT    BY REG6
         MVI   18(R8),C' '
         MVC   19(8,R8),TIMER_DPL_SP_TOD
         MVI   27(R8),C')'
         MVC   28(4,R8),LCL_SYSID
         MVI   32(R8),C'>'           SET ALL UP FOR MOVE TO COMMAREA
         LR    R7,R9
         MVCL  R6,R8                 MOV ALL OR PART OF RESPONSE
         ST    R6,P_MOV_2_DATA_CURPOS  NOW POINT AT END OF LAST MOVES
         J     DPL_FIN_0             SUFFIX DATA TO SCRATCH AREA
*
*
DPL_FIN_0 EQU *
NO_DATA_TRLR EQU *
         J     FIN_DPL_STUFF
*
*  WE ONLY CHECK THE COMMAND WHEN WE ARE AT THE TARGET SYSID
NOT_SYSID EQU *
CHK_CMD  EQU  *
         CLC   SAV_CAL_REMN,H4   MIN LNG IS 4
         JL    BAD_CMD_LEN_2_TD
         ICM   R6,B'1111',P_OCA_CURPOS  PTR TO SEP CHAR OR 0
         JZ    NOCA             ILLOGICAL BUT TEST ANYWAY
*        L     R5,DFHEICAP      OK, WHAT IS LEFT IN COMMAREA?
*        SR    R6,R5            SUBT SAV_SEP_ADR FROM CA_BEG
*        CH    R6,SAV_CAL       COMP TO SEE IF ANY CA LEFT
*                               R6 SHOULD BE LESS THAN CALEN
*        JL    NOCA             EQ OR GT CALEN
*
         L     R5,P_OCA_CURPOS  GET THE POS OF FIRST CHAR IN CMD
         CLC   LIT_PING,0(R5)
         JNE   CHK_NXT_CMD
*
         CLC   CH_NM,SPACE255
         JE    DO_PING_USE_CA
*        L     R6,P_OCA_CURPOS
         JAS   R9,CHK_CN_CMD_DATA
         CIJNE R15,0,BAD_PING_CN_DATA
*
DO_PING_USE_CA DS 0H
         AHI   R5,4
         ST    R5,P_OCA_CURPOS
*        J     GOT_PING
*
FIN_DPL_STUFF EQU *
GOT_PING EQU   *
         JAS   R9,WRIT_CMD_2_TDQ
*
         L     R6,P_MOV_2_DATA_CURPOS
         MVC   0(74,R6),SPACE255         MOVE SPACES INTO PING MSG
         MVC   0(8,R6),LCL_UID
         MVC   9(20,R6),LCL_UNAME
         MVC   30(4,R6),EIBTRNID
         MVC   35(4,R6),EIBTRMID
         MVC   40(7,R6),TASKNUM+1
         MVC   47(8,R6),=C'(RETURN:'
         AHI   R6,55
*        ST    R6,P_MOV_2_DATA_CURPOS
*
         JAS   R9,GET_FORMAT_TIME
         MVC   TIMER_ENT_SP_JDT,TIMER_ENT_CN_JDT
         MVC   TIMER_ENT_SP_TOD,TIMER_ENT_CN_TOD
*
         MVC   0(8,R6),TIMER_ENT_SP_JDT
         MVC   9(8,R6),TIMER_ENT_SP_TOD
         MVI   17(R6),C')'
         MVI   18(R6),C'>'
         AHI   R6,19
         ST    R6,P_MOV_2_DATA_CURPOS
         J     DO_RETURN
*
CHK_NXT_CMD    EQU *
*        CHK FOR ANY OTHER COMMANDS, ELSE JUST WRITE TDQ
         CLC   LIT_CEMT,0(R5)
         JE    GOT_CEMT
*
         CLC   LIT_CEDA,0(R5)
         JE    GOT_RDO
*
         CLC   LIT_LINK,0(R5)
         JE    GOT_LINK
*
         JNE   CHK_NXT_CMD1
*
GOT_RDO        EQU *
*
         CLC   CH_NM,SPACE255
         JE    DO_RDO_USE_CA
*
*        L     R6,P_OCA_CURPOS
         JAS   R9,CHK_CN_CMD_DATA
         CIJNE R15,0,BAD_CEDA_CN_DATA
*
DO_RDO_USE_CA DS 0H
         AHI   R5,5
*
         CLC   LIT_RDO_DIS,0(R5)
         JE    GOT_RDO_DIS
*
         CLC   LIT_RDO_ALT,0(R5)                20180604
         JE    GOT_RDO_ALT
*
         CLC   LIT_RDO_MOV,0(R5)                20180604
         JE    GOT_RDO_MOV
*
         CLC   LIT_RDO_REN,0(R5)                20180604
         JE    GOT_RDO_REN
*
         CLC   LIT_RDO_DEF,0(R5)
         JE    GOT_RDO_DEF
*
         CLC   LIT_RDO_INS,0(R5)
         JE    GOT_RDO_INS
*
         CLC   LIT_RDO_EXP,0(R5)
         JE    GOT_RDO_EXP
*
         CLC   LIT_RDO_COPY,0(R5)
         JE    GOT_RDO_COPY
*
         CLC   LIT_RDO_VIEW,0(R5)
         JE    GOT_RDO_VIEW
         J     RESTRK_CMD
*
GOT_RDO_ALT  EQU *
         LA    R15,LIT_ME_X
         LA    R9,LIT_ME
CHK_NXT_ID    EQU  *
         CLC   LCL_UID,0(R9)
         JE    GOT_GD_R_ID
         AHI   R9,8
*        CR    R9,R15
         CRJL  R9,R15,CHK_NXT_ID
         CLC   LCL_UID,LCL_APPLID
         JE    GOT_GD_R_ID
         EXEC CICS INQUIRE SYSTEM DFLTUSER(LCL_DEF_UID)
         CLC   LCL_UID,LCL_DEF_UID
         JE    GOT_GD_R_ID
         J     RESTRK_CMD
*
GOT_GD_R_ID  EQU *
GOT_RDO_DIS  EQU *
GOT_RDO_MOV  EQU *
GOT_RDO_REN  EQU *
GOT_RDO_DEF  EQU *
GOT_RDO_INS  EQU *
GOT_RDO_EXP  EQU *
GOT_RDO_VIEW EQU *
GOT_RDO_COPY EQU *
         AHI   R5,-5          20090427 SET THE 0CA PTR BACK TO CMD
*
         MVC   PGM_CMD,LIT_DFHEDAP
         J     SETUP_CMD
*
GOT_CEMT       EQU *
*
         CLC   CH_NM,SPACE255
         JE    DO_CEMT_USE_CA
*
*        L     R6,P_OCA_CURPOS
         JAS   R9,CHK_CN_CMD_DATA
         CIJNE R15,0,BAD_CEMT_CN_DATA
*
DO_CEMT_USE_CA DS 0H
         CLC   LIT_INQ,5(R5)
         JE    GOT_INQ
*
         CLC   LIT_SET,5(R5)
         JNE   RESTRK_CMD
*
GOT_INQ  EQU   *
         MVC   PGM_CMD,LIT_DFHEMTA
*
SETUP_CMD EQU  *
         JAS   R9,WRIT_CMD_2_TDQ
*
         JAS   R9,SET_UP_CMD4XEQ
         LTR   R15,R15
         JNZ   FAIL_SET_UP_CMD1
*
         L     R8,P_CMD_A
         USING CMD_CA,R8
         EXEC CICS LINK PROGRAM(PGM_CMD)                               *
               COMMAREA(CMD_CA)                                        *
               LENGTH(H_DPL_CAL)                                       *
               RESP(FRESP)                                             *
               RESP2(FRESP2)
*
*        CLC   FRESP,DFHRESP(NORMAL)
         DROP  R8
         CLC   FRESP,=F'0'
         JNE   FAIL_SET_UP_CMD0
*
         XR    R15,R15
         L     R9,12(R8)     PTR TO BEG GM CMD WK AREA
         ICM   R15,B'0011',4(R9)  INSERT THE OP INTRPT PHASE RC
         STC   R15,RC
         ST    R15,FRC
         C     R15,F8
         JNL   FAIL_SET_UP_CMD1   IF GT 7, WE HAD PROB
*
         ICM   R15,B'0011',0(R9)  INSERT THE OP INTRPT PHASE LEN
         JZ    FAIL_SET_UP_CMD0   IF ZERO, WE HAD PROB
*
         ARK   R8,R15,R9    POINT TO THE OP BUFF TOT LEN
         XR    R9,R9
         ICM   R9,B'0011',0(R8)   INSERT OP TOT LNG INTO R9
         AHI   R9,-7              SUBTRACT 7 FOR THIS HDR AREA
*                    WHICH HOLDS 3 HW VALUES FROM THE CMD AND X'15' DLM
*                    IN ORDER TO GET ACTUAL LENGTH OF DATA
         JNP   FAIL_SET_UP_CMD0   IF LE 0, WE HAD PROB
*
         AHI   R8,7               BUMP PAST THAT HDR AREA (SEE ABOVE)
*
         CLC   PGM_CMD,LIT_DFHEDAP
         JE    DONE_DFHEDAP
         J     DONE_DFHEMTA
*
DONE_LINK DS   0H
*    WE COULD DO SPECIAL PROPCESSING FOR CEMT HERE
         J      CMD_DONE
*
DONE_DFHEMTA   DS 0H
*    WE COULD DO SPECIAL PROPCESSING FOR CEMT HERE
         J      CMD_DONE
DONE_DFHEDAP   DS 0H
*    WE COULD DO SPECIAL PROPCESSING FOR CEDA HERE
         J      CMD_DONE
CMD_DONE DS 0H
         MVI   RC,X'F0'
         J     ARND_FAIL
*
RESTRK_CMD     EQU *
         JAS   R9,WRIT_CMD_2_TDQ
*
         LA    R8,LIT_RESTRICTED
         XR    R9,R9
         LA    R9,L'LIT_RESTRICTED
         MVI   RC,C'4'
         J     ARND_FAIL
*
FAIL_SET_UP_CMD0 DS 0H
         LA    r15,8
FAIL_SET_UP_CMD1 DS 0H
         STC   R15,RC
         ST    R15,FRC
         LA    R8,LIT_FAILED_CMD
         XR    R9,R9
         LA    R9,L'LIT_FAILED_CMD
ARND_FAIL EQU  *
         LH    R7,SAV_CAL
         AHI   R7,-3     SAV_CAL OUR RETURN CA, AND LEN NEEDS TO
*                    BE REDUCED: 1 FOR THE ABOVE RC, 1 TO APPEND THE
*                    X'15' FINAL DLM AFTER THE MVCL, AND THEN ANOTHER 1
*                    BECAUSE WE  APPEND A X'00'. USED AS THE DELM IN A
*                    ASSEMBLER MVST (MOVE UNTIL STRING FOUND INSTRCTN).
*                    IN TOTAL, THAT IS 3. WILL STOP THE STG VIO 200905
*
*              NOTE- R8 POINTS AT THE OP FROM A LINK,CEMT,CEDA CMD
*              NOTE- R9 POINTS LNG OF LINK TO CA
         CRJL  R7,R9,ARND_FAIL_USE_CAL
         LR    R7,R9         USE ERR MSG LENGTH
ARND_FAIL_USE_CAL DS 0H
         LR    R9,R7         USE THE OCA CAL IN SAV_CAL
*  check for a channel name
         CLC   CH_NM,SPACE255
         JE    ARND_FAIL_USE_CA
         L     R6,CN_CA_SURROGATE  USE SURROGATE RATHER THAN DFHEICAP
         J     ARND_FAIL_GO
ARND_FAIL_USE_CA DS 0H
*        L     R6,DFHEICAP
         L     R6,P_OCA
ARND_FAIL_GO DS  0H
         MVC   0(1,R6),RC
         AHI   R6,1
         MVCL  R6,R8
         MVI   0(R6),X'15'    EIBLEN -1 AND EIBLEN -0
         MVI   1(R6),X'00'    STO VIO FIXED 200905
*
         L     R8,P_DPL_CA
         CIJE  R8,0,DO_FIN
*
         EXEC CICS FREEMAIN DATAPOINTER(R8)                            *
               NOHANDLE
         J     DO_FIN
*
*
*
GOT_LINK DS 0H
*              NOTE- LINK CMD MUST LOOK LIKE
*                    LINK=ABCDEFG,
*                    LINK=(ABCDEFG),
*                    LINK(ABCDEFG),
*                  FOLLOWED BY A COMMA AND COMMAREA (IF ANY)
*                  OTHERWISE IT IS AN ERROR
*
*              ENTER R5 IS P_OCA
*
         CLC   CH_NM,SPACE255
         JE    DO_LINK_USE_CA
*
*        L     R6,P_OCA_CURPOS
         JAS   R9,CHK_CN_CMD_DATA
         CIJNE R15,0,BAD_LINK_CN_DATA
*
DO_LINK_USE_CA DS 0H
         JAS   R9,WRIT_CMD_2_TDQ
*
         LH    R15,SAV_CAL_REMN
*
*        CHI   R15,6                CHECK FOR A MINIMUM LINK=X
*        JL    CHK_NXT_CMD1
         CIJL  R15,6,CHK_NXT_CMD1   TOO SMALL
*
         MVI   SEP,C')'          USE ')' AS DEF SEPERATOR
         LA    R15,2              IMPLIES ), AS LENGTH=2
         STH   R15,PROGRAM_SUFXL
         CLI   4(R5),C'('            LINK(
         JE    OK_LINK5
*
         CLI   4(R5),C'='            LINK=
         JNE   BAD_LINK_CMD_EQ       NONE FIT, SO ERROR
*
         CLI   5(R5),C'('            LINK=(
         JE    OK_LINK6
*                               DEFINITELY HAVE SYSID=_
         MVI   SEP,C','             USE COMMA AS SEPARATOR
         LA    R15,1
         STH   R15,PROGRAM_SUFXL
*
OK_LINK5  EQU   *
         LA    R15,5           PRESERVE LNG LINK=  OR LINK(
         J     CK_CA_LINK_LNG
*
OK_LINK6  EQU   *
         LA    R15,6           PRESERVE LNG  LINK=(
*        J     CK_CA_LINK_LNG
*
CK_CA_LINK_LNG EQU  *
*        LR    R7,R15      %?  SAVE THIS LNG, SO WE CAN SUBT LATER
         LA    R5,0(R15,R5)    POINT OCA CURPOS BEYOND LINK
         ST    R5,P_OCA_CURPOS    SAVE CURPOS IN OCA
         LH    R1,SAV_CAL_REMN    CHK AGAINS REMN OCA LNG
         SR    R1,R15             BY SUBTRACTING LNG
         STH   R1,SAV_CAL_REMN
*        CHI   R1,9
*        JL    OK_L_LINK
         CIJL  R1,9,OK_L_LINK  DETERMIN IF THE REMAINDER IS LT 9
*                              R1 IS EITHER LT 9 (WHICH WE USE)
         LA    R1,9            OR WE SET IT TO 9
OK_L_LINK EQU  *
* EXTRACT THE PROGRAM NAME; LOOK FOR ')' (IF ( FOUND ABOVE)
*                                 OR ','
*  IF NEITHER FOUND, THEN ASSUME THAT NOCA. LOOK FOR THE
*        PGMNAME DELIMITED BY SPACE OR NOT DELIMITED
*        AS IN THE OCA ONLY CONTAINED THE PGMNAME
*   IF THE PGMNAME LENGTH IS ZERO, THEN THAT IS AN ERROR.
* FIND THE FIRST OCCURANCE OF ENDING CHAR
*              R5 HAS ADDR OF FIRST CHAR FOLLOWING LINK.?
*              R1 HAS ADDR OF LAST SEARCH POS (SEARCH FOR SEP CHAR)
*                 WHICH WE LIMIT TO 9 CHARACTERS OR CAL_REMN
*
*   SRST R0 56-63 HAS BYTE TO SEARCH FOR
*        R1 (FIRST REG) HAS THE ENDING ADDR
*        R2 (2ND   REG) HAS THE STARTING ADDR
*   CHK  JC    MASK,JUMP_TO_REL_ADDR
*        CC  0 8    NOT DEFINED
*            1 4    FOUND, R1 UPDATED WITH BYTE FOUND,R2 UNCHGD
*            2 2    NOT FOUND, R1 AND R2 UNCHANGED
*            3 1    SPIN SEARCH, R1 UNCHGD, R2 POINTS TO NEXT SRCH ADR
*              + THIS IS THE VALUE TO USE IN THE JC INSTR
         LA    R1,0(R5,R1)     ADD 9 TO OCA CURPOS
RETRY_LINK_SRST DS 0H
         LR    R8,R1     RESET LAST POS TO SEARCH OCA
*              WHICH IS POINT AFTER LINK(|LINK=|LINK=(
         LR    R9,R5     RESET TO CURPOS IN OCA
         XR    R0,R0
         IC    R0,SEP    PLACE SEP CHAR INTO BIT 24-31
*
RET_SRST_LINK SRST R8,R9
*
         JC    4,FND_LINK_SEP
         JC    1,RET_SRST_LINK  RE-DRIVE
*              NOTE FIRST PASS, SEP IS EITHER ')' OR ','
         CLI   SEP,C','       DID NOT FIND IT, SO WE WILL SEE IF
         JNE   BAD_LINK_CMD_SEP WE ARE ON FIRST OR SECOND PASS
*                               FIRST PASS, SO RPLACE SEP TO USE SPACE
         MVI   SEP,X'40'         BUT WE WILL TAKE A SPACE AS THE
         LA    R15,1
         STH   R15,PROGRAM_SUFXL
         J     RETRY_LINK_SRST
*
FND_LINK_SEP  EQU   *
*              NOTE - R9 STILL PTR TO BEGIN OF SEARCH
         LR    R15,R8     R8 POINTS AT THE SEP CHAR
         ST    R15,SAV_SEP_ADR SAVE ADDR
         AH    R15,PROGRAM_SUFXL   ADJUST BY SEP LNG 1 OR 2
         ST    R15,P_OCA_CURPOS  NOW POINTS 1 BEYOND SEP CHAR(S)
         SR    R8,R5          BEG PROG  MINUS END POSTN GIVES LNG
         LH    R15,SAV_CAL_REMN   GET REMAINING CA LEN
         SR    R15,R8         SUB PROG  LNG TO GET NEW REM CA LNG
         BCTR  R15,0          SUB 1 MORE TO ACCT FOR SEP !20170720
         STH   R15,SAV_CAL_REMN SAVE IT
*
*          R5 STILL POINTS TO FIRST POS IN PGMNAME
         LR    R9,R8
         BCTR  R9,0      REDUCE BY 1 FOR EXECUTE
         MVC   PGM_CMD,SPACE255
         LA    R15,PGM_CMD
*
*MVC_DST_R15_SRC_R5 MVC 0(0,R15),0(R5)
         EXRL  R9,MVC_DST_R15_SRC_R5   MOVE VIA EXECUTE
*
         CLC   PGM_CMD,PGM_CUR
         JE    BAD_LINK_CMD_RECUSION
* NOW HAVE POS BEYOND SEP IN SAV_SEP_ADR
* THIS IS START OF ANY COMMAREA...
* GOT A COMMAREA
*        SO incrse IT BY 1, AND MVCL TO THE NEW COMA
         XC    P_DPL_CA,P_DPL_CA
*
* SO CHECK SAV_CAL_REMN. IF POS, THEN MVCL TO THE GM COMMAERA
* IF NOT POS, THEN LINK WITHOUT CA
         LH    R9,SAV_CAL_REMN
         CIJNH R9,0,LINK_EMPTY_CA  NOTHING IN OCA TO SEND TO PGM
*                  BUT THIS IS OK, WANT TO RETRUN A CA RESP IN OCA
         LH    R15,H32400
*        LA    R15,1(R15)      REM%%% MOVING PART OF END SAA
         ST    R15,F_DPL_CAL
*
         MVC   GM_STG_FL,F_DPL_CAL
         JAS   R9,GM_STG
         LT    R8,GM_STG_ADR
         JZ    BAD_DPL_STG
*
         ST    R8,P_DPL_CA
         L     R6,P_OCA_CURPOS
*        L     R9,F_DPL_CAL
         LH    R9,SAV_CAL_REMN    !20170720 - F_DPL_CAL IS WRONG
         LR    R7,R9
         MVCL  R8,R6          MOVE ENTIRE ORIG CA TO NEW CA FOR DPL
         L     R8,P_DPL_CA
         LH    R9,SAV_CAL_REMN
*
LINK_EMPTY_CA DS 0H
         ZAP   MYABSTM,PZERO
         EXEC CICS ASKTIME ABSTIME(MYABSTM)
*
         CIJNH R9,0,LINK_EMPTY_CA2  NOTHING IN OCA TO SEND TO PGM
*
         USING CMD_CA,R8
         EXEC CICS LINK PROGRAM(PGM_CMD)                               *
               COMMAREA(CMD_CA)                                        *
               LENGTH(H_DPL_CAL)                                       *
               DATALENGTH(SAV_CAL_REMN)                                *
               RESP(FRESP)                                             *
               RESP2(FRESP2)
         J     ARND_LINK_EMPTY_CA2
*
LINK_EMPTY_CA2 DS 0H
         EXEC CICS LINK PROGRAM(PGM_CMD)                               *
               RESP(FRESP)                                             *
               RESP2(FRESP2)
*
         J     ARND_LINK_EMPTY_CA2
*
ARND_LINK_EMPTY_CA2 DS 0H
         DROP  R8
         CLC   FRESP,DFHRESP(NORMAL)
         JNE   BAD_LINK_RESP
*
         ZAP   MYABSTM1,PZERO
         EXEC CICS ASKTIME ABSTIME(MYABSTM1)
*
         EXEC CICS FORMATTIME ABSTIME(MYABSTM)                         *
              YYYYDDD(TIMER_DPL_ST_JDT)  DATESEP('-')                  *
              TIME(TIMER_DPL_ST_TOD)  TIMESEP(':')
         EXEC CICS FORMATTIME ABSTIME(MYABSTM1)                        *
              YYYYDDD(TIMER_DPL_SP_JDT)  DATESEP('-')                  *
              TIME(TIMER_DPL_SP_TOD)  TIMESEP(':')
*
*       IF NO CA, RETURN OF A PING LIKE MSG
*
         CIJNH R9,0,FIN_DPL_STUFF
*
         LH    R9,H_DPL_CAL    USED IN LOGIC ARND_FAIL
         J     DONE_LINK
*
CHK_NXT_CMD1   EQU *
*        CHK FOR ANY OTHER COMMANDS, ELSE JUST WRITE TDQ
*
* NOPE. NO MORE COMMANDS
         MVC   OPLIT(L_NO_VALID_CMD_MSG),NO_VALID_CMD_MSG
*        MVC   OPLIT+1(5),TASK_NUM
         MVC   OPLIT+L_NO_VALID_CMD_MSG1(5),TASK_EIBCAL
         MVC   OPLIT+L_NO_VALID_CMD_MSG2(4),0(R5)
         JAS   R9,WRIT_EMSG_2_TD
         JAS   R9,WRIT_CMD_2_TDQ
         MVI   RC,C'8'        SET RC TO INDICATE INCOMPLETE
         MVC   FRC,F8
         J     DO_RETURN
*
BAD_CMD_LEN_2_TD DS  0H
         MVC   OPLIT(L_BAD_CMD_IP_CA_MSG),BAD_CMD_IP_CA_MSG
*        MVC   OPLIT+1(5),TASK_NUM
         MVC   OPLIT+L_BAD_CMD_IP_CA_MSG1(5),TASK_EIBCAL
         MVC   OPLIT+L_BAD_CMD_IP_CA_MSG2(4),0(R5)
         JAS   R9,WRIT_EMSG_2_TD
         JAS   R9,BASEMSG
*
         J     CHK_RET_OR_FIN
*
MVC_REST_CA MVC OPLIT(0),0(R5)
*
NOCA     EQU   *
         CLC   EIBCALEN,H0
         JE    NOCA_ZERO_LEN
*
         MVC   OPLIT(L_BAD_CMD_IP_CA_MSG),BAD_CMD_IP_CA_MSG
*        MVC   OPLIT+1(5),TASK_NUM
         MVC   OPLIT+L_BAD_CMD_IP_CA_MSG1(5),TASK_EIBCAL
         MVC   OPLIT+L_BAD_CMD_IP_CA_MSG2(4),0(R5)
*        L     R5,DFHEICAP
         L     R5,P_OCA
         LH    R9,EIBCALEN
         BCTR  R9,0
         EXRL  R9,MVC_LOWCA
         J     NOCA_WRIT_MSG
NOCA_ZERO_LEN  DS 0H
         MVC   OPLIT(L'NOCA_EMP_IP_CA_MSG),NOCA_EMP_IP_CA_MSG
         MVC   OPLIT+L'NOCA_EMP_IP_CA_MSG(8),LCL_UID  !20170802
*        MVC   OPLIT+1(5),TASK_NUM
NOCA_WRIT_MSG  DS 0H
         JAS   R9,WRIT_EMSG_2_TD
         JAS   R9,BASEMSG
*
         J     CHK_RET_OR_FIN
*
MVC_LOWCA MVC   OPLIT+L_BAD_CMD_IP_CA_MSG2(0),0(R5)
*
CHK_RET_OR_FIN DS  0H
*
DO_RETURN EQU  *
         LH    R9,SAV_CAL      check to see if any ca was shipped
         CHI   R9,X'00'        nope. so got to fin
         JNP   DO_FIN          CNC WILL HAVE SET THE SAV_CAL
*                              SO WE CONTINUE
         L     R7,P_MOV_2_DATA_CURPOS    IS THERE ANY INFO
         L     R6,P_MOV_2_DATA           TO RETURN FROM
         SR    R7,R6                     GM WORKAREA
         JNP   NO_DATA_2_RTN             IS START EQ TO CUR POS
         ST    R7,P_MOV_2_DATA_LST       CUR POS IS GT (POS)
*
*        L     R8,P_OCA_LSTPOS
*        LR    R9,R8
*        S     R9,P_OCA_CURPOS
*        JNP   NO_DATA_2_RTN
*                             R7 HAS LNG OF THIS PROGRAMS DATA
*                             R9 HAS LNG OF THE ORIG CA
*        CR    R7,R9          SEE IF DATA (R7) FITS IN CA (R9).
*        JL    USE_MOV_2_L
         CRJL  R7,R9,USE_MOV_2_L  DATAL IS LESS THAN RENM CA. MOVE ALL
         MVI   RC,C'1'        MOVE 1 TO RC TO DENOTE PARTIAL RESULT
         MVC   FRC,F1
         LR    R7,R9          USE REMN CA LNG FOR MVCL BELOW
USE_MOV_2_L DS  0H
*  ??    L     R8,P_OCA_CURPOS     CURRENT CA POS
         L     R8,P_OCA            ORIG CA START POS
         LR    R9,R7               SET REGS LENGTH EQUAL
         MVCL  R8,R6               MOVE IT TO THE ORIG_CA
*
*                             R8 NOW POINTS TO 1 POS BEYOND DATA IN CA
*                             WE SEE IF IT IS STILL WITHIN THE CA
*              NOTE-R8 NOW POINTS 1 BEYOND DATA MVCL ABOVE.
*                   R8 COULD BE OUT OF ORIG CA BY ONE, SO REDUCE IT
         BCTR  R8,0           WE WANT TO APPEND A NULL VALUE TO CA
         C     R8,P_OCA_LSTPOS     SO THAT C AND C++ PGMS CAN SEE IT
*                                  AS A REGULAR NULL TERMINATED STRING
         JL    ADD1_NULL_2_CA    CUR POS STILL WITH IN CA;
*                             SO WE WILL PLACE NULL IN POS BEYOND
*                             THE RETURNED MSG IN THE ORIG CA
*
         MVI   RC,C'1'        SET RC TO INDICATE INCOMPLETE
         MVC   FRC,F1
         JE    NULL_IT        RETURNING CA FILL. OVERWRITE LAST POSN
*              NOTE-SHOULD NEVER GET HERE. THIS INDICATES THAT THE
*                   MVCL ABOVE MOVED DATA BEYOND THE ORIG CA
         MVI   RC,C'2'        SET RC TO INDICATE INC AND NON-NULL_TERM
         MVC   FRC,F2
         J     CANT_RET_NULL_TERM  RET A NON NULL TERM STRING
*
NO_DATA_2_RTN EQU *
         L     R5,P_OCA       CHECK IF CMD IN ORIG CA
         CLC   LIT_PING,0(R5)       IS PING
         JE    DO_FIN         YES. GO FIN
*
*              NOTE-ORIG CA DID NOT HAVE A VALID CMD (OR CAL=0)
         MVC   OPLIT(L'NO_DATA_2_CA_MSG),NO_DATA_2_CA_MSG
*        MVC   OPLIT+1(5),TASK_NUM
         JAS   R9,WRIT_EMSG_2_TD
         J     DO_FIN
*
ADD1_NULL_2_CA EQU *
*                           ADD 1 BACK TO R8, BECAUSE WE CAN FIT
         AHI   R8,1         THE NULL TERM CHARACT WITHIN ORIG CA
NULL_IT  EQU *
         MVI   0(R8),X'00'  PLACE A NULL AT LAST POS IN ORIG CA
CANT_RET_NULL_TERM EQU *
* ??     L     R8,P_OCA_CURPOS
*              ORIG CA LENG > 0, SO WE CAN ISSUE A RETURN CODE
         L     R8,P_OCA       REAL CA OR CN_SURR_CA
         MVC   0(1,R8),RC     INSERT THE RETURN CODE
*     NEW CODE FOR CN
DO_FIN   EQU   *
         CLC   CH_NM,SPACE255  CHECK FOR CHANNEL NAME
         JE    GOT_CA_NOT_CN
         L     R9,SAV_CN_CMD_RET9
         L     R15,FRC    GET RC FROM STG
         BR    R9         BRANCH BACK TO THE CNC LOGIC
*             WHICH IS GONNA LAND YOU AT LABEL
*             CN_RET_FROM_OLD_CMD
*
GOT_CA_NOT_CN DS 0H
DO_FIN_CN_RETURN DS 0H
*
         EXEC  CICS RETURN
         DFHEIRET           RESTORE THE CALLERS REGS HERE
*
* ERROR MESSAGES
*
CANT_DO_IT EQU *
         MVC   OPLIT,LIT_CANT_DO_IT
         MVC   OPLIT+24(2),ST_CD
         J     DO_WRITE_TD_ERR
*
BAD_PING_CN_DATA DS 0H
BAD_CEMT_CN_DATA DS 0H
BAD_CEDA_CN_DATA DS 0H
BAD_LINK_CN_DATA DS 0H
BAD_CMD_CN_DATA DS 0H
         MVC   OPLIT(L'BAD_LINK_CN_DATA_MSG),BAD_LINK_CN_DATA_MSG
         MVC   OPLIT+14(4),CN_NM
         MVC   OPLIT+59(4),0(R5)
         J     DO_WRITE_TD_ERR
*
BAD_LINK_CMD_EQ        DS 0H
         MVC   HLDSTR,LIT_BAD_EQ
         J     BAD_LINK_CMD
BAD_LINK_CMD_SEP       DS 0H
         MVC   HLDSTR,LIT_BAD_SEP
         J     BAD_LINK_CMD
BAD_LINK_CMD_RECUSION  DS 0H
         MVC   HLDSTR,LIT_BAD_RECSN
         J     BAD_LINK_CMD
BAD_LINK_CMD   DS 0H
         MVC   OPLIT(L'LIT_BAD_LINK_CMD),LIT_BAD_LINK_CMD
         MVC   OPLIT+43(7),HLDSTR
         J     DO_WRITE_TD_ERR
*
BAD_LINK_RESP EQU *
         MVC   OPLIT(L'LIT_BAD_LINK_RSP),LIT_BAD_LINK_RSP
         J     DO_WRITE_TD_ERR
*
ERR_CA_STR EQU *
         MVC   OPLIT(L'LIT_BAD_CA_STR),LIT_BAD_CA_STR
         MVC   OPLIT+38(4),RTE_TO_SYSID
         J     DO_WRITE_TD_ERR
*
BAD_SYSID_RESP EQU *
         MVC   OPLIT,LIT_BAD_SYSID
         MVC   OPLIT+19(4),RTE_TO_SYSID
         J     DO_WRITE_TD_ERR
*
BAD_START_CMD_GM DS 0H
BAD_START_UKN_GM DS 0H
BAD_START_CN EQU *
         MVC   OPLIT+1(L'BAD_START_CN_MSG),BAD_START_CN_MSG
         CLC   CN_GM_PARM_STK_IND,F0
         JNE   BAD_START_UKN_LIT
         MVC   OPLIT+34(L'CN_CMD_LIT),CN_CMD_LIT
         J     BAD_START_CN_PUT_MSG
BAD_START_UKN_LIT    DS 0H
         MVC   OPLIT+45(L'CN_UKN_LIT),CN_UKN_LIT
BAD_START_CN_PUT_MSG DS 0H
         L     R15,FRESP
         JAS   R9,B2C
         MVC   OPLIT+77(3),HLDSTR+4
         L     R15,FRESP2
         JAS   R9,B2C
         MVC   OPLIT+88(3),HLDSTR+4
         IILF  R0,L'BAD_START_CN_MSG
         ST    R0,PUT_APND_MSG_FL
         JAS   R9,PUT_APND_RESP_CN
*
         MVC   OPLIT,OPLIT+1
         J     DO_WRITE_TD_ERR
*
BAD_START EQU *
         MVC   OPLIT,LIT_BAD_START
         J     DO_WRITE_TD_ERR
*
DO_WRITE_TD_ERR EQU *
         JAS   R9,WRIT_CMD_2_TDQ_OPLIT
         JAS   R9,BASEMSG
         J     DO_RETURN
*
* BASEMSG WHEN USES MOSTLY EIB INFORMATION
*
BASEMSG  EQU   *
         ST    R9,SAV_RET_9A
*
         EXEC CICS INQUIRE TERMINAL(EIBTRMID)                          *
               NETNAME(TRMNETID)                                       *
               USERNAME(TRMUSRNM)                                      *
               RESP(FRESP)                                             *
               RESP2(FRESP2)
*        CLC   FRESP,DFHRESP(NORMAL)
         MVC   OPLIT,OPLIT1
         MVC   OPLIT(8),TRMNETID
         MVC   OPLIT+9(8),LCL_UID                !20170802
         MVC   OPLIT+18(8),TRMUSRNM
         MVC   OPLIT+27(4),EIBTRNID
         MVC   OPLIT+32(4),EIBTRMID
*        ZAP   P4,EIBTASKN
*        UNPK  C8,P4
*        OI    C8+7,X'F0'
*        MVC   OPLIT+37(7),C8+1
         MVC   OPLIT+37(7),TASKNUM+1
         ZAP   P4,EIBTIME
         UNPK  C8,P4
         OI    C8+7,X'F0'
         MVC   OPLIT+45(2),C8+2
         MVI   OPLIT+47,C'.'
         MVC   OPLIT+48(2),C8+4
         MVI   OPLIT+50,C'.'
         MVC   OPLIT+51(2),C8+6
         MVC   OPLIT+54(8),PGM_CUR
         EXEC CICS INQUIRE PROGRAM(PGM_CUR)                            *
               EXECUTIONSET(PGMAPI)                                    *
               RESP(FRESP)                                             *
               RESP2(FRESP2)
         CLC   PGMAPI,DFHVALUE(FULLAPI)
         JE    FULLAPI
         CLC   PGMAPI,DFHVALUE(DPLSUBSET)
         JNE   NOTAPPL
         MVC   OPLIT+63(9),=C'DPLSUBDET'
         J     BASEMSG_DOWRITTD
NOTAPPL  EQU   *
         MVC   OPLIT+63(9),=C'NOTAPPLIC'
         J     BASEMSG_DOWRITTD
FULLAPI  EQU   *
         MVC   OPLIT+63(7),=C'FULLAPI'
         J     BASEMSG_DOWRITTD
*
BASEMSG_DOWRITTD EQU *
         JAS   R9,WRIT_CMD_2_TDQ_OPLIT
         L     R9,SAV_RET_9A    R9 SAVED AT TOP OF BASEMSG
         BR    R9
*
*  GENERIC WRITE TDQ WITH ERROR MESSAGE IN OPLIM10
*   WE CALL WRIT_CMD_2_TDQ_OPLIT
WRIT_EMSG_2_TD EQU *
         ST    R9,SAV_RET_9B
         MVC   OPLIT00+1(8),TIMER_ENT_ST_JDT
         MVC   OPLIT00+10(8),TIMER_ENT_ST_TOD
         MVC   OPLIT+1(5),TASK_NUM
         JAS   R9,WRIT_CMD_2_TDQ_OPLIT
*        JAS   R9,WRTLINE
         L     R9,SAV_RET_9B
         BR    R9
*
* GENERIC WRITE TDQ WITH MESSAGE IN OPLIM10
*
WRTLINE  DS    0H
         CLC   TDQ_ENA,DFHVALUE(ENABLED)
         JNE   WRTLINE_XIT
         EXEC  CICS WRITEQ TD QUEUE(TDQ) FROM(OPLIT00) LENGTH(H80)
WRTLINE_XIT DS 0H
         MVC   OPLIT,OPLIT1
         BR    R9
*
* ROUTINE TO WRITE CMD LINE TO TDQ WHEN CEMT,CEDA,LINK,...
* TO PROVE WE GOT WHERE WE WERE SUPPOSE TO GET TO.
*   WE CALL WRIT_CMD_2_TDQ_OPLIT TO MVC OPLIT TO UR_REST
WRIT_CMD_2_TDQ_OPLIT DS 0H
         CLC   TDQ_ENA,DFHVALUE(ENABLED)
         JNE    WRIT_CMD_2_TDQ_OP_X
*
         ST    R9,SAV_RET_9
         LA    R9,OPLIT00
         ST    R9,CN_MSG_A
         IILF  R15,OPLIT00_TOT_EQU
         ST    R15,CN_MSG_L
WRIT_CMD_2_TDQ_OP_0 DS 0H
         CH    R15,TDQ_RECLH
         JL    WRIT_CMD_2_TDQ_OP_2
         SH    R15,TDQ_RECLH
         ST    R15,CN_MSG_L
         LH    R15,TDQ_RECLH
         J     WRIT_CMD_2_TDQ_OP_3
*   CHECK FOR ALL SPACES, AND BYPASS IF TRUE
WRIT_CMD_2_TDQ_OP_2 DS 0H
         XC    CN_MSG_L,CN_MSG_L   ZERO REMN LNG
*   CHECK FOR ALL SPACES, AND BYPASS IF TRUE
WRIT_CMD_2_TDQ_OP_3 DS 0H
         BCTR  R15,0
         EXRL  R15,WRIT_CMD_TDQ_OP_CLC
         LA    R15,1(R15)   ADD BACK BCTR
         JE    WRIT_CMD_2_TDQ_OP_SPACES
         STH   R15,TDQ_RECL_REQ_LNG
*
         EXEC  CICS WRITEQ TD QUEUE(TDQ)                               *
               FROM(0(R9))   LENGTH(TDQ_RECL_REQ_LNG)                  *
               RESP(FRESP)                                             *
               RESP2(FRESP2)
         LH    R15,TDQ_RECL_REQ_LNG
WRIT_CMD_2_TDQ_OP_SPACES DS 0H
         AR    R9,R15
         ST    R9,CN_MSG_A
         LT    R15,CN_MSG_L
         JP    WRIT_CMD_2_TDQ_OP_0
*
WRIT_CMD_2_TDQ_OP_1 DS 0H
         L     R9,SAV_RET_9
WRIT_CMD_2_TDQ_OP_X DS 0H
         BR    R9
*
WRIT_CMD_TDQ_OP_CLC CLC 0(0,R9),SPACE255
*
WRIT_CMD_2_TDQ DS 0H
         CLC   TDQ_ENA,DFHVALUE(ENABLED)
         JNE   WRIT_CMD_2_TDQ_XIT
*
         ST    R9,SAV_RET_9
         LA    R9,L'UR_RESP
         CH    R9,TDQ_RECLH
         JL    WRIT_CMD_2_TDQ_GO
         LH    R9,TDQ_RECLH
WRIT_CMD_2_TDQ_GO DS 0H
         STH   R9,TDQ_RECL_REQ_LNG
         EXEC  CICS WRITEQ TD QUEUE(TDQ)                               *
               FROM(UR_RESP) LENGTH(TDQ_RECL_REQ_LNG)                  *
               RESP(FRESP)                                             *
               RESP2(FRESP2)
         MVC   OPLIT,OPLIT1
         L     R9,SAV_RET_9
WRIT_CMD_2_TDQ_XIT DS 0H
         BR    R9
*
* DFHEMTA AND DFHEDAP USES SIMILAR PARM LISTS
*
* GM AREA (32402) IS USED AS FOLLOWS
*  PARM TO CALL CONSISTS OF 5 FW ADDRESSES
*   OFFSET X'0'
*     1) PTR TO CMD AREA
*   OFFSET X'4'
*     2) PTR TO CMD HW LENGTH
*   OFFSET X'8'
*     3) PTR TO FLAG BYTE
*   OFFSET X'C'
*     4) PTR TO OUTPUT AREA
*   OFFSET X'10'
*     5) PTR TO OUTPUT AREA LENGTH
*   OFFSET X'14' HOLDS DERIVED HW LNG OF CMD
*   OFFSET X'16' HOLDS FLAG BYTE
*   OFFSET X'18' HOLDS HW LNG OF THE OP AREA (32400-26)
*   OUTPUT AREA STARTS HERE AT
*   OFFSET X'1A'
*     EXPECT OUTPUT DATA AS FOLLOWS
*              PROGRAM USES AS REQUIRED
*          A) 3 HW ????
*          B) 1 HW OUTPUT LENGTH
*          C) 1 HW OUTPUT NUMBER OF LINES
*          D) 1 HW OUTPUT CONDITION CODE
*          E) ACTUAL OUTPUT (EACH LINE HAS PREFIX X'15')
*     WE INSURE LAST TWO BYTES ARE INITIALIZED:
*  OFFSET 32400 - X'15' FORCE 'LAST OUTPUT LINE'
*         32401 - X'00'   USED TO DELIMIT SSTR INSTRUCTION
*
* FW|FW|FW|FW|FW|HW|BY|BY|HW|OPDATA......|BY|BY
*
SET_UP_CMD4XEQ DS 0H
         ST    R9,SAV_RET_9
         LH    R15,H32400
         AHI   R15,2         NEEDED BELOW TO LIMIT CEMT BOUNDS
         ST    R15,F_DPL_CAL
*
         MVC   GM_STG_FL,F_DPL_CAL
         JAS   R9,GM_STG
         LT    R8,GM_STG_ADR
         JZ    BAD_CMD_STG
*
         ST    R8,P_CMD_A       SAVE PTR TO THIS GM AREA
         ST    R5,0(R8)         SAVE PTR INTO THIS CMD AREA
*                       THE CMD AREA IS PASSED TO DFHEMTA/DFHEDAP
*                       AND THE FIRST PARM IS ADDR OF THE CMD
*                       WHICH IS THE CMD IN CA OR CN
*
         LH    R15,SAV_CAL_REMN
         CH    R15,MAX_CMD_LEN
         JL    SET_UP_USE_CAL_REMN
         MVC   H_MAX_CMD_LEN,MAX_CMD_LEN  USE DEFAULT
         J     SET_UP_USE_DFT_CMD_LEN
SET_UP_USE_CAL_REMN DS 0H
         STH   R15,H_MAX_CMD_LEN   USE CAL_REMN AS SEARCH LENGTH
SET_UP_USE_DFT_CMD_LEN DS 0H
*   SRST R0 56-63 HAS BYTE TO SEARCH FOR
*        R1 (FIRST REG) HAS THE ENDING ADDR
*        R2 (2ND   REG) HAS THE STARTING ADDR
*   CHK  JC    MASK,JUMP_TO_REL_ADDR
*        CC  0 8    NOT DEFINED
*            1 4    FOUND, R1 UPDATED WITH BYTE FOUND,R2 UNCHGD
*            2 2    NOT FOUND, R1 AND R2 UNCHANGED
*            3 1    SPIN SEARCH, R1 UNCHGD, R2 POINTS TO NEXT SRCH ADR
*              + THIS IS THE VALUE TO USE IN THE JC INSTR
         LA    R0,0             CLEAR R0  LOOK FOR NULL
         LA    R15,0(R15,R5)    BUMP OCA BEYOND LAST SEARCH CHAR
         ST    R5,SAV_4_SRST    SAVE PTR TO CMD BEG ADR
*
SET_UP_LOOK_FOR_NULL SRST R15,R5
*
         JC    4,SET_UP_KEEP_NULL_LNG      FOUND
         JC    2,SET_UP_NO_NULLS     NOT FOUND. SPACE FILL?
         JC    1,SET_UP_LOOK_FOR_NULL      SPIN
SET_UP_KEEP_NULL_LNG EQU *
         L     R5,SAV_4_SRST    RESTORE BEGINNING CMD
         SR    R15,R5           GET SEARCH LENGTH
         STH   R15,H_MAX_CMD_LEN   SAVE LNG
SET_UP_NO_NULLS EQU *
* WANT TO FIND THE FIRST CHAR IN PASSED COMMAREA THAT IS NOT A SPACE
*    IN ORDER TO DETERMINE THE ACCURATE COMMAND LENGTH
* USE THE PARS ROUTINE TO FIND, SEARCHIN BACKWARDS
         L     R5,0(R8)           GET START OF CMD (ADR SAVE ABOVE)
*                                 SAVED PTR (ABOVE) IN THIS GM AREA
*                                 POINTS TO THE OCA CURPOS
         MVC   PARSE_DIRECTN,HMINUS1   SEARCH BACKWARDS
         MVC   PARSE_EQ,HMINUS1        FIND UNEQUAL
         LA    R1,THEPARM
         ST    R5,8(R1)                ST ADDR OF THE HAYSTAK
         LA    R15,H_MAX_CMD_LEN        MAX COMMAND LENGTH IS 80 !!
         ST    R15,12(R1)              ST ADDR OF HAYSTAK LENGTH
         LA    R15,SP1
         ST    R15,0(R1)               ST ADDR OF NEEDLE
         LA    R15,H1
         ST    R15,4(R1)               ST ADDR OF NEEDLE LENGTH
* FIND FIRST NON SPACE STARTING FROM END OF CA
         XR    R15,R15
         JAS   R9,PARS
         LTR   R15,R15
         JZ    BAD_CMD_ALL_SP          NO CMD IN CAL_REMN
*
*  CHECK CMD_CA FOR ACCURATE CEDA CALL TSR3.2 20090427
*
         L     R8,P_CMD_A       LOAD ADDR OF THE GM (ABOVE) CMD CA
*
         AHI   R15,1            ADD 1 AND SUBTRACT CMD END ADDR TO
         SR    R15,R5           DERIVE LNG OF CMD (R15 IS SRCH RSLT)
*                               AND R5 IS THE OCA CURPOS
         CH    R15,H8           GOT CMD LNG. CHK FOR MIN LNG
         JL    BAD_CMD_LEN
         STH   R15,20(R8)      SAVE THE COMMAND LENGTH AT 20 20090427
         LA    R15,20(R8)       STORE PTR TO THEI CMD LNG ADDR
         ST    R15,4(R8)        SAVE PTR TO COMMAND OP AREA BEGIN
*
         MVI   22(R8),X'00'
         LA    R15,22(R8)       DEFAULT COMMAND LENGTH TO REST OF CA
         ST    R15,8(R8)        SAVE PTR TO COMMAND OP LNG
*
         LA    R15,26(R8)       POINT PAST THE CEDAPARM (5 FW ADDR)
         ST    R15,12(R8)        SAVE PTR TO COMMAND OP AREA BEGIN
*
         LH    R15,H32400       OUTPUT AREA LNG MINUS 26
         AHI   R15,-26            20 FOR 5 FW PARMS, 2 FOR HW CMD LNG
         STH   R15,24(R8)         2 FOR FLG/FILL, 2 FOR OP HW LNG
         LA    R15,24(R8)       POINT PAST THE CEDAPARM (5 FW ADDR)
         ST    R15,16(R8)        SAVE PTR TO COMMAND OP AREA BEGIN
*
         A     R8,F32400         POINT TO LAST-1 POS IN GM AREA
         CLC   PGM_CMD,LIT_DFHEDAP
         JNE   GOT_DFHEMTA
         MVI   1(R8),X'00'    FORCE BUFFER END FOR SRST VALUE
         J     ARND_DFHEMTA
GOT_DFHEMTA    EQU *
         MVI   1(R8),X'15'    MOVE X'15' CEMT DELM
ARND_DFHEMTA   EQU *
         MVI   2(R8),X'00'    MOVE X'00' (SRST) DELIMITER
         XR    R15,R15          RETURN 0
         J     RET_SET_UP_CMD4XEQ
BAD_CMD_LEN    EQU *
BAD_CMD_ALL_SP EQU *
BAD_CMD_STG    EQU *
         MVC   FRC,F8
         L     R15,F8
RET_SET_UP_CMD4XEQ EQU *
         L     R9,SAV_RET_9
         BR    R9

**
* find the cnc_cn_elem by matching name in cn_move_nm
FND_CNC_ELEM_BY_CN DS 0H
         ST    R9,SAV_FND_CNC_ELEM_R9
         STM   R4,R8,SAV_FND_CNC_REGS_4_8
*
         XR    R15,R15
         LA    R9,CMD_TBL
FND_CNC_SRCH_4_CMD DS 0H
         CLC   CN_MOVE_NM(4),0(R9)
         JE    FND_CNC_CN_GOT_CMD
         CLC   0(4,R9),CMD_END    CMD_END LIT IS X0 AS IS END OF TBL
         JE    FND_CNC_CN_NOT_CMD
         AHI   R9,CMD_TBL_ENT_LNG
         J     FND_CNC_SRCH_4_CMD
*
FND_CNC_CN_GOT_CMD  DS 0H
         LT    R6,CN_GM_CMD_ANCH    PTR TO FIRST CN STK
         JZ    FND_CNC_CN_NOT_CMD   WE HAVE NO CNC - SO ABORT
*
*        USING CNC_CN,R6           R6 IS THE STK ANCH - USING SET
         L     R7,CNC_CN_LIST_ELEM_TOP    CUR STK, FIRST ELEM ADR
*         ST    R7,CN_CUR_CN_ELEM          SAVE THE CUR ELEM ENTRY
*        USING CNC_CN_ELEM,R7      R7 IS THE ELEM ADR - USING SET
         XC    FND_CMD_STK_PROCD,FND_CMD_STK_PROCD      COUNTER
FND_CNC_TOP_OF_CN_LOOP DS 0H
         CLC   CN_MOVE_NM,CNC_CN_N
         JE   FND_CNC_FND_CN
*
         L     R9,FND_CMD_STK_PROCD    HOW MANY ELEM FROM THIS STAK
         AHI   R9,1                      WERE PROCESSED. AT MAX?
         C     R9,CNC_CN_LIST_ELEM_CUR_CT
         JNL   FND_CNC_CN_PROCESS_NXT_STK        YES SO GO TO GET NXT
         ST    R9,FND_CMD_STK_PROCD
         AHI   R7,CNC_CN_ENT_L   STILL IN ELEM LIST ON CUR STK
         J     FND_CNC_TOP_OF_CN_LOOP       SO ADD LNG OF ELEM TO GET
*
FND_CNC_CN_PROCESS_NXT_STK DS  0H    GET THE NEXT STACK AREA
*    STILL HAVE:USING CNC_CN,R6
*               USING CNC_CN_ELEM,R7
*                  ZERO STK ELEM COUNTER
         XC    FND_CMD_STK_PROCD,FND_CMD_STK_PROCD
         L     R6,CNC_CN_LIST_NXT       PT TO NXT STK
         CIJE  R6,0,FND_CNC_CN_FIN_CMD_ELEM     MAKE SURE IT EXISTS
*                 IF NXT IS ZEROS, THEN NO MORE STK
*                 IF IT DOES, THEN AT LEAST ONE CMD IN NXT STK
*                  SO SET UP FOR FIRST ELEM
         L     R7,CNC_CN_LIST_ELEM_TOP    CUR STK, FIRST ELEM ADR
         C     R9,CNC_CN_LIST_ELEM_CUR_CT
         CIJE  R6,0,FND_CNC_CN_FIN_CMD_ELEM     IF NOT > 0 THEN JUMP D
         J     FND_CNC_TOP_OF_CN_LOOP         AT LEAST ONE
*
FND_CNC_FND_CN DS 0H
         LR    R15,R7
         J     FND_CNC_FIN
*
FND_CNC_CN_NOT_CMD      DS 0H
FND_CNC_FIN             DS 0H
FND_CNC_CN_FIN_CMD_ELEM DS 0H
         LM   R4,R8,SAV_FND_CNC_REGS_4_8
         L    R9,SAV_FND_CNC_ELEM_R9
         BR   R9
*
**
* GENERALIZED STRING PARSER
*  EXPECTS PARM LIST OF LENGTH X'10' TO BE PASSED IN REG1
*   1ST FW PTR TO STRING TO BE SEARCHED FOR (NEEDLE)
*   2ND FW PTR TO HW LENGTH OF STRING TO BE SEARCHED FOR (NEEDLE)
*   3RD FW PTR TO STRING TO BE SEARCHED     (HAYSTACK)
*   4TH FW PTR TO HW LENGTH OF STRING TO BE SEARCHED
*  RETURN REG 15
*    0 IF NOT FOUND
*    ADDRESS OF FIRST FIND OR NOT FOUND
*  PARSE_DIRECTN SET TO +1 FOR FOWARD SEARCH
*                       -1 FOR BACKWARD SEARCH
*  PARSE_EQ      SET TO  0 FOR STOP WHEN EQUAL FOUND
*                       -1 FOR STOP WHEN NOTEQUAL FOUND
* GENERALIZED STRING PARSER
* BASED ON VERSION 1.2 - SEE THEPARM IN DYN STG
**
PARS     EQU   *
         STM   R0,R12,PARS_REG_SA
         LTR   R1,R1               REG1 MUST NOT BE NULL
         JZ    NOPARM              addr of 1st of 4 fw ptrs
*
         ICM   R4,B'1111',0(R1)    FIRST PTR TO NEEDLE
         JZ    NOPARM
         ICM   R5,B'1111',4(R1)    BUMP TO NXT ADDR,POINT TO
         LH    R5,0(R5)            HW LNG OF NEEDLE
         LTR   R5,R5
         JZ    NOPARM
         ICM   R6,B'1111',8(R1)    BUMP PAST FIRST TWO ADDR FOR ADDR
         JZ    NOPARM              OF HAYSTACK
         ICM   R7,B'1111',12(R1)   FINALLY BUMP TO LAST ADDR TO GET
         LH    R7,0(R7)            PTR TO HW HAYSTACK ADDR
         LTR   R7,R7
         JZ    NOPARM
*        CR    R5,R7              NEEDLE LNG GT HAY LNG
*        JH    NOPARM
         CRJH  R5,R7,NOPARM
*
         SR    R7,R5          REDUCE THE HAYS LNG BY NEEDLE LNG TO
*                              LIMIT THE COMPARE OF LAST ADDR
         LR    R8,R6          PRESERVE HAYS ADDR
         AR    R8,R7          ADD IN HAYS LNG FOR FINAL POS
         BCTR  R5,0            REDUCE FOR EXECUTE
         LH    R15,PARSE_DIRECTN +1 OR -1
         CHI   R15,0
         JNL   CLCLOOP
         LR    R0,R8          SWAP FOR NEG DIRECTN
         LR    R8,R6           START AT LAST POSN AND END AT FIRST
         LR    R6,R0
CLCLOOP  EQU   *
         CLC   PARSE_EQ,H0
         JNE   DO_UNEQ
*
         EXRL  R5,CLCPARSE     CLC   0(0,R6),0(R4)
         JE    NEEDLEF
         J     CLC_NEXT
*
DO_UNEQ  EQU   *
         EXRL  R5,CLCPARSE     CLC   0(0,R6),0(R4)
         JNE   NEEDLEF
*
CLC_NEXT EQU   *
         AR    R6,R15
         LTR   R15,R15
         JNP   DO_NEG_DIR_TST
*        CR    R6,R8
*        BNH   CLCLOOP
         CRJNH R6,R8,CLCLOOP
         J     NOPARM
*
DO_NEG_DIR_TST EQU *
*        CR    R6,R8
*        JNL   CLCLOOP
         CRJNL R6,R8,CLCLOOP
         J     NOPARM
*
NOPARM   EQU   *
         XR    R15,R15
         J     DONEPGM
*
NEEDLEF  EQU   *
         LR    R15,R6
*
DONEPGM  EQU   *
*              RESET THE PARS DEFAULTS
         XC    PARSE_DIRECTN,PARSE_DIRECTN
         MVI   PARSE_DIRECTN+1,X'01'
         XC    PARSE_EQ,PARSE_EQ
         LM    R0,R12,PARS_REG_SA
         BR    R9
*
***
*  ON ENTRY, THE CN_GM_PARM_LIST CONTAINS GM VALUES
*     CHAIN SET UP:
*     CN_GM_PARM_STK_CUR_PTR POINTS TO THE NEXT
*      FOR WHICH ON FIRST GM, IT HOLD THE ANCH
*      AND FOR SUBSEQUENT, IT HOLDS THE
***
* GET STORAGE FOR LIST OF CONTAINERS, LIMIT 100 PER STACK GM
GM_CN_STACK DS 0H
         ST    R9,SAV_RET_9          SAVE LINK REG
         XR    R15,R15               ZEROS FOR RC
*
         MVC   GM_STG_FL,CN_LIST_GM_L
         JAS   R9,GM_STG
         LT    R6,GM_STG_ADR
         JZ    CN_GM_STACK_RESP_ERR
*
         L     R9,CN_GM_PARM_STK_CUR_PTR
         ST    R6,CN_GM_PARM_STK_CUR_PTR
         ST    R6,0(R9)          PTR TO 'NEXT' SAVE AREA
*              IN THE CURRENT STK, THAT WE SET ADDR TO VIA CUR_PTR
*              ON CALL TO THIS PROCEDURE, BEFORE CALLING,
*  CN_GM_PARM_STK_CUR_PTR IS POINTING TO EITHER:
*               ANCH ANCHOR SAVE AREA ON INITIIALGM
*               OR THE MOST CURRENT (LAST) STACK 'NEXT' SAVE
*              SO WE CAN SAVE THE FW PTR TO THIS NEW STK AREA
*               INTO THE CURRENT STK 'NEXT' SAVE AREA
*   PROCESS NEW STACK ENTRY
         USING CNC_CN,R6
         XC    CNC_CN_LIST_NXT,CNC_CN_LIST_NXT  LV IND TOP
         MVC   CNC_CN_LIST_LNG,CN_LIST_GM_L  LNG OF GM
         MVC   CNC_CN_LIST_TYP,CN_GM_PARM_STK_IND TYP OF GM
*                  MOVE MAX CNT FOR THIS STK TO THIS AREA
         MVC   CNC_CN_LIST_ELEM_MX_CT,CN_GM_ELEM_CT_INCR
*                  ZERO CUR ELEM STK PT FOR THIS STK
         XC    CNC_CN_LIST_ELEM_CUR_CT,CNC_CN_LIST_ELEM_CUR_CT
         LA    R9,CNC_CN_ENT_L  (EQU)   GET ELEM LNG
         ST    R9,CNC_CN_LIST_ELEM_LNG  SAVE IN THIS STK AREA
         LA    R9,CNC_CN_SAA_L(,R6)
         ST    R9,CNC_CN_LIST_ELEM_TOP     SAVE AS TOP
*            POINT R9 BACK L OF STK ELEM, TO SET UP
*                   FOR FIRST CN ENTRY
         AHI   R9,-(CNC_CN_ENT_L)
         ST    R9,CNC_CN_LIST_ELEM_CUR
*
         XR    R15,R15
*        DROP  R6
         J     RET_GM_CN_STACK
*
CN_GM_STACK_RESP_ERR DS 0H
         LA    R15,8
         J     RET_GM_CN_STACK
*
RET_GM_CN_STACK DS 0H
         L     R9,SAV_RET_9
         BR    R9
*
*  MOVE CHANNEL CN FROM CH_MOVE_NM_FROM
*                    TO CH_MOVE_NM_TO
*
*   ON DPL WITH CN, NEED TO MOVE ALL RETURNING CN TO CUR CH
CN_MOVE_2_CUR_CH DS 0H
         ST    R9,SAV_CN_MOVE_R9
         XR    R15,R15               ZEROS FOR RC
         XC    CN_BRS_TKN,CN_BRS_TKN
         XC    CN_MOV_BRS_ERRCT,CN_MOV_BRS_ERRCT
         XC    GM_STG_FL,GM_STG_FL
*
* FIRST: DETERMINE IF STANDARD RESPONSE CN IS ON SYSID CH
*        IF SO: THEN APPEND DATA TO THE MAIN RESPONSE CN
         EXEC CICS GET CONTAINER(CN_RESP_NM) CHANNEL(CH_MOVE_NM_FROM)  *
              NODATA FLENGTH(TMP_CN_FL)                                *
              RESP(FRESP)                                              *
              RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)    GET CN
         JNE   CN_MOVE_ST_BRS
*
         MVC   GM_STG_FL,TMP_CN_FL
         JAS   R9,GM_STG
         LT    R9,GM_STG_ADR
         JZ    CN_MOVE_RSP_ERR
*   USING CN_MOV_BRS_ERRCT TO TMP HOLD STG ADR
         ST    R9,CN_MOV_BRS_ERRCT
         EXEC CICS GET CONTAINER(CN_RESP_NM) CHANNEL(CH_MOVE_NM_FROM)  *
              INTO(0(,R9)) FLENGTH(TMP_CN_FL)                          *
              RESP(FRESP)                                              *
              RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)    GET CN
         JNE   CN_MOVE_RSP_ERR
*
         ST    R9,PUT_APND_MSG_ADR
         MVC   PUT_APND_MSG_FL,TMP_CN_FL
         JAS   R9,PUT_APND_RESP_CN
*
         EXEC CICS DELETE   CONTAINER(CN_RESP_NM)                      *
              CHANNEL(CH_MOVE_NM_FROM)                                 *
              NOHANDLE
         J    CN_MOVE_ST_BRS
*
CN_MOVE_RSP_ERR DS 0H
         MVC   OPLIT(L'DPL_CN_RESP_ER),DPL_CN_RESP_ER
         IILF  R0,L'DPL_CN_RESP_ER
         ST    R0,PUT_APND_MSG_FL
*
         JAS   R9,PUT_APND_RESP_CN
*
CN_MOVE_ST_BRS DS 0H
         LT    R9,CN_MOV_BRS_ERRCT
         JZ    CN_MOVE_ST_BRS2
*
         EXEC CICS FREEMAIN DATAPOINTER(R9)                            *
               NOHANDLE
         XC    CN_MOV_BRS_ERRCT,CN_MOV_BRS_ERRCT
*
*  MOVE OR PUT APPEND ALL SRC CONTAINERS TO
*       TGT CHANNEL
*       WHEN IN PLAY LIST, ALTER ANY TGT CN NAMES WITH PLA PFX
CN_MOVE_ST_BRS2 DS 0H
         EXEC CICS STARTBROWSE CONTAINER                               *
         CHANNEL(CH_MOVE_NM_FROM)                                      *
         BROWSETOKEN(CN_BRS_TKN)                                       *
         RESP(FRESP)                                                   *
         RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)    CH STBR
         JNE   CN_MOVE_ST_BRWS_ERR
*
CN_MOVE_GETNEXT DS 0H
         EXEC CICS GETNEXT CONTAINER(CN_MOVE_NM)                       *
          BROWSETOKEN(CN_BRS_TKN)                                      *
          RESP(FRESP)                                                  *
          RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(END)
         JE    CN_MOVE_DONE_BRS
*
         CLC   FRESP,DFHRESP(NORMAL)
         JNE   CN_MOVE_GETNEXT_ERR
*
* CLONE LOGIC
*  TEST IF WE ARE MOVING CN WITHIN A PLAY CMD
*  IF SO, THEN WE GOT TO RESET THE CH_NM BACK TO THE TMP CLONE CH
*  STORED IN PLAY_CLONE_TMP_CH_NM
* CLONE LOGIC
*  CONTAINER NAME COPIED - IF NOT PLAYED, WE USE IT AS IS
         MVC   PLAY_CLONE_CN,CN_MOVE_NM
         CLI   PLAY_LCNC_REQUEST,X'FF'
         JNE   CN_MOV_NOT_PLAY_CN         NOT A PLAYED CMD
*  MOVE RSP CN BACK TO PLAY CN
*  UPON RETURN HERE: THE REPONSE CN HAS BEEN WRITTEN TO THE
*   TMP CH NM IN PLAY_CLONE_TMP_CH_NM (CHAN NAME ALSO IN CH_NM)
*  WE NEED TO CREATE A UNIQUE CONT NAME FOR THIS CMD RESP, AND THEN
*   MOVE THIS CN FROM THE TMP CH BACK TO THE REAL CN WHOSE NAME IS
*   SAVED IN THE PLAY_CLONE_SAV_CH_NM
*
*   PLAY_CLONE_PFX ALREADY SET TO 'PLA'
*   THE 4TH POS IS THE UNIQUE PLAY_CLONE_PFX_ELEM NUM
*   SIMPLY MOVE THE REST OF THE REAL CN TO THE TMP CN NM
*   PLA#XXXXXXXXYYYY  ORIG CN 1-8 AND 13-16
         MVC  PLAY_CLONE_PFX,CMD_PLAY                    POS 1-3
         MVC  PLAY_CLONE_PFX_ELEM,PLAY_CLONE_PFX_ELEM_CT POS 4
         MVC  PLAY_CLONE_CMD_1_12,CN_MOVE_NM             POS 5-16
         J    CN_MOV_FIN_DST_CN_NM
*
CN_MOV_NOT_PLAY_CN DS 0H
*  LCNC MOVE SRC TO TGT - IF OTHER USERS ARE NEEDED, THEN
*   CREATE ADDITIONAL VALUES FOR SWITCH PLAY_LCNC_REQUEST SO
*   THAT OTHER CN PREFIX NAMES CAN BE ACOMIDATEDC_REQUEST SO
*
*  MOVE RSP CN BACK TO LCNC CN - ADD LCN AS PREFIX VALUE
*  UPON RETURN HERE: THE REPONSE CN HAS BEEN WRITTEN TO THE
*   TMP CH NM IN PLAY_CLONE_TMP_CH_NM (CHAN NAME ALSO IN CH_NM)
*  WE NEED TO CREATE A UNIQUE CONT NAME FOR THIS CMD RESP, AND THEN
*   MOVE THIS CN FROM THE TMP CH BACK TO THE ORIG CN WHOSE NAME IS
*   SAVED IN THE PLAY_CLONE_SAV_CH_NM
*
*   PLAY_CLONE_PFX ALREADY SET TO 'PLA'
*   THE 4TH POS IS THE UNIQUE PLAY_CLONE_PFX_ELEM NUM
*   SIMPLY MOVE THE REST OF THE REAL CN TO THE TMP CN NM
*   PLA#XXXXXXXXYYYY  ORIG CN 1-8 AND 13-16
         MVC  PLAY_CLONE_PFX,CMD_LCNC                    POS 1-3
         MVC  PLAY_CLONE_PFX_ELEM,LCNC_CLONE_PFX_ELEM_CT POS 4
         MVC  PLAY_CLONE_CMD_1_12,CN_MOVE_NM             POS 5-16
         J    CN_MOV_FIN_DST_CN_NM
*
CN_MOV_FIN_DST_CN_NM DS 0H
*   DETERMINE IF TGT CN EXISTS
*     IF NOT THEN JUST MOVE CN
*     IF SO, THEN WE WILL APPEND DATA TO TGT CN, WITH 'XFF' PFX DLM
         EXEC CICS GET CONTAINER(PLAY_CLONE_CN)                        *
              CHANNEL(CH_MOVE_NM_TO)                                   *
              FLENGTH(TMP_CN_FL)                                       *
              NODATA                                                   *
              RESP(FRESP)                                              *
              RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)    TST FOR DEST EXIST
         JE    CN_MOVE_RSP_EXEC_FL      IF YES, THEN PUT X'FF' PFX
*
         CLC   FRESP,DFHRESP(CONTAINERERR)
         JNE   CN_MOVE_RSP_TGT_ERR
*
* DEST CONTAINER DOES NOT EXIST - SO JUST MOVE SRC
         EXEC CICS MOVE CONTAINER(CN_MOVE_NM)                          *
             CHANNEL(CH_MOVE_NM_FROM)                                  *
             TOCHANNEL(CH_MOVE_NM_TO)                                  *
             AS(PLAY_CLONE_CN)                                         *
             RESP(FRESP)                                               *
             RESP2(FRESP2)
*
* CLONE LOGIC END
         CLC   FRESP,DFHRESP(NORMAL)  MOVE CN
         JE    CN_MOVE_GETNEXT
*
         MVC   OPLIT(L'CN_MOVE_NEW_CN_ERR),CN_MOVE_NEW_CN_ERR
         L     R15,CN_MOV_BRS_ERRCT
         JAS   R9,B2C
         MVC   OPLIT+31(2),HLDSTR+6
         MVC   OPLIT+38(16),PLAY_CLONE_CN
         IILF  R0,L'CN_MOVE_NEW_CN_ERR
         AHI   R0,16
         ST    R0,PUT_APND_MSG_FL
         JAS   R9,PUT_APND_RESP_CN
         J     CN_MOVE_GETNEXT_ERR
*
* CLONE LOGIC END
CN_MOVE_RSP_EXEC_FL DS 0H
*  TARGET CN ALREADY EXISTS. SO PUT APPEND MSG WITH X'FF' PFX
*   FIRST GET LNG OF SRC CN
         EXEC CICS GET CONTAINER(CN_MOVE_NM)                           *
              CHANNEL(CH_MOVE_NM_FROM)                                 *
              NODATA FLENGTH(TMP_CN_FL)                                *
              RESP(FRESP)                                              *
              RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)    GET CN
         JNE   CN_MOVE_CN_GET_NOD_ERR
*
*  ADD 1 FOR X'FF' PFX
         L     R15,TMP_CN_FL
         LA    R15,1(R15)
         ST    R15,EXEC_CICS_FL         SAVE THIS FOR PUT
* GET STG FOR MSG PLUS 1 BYTE FOR X'FF' PREFIX DLM
         MVC   GM_STG_FL,EXEC_CICS_FL
         JAS   R9,GM_STG
         LT    R9,GM_STG_ADR
         JZ    CN_MOVE_RSP_ERR
*   USING CN_MOV_BRS_ERRCT TO TMP HOLD STG ADR
         ST    R9,CN_MOV_BRS_ERRCT
         MVI   0(R9),X'FF'       SEP VALUE
* READ INTO 2ND POS - LEAVE X'FF' IN POS 1
*
         EXEC CICS GET CONTAINER(CN_MOVE_NM)                           *
              CHANNEL(CH_MOVE_NM_FROM)                                 *
              INTO(1(,R9)) FLENGTH(TMP_CN_FL)                          *
              RESP(FRESP)                                              *
              RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)    GET CN
         JNE   CN_MOVE_RSP_GET_SRC_ERR
*
         EXEC CICS PUT CONTAINER(PLAY_CLONE_CN)                        *
              CHANNEL(CH_MOVE_NM_TO)                                   *
              FROM(0(,R9)) FLENGTH(EXEC_CICS_FL)                       *
              APPEND                                                   *
              RESP(FRESP)                                              *
              RESP2(FRESP2)
*
         EXEC CICS FREEMAIN DATAPOINTER(R9)                            *
               NOHANDLE
*
         EXEC CICS DELETE   CONTAINER(CN_MOVE_NM)                      *
              CHANNEL(CH_MOVE_NM_FROM)                                 *
              NOHANDLE
*
         CLC   FRESP,DFHRESP(NORMAL)    RESP FROM PUT APPEND
         JE    CN_MOVE_GETNEXT
*
         MVC   OPLIT(L'CN_MOVE_APN_CN_ERR),CN_MOVE_APN_CN_ERR
         L     R15,CN_MOV_BRS_ERRCT
         JAS   R9,B2C
         MVC   OPLIT+31(2),HLDSTR+6
         MVC   OPLIT+38(16),PLAY_CLONE_CN
         IILF  R0,L'CN_MOVE_APN_CN_ERR
         AHI   R0,16
         ST    R0,PUT_APND_MSG_FL
         JAS   R9,PUT_APND_RESP_CN
         J     CN_MOVE_GETNEXT_ERR
*
CN_MOVE_RSP_TGT_ERR DS 0H
         MVC   OPLIT(L'CN_MOVE_TGT_CN_ERR),CN_MOVE_TGT_CN_ERR
         L     R15,CN_MOV_BRS_ERRCT
         JAS   R9,B2C
         MVC   OPLIT+31(2),HLDSTR+6
         MVC   OPLIT+38(16),PLAY_CLONE_CN
         IILF  R0,L'CN_MOVE_TGT_CN_ERR
         AHI   R0,16
         ST    R0,PUT_APND_MSG_FL
         JAS   R9,PUT_APND_RESP_CN
         J     CN_MOVE_GETNEXT_ERR
*
CN_MOVE_CN_GET_NOD_ERR DS 0H
         MVC   OPLIT(L'CN_MOVE_SRC_ND_ERR),CN_MOVE_SRC_ND_ERR
         J     CN_MOVE_RSP_GET_SRC_ERR_1
*
CN_MOVE_RSP_GET_SRC_ERR DS 0H
         MVC   OPLIT(L'CN_MOVE_SRC_CN_ERR),CN_MOVE_SRC_CN_ERR
*
CN_MOVE_RSP_GET_SRC_ERR_1 DS 0H
         L     R15,CN_MOV_BRS_ERRCT
         JAS   R9,B2C
         MVC   OPLIT+31(2),HLDSTR+6
         MVC   OPLIT+38(16),PLAY_CLONE_CN
         IILF  R0,L'CN_MOVE_SRC_CN_ERR
         AHI   R0,16
         ST    R0,PUT_APND_MSG_FL
         JAS   R9,PUT_APND_RESP_CN
         J     CN_MOVE_GETNEXT_ERR
*
CN_MOVE_GETNEXT_ERR DS 0H
         L     R15,CN_MOV_BRS_ERRCT
         LA    R15,1(R15)
         ST    R15,CN_MOV_BRS_ERRCT
* ARBITRARY ERROR COUNT SET AT 5 MAX - QUIT AFTER 5 ERRORS
         CIJH  R15,5,CN_MOVE_DONE_BRS_ERR
         J     CN_MOVE_GETNEXT
*
CN_MOVE_DONE_BRS_ERR DS 0H
         MVC   OPLIT(L'CN_MOVE_BRS_CN_ERR),CN_MOVE_BRS_CN_ERR
         L     R15,CN_MOV_BRS_ERRCT
         JAS   R9,B2C
         MVC   OPLIT+31(2),HLDSTR+6
         JAS   R9,PUT_APND_RESP_CN
*
CN_MOVE_DONE_BRS DS 0H
         CLC   CN_BRS_TKN,F0
         JE    CN_MOVE_2_CUR_CH_XIT
         EXEC CICS ENDBROWSE CONTAINER                                 *
            BROWSETOKEN(CN_BRS_TKN)                                    *
            NOHANDLE
         J     CN_MOVE_2_CUR_CH_XIT
*
CN_MOVE_ST_BRWS_ERR DS 0H
         MVC   OPLIT(L'CN_MOVE_STBR_ERR),CN_MOVE_STBR_ERR
         L     R15,FRESP
         JAS   R9,B2C
         MVC   OPLIT+37(3),HLDSTR+5
         L     R15,FRESP2
         JAS   R9,B2C
         MVC   OPLIT+46(3),HLDSTR+5
         IILF  R0,L'CN_MOVE_STBR_ERR
         ST    R0,PUT_APND_MSG_FL
         JAS   R9,PUT_APND_RESP_CN
         J     CN_MOVE_2_CUR_CH_XIT
*
CN_MOVE_2_CUR_CH_XIT DS 0H
         L     R9,SAV_CN_MOVE_R9
         BR    R9
*
*    COPY A CONTAINER FROM EXPECTS GM_STG_FL CN LNG IN R15
*                          CH_COPY_NM_FROM
*                          CH_COPY_NM_TO
*                          CN_COPY_NM_FROM
*                          CN_COPY_NM_TO
*                          RET R15 - 0 IF OK
CN_COPY  DS    0H
         ST    R9,SAV_CPY_CN_R9
*
         CIJNE  R15,0,CN_COPY_GOT_CN_L
*   GET CN FROM ORIG CH
         EXEC CICS GET  CONTAINER(CN_COPY_NM_FROM)                     *
             CHANNEL(CH_COPY_NM_FROM)                                  *
             NODATA                                                    *
             FLENGTH(EXEC_CICS_FL)                                     *
             RESP(FRESP)                                               *
             RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)
         JNE   CN_COPY_FIN_ERR
         L     R15,EXEC_CICS_FL
*
CN_COPY_GOT_CN_L DS 0H
         ST    R15,GM_STG_FL
         ST    R15,EXEC_CICS_FL
         XR    R15,R15
         JAS   R9,GM_STG           BY THE GET CN CMD
         LT    R9,GM_STG_ADR
         JZ    CN_COPY_FIN_ERR
*                                  SET IT HERE
*   GET CN FROM ORIG CH
         EXEC CICS GET  CONTAINER(CN_COPY_NM_FROM)                     *
             CHANNEL(CH_COPY_NM_FROM)                                  *
             INTO(0(0,R9))                                             *
             FLENGTH(EXEC_CICS_FL)                                     *
             RESP(FRESP)                                               *
             RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)
         JNE   CN_COPY_FIN_ERR
*   PUT IT TO THE NEW CH
         EXEC CICS PUT  CONTAINER(CN_COPY_NM_TO)                       *
             CHANNEL(CH_COPY_NM_TO)                                    *
             FROM(0(0,R9))                                             *
             FLENGTH(EXEC_CICS_FL)                                     *
             CHAR                                                      *
             RESP(FRESP)                                               *
             RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)
         JNE   CN_COPY_FIN_ERR
*
         EXEC CICS FREEMAIN DATAPOINTER(R8)                            *
               NOHANDLE
         J     CN_COPY_FIN
*
CN_COPY_FIN_ERR DS 0H
         L     R15,FMINUS1
*
CN_COPY_FIN DS 0H
         L     R9,SAV_CPY_CN_R9
         BR    R9
*
*    DELETE CHANNEL
*
CN_DEL_CH   DS 0H
         ST    R9,SAV_DEL_CH_R9
         XC    CN_DEL_BRS_TKN,CN_DEL_BRS_TKN
         EXEC CICS STARTBROWSE CONTAINER                               *
         CHANNEL(CH_DEL_NM)                                            *
         BROWSETOKEN(CN_DEL_BRS_TKN)                                   *
         RESP(FRESP)                                                   *
         RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)    CH STBR
         JNE   CN_DEL_CH_BRS_FIN
*
CN_DEL_CH_GETNEXT DS 0H
         EXEC CICS GETNEXT CONTAINER(CN_DEL_NM)                        *
          BROWSETOKEN(CN_DEL_BRS_TKN)                                  *
          RESP(FRESP)                                                  *
          RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(END)
         JE    CN_DEL_CH_DONE_BRS
*
         CLC   FRESP,DFHRESP(NORMAL)
         JNE   CN_DEL_CH_GETNEXT
*
*
         EXEC CICS DELETE   CONTAINER(CN_DEL_NM) CHANNEL(CH_DEL_NM)    *
              NOHANDLE
         J     CN_DEL_CH_GETNEXT
*
CN_DEL_CH_DONE_BRS DS 0H
         EXEC CICS ENDBROWSE CONTAINER                                 *
            BROWSETOKEN(CN_DEL_BRS_TKN)                                *
            NOHANDLE
*
CN_DEL_CH_BRS_FIN DS 0H
         L     R9,SAV_DEL_CH_R9
         BR    R9
*
***
*  COMPUTE MESSAGE DIGESTS
*   sha1, sha256 and sha512 digests are derived
*    expect addr of container data in cn_msg_a
*    and length if container data in  cn_msg_l
*   three response containers generated with respective sha values
*    using the crnd container suffix value (cn nm 5-16)
*    generate sha1x-x, s256x-x and s512x-x container names
*
do_crying ds 0h
do_msg_dg ds 0h
         ST  R9,KRY_SAV_R9
         STM R0,R5,KRY_SAV_R0_R5
*  kimd/klmd COMPUTE INTERMEDIATE MESSAGE/LAST DIGEST
*  Reg0 0-56 zeroes 57-63 function code
*  Reg1 - adr of parm block
*  even odd pair r1/r1+1 neither is used
*                r2/r2+1
*                   r2 adr of msg
*                   r2+1 lenght of msg (32bit unsigned)
*                (r2 incr by each bye processed)
*                (r2+1 lng is decr as each byte processed0
* For COMPUTE INTERMEDIATE MESSAGE DIGEST, normal completn occurs when
* number of bytes in the second operand as specified in general reg
* R2+1 have been processed. For COMPUTE LAST MESSAGE DIGEST, after all
* bytes in the second operand as specified in general register R2+1 has
* been processed, the padding operation is performed, and then normal
* completion occurs.
*  normal completion, condition code 0 (r2+1 is zero)
*  partial compltion, condition code 3 (r2+1 is non zero)
*  completion, condition code 3 is set and the resulting
*  value in R2 + 1 is nonzero.
*
*
         xr   r0,r0     holds function code
         xr   r2,r2     even reg, not used
         xr   r3,r3     odd reg, not used
         xr   r4,r4     even reg, holds src
         xr   r5,r5     odd reg, hold length of both area (equal lng)
* here we go with a func 1 call for sha_1
         iilf r0,1     move func x'01' to r0
         la   r1,KLMDF1_parm
         xc   0(KLMDF1_parml,r1),0(r1)  empty parm
         mvc  0(sha_1_icv_l_equ,r1),sha_1_icv_H0  icv for sha1
*
         l    r4,cn_msg_a      load the msg adr of the cn
         l    r5,cn_msg_l      load the msg lng of th ecn
         iihf r5,0             zero the high reg
         sllg r5,r5,3          shift low reg left 3 (mult by 8)
         st   r5,sav_mbl_val   save this value
         st   r5,KLMDF1_mbl+4   store into parm list
         l    r5,cn_msg_l      load the msg lng (again)
*   CHK  JC    MASK,JUMP_TO_REL_ADDR
*        CC>>0 8    normal completion
*            1 4    not defined
*            2 2    not defined
*            3 1    partial completion; jmp to retry
*              + MASK IS THE VALUE TO USE IN THE JC INSTR
klmd_lop klmd R2,R4
         jc   1,klmd_lop
         cijne r5,0,klmd_lop
*  if we are here, then we are done
         IILF  R15,KIMDF1_parml
         STH   R15,FROM_HEX_STR_L
         AR    R15,R15
         STH   R15,TO_CHAR_STR_L
*
         LA    R15,FROM_HEX_STR_L
         ST    R15,X_FROM_L_A
         LA    R15,KLMDF1_parm
         ST    R15,X_FROM_A
         LA    R15,TO_CHAR_STR_L
         ST    R15,X_TO_L_A
         LA    R15,KLMDF1_x2cxl
         ST    R15,X_TO_A
         LA    R15,X2CX_PRM_ADR
         jas  r9,x2cx
* here we go with a func 1 call for sha_256
         iilf r0,2     move func x'01' to r0
         la   r1,KLMDF2_parm
         xc   0(KLMDF2_parml,r1),0(r1)
         mvc  0(sha_256_icv_l_equ,r1),sha_256_icv_H0
         l    r4,cn_msg_a
         l    r5,cn_msg_l
         mvc  KLMDF2_mbl+4,sav_mbl_val
*   CHK  JC    MASK,JUMP_TO_REL_ADDR
*        CC>>0 8    normal completion
*            1 4    not defined
*            2 2    not defined
*            3 1    partial completion; jmp to retry
*              + MASK IS THE VALUE TO USE IN THE JC INSTR
klmd_lop2 klmd 2,4
         jc   1,klmd_lop2
         cijne r5,0,klmd_lop2
*  if we are here, then we are done
         IILF  R15,KIMDF2_parml
         STH   R15,FROM_HEX_STR_L
         AR    R15,R15
         STH   R15,TO_CHAR_STR_L
*
         LA    R15,FROM_HEX_STR_L
         ST    R15,X_FROM_L_A
         LA    R15,KLMDF2_parm
         ST    R15,X_FROM_A
         LA    R15,TO_CHAR_STR_L
         ST    R15,X_TO_L_A
         LA    R15,KLMDF2_x2cxl
         ST    R15,X_TO_A
         LA    R15,X2CX_PRM_ADR
         jas  r9,x2cx
* here we go with a func 3 call for sha_512
         iilf r0,3     move func x'03' to r0
         la   r1,KLMDF3_parm
         xc   0(KLMDF3_parml,r1),0(r1)
         mvc  0(sha_512_icv_l_equ,r1),sha_512_icv_H0
         l    r4,cn_msg_a
         l    r5,cn_msg_l
         mvc  KLMDF3_mbl+12,sav_mbl_val
*   CHK  JC    MASK,JUMP_TO_REL_ADDR
*        CC>>0 8    normal completion
*            1 4    not defined
*            2 2    not defined
*            3 1    partial completion; jmp to retry
*              + MASK IS THE VALUE TO USE IN THE JC INSTR
klmd_lop3 klmd 2,4
         jc   1,klmd_lop3
         cijne r5,0,klmd_lop3
*  if we are here, then we are done
         IILF  R15,KIMDF3_parml
         STH   R15,FROM_HEX_STR_L
         AR    R15,R15
         STH   R15,TO_CHAR_STR_L
*
         LA    R15,FROM_HEX_STR_L
         ST    R15,X_FROM_L_A
         LA    R15,KLMDF3_parm
         ST    R15,X_FROM_A
         LA    R15,TO_CHAR_STR_L
         ST    R15,X_TO_L_A
         LA    R15,KLMDF3_x2cxl
         ST    R15,X_TO_A
         LA    R15,X2CX_PRM_ADR
         JAS  R9,X2CX
         L     R9,KRY_SAV_R9
         LM    R0,R5,KRY_SAV_R0_R5
         BR    R9
*
*
* COMMON GM ROUTINE
*
**
*         MVC   GM_STG_FL,MOV_2_DATAL SET UP LNG
*         JAS   R9,GM_STG
*         LT    R9,GM_STG_ADR         CK RET ADR > 0
*         JZ    CN_MOVE_RSP_ERR       ERROR
**
GM_STG   DS    0H
         ST    R9,SAV_R9_GM_RET_ADR
         XC    GM_STG_ADR,GM_STG_ADR
         EXEC CICS GETMAIN FLENGTH(GM_STG_FL)                          *
               SET(R9)                                                 *
               INITIMG(H0)                                             *
               NOSUSPEND                                               *
               RESP(FRESP)                                             *
               RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)    GM WS
         JNE   GM_STG_ERR
*
         ST    R9,GM_STG_ADR
         J     GM_STG_RET
*
GM_STG_ERR DS 0H
         XC    GM_STG_FL,GM_STG_FL
*
GM_STG_RET DS 0H
         L     R15,GM_STG_FL
         L     R9,SAV_R9_GM_RET_ADR
         BR    R9
*
***
B2C      EQU   *              CVT BIN TO READABLE TEXT
         CVD   R15,DWORD
         UNPK  HLDSTR,DWORD+4(4)
         OI    HLDSTR+6,X'F0'
         XR    R15,R15
         BR    R9
***
X2CX     EQU   *
         STM   R4,R9,X2CX49
         LTR   R4,R15
         JNP   NO_X2CX
*
         L     R5,4(R4)          GET PTR TO HW X SRC LNG
         XR    R6,R6
         ICM   R6,B'0011',0(R5)  GET THE LNG
         JNP   NO_X2CX
*
         L     R5,12(R4)          GET PTR TO HW X SRC LNG
         XR    R7,R7
         ICM   R7,B'0011',0(R5)  GET THE LNG
         JNP   NO_X2CX
*
         SLL   R6,1              MULTIPLY BY 2
         CRJNE R6,R7,BAD_X2CX
*
         SRL   R6,1              GET ORIGINAL VALUE BACK
*
         L     R5,8(R4)       GET ADR OF THE TGT CHAR FLD
         L     R4,0(R4)          GET ADR OF SRC HEX FLD
         LA    R9,X2CX_TABLE   TRANSLATE TO CHAR FORM
         AHI   R9,-240
*
CONVERT  EQU   *
         CIJL  R6,4,CONVERT1
         MVC   MYXSTR(4),0(R4)
         UNPK  MYCHAR,MYXSTR(5) UNPACK HEX STREAM
         TR    MYCHAR,0(R9)     TRANSLATE TO CHAR FORM
         MVC   0(8,R5),MYCHAR
         AHI   R5,8
         AHI   R4,4
         AHI   R6,-3
         J     CONVERT2
CONVERT1 DS    0H
         XR    R8,R8            CLEAR REG
         IC    R8,0(R4)         INSERT CHAR IN 25-32
         SRDL  R8,4             SHIFT OUT 29-32 INTO R9
         STC   R8,0(R5)         STORE SHIFTED 25-28 AS X'0X'
         TR    0(1,R5),HEXTRAN  TRANSLATE ALL 00 THRU 0F
*                                     TO->    F0 - F9,C1 - C6
         LA    R5,1(R5)         ADVANCE PTR TO NEXT POS
         XR    R8,R8            CLEAR REG
         SLDL  R8,4             SHIFT IN THE 29-32
         STC   R8,0(R5)         STORE IT
         TR    0(1,R5),HEXTRAN  TRANSLATE ALL 00 THRU 0F TO
*                                     TO->    F0 - F9,C1 - C6
         LA    R5,1(R5)         ADVANCE ANOTHER
         LA    R4,1(R4)         ADVANCE NEXT
CONVERT2 DS    0H
         JCT   R6,CONVERT       REDUCE COUNTER
*
         XR    R15,R15
         J     OK_X2CX
BAD_X2CX EQU   *
         LA    R15,8
         J     OK_X2CX
NO_X2CX  EQU   *
         LA    R15,4
         J     OK_X2CX
OK_X2CX  EQU   *
         LM    R4,R9,X2CX49
         BR    R9
*
*
* SUBROUTINE TO SORT PLAYLIST ENTRIES
SORT_PLAYLIST_TBL  DS 0H
         ST    R9,SAV_PLAY_SORT_R9
         STM   R4,R8,SAV_PLAY_REGS4_8
         XR    R9,R9           LOOP COUNT
         LA    R8,PLAYLIST_TBLBEG
         L     R15,PLAY_ELM_CT
         BCTR  R15,0
         ST    R15,PLAY_ELM_CT_LESS_1
*
SORT_TOP_LOOP DS 0H
         MVC   PLAYLIST_TMP_GRP,0(R8) MOVE CUR STG TBL ENT TO TMP
         LA    R6,1(R9)        INNER LOOP STARTS AT CUR ELM PLUS 1
         LR    R7,R8           USE R7 TO ITERATE DOWN/UP THE LIST
         AHI   R7,PLAYLIST_TBLGRP_L
SORT_CHK_NXT_TOP DS 0H
         CLC   PLAYLIST_TMP_ELM,0(R7)
         JL    SORT_CHK_NXT_GO_NXT
*                              FND NXT ELM LOWER THAN TMP (CUR ELM)
         MVC   0(PLAYLIST_TBLGRP_L,R8),0(R7)
         MVC   0(PLAYLIST_TBLGRP_L,R7),PLAYLIST_TMP_ELM
         MVC   PLAYLIST_TMP_GRP,0(R8) REPLACE TMP WITH NEW LOW IN CUR
*
SORT_CHK_NXT_GO_NXT DS 0H
         LA    R6,1(R6)
         AHI   R7,PLAYLIST_TBLGRP_L  TO NEXT TST ELM
         CLC   FMINUS1,0(R7)
         JE    SORT_CHK_NXT_GO_NXT_TBLENT
         C     R6,PLAY_ELM_CT
         JL    SORT_CHK_NXT_TOP
*
SORT_CHK_NXT_GO_NXT_TBLENT DS 0H
         LA    R9,1(R9)
         AHI   R8,PLAYLIST_TBLGRP_L   PTR TO NEXT TST ELM
         CLC   FMINUS1,0(R8)
         JE    SORT_CHK_FIN_GO_NXT_TBLENT
         C     R9,PLAY_ELM_CT_LESS_1 IF WE ARE AT LAST ELM
         JL    SORT_TOP_LOOP       THEN WE ARE SORTED
*   WE HAVE SORTED PLAYLIST_TBLBEG
*
SORT_CHK_FIN_GO_NXT_TBLENT DS 0H
*        GET TOP OF PLAYLIST_TBLBEG INTO R8
         LA    R8,PLAYLIST_TBLBEG
*        GET TOP OF PLAYLIST ARRAY  INTO R7
*        LA    R7,CN_PLAY_LIST
*        XR    R9,R9
*        XR    R6,R6
SORT_TST_NXT_TBLENT DS 0H
*        MVC   0(4,R7),PLAYLIST_TBLENT_L(R8)
*        AHI   R7,4
*        AHI   R8,PLAYLIST_TBLGRP_L
*        CLC   FMINUS1,0(R8)
*        JE    SORT_PLAYLIST_FIN
*        LA    R6,1(R6)
*        C     R6,PLAY_ELM_CT
*        JL    SORT_TST_NXT_TBLENT
* FINISHED RESETTING THE CN_PLAY_LIST WITH SORTED LIST
SORT_PLAYLIST_FIN DS 0H
         L     R9,SAV_PLAY_SORT_R9
         LM    R4,R8,SAV_PLAY_REGS4_8
         BR    R9
*
* SUBROUTINE TO assign valid character for CNC name
CNC_GET_CN_CHR DS 0H
         ST    R9,SAV_GET_VAL_CNC_CHR_R9
* ROTATE THRU VALID CNC NAME CHARACTER VALUES
CNC_GET_VAL_CHR DS  0H
         IC    R15,LCNC_CLONE_PFX_ELEM_CT
         LA    R15,1(R15)
         STC   R15,LCNC_CLONE_PFX_ELEM_CT
CNC_GET_NXT_VAL_CHR_TOP DS 0H
         L     R8,CNC_VAL_CHR_CUR_TBL_ENT
         CLC   LCNC_CLONE_PFX_ELEM_CT,1(R8) EACH TBL ENT HAS BEG VAL
*                                         AND A HIGH VALUE
         JNH     CNC_GOT_NXT_VAL_CHR
*
         LA    R8,VAL_CNC_E_L(R8)        IF HIGH, THEN GET NXT TBL
         CLI   0(R8),X'FF'               AT X'FF' WE AT AT END
         JE    CNC_TBL_END
*
         MVC   LCNC_CLONE_PFX_ELEM_CT,0(R8) EACH TBL ENT HAS BEG VAL
         ST    R8,CNC_VAL_CHR_CUR_TBL_ENT
*
CNC_GOT_NXT_VAL_CHR DS 0H
*
CNC_TBL_END DS 0H
*
         ST    R9,SAV_GET_VAL_CNC_CHR_R9
         BR    R9
*
* SUBROUTINE TO SEARCH CA FOR A SEP CHAR
* EXPECT R6 AS BRANCH REG
*        R8 AS ADR OF THE HAYSTACK
*        R9 IS THE LENGTH OF THE HAYSTACK
*    USE R0, R1, R6, R7
*    RETURN R9 AS POINT THAT SEP FND OF 0 IF NF
LOOK_4_SEP EQU  *
         ST    R6,SAV_SEP_6
         LA    R6,SEP    SEPARATER CHARACTER
         LA    R7,0      SET R7 SO THAT WE USE THE PAD CHAR
         LA    R0,1      R0 IS SET TO LNG OF 1 FOR CUSE LENGTH
         XR    R1,R1
         IC    R1,SEP    PLACE SEP CHAR INTO BIT 24-31
RET_CUSE_SEP_LOOP EQU *
         CUSE  R8,R6     LOOK FOR SEP
         JZ    SEP_FND      CC 0 OR BC 8
         JO    RET_CUSE_SEP_LOOP
         CLI   SEP,C','             IF SYSID=____, WE LOOK FOR A ','
         JNE   SEP_CHAR_NF
         CLI   0(R8),X'40'         BUT WE WILL TAKE A SPACE AS THE
         JE    SEP_FND             DELIMETER
SEP_CHAR_NF  EQU   *
         XR    R9,R9
*
SEP_FND  EQU   *
         L     R6,SAV_SEP_6
         BR    R6
*
*
MVC_DST_R15_SRC_R5 MVC 0(0,R15),0(R5)
CLCPARSE CLC   0(0,R6),0(R4)
*
STATSTG  LOCTR  ,
*   cics static storage area needs label as specified on dfheient
STATR    ds    0d
CMD_TBL_LIT DS 0F
CMD_PING DC     CL4'PING',A(DO_PING),A(CN_RET_FROM_OLD_CMD)
CMD_TBL_ENT_LNG EQU *-CMD_TBL_LIT
CMD_LINK DC     CL4'LINK',A(DO_LINK),A(CN_RET_FROM_OLD_CMD)
CMD_CEMT DC     CL4'CEMT',A(DO_CEMT),A(CN_RET_FROM_OLD_CMD)
CMD_CEDA DC     CL4'CEDA',A(DO_CEDA),A(CN_RET_FROM_OLD_CMD)
CMD_LCNC DC     CL4'LCNC',A(DO_LCNC),A(CN_CMD_PROCESSED)
CMD_PLAY DC     CL4'PLAY',A(DO_PLAY),A(CN_FIN_CMD_ELEM)
CMD_JRND DC     CL4'JRND',A(DO_JRND),A(CN_CMD_PROCESSED)
CMD_CRND DC     CL4'CRND',A(DO_CRND),A(CN_CMD_PROCESSED)
CMD_END  DS     XL4'00000000',F'0',F'0'
CMD_TBL_LIT_LNG EQU *-CMD_TBL_LIT
*
F32400   DC    F'32400'
         ORG   *-2
H32400   DS    H
*
F4080    DC    F'4080'
         ORG   *-2
H4080    DS    H
*
F100     DC    F'80'
         ORG   *-2
H100     DS    H
*
F80      DC    F'80'
         ORG   *-2
H80      DS    H
*
MAX_CMD_LEN DC H'80'
*
F16      DC    F'16'
         ORG   *-2
H16      DS    H
*
F10      DC    F'10'
         ORG   *-2
H10      DS    H
*
F8       DC    F'8'
         ORG   *-2
H8       DS    H
*
F4       DC    F'4'
         ORG   *-2
H4       DS    H
*
F2       DC    F'2'
         ORG   *-2
H2       DS    H
*
F1       DC    F'1'
         ORG   *-2
H1       DS    H
*
F0       DC    F'0'
         ORG   *-2
H0       DS    H
*
FMINUS1  DC    F'-1'
         ORG   *-2
HMINUS1  DS    H
*
FMINUS20 DC    F'-20'
         ORG   *-2
HMINUS20 DS    H
*
TOD_SEP  DC    CL1':'
SP1      DC    CL1' '
PZERO    DC    PL1'0'
*
* x2cx translate table
HEXTRAN  Ds    X'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
*
X2CX_TABLE   DC C'0123456789ABCDEF'
*
LIT_DECENDING DC CL1'D'
LIT_ASCENDING DC CL1'A'
LIT_EQUAL DC   XL1'0'
LIT_UNEQUAL DC   XL1'1'
*
LIT_DPL_D DC   CL2'D '
*D     A DISTRIBUTED PROGRAM LINK (DPL) REQUEST THAT DID NOT SPECIFY
*      SYNCONRETURN OPTION. THE TASK CANNOT ISSUE I/O REQUESTS AGAINST
*      PRINCIPAL FACILITY, NOR CAN IT ISSUE ANY SYNCPOINT REQUESTS.
LIT_DPL_DS DC  CL2'DS'
*DS    A DISTRIBUTED PROGRAM LINK (DPL) REQUEST, AS IN CODE D, THAT DID
*      SYNCONRETURN OPTION. THE TASK CAN ISSUE SYNCPOINT
*      REQUESTS.
LIT_TDQ_QD DC  CL2'QD'
*QD    TRANSIENT DATA TRIGGER LEVEL.
LIT_ST_S  DC  CL2'S '
*S     START COMMAND WITHOUT DATA.
LIT_ST_SD  DC  CL2'SD'
*SD    START COMMAND WITH DATA.
LIT_FP_SZ  DC  CL2'SZ'
*SZ    FEPI START COMMAND.
LIT_TERM_TD DC  CL2'TD'
*TD    TERMINAL INPUT OR PERMANENT TRANSID.
LIT_USER_U  DC  CL2'U '
*U     USER-ATTACHED TASK.
*
LIT_EKTRMPOS DC  CL8'EKTRMPOS'
LIT_UCEMRAN0 DC  CL8'UCEMRAN0'
LIT_UCEMPARS DC CL8'UCEMPARS'
LIT_DFHEMTA DC CL8'DFHEMTA'
LIT_DFHEDAP DC CL8'DFHEDAP'
LIT_INQ  DC    C'INQ'
LIT_SET  DC    C'SET'
LIT_CEMT DC    C'CEMT'
LIT_CEDA DC    C'CEDA'
LIT_RDO_DIS DC    C'DISPLAY'
LIT_RDO_ALT DC    C'ALTER'        20180604
LIT_RDO_MOV DC    C'MOVE'         20180604
LIT_RDO_REN DC    C'RENAME'       20180604
LIT_RDO_EXP DC    C'EXPAND'
LIT_RDO_INS DC    C'INSTALL'
LIT_RDO_DEF DC    C'DEFINE'
LIT_RDO_VIEW DC   C'VIEW'
LIT_RDO_COPY DC   C'COPY'
*
LIT_RET_CN_LIST DC   C'RETURN_'
LIT_CN_LIST     DC   C'CN_LIST'
LIT_RET_CN_LIST_L EQU *-LIT_RET_CN_LIST
          ORG *-4
LIT_LIST     DS   CL4
*
LIT_CN_SYSID    DC   C'CN_SYSID'
          ORG *-5
LIT_SYSID    DS   CL5
*
LIT_CN_PGM      DC   C'CN_PROGRAM'
          ORG *-7
LIT_PGM      DS   CL7
*
LIT_TTERMSVR DC CL4'TT01'
LIT_PTERMSVR DC CL4'PT01'
SPACE255 DC    CL255' '
SSTR_DELM DC   XL1'FF'
LIT_SYSID_EP DC   CL(7)'SYSID=('
             ORG  LIT_SYSID_EP
LIT_SYSID_   DS   CL(5)
LIT_SYSID_EQ DS   CL(1)
LIT_SYSID_PAR DS   CL(1)
*            ORG  LIT_SYSID_EP+L'LIT_SYSID_EP
LIT_PING     DC   C'PING'
LIT_LINK     DC   C'LINK'
LIT_PROGRAM_EP DC   CL(7)'PROGRAM=('
             ORG  LIT_PROGRAM_EP
LIT_PROGRAM_E  DS   CL(6)
             ORG  LIT_PROGRAM_EP+L'LIT_PROGRAM_EP
RIGHT_PARENT DC   CL1')'
DPL_STP_ERRMSG DC CL33'}RETURN:UNKNOWN)>'
LIT_CANT_DO_IT DC C'#     *ERROR*START CODE>  < INVREQ ASSIGN FUNCTION.X
               ABORTING TRANSACTION.'
*                  #     *ERROR*
LIT_BAD_LINK_CMD DC C'#LINK *ERROR* LINK COMMAND INVALID DUE TO:43_____*
                :PARAMETER ERROR'
LIT_BAD_LINK_RSP DC C'#     *ERROR* LINK COMMAND FAILED WITH ERROR RESPX
               ONSE. ABORT TRANSACTION.'
LIT_BAD_CA_STR DC C'#     *ERROR* COMMAREA EMPTY OR HAS INVALID DATA.'
LIT_BAD_DPL   DC C'#     *ERROR* DPL OF UCEMPINR TO SYSID ____ FAILED.'
LIT_BAD_DPL_ALL_SP DC C'#     *ERROR* DPL OF UCEMPINR TO SYSID ____ RETX
               URNED EMPTY COMMAREA.'
DPL_CN_RESP_ER DC C'*** INFO: COULD NOT APPEND DPL RESP CN TO MAIN CN'
CN_MOVE_APN_CN_ERR DC C'!!! MOVE CN:APPEND TGT  ERR:CT:31:END:38'
CN_MOVE_TGT_CN_ERR DC C'!!! MOVE CN:GET TGT CN  ERR:CT:31:END:38'
CN_MOVE_SRC_CN_ERR DC C'!!! MOVE CN:GET SRC CN  ERR:CT:31:END:38'
CN_MOVE_SRC_ND_ERR DC C'!!! MOVE CN:GET SRC NOD ERR:CT:31:END:38'
CN_MOVE_NEW_CN_ERR DC C'!!! MOVE CN:MOVE NEW CN ERR:CT:31:END:38'
CN_MOVE_BRS_CN_ERR DC C'!!! MOVE CN:BROWSE NEXT ERR:CT:31:END:'
CN_MOVE_STBR_ERR DC C'!!! MOVE CN:START BROWSE FAILED:RESP:37 :RESP2:46*
                : DONE DPL:'
LIT_BAD_START DC C'#     *ERROR* GETMAIN OF SCRATCH AREA GETMAIN FAILEDX
               .ABORT TRANSACTION.'
LIT_BAD_SYSID DC C'#     *ERROR* SYSID ____ INVALID. THIS LOCAL REGION X
               NOT CONN TO REMOTE SYSID.'
LIT_FAILED_CMD DC C'{CALL TO EXECUTE COMMAND FAILED. RETURN NO DATA'
LIT_RESTRICTED DC C'{CALL TO EXECUTE COMMAND RESTRICTED.'
CA_RET_BAD_LIT DC C'8{COMMAREA NOT RETURNED OR DPL ERROR}'
CA_RET_SBZ_LIT DC C'8{ALL SESSION LINKS TO SYSID BUSY. TRY LATER?}'
CA_RET_SRL_LIT DC C'8{ALL SESSION LINKS TO SYSID RELEASED.}'
NO_DATA_2_CA_MSG DC C'#     *ERROR* NO DATA GENERATED IN COMMAREA FOR RX
               ETURN TO CALLER!'
NOCA_EMP_IP_CA_MSG  DC C'#     *ERROR* NO INPUT COMMAREA FROM CALLER!>'
*
BAD_CMD_IP_CA_MSG DC C'#     *ERROR* NO VALID DATA INCOMING COMMAREA FRX
               OM CALLER! CAL>'
L_BAD_CMD_IP_CA_MSG1 EQU *-BAD_CMD_IP_CA_MSG
          DC C'     < CA>'
L_BAD_CMD_IP_CA_MSG2 EQU *-BAD_CMD_IP_CA_MSG
          DC  C'    <'
L_BAD_CMD_IP_CA_MSG  EQU *-BAD_CMD_IP_CA_MSG
*
NO_VALID_CMD_MSG DC C'#     *ERROR* NO VALID COMMANDS IN COMMAREA FROM X
               CALLER! CAL>'
L_NO_VALID_CMD_MSG1 EQU *-NO_VALID_CMD_MSG
          DC  C'     < CA>'
L_NO_VALID_CMD_MSG2 EQU *-NO_VALID_CMD_MSG
          DC  C'    <'
L_NO_VALID_CMD_MSG  EQU *-NO_VALID_CMD_MSG
*
*  CaPs MuSt Be OfF fOr BELOW TEST_PATTERN_AREA
*
TEST_PATTERN_AREA DC   X'4a',C'.<(+',X'4f50',C'!$*);^-/|,%_>?`:#@''="',X
               C'abcdefghijklmnopqr~stuvwxyz{ABCDEFGHI}JKLMNOPQR\STUV',X
               C'WXYZ0123456789'
L_TEST_PATTERN_AREA EQU *-TEST_PATTERN_AREA
*
*
LIT_BAD_EQ  DC CL7'EQUAL'
LIT_BAD_SEP DC CL7'COMMA'
LIT_BAD_RECSN  DC CL7'RECURSN'
CN_CMD_LIT DC CL7'COMMAND'
CN_UKN_LIT DC CL7'UNKNOWN'
CN_TOT_LIT DC CL7'-TOTAL-'
CN_STK_LIT DC CL7'-STACK-'
CN_EXE_LIT DC CL7'EXECUTE'
*
CN_STRTB_MSG DC C'$$$ BEGIN CHANNEL AND CONTAINER PROCESSING. CHANNEL:5*
               3______________. ***'
*CN_RESP_255  EQU 255,4           VAL IS 255, SYM HAS LNG OF 4
*CN_RESP_MSG_L DC A(CN_RESP_255)  I CAN USE THIS AS FLENGTH
*CN_RESP_MSG  DC CL(CN_RESP_255)' '
CN_CMDNF_MSG DC C'UCEMPINR - CNC FOUND. COMMAND OR UNKNOW CONTAINER NAM*
               ES FOLLOW:63'
BAD_GET_NODA_MSG  DC C'!!! BWS CN LOOP:GET NODATA FAILED WITH RESP:45__*
               _::RESP2:58___. BYPASSING CN:79______________.'
BAD_END_BRS_MSG   DC C'!!! END BROWSE CONTAINER   FAILED WITH RESP:45__*
               _::RESP2:58___. BYPASSING THIS CONTAINER.'
BAD_GETN_BRS_MSG  DC C'!!! BROWSE CONTAINER GETNX FAILED WITH RESP:45__*
               _::RESP2:58___. BYPASSING THIS CONTAINER.'
BAD_START_BRS_MSG DC C'!!! BROWSE CONTAINER START FAILED WITH RESP:45__*
               _::RESP2:58___. ENDING EXECUTION!!! '
BAD_START_CN_MSG DC C'!!! ERROR - FAILURE TO INITIALIZE 34_____ CONTAIN*
               ER STACK ELEMENT AREA. RESP=77_::RESP2=88_. ABORT.'
BAD_GM_STK_MSG DC C'!!! ERROR - GM FAILED TO OBTAIN 32_____ STACK ELEME*
               NT AREA. CURRENTLY 70___ CONTAINERS. NO COMMAND EXEC.'
BAD_CEDA_CN_DATA_MSG DC 0C
BAD_CEMT_CN_DATA_MSG DC 0C
BAD_LINK_CN_DATA_MSG DC C'!!! CONTAINER 14______________ DOES NOT MATCH*
                COMMAND DATA 59__ RECEIVED IN CONTAINER.'
TOO_MANY_UKN_MSG DC C'*** ERROR - 12__ 17_____ CONTAINERS EXCEEDS THE L*
               IMIT OF 57___ CONTAINERS IN ONE REQUEST.'
LIT_DPL_WITH_CN DC C'<DPL WITH CH:'
LIT_DPL_CN_SYSID DC C':TO SYSID:'
DO_DPL_MSG DC C'*** DPL:8       :LINK TO PGM:28      :SYSID:42  :END:50*
                     :59:62              <<' <<77
DO_LCNC_MSG DC C'*** LCNC:9       :PGM:22      :CHAN:36              :S*
               YSID:59  :END:68      :<<'
PLAY_LS_MSG DC C'*** CN:7               :LIST:' <<29
*
FINPLAY_CMD_MSG  DC C'*** PLAY LIST COMMANDS FINISHED!32       :BYE:'
*
PLAY_ERR_INVD DC C'!!! PLAY LIST COMMAND<22              > IS INVALID O*
               R EMPTY: LOOP FOR NEXT CMD IN PLAY LIST:'
*
DO_LCNC_ERR DC C'!!! LCNC COMMAND FAILED DUE TO REASON:38'
*
RET_CN_LIST_MSG DC C'***   SUCCESSFULLY PUT RET_CN_LIST:35'
*
CN_CMD_XEQ_FAIL_MSG DC C'$$$ 4_______________ COMMAND FAILED TO EXECUTE*
               , RETURNING RC=61. CONTINUE.'
CN_FIN_ALL_CMDS DC C'*** FINISHED PROCESSING CN CMDS. MXRC:38.  SUCCESS*
               FUL CMDS:59_, UKN:68_ OF CMDS:80_ IN TOTAL.'
CN_NO_CMDS_MSG DC C'**** CONTAINER PROCESSING FOUND NO VALID COMMAND TO*
                PROCESS. FOUND 67_ TOTAL CONTAINERS.'
CN_ERR_ABT_MSG DC C'!!!! CONTAINER PROCESSING RC=29 WAS ENCOUNTERED. NO*
                FURTHER PROCESSING POSSIBLE.'
CN_STG_GM_FAIL_MSG DC C'!!! GETMAIN FOR 16_____ STORAGE FAILED. RESP=45*
               _ :: RESP2=58_. ABORTING.'
CN_CMD_NOT_IMPL_MSG DC C'*** 4_______________ IS A VALID EXPECTED COMMA*
               ND BUT IS CURRENTLY NOT IMPLEMENTED. BYPASS CMD'
CN_CMD_NOT_CHAR_MSG DC C'*** 4_______________ IS A VALID EXPECTED COMMA*
               ND BUT IS NOT A CHAR CONTAINER. BYPASS CMD'
CN_CMD_NO_CONT_MSG  DC C'*** 4_______________ IS A VALID COMMAND BUT TH*
               E CONTAINER GET NODATA FAILED. BYPASS CMD.'
CN_GET_CMD_CN_FAIL_M DC C'*** ERROR GET CONTAINER:24______________, FAI*
               LED RESP:54_, RESP2:65_. CONTINUE.'
CN_CMD_NOT_DATA_MSG DC C'!!! 4_______________ CONTAINER NAME, DOES NOT *
               MATCH DATA REQUEST:65__. BYPASSING EXECUTION'
CN_CMD_PUT_FAIL_MSG DC C'*** PUT UPDATED CN:19______________ FAILED WIT*
               H RESP:53_, RESP2:64_. GOING TO NEXT COMMAND.'
CN_CMD_PUT_GOOD_MSG DC C'*** PUT UPDATED CN:19______________ SUCCEEDED.*
                CONTAINER LENGTH IS:67___. PROCESSING NEXT COMMAND.'
CN_WRIT_TDQ_MSG DC C'*** FINISHED CHANNEL AND CONTAINERS. MAX RC:44. PR*
               OCESSED 58_ CONTAINERS IN CHANNEL:84_______________.'
CN_CRND_LNK_FAIL_MSG DC C'!!! CRND LINK TO PROGRAM FAILED WITH RESP:42_*
               _, RESP2:53__.'
CN_CRND_LNK_SHA_MSG DC C'*** CRND 9___ SHA512:'
CN_CRND_BIT_MSG DC C'!!! CRND COMMAND WITH COMMAND CONTAINER:40________*
               ______ IS NOT DATATYPE CHAR. BYPASS COMMAND.'
MOV_UKN_FAIL_MSG DC C'!!! ONE OR MORE ASSOCIATED (UKN) CNTRS COULD NOT *
               BE MOVED TO NEW CHANNEL:73______________: LAST CN:99____*
               __________.'
CRND_CN_MOV2CURR_MSG DC C'!!! CRND CN:12______________ MOVE TO CUR CHAN*
               NEL FAILED: RESP1:____, RESP2:____.'
CRND_CN_PUT_SHA_MSG  DC C'!!! CRND CN:12______________ PUT CN FOR SHA D*
               GST FAILED: RESP1:____, RESP2:____.'
CRND_CN_GET4SH_MSG   DC C'!!! CRND CN:12______________ GET CN FOR MSG D*
               GST FAILED: RESP1:____, RESP2:____.'
CN_CRND_NO_RESP_MSG DC C'!!! 4_______________ GET RESPONSE CONTAINER FA*
               ILED RESP1:57__, RESP2:69__.'
CN_CRND_OK_RESP_MSG DC C'*** 4_______________ VAL:25'
*
PLAY_TOO_MANY DC C'!!! PLAY CMD 13               EXCEEDS THE MAXIMUM OF*
                10 PLAY CMD ENTRIES. IGNORING.'
*  USE THE FOLLOWING LCNC LITERALS FOR PLAY PROCESSING. REPLAY LCNC AT
*                     POS      12     WITH PLAY LITERAL FROM CMD_TBL
*                  0           12                         40 Lng41
LCNC_ERR_CP   DC C'( 1)CODEPG  LCNC CN GET :25              :'
LCNC_ERR_GMCN DC C'(1A)EKTRMPS LCNC CN GM  :25              :'
LCNC_ERR_GPCN DC C'(1B)EKTRMPS LCNC CN GET :25              :'
LCNC_ERR_PPCN DC C'( 2)EKTRMPS LCNC CN PUT :25              :'
LCNC_ERR_LKV  DC C'( 3)PRIMARY LCNC CN LINK:PARSE K/V PAIRS<<'
LCNC_ERR_GKVL DC C'(4A)GET K/V LCNC CN GET :CN_LIST CN    <<<'
LCNC_ERR_LSTE DC C'(4D)CN LIST LCNC CN GET :25              :'
LCNC_ERR_GMLV DC C'( 5)K/V CN  LCNC CN GM  :CN_LIST CN    <<<'
LCNC_ERR_GKVP DC C'( 5)K/V CN  LCNC CN GET :CN_PGM  CN    <<<'
LCNC_ERR_GKVS DC C'( 6)K/V CN  LCNC CN GET :CN_SYSD CN    <<<'
LCNC_ERR_GPGM DC C'( 7)PGM_NM  LCNC CN GET :25              :'
LCNC_ERR_GSYD DC C'( 8)SYSD_NM LCNC CN GET :25              :'
LCNC_ERR_GLST DC C'(9A)LIST_NM NODA CN GET :25              :'
LCNC_ERR_FDCN DC C'(11)FIND CN LCNC CN NAME:25              :'
PLAY_ERR_CLON DC C'(BA)CLONECN LCNC CN NAME:25              :' <42
LCNC_ERR_M2CH DC C'(11)MOVE_NM TO CH:CN NM :25              :'
LCNC_ERR_LINK DC C'(12)LINK TO PROGRAM  NM :25              :'
LCNC_ERR_MBAK DC C'(13)LOOP: MOVE RESULT BACK TO PRIM CHAN<<<'
* CNC LITERALS END
*
LIT_SEED    DC CL4'SEED'
LIT_NUMB    DC CL4'NUMB'
LIT_BRAN    DC CL4'BRAN'
LIT_CRAN    DC CL4'CRAN'
LIT_SHA     DC CL3'SHA'
LIT_SHA256  DC CL3'256'
LIT_SHA512  DC CL3'512'
*
lit_sha_1_icv  ds 0d
sha_1_icv_H0 dc xl4'67452301'
sha_1_icv_H1 dc xl4'EFCDAB89'
sha_1_icv_H2 dc xl4'98BADCFE'
sha_1_icv_H3 dc xl4'10325476'
sha_1_icv_H4 dc xl4'C3D2E1F0'
sha_1_icv_l_equ equ *-sha_1_icv_H0
*
*
lit_sha_256_icv ds 0d
sha_256_icv_H0 dc xl4'6A09E667'
sha_256_icv_H1 dc xl4'BB67AE85'
sha_256_icv_H2 dc xl4'3C6EF372'
sha_256_icv_H3 dc xl4'A54FF53A'
sha_256_icv_H4 dc xl4'510E527F'
sha_256_icv_H5 dc xl4'9B05688C'
sha_256_icv_H6 dc xl4'1F83D9AB'
sha_256_icv_H7 dc xl4'5BE0CD19'
sha_256_icv_l_equ equ *-sha_256_icv_H0
*
*
lit_sha_512_icv ds 0d
sha_512_icv_H0 dc xl8'6A09E667F3BCC908'
sha_512_icv_H1 dc xl8'BB67AE8584CAA73B'
sha_512_icv_H2 dc xl8'3C6EF372FE94F82B'
sha_512_icv_H3 dc xl8'A54FF53A5F1D36F1'
sha_512_icv_H4 dc xl8'510E527FADE682D1'
sha_512_icv_H5 dc xl8'9B05688C2B3E6C1F'
sha_512_icv_H6 dc xl8'1F83D9ABFB41BD6B'
sha_512_icv_H7 dc xl8'5BE0CD19137E2179'
sha_512_icv_l_equ equ *-sha_512_icv_H0
*
*  NO CAPS ON for table BeLoW
val_cnc_chars ds  0f
val_cnc_e1    dc  c'0',c'9'   f0-f9
val_cnc_e2    dc  c'.',c'<'   4b-4c
val_cnc_e3    dc  c'|',c'&&'  4f-50
val_cnc_e4    dc  c'!',c'$'   5a-5b
val_cnc_e5    dc  c';',c';'   5e-5e
val_cnc_e6    dc  c'-',c'/'   60-61
val_cnc_e7    dc  c',',c'?'   6b-6f
val_cnc_e8    dc  c':',c'@'   7a-7c
val_cnc_e9    dc  c'=',c'"'   7e-7f
*
val_cnc_e10   dc  c'a',c'i'   81-89
val_cnc_e11   dc  c'j',c'r'   91-99
val_cnc_e12   dc  c's',c'z'   a2-a9
val_cnc_e13   dc  c'A',c'I'   c1-c9
val_cnc_e14   dc  c'J',c'R'   d1-d9
val_cnc_e15   dc  c'S',c'Z'   e2-e9
val_cnc_ff    dc  x'ff',x'ff' ff-ff
val_cnc_e_l   equ *-val_cnc_ff
*  NO CAPS ON for table aBoVe
*
* abcdefghi
*          jklmnopqr
*                   stuvwxyz
* ABCDEFGHI
*          JKLMNOPQR
*                   STUVWXYZ
* 0123456789
*
*
* .<|&!$;-/,%_>?:#@="
* 44455556666666777774
*
         DC    0D,C'********'
PROGNAME DC    C'UCEMPINR'
         DC    C' * '
PROGVER  DC    C'V3.5'
         DC    C' * '
         DC    C'DATE='
         DC    C'&SYSDATE'
         DC    C' '
         DC    C'TIME='
         DC    C'&SYSTIME'
         DC    C' '
LIT_ME   DC    CL8'TCEM'
         DC    CL8' '
LIT_ME_X EQU   *
         DC    C'********'
statr_l_equ    equ *-statr
*
* moved to end for relative addressing
         LTORG
         END
###END UCEMPINR
$$$BEG CICSLOOP
* THIS SOURCE IS NOT COMPLETE. NEED LOGIC ADDED IF CNC IS PROVIDED
* THIS SOURCE IS NOT COMPLETE. NEED LOGIC ADDED IF CNC IS PROVIDED
* THIS SOURCE IS NOT COMPLETE. NEED LOGIC ADDED IF CNC IS PROVIDED
* THIS SOURCE IS NOT COMPLETE. NEED LOGIC ADDED IF CNC IS PROVIDED
* THIS SOURCE IS NOT COMPLETE. NEED LOGIC ADDED IF CNC IS PROVIDED
* FOR EACH EXEC CICS CALL MACRO EXPANDS TO
*  DFHECALL MACRO WHICH IS STD SYSTEM CALL
*  R0  UNDEFINED
*  R1  POINTS TO ADDR OF PARM LIST
*  R14 POINTS TO RETURN POINT IN YOUR PGM
*  R15 POINTS TO ADDR OF ENTRY  PT IN EXEC INTF
* DFHEAI MUST BE LINK EDITED WITH YOUR PGM FOR EXEC INTF RESOLUTION
* EXEC CICS RETURN WILL EXIT YOUR PGM OR DFHEIRET IS INSERTED BY
*  THE TRANSLATOR IF NO EXEC RETURN FOUND
* DFHEIRET INSERTED BY TRANSLATOR AT END OF PGM
*  THIS MACRO: RESTORES REGS
*              RETURNS VIA R14
* DFHECALL BUILDS THE PARM LIST IN DYN STG FOR REENTRANCY
* DFHEIENT INSERTED BY TRANSLATOR AFTER FIRST CSECT
*  THIS MACRO: SAVES REGS
*              GETMAIN STG FOR DFHEISTG
*              SETS BASE REG (R3 DEFAULT)
*              SETS DYN STG REG (R13 DEFAULT)
*              SETS EIB REG (R11 DEFAULT)
* DFHEISTG INSERTED BY TRANSLATOR
*              DEFINES STG PARM LIST
*              DEFINES STG FOR REG SAVE AREA
*              INCLUDES YOUR VARS WHEN YOU CODE THE DFHEISTG MACRO
* DFHEIEND INSERTED BY TRANSLATOR TO ID END OF EIDSA
* DFHEIBLK INSERTED BY TRANSLATOR DEFINES EIB DSECT
* MULTIPLE BASE REGS DEFINED BY DFHEIENT (CODEREG DATAREG EIBREG)
* DFHEIPLR IS THE REG VAR ASSIGNED TO FIRST EIBREG OR DEFAULT
*REG 1                      PASSED ADDR OF PARMS
*REG 3                      BASE REGISTER (CMD LVL)
*REG 11                     PTR TO EIB (SET BY DFHEIENT)
*REG 13                     PTR TO DFHEISTG (SET BY DFHEIENT(
* DFHEIENT ALLOWS FOR PARAMETERS:
*    CODEREGS=(1,...,N) OR R3 BY DEFAULT
*    EIBREG=(N) OR R11/RB BY DEFAULT
*    DATAREG=(N) OR R13/RD BY DEFAULT
*
         REGSMAC
MYDSECT  DSECT
MYMF1    DS    F
*
* DFHEISTG GENERATES A DSECT WHICH ANCHORS THE EXEC INTF. THE MACRO
*  WILL GENERATE A PREFIX AREA TO YOUR OWN DATA, FOLLOWING THE DSECT
*  STATEMENT. IN THIS PREFIX AREA, THE DFHEIPLR (R13), THE DFHEIBP
*  FW POINTER AND DFHEICAP (COMMAREA) POINTERS ARE INITIALIZED BY
*  CICS.
*
DFHEISTG DSECT
SAV_CN_REGS4_7   DS  4F
SAV_CN_PUT_RET9  DS   F
SAV_RET_FMT_TM_9 DS   F
DWORD    DS    D
FWORD    DS    F
HWORD    DS    H
SAVCALEN DS    F     MAKE CALEN FW FOR CONVENIENCE
SAVEICAP DS    F
         DS    0D
*
CVTH     DS    CL8
*
MYMSG1   DS    CL1
MYMSG    DS    CL80
MYTIME   DS    CL8
MYABSTM  DS    PL8
MYSTATM  DS    PL8
MYSTPTM  DS    PL8
MYFJDT   DS    CL6
MYFTIME  DS    CL8
MYXJDT   DS    CL6
MYXTIME  DS    CL8
MYPJDT   DS    CL6
MYPTIME  DS    CL8
SAVETRAN DS    CL4
***
F_STGGM  DS    F
***
STOR_LOOP_CNT DS F
HARD_LOOP_CNT DS F
EXEC_LOOP_CNT DS F
EXEC_CICS_FL DS F        USED TO HOLD FLENGTH VALUES
EXEC_CICS_HL DS H        USED TO HOLD LENGTH VALUES
FRESP    DS    F
FRESP2   DS    F
$DBLWD   DS    D
D_ABSTIME DS   D
*
PGM_CMD_AREA_L DS F
PGM_CMD_AREA_A DS F
PGM_CMD_L      DS F
PGM_CMD  DS   CL18
*
TASKNUM  DS    CL8
         ORG   *-5
TASK_NUM DS    CL5
*
TIMER_ENT_ST_JDT DS CL8
TIMER_ENT_SEP    DS CL1
TIMER_ENT_ST_TOD DS CL8
TIMER_L    EQU  *-TIMER_ENT_ST_JDT
*
MYABSTM8 DS    PL8   FOR CNC GET TIME ROUTINE
MYABSTM1 DS    PL8
CUR_CH_NM   DS CL16       CHANNEL NAME ON ENTRY
CN_CT       DS F          COUNT OF CONTAINERS IN TOTAL
CN_NM       DS CL16       CONTAINER NAME
CN_GET_CN_ADR DS  F       ADR OF CUR CMD CN STG DATA
CN_BRS_TKN  DS F          BROWSE CONTAINER TOKEN
*
SPACE255 DS    CL255
*
OPLIT00  DS    CL(TIMER_L) USED FOR CN RESP DT AND TIME
         DS    CL1
OPLITM08 DS    CL8      USED FOR THE PGM NAME
         DS    CL1      USED FOR THE PGM NAME
OPLITM05 DS    CL5      USED FOR THE TXN #
         DS    CL1      SPACE
OPLIT00_L    EQU *-OPLIT00
         ORG   *-1
OPLIT1   DS    CL1
OPLIT1_EQU EQU *-OPLIT00
OPLIT    DS    CL(255-OPLIT1_EQU)
OPLIT00_TOT_EQU EQU *-OPLIT00
*
PUT_RESP_CN_OK DS XL1    VALUE 0 (RESP_CN_OK) AND 1 (RESP_CN_NOT CRE)
PUT_APND_PARMS DS 0F
PUT_APND_MSG_FL DS F     LNG OF APPEND MSG
PUT_APND_MSG_ADR DS F    ADDR OF APPEND MSG
*
*
ENDOFEIS DS    CL8          SET TO ENDOFEIS
********************************************************************
*
* THE FIRST CSECT IS GOING TO BE USED BY THE TRANSLATOR TO INSERT
*  THE  DFHEIENT MACRO. YOU COULD HAVE ALSO CODED YOUR OWN  DFHEIENT
*  IN ORDER TO SPECIFY CODE AND DATA REGISTERS. THE MACRO GENERATES
*  THE ACTUAL EIBLK DSECT AND THEN INITIALIZES THE EXPECTED DYN STG
*  AND VARIOUS POINTERS IN THE AREA GENERATED BY DFHEISTG.
CICSLOOP DFHEIENT
         B     MAIN000
         SPACE 2
*****    GBLC  &SYSDATE
PGM_NM   DC    C'CICSLOOP'
ASM_DT   DC    C'&SYSDATE'
         SPACE 1
MAIN000  DS    0H
         MVC   ENDOFEIS,L_ENDOFEIS
         MVI   MYMSG1,X'40'
*
         MVI   SPACE255,X'40'
         MVC   SPACE255+1(L'SPACE255-1),SPACE255
         MVC   OPLIT00(OPLIT00_TOT_EQU),SPACE255
         MVC   TIMER_ENT_ST_JDT(TIMER_L),SPACE255
         BAS   R9,GET_FORMAT_TIME
         MVC   OPLIT00(TIMER_L),TIMER_ENT_ST_JDT
         MVC   OPLITM08,PGM_NM
         UNPK  TASKNUM,EIBTASKN
         OI    TASKNUM+7,X'F0'
         MVC   OPLITM05,TASK_NUM
         MVC   F_STGGM,F4080      STG LOOP LENGTH VALUE
         MVC   PGM_CMD,SPACE255
*
         L     R5,DFHEICAP
         ST    R5,SAVEICAP
         LH    R15,EIBCALEN
         ST    R15,SAVCALEN    ST AS FW
*  CHECK FOR COMMAREA OR CNC
         EXEC CICS ASSIGN CHANNEL(CUR_CH_NM)                           *
             RESP(FRESP)                                               *
             RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)   ASG CHANNM
         JNE   NO_CH_FND   GO TO CHECK FOR COMMAREA
*
         CLC   CUR_CH_NM,SPACE255
         JE    NO_CH_FND       GOTO CHECK CA IF HANNEL NAME IS SPACES
*
MVC_PGM_CMD  MVC PGM_CMD(0),0(R15)
CN_RESP_NM DC CL16'CICSLOOP_CNRETNM'    TMP CN TO HOLD RESP MSG
DFT_CUR_CH_NM DC CL16'CICSLOOP_D_CHANM'
DFT_CN_NM DC CL16'CICSLOOP_D_CONTM'
LIT_NO_CA DC C':NO COMMAREA SPECIFIED:'
LIT_BAD_CA DC C':BAD COMMAREA SPECIFIED:'
LIT_NO_CH DC C':NO CHANNEL SPECIFIED:'
LIT_NO_CN DC C':NO CONTAINER SPECIFIED:'
LIT_USE_CA DC C':USING CA:'
LIT_CAL   DC C':CA LENGTH:'
*
NO_CH_FND DS 0H
         MVC   CUR_CH_NM,DFT_CUR_CH_NM
         MVC   CN_NM,DFT_CN_NM
         MVC   OPLIT(L'LIT_NO_CH),LIT_NO_CH
         IILF  R0,L'LIT_NO_CH
         ALFI  R0,OPLIT00_L
         ST    R0,EXEC_CICS_FL
         BAS   R9,PUT_APND_RESP_CN
*
         LT    R15,SAVCALEN
         BZ    NO_CA_USE_DEFAULT
         CLFI  R15,11
         BL    BAD_CA_LNG
*
         ST    R15,PGM_CMD_AREA_L
         MVC   PGM_CMD_AREA_A,SAVEICAP
         B     CHK_4_LOOP_CMD
*
BAD_CA_LNG        DS 0H
         MVC   OPLIT(L'LIT_BAD_CA),LIT_BAD_CA
         IILF  R0,L'LIT_BAD_CA
         ST    R0,PUT_APND_MSG_FL
         LA    R0,OPLIT
         ST    R0,PUT_APND_MSG_ADR
         BAS   R9,PUT_APND_RESP_CN
         B     CHK_4_LOOP_CMD0
*
NO_CA_USE_DEFAULT DS 0H
         MVC   OPLIT(L'LIT_NO_CA),LIT_NO_CA
         IILF  R0,L'LIT_NO_CA
         ST    R0,PUT_APND_MSG_FL
         LA    R0,OPLIT
         ST    R0,PUT_APND_MSG_ADR
         BAS   R9,PUT_APND_RESP_CN
         B     CHK_4_LOOP_CMD0
*
CHK_4_LOOP_CMD0   DS 0H
         MVC   PGM_CMD,EXEC_LOOP
         LA    R15,1
         ST    R15,EXEC_LOOP_CNT
         B     EXEC_LOOP0
*
CHK_4_LOOP_CMD    DS 0H
         L     R15,PGM_CMD_AREA_L
         CLFI  R15,18
         BL    CHK_4_USE_LNG
         IILF  R15,18
CHK_4_USE_LNG DS 0H
         L     R8,PGM_CMD_AREA_L
CHK_4_FND_SEP DS 0H
         CLI   0(R7),C' '
         BE    CHK_4_GOT_SEP
         CLI   0(R7),C','
         BE    CHK_4_GOT_SEP
         CLI   0(R7),X'00'
         BE    CHK_4_GOT_SEP
         LA    R7,1(R7)
         BCT   R15,CHK_4_FND_SEP
         B     BAD_PGM_CMD
*
CHK_4_GOT_SEP DS 0H
         ST    R15,PGM_CMD_L
         BCTR  R15,0
         EX    R15,MVC_PGM_CMD
         ST    R15,STOR_LOOP_CNT
         ST    R15,HARD_LOOP_CNT
         ST    R15,EXEC_LOOP_CNT
*   DEF: R11 IS EIB
*        R13 IS DYN STG
*
         EXEC  CICS HANDLE CONDITION ERROR(ERROR01)
*          @@@
STGLOOP0 EQU   *
         L     R6,STOR_LOOP_CNT
         EXEC CICS ASKTIME ABSTIME(MYSTATM)
*          @@@
STGLOOP1 EQU   *
         EXEC  CICS GETMAIN FLENGTH(F_STGGM)                           *
               SET(R10)                                                *
               NOSUSPEND
         MVC   F_STGGM,F4080
         BCT   R6,STGLOOP1
         EXEC CICS ASKTIME ABSTIME(MYSTPTM)
*          @@@
         B     RETURN
EXEC_LOOP0 EQU *
         L     R6,EXEC_LOOP_CNT
         EXEC CICS ASKTIME ABSTIME(MYSTATM)
*          @@@
EXEC_LOOP1 EQU *
         ZAP   MYABSTM,PZERO
         EXEC CICS ASKTIME ABSTIME(MYABSTM)
         BCT   R6,EXEC_LOOP1
         EXEC CICS ASKTIME ABSTIME(MYSTPTM)
         B     RETURN
*          @@@
HARD_LOOP0 EQU *
         L     R6,EXEC_LOOP_CNT
         EXEC CICS ASKTIME ABSTIME(MYSTATM)
*          @@@
HARD_LOOP1 EQU *
         LR    R15,R6
         BCT   R6,HARD_LOOP1
         EXEC CICS ASKTIME ABSTIME(MYSTPTM)
         B     RETURN
*          @@@
BAD_PGM_CMD DS 0H
*
RETURN   EQU   *
         EXEC CICS FORMATTIME ABSTIME(MYSTATM)                         *
              YYDDD(MYFJDT) TIMESEP TIME(MYFTIME)
         EXEC CICS FORMATTIME ABSTIME(MYSTPTM)                         *
              YYDDD(MYPJDT) TIMESEP TIME(MYPTIME)
         MVC   MYMSG,BEGMSG
         MVC   MYMSG+21(6),MYFJDT
         MVC   MYMSG+28(8),MYFTIME
         BAS   R9,WRTLINE
         MVC   MYMSG,ENDMSG
         MVC   MYMSG+21(6),MYPJDT
         MVC   MYMSG+28(8),MYPTIME
         BAS   R9,WRTLINE
         EXEC  CICS RETURN
         SPACE
CVTCNT   EQU   *
         CVD   R8,DWORD
         UNPK  CVTH,DWORD+3(5)
         OI    CVTH+4,X'F0'
         XR    R8,R8
         BR    R9
*        %%%%%
WRTLINE  EQU   *
DOTD     EQU   *
         EXEC  CICS WRITEQ TD QUEUE('CSSL') FROM(MYMSG) LENGTH(H80)
         MVC   MYMSG,MYMSG1
         BR    R9
ERROR01  DS    0H
         MVC   MYMSG,ERR1LNE
         BAS   R9,WRTLINE
         B     RETURN
ERROR02  DS    0H
         MVC   MYMSG,ERR2LNE
         BAS   R9,WRTLINE
         B     RETURN
*
*
* APPEND DATA TO RESPONSE CONTAINER
PUT_APND_RESP_CN DS 0H
         CLI   PUT_RESP_CN_OK,X'0'  CAN WE USE RESP CN?
         JNE   PUT_APND_CN_RET
         ST    R9,SAV_CN_PUT_RET9      YES, USE RESP CN
         STM   R4,R7,SAV_CN_REGS4_7
         JAS   R9,GET_FORMAT_TIME
         MVI   OPLIT00,X'15'
         MVC   OPLIT00+1(8),TIMER_ENT_ST_JDT
         MVC   OPLIT00+10(8),TIMER_ENT_ST_TOD
*
*   TEST TO SEE IF MSG IS IN OPLIT.. IF SO USE IT ELSE MOVE TO OPLIT
         L     R7,PUT_APND_MSG_FL
         L     R6,PUT_APND_MSG_ADR  THE ADR OF THE MSG IN PARM
         LA    R4,OPLIT
         CRJE  R4,R6,PUT_RESP_CN_NOMVC
         LR    R5,R7
         MVCL  R4,R6
         L     R7,PUT_APND_MSG_FL
PUT_RESP_CN_NOMVC DS 0H
         ALFI  R7,OPLIT00_L
         ST    R7,EXEC_CICS_FL  MOVE FLENGTH FOR PUT
*
         EXEC CICS PUT CONTAINER(CN_RESP_NM)        CHANNEL(CUR_CH_NM) *
               FROM(OPLIT00)      FLENGTH(EXEC_CICS_FL)                *
               CHAR APPEND                                             *
               RESP(FRESP)                                             *
               RESP2(FRESP2)
*
         MVC   OPLIT,SPACE255          PUT APND RESP CN
         CLC   FRESP,DFHRESP(NORMAL)
         JE    PUT_RESP_CN_APNDED
         MVI   PUT_RESP_CN_OK,X'1'    TURN OFF RESP CONTAINER
*
PUT_RESP_CN_APNDED  DS 0H
         LM    R4,R7,SAV_CN_REGS4_7
         L     R9,SAV_CN_PUT_RET9
PUT_APND_CN_RET DS 0H
         BR    R9
*
*
GET_FORMAT_TIME DS 0H
         ST   R9,SAV_RET_FMT_TM_9
         ZAP   MYABSTM1,PZERO
         EXEC CICS ASKTIME ABSTIME(MYABSTM1)
         EXEC CICS FORMATTIME ABSTIME(MYABSTM)                         *
              YYYYDDD(TIMER_ENT_ST_JDT)  DATESEP('-')                  *
              TIME(TIMER_ENT_ST_TOD)  TIMESEP(':')
*
         L    R9,SAV_RET_FMT_TM_9
         BR    R9
*
         EJECT
F4080    DC    F'4080'
HNEG1    DC    H'-1'
H0       DC    H'0'
H20      DC    H'20'
H80      DC    H'80'
H4080    DC    H'4096'
*CEMTBLA  DC    A(CEMVALUE)
         SPACE
PZERO    DC    PL1'0'
SP80     DC    CL80' '
*                   0         0         0         0         0    5'
BEGMSG   DC    CL80'*** BEGIN CICSLOOP ***'
TIMELNE  DC    CL80'***          ++++        '
ENDMSG   DC    CL80'*** END   CICSLOOP ***'
STGMSG   DC    CL80'$$$ STORAGE FOR COND GETMAIN NOT AVAILABLE. BYE.'
ERR1LNE  DC    CL80'$$$ ERROR IN INITIALIZATION OF ROUTINE ERROR 1'
ERR2LNE  DC    CL80'$$$ ERROR IN PROCESSING ERROR 2'
*                   0         0         0         0         0    5'
CMD_TBL  EQU *
STOB_LOOP DC CL9'STOB_LOOP'    STG BELOW LOOP
STOA_LOOP DC CL9'STOA_LOOP'    STG ABOVE LOOP
HARD_LOOP DC CL9'HARD_LOOP'
EXEC_LOOP DC CL9'EXEC_LOOP'
CMD_TBL_END   EQU *
CMD_TBL_END_L EQU *-CMD_TBL
CMD_TBL_END_CT EQU CMD_TBL_END_L/9
*                   0         0         0         0         0    5'
L_ENDOFEIS DC  CL8'ENDOFEIS'
         SPACE 3
         LTORG
         DC    C'****'
         DC    C'CICSLOOP - CIGNA * CPCW *'
         DC    C' '
         DC    C'DATE='
         DC    C'&SYSDATE'
         DC    C' '
         DC    C'TIME='
         DC    C'&SYSTIME'
         DC    C' '
         DC    C'TCEM'
         DC    C'****'
*        EXTRN CEMVALUE
         END
###END CICSLOOP
$$$BEG RXVARSLS
  TITLE 'RXVARSLS - REXX Function To READ / WRITE REXX VARS'
*
* test with  RX exec TTED.TSK.P.TCEM.CLIST(TSTRXVLS)
*
* using RXVARS as sample; rx vars expects a single rx var passed
*  to this routine. we then parse this as a comma separated
*  list of other rx vars that we are interested in. as we fetch
*  each var name and value, we push it onto the current rx queue
*  for which the invoking clist can pull values
* finally we alter the first char in each variable with '!'
*  such that the invoking rx exec can also display those vars to
*  confirm that we can alter the rx var in content and size
*
RXVARSLS CSECT
RXVARSLS AMODE 31
RXVARSLS RMODE ANY
*
R0       EQU   0                  REGISTER EQUATES
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6                  -> SHVBLOCK (also used as a work reg)
R7       EQU   7
R8       EQU   8                  -> ARGUMENT LIST
R9       EQU   9                  -> LOCAL WORK AREA
R10      EQU   10                 BASE REGISTER 3
R11      EQU   11                 BAS REG
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
*
*
         USING RXVARSLS,R10
         BAKR  R14,0              SAVE CALLER'S REGS & RETURN LOC
         LR    R10,R15            SET 1ST BASE REG
* logic added below allows this routine to be invoked using
*  rx CALL rxvarsls 'parms'
*  or via a ISPEXEC SELECT PGM(rxvarsls) PARM('parms')
* in which case the RX CALL passes the ENVB in R0 and RX PARM TBL in R1
*    but the ISPEXEC passes a usual OS parm (00llparms) addr in R1
* this is diferentiated by using R0: if first DW is 'ENVBLOCK' eyec
* then assume we are invoked by RX CALL
*
         LR    R4,R1              PARK PARM POINTER (R1) IN R4
         LR    R5,R0              PARK ENV BLOCK PTR (R0) IN R5    @ANZ
         LA    R2,LOCAL_WORKAREA_LENGTH  SIZE OF OUR LOCAL WORK AREA
         BAS   R11,GM_WK
         LTR   R15,R15
         BNZ   SA_STG_GM_FAIL     No WKAREA available - bye
*
         LR    R9,R1              SET R9 W R1 GM STG@ OF LOCAL WORKAREA
         USING LOCAL_WORKAREA,R9  SET ADDRESSABILITY
         LR    R2,R9              clear wkarea with x'00'
         LA    R3,LOCAL_WORKAREA_LENGTH
         SR    R15,R15            PAD OF X'00' & ZERO LENGTH
         MVCL  R2,R14             INIT WORKAREA TO BINARY ZERO
*
         LA    R15,SAVEAREA       SET -> TO OUR SAVE AREA
         ST    R13,4(R15)         CHAIN BACKWARD ->
         ST    R15,8(R13)         CHAIN FORWARD ->
         LR    R13,R15            THIS SETS UP OUR SA IN CASE WE CALL
*
         st    r4,sav_r1          preserve ptr to parm if needed
         st    r5,sav_r0          preserve ptr to parm if needed
         LA    R11,MSG             GET @  MSG/RECEIVE BUF
         ST    R11,MSG@            SAVE IT
         MVI   MSGINIT,C' '       INIT MSG AREA TO SPACES
         MVC   MSG,MSGINIT        move spaces to msg
* NOT REALLY NEEDED BUT COOOL JES STUFF
         IAZXJSAB READ,JOBID=MYJOBID,JOBNAME=MYJOBNM
*
         xc    rc,rc
         XC    ARGS_CT,ARGS_CT
         XC    ARGS_GD,ARGS_GD
         XC    ARGS_BD,ARGS_BD
         XC    VARLST_GM_@,VARLST_GM_@
         XC    VAR_GM_ADDR,VAR_GM_ADDR
*  set up irx queue parm area
         MVC   IRFUNCT,LIT_QUEUE
         mvc   IRSTRADR,msg@
         LA    R1,L'MSG
         ST    R1,IRSTRLEN
*  set up irparms
         la    r1,irfunct
         st    r1,irparm1
         la    r1,IRSTRADR
         st    r1,irparm2
         la    r1,IRSTRLEN
         st    r1,irparm3
         la    r1,IRRETCD
         st    r1,irparm4
         OI    IRPARM4,X'80'
*
         xc    EFPL@,EFPL@        use this stg as switch to indicate
*                                  if rx efpl via CALL, or zero for OS
         LA    R6,irxexcom_shv_blk INIT -> TO OUR SHARED VAR BLK
         USING SHVBLOCK,R6        SET ADDRESSABILITY
*
         l     r5,sav_r0          just for code clarity
         clc   lit_envblock,0(r5) RX CALL sets R0 to ENVB with
         bne   try_jobparm_fmt     eyec 'ENVBLOCK'
*                              YEP - We are RX CALL
         Lt    R1,sav_r1          RESTORE PARM (R1) FROM SAVED REG
         BZ    NOPARM_passed      expect -> to EFPL
*
*  add this logic because we have a envblock, but we might not
*   have addr to EFPL;  EFPL has 4 reserved fw (all nulls)
*   or if from ADDRESS LINK then first two fw point to args
*   in which case we have a different control block where
*   first fw points to a addr which points to the actual arg val
*   second fw points to a addr which points to the arg lng
*  once we can get the arg value, and the arg lng, we can drive
*   the call to irxexcom using these addr as shvnama and shvnaml
*  TEST for lv in first Fw: if so then we have EFPL
         lt    r15,0(r1)
         bnz   efpl_not_indicated
*
EFPL_found ds 0h
         USING EFPL,R1            SET ADDRESSABILITY
         ST    R1,EFPL@           KEEP POINTER AROUND JUST IN CASE
*                     EFPL is RX funct parm list
*  which has  EFPLARG  DS A             * POINTER TO ARGUMENTS TABLE
*             EFPLEVAL DS A             * POINTER TO ADDRESS OF EVALBLk
*
         L     R8,EFPLARG         GET -> TO ARGUMENT LIST
         USING ARGTABLE_ENTRY,R8  SET ADDRESSABILITY
         DROP  R1                 DROP EFPL ADDRESSABILITY
*
*R5 already -> environment block -- saved from R0 at entry to RXVARSLS
*
         USING ENVBLOCK,R5        SET ADDRESSABILITY TO ENVBLOCK   @ANZ
         ST    R5,ENVB@           SAVE ENVIRONMENT BLOCK POINTER   @ANZ
         L     R5,ENVBLOCK_IRXEXTE EXTERNAL ENTRY VECTOR ADDRESS   @ANZ
         USING IRXEXTE,R5         SET ADDRESSABILITY TO EXTE       @ANZ
         L     R0,IRXSTK          GET ADDRESS OF IRXSTK ROUTINE
         ST    R0,IRXSTK@           SAVE IT
         L     R0,IRXEXCOM        IRXEXCOM ROUTINE ADDRESS         @ANZ
         ST    R0,IRXEXCO@        SAVE ROUTINE ADDRESS FOR LATER USE
         DROP  R5                 DROP IRXEXTE  ADDRESSABILITY     @ANZ
*
         XR    R7,R7              COUNT OF ARGS
         LM    R3,R4,ARGTABLE_ARGSTRING_PTR  GET ADDR & LENGTH OF ARG
         C     R3,L_HV            IF ADDRESS IS ALL X'FF'
         BE    NO_ARGS_PASSED     expect single parm with RX vars list
*
         STM   R3,R4,VARLST_@     SAVE @ OF RX PARM AND LNG
*
         LR    R11,R4
         BCTR  R11,0
         LA    R5,VARLST_NM
         EX    R11,EX_MVC_NM      SAVE THE NAME
*
         MVC   MSG(L'LIT_GOT_LST),LIT_GOT_LST
         LA    R5,MSG+35
         EX    R11,EX_MVC_NM
         BAS   R11,QUEUE_IT
         MVC   MSG,MSGINIT        move spaces to msg
         b     rx_fetch_list
*
* our incoming r1 points to a data area that is not indicitive of
*  containing the EFPL. so treat it as a LINK
*  0(r1) points to a fw addr containing the arg name
EFPL_NOT_INDICATED ds 0h
         l     r3,0(r1)        r3 now has addr of arg addr
         lt    r3,0(r3)        r3 now has addr of arg
         BZ    NOPARM_passed
         Lt    R4,4(r1)        GET THE addr of the arg lng
         BZ    NOPARM_passed
         Lt    R4,0(r4)        tst THE actual arg lng
         BZ    NOPARM_passed
*
         bas   r11,LOAD_IRX_mods  get the LOAD addr of IRXEXCOM IRX
         ltr   r15,r15         if we return > 0 then some error
         bnz   irx_mods_not_loaded
*
         b     rx_fetch_list
*
try_jobparm_fmt ds 0h
         Lt    R1,sav_r1
         BZ    NOPARM_passed
         L     R1,0(R1)        address OS parm string
         ST    R1,PARMAP
         LH    R4,0(R1)
         LTR   R4,R4
         BZ    NOPARM_passed
         CH    R4,H125
         BH    NOPARM_passed
         STH   R4,PARMAL
*                              set up r4 with rx var name (from parm)
         LA    R3,2(R1)        set up r3 with rx var name lng
         ST    R3,PARMA
*
         bas   r11,LOAD_IRX_mods  get the LOAD addr of IRXEXCOM IRX
         ltr   r15,r15         if we return > 0 then some error
         bnz   irx_mods_not_loaded
*
         b     rx_fetch_list
*
rx_fetch_list ds 0h
         STM   R3,R4,SHVNAMA      @NAME & @LENGTH OF VARIABLE NAME
*                                         SHVNAML IS FW LNG
         BAS   R11,FETCH_RX_VAR           GET THE RX LST VAR
*                                         SHVNAML IS FW LNG
         LTR   R15,R15
         BZ    GOT_RX_LIST
*
         MVC   MSG(L'LIT_BAD_LST),LIT_BAD_LST
         L     R11,SHVNAML
         BCTR  R11,0
         LA    R5,MSG+35
         EX    R11,EX_MVC_NM
         BAS   R11,QUEUE_IT
         MVC   MSG,MSGINIT        move spaces to msg
         B     FIN_RX_LIST
*
GOT_RX_LIST DS 0H
*               note - call to GM stg in the fetch_rx_var sub-rtn
*                      returns addr in VAR_GM_ADDR - preserve it
         MVC   VARLST_GM_@,VAR_GM_ADDR    SAVE FOR FREEMAIN at end
         MVC   VARLST_@,SHVVALA   PRESERVE RX list val stg addr
         MVC   VARLST_L,SHVVALL               AND LNG of RX nm list
*                               which are set in fetch_rx_var sub-rtn
         MVC   VARLST_CUR_@,VARLST_@  save the beg of lst addr
         L     R7,VARLST_CUR_@        we will parse this
         L     R4,VARLST_L             for rx var names
         ARK   R11,R7,R4
         BCTR  R11,0              calculate the
         ST    R11,VARLST_LAST_@  LAST POS IN LIST OF RX VARS
*
RX_LIST_LOOP DS 0H                look for sep chars ',' ' '
         CLI   0(R7),C','
         BE    RX_LIST_FND_SEP
         CLI   0(R7),C' '
         BE    RX_LIST_FND_SEP
         LA    R7,1(R7)
         C     R7,VARLST_LAST_@
         BNH   RX_LIST_LOOP      could be sep at last pos
*                                invalid but possible
RX_LIST_FND_SEP DS 0H
         L     R3,VARLST_CUR_@   lower @ of beg of rx var nm
         ST    R7,VARLST_CUR_@    SAVE ADDR OF SEP CHAR
*        BCTR  R7,0              TAKE 1 FROM LNG FOR SEP OR END
         SRK   R4,R7,R3           DERIVE ACTUAL RX VAR NM LNG
         LTR   R4,R4              IF NOT POS THEN MAYBE MULT SEP
         BNP   RX_LIST_CHK_LAST   IN A ROW OR SEP WAS LAST POS
*
         L     r15,ARGS_CT
         LA    r15,1(r15)         COUNT OF ARGS
         ST    r15,ARGS_CT
*        CH    R4,=H'##'          HERE WE WOULD TEST THE ARG LNG
*        BH    BAD_ARG_LNG        IT'S AN ERROR
*        WE ALSO HAVE A PTR TO IT IN R3 SO WE COULD USE IT
         STM   R3,R4,SHVNAMA      @NAME & @LENGTH OF VARIABLE NAME
*                                         SHVNAML IS FW LNG
         BAS   R11,FETCH_RX_VAR
*                                         SHVNAML IS FW LNG
         LTR   R15,R15
         BZ    RX_LIST_GOT_VAR
*
         L     r15,ARGS_bd
         LA    r15,1(r15)         COUNT OF ARGS
         ST    r15,ARGS_bd
*
         MVC   MSG(L'LIT_BAD_VAR),LIT_BAD_VAR
         BAS   R11,B2C            uses x val in r15
         MVC   MSG+21(8),HLDSTR     COUNTER OF BAD VAR
         L     R11,SHVNAML
         BCTR  R11,0
         LA    R5,MSG+35
         EX    R11,EX_MVC_NM
         BAS   R11,QUEUE_IT
         MVC   MSG,MSGINIT        move spaces to msg
         B     RX_LIST_CHK_LAST
*
EX_MVC_NM MVC   0(0,R5),0(R3)      SHVNAMA IS R3
*
RX_LIST_GOT_VAR DS 0H
         MVC   MSG(L'LIT_GOT_VAR),LIT_GOT_VAR
         L     r15,ARGS_gd
         LA    r15,1(r15)         COUNT OF ARGS
         ST    r15,ARGS_gd
*
         BAS   R11,B2C            uses x val in r15
         MVC   MSG+21(8),HLDSTR     COUNTER OF BAD VAR
         L     R11,SHVNAML
         BCTR  R11,0
         LA    R5,MSG+35
         EX    R11,EX_MVC_NM        MVC THE VAR NAME TO
         LA    R5,VARNAME               VARNAME
         EX    R11,EX_MVC_NM        MVC THE VAR NAME THA WE FND
         BAS   R11,QUEUE_IT
         MVC   MSG,MSGINIT        move spaces to msg
*     pre-pennd a '$' on the front of each rx var value in as
*      returned by the FETCH_RX_VAR sub-rtn. in that code, we did
*      increase the gm area by one, and fetched the rc var val to
*      pos 2 of the area pointed to by VAR_GM_ADDR
*     and now we are going to store the new value in the rx var
         L     R3,VAR_GM_ADDR
         MVI   0(R3),C'$'
         MVC   SHVVALL,SHVBUFL    SET RETURN LNG TO 1 BIGGER
         ST    R3,SHVVALA         this includes pre-pended $
         MVI   SHVCODE,SHVSTORE   REQUEST: STORE A VARIABLE
         L     R15,IRXEXCO@       ADDR OF IRXEXCOM ROUTINE
* The VL in the CALL macro directs the macro to store the high order
* bit in the last word of the parameter list.
         CALL  (15),(IRXEXLIT,0,0,SHVBLOCK),VL,MF=(E,EXCOPLST)
*
         TM    SHVRET,SHVBADN+SHVBADV+SHVBADF  CHECK ERROR BITS
         BZ    RX_LIST_CHK_LAST   IF ALL OK, CONTINUE
*        WE ALSO HAVE A PTR TO IT IN R3 SO WE COULD USE IT
*
RX_LIST_CHK_LAST DS 0H
         L     R1,VAR_GM_ADDR     FREE THIS STORAGE AREA
         L     R2,VAR_LEN
         BAS   R11,FM
*
         L     R7,VARLST_CUR_@    points at last sep or end plus 1
         LA    R7,1(R7)           BUMP BEYOND CUR SEP
         st    r7,VARLST_CUR_@    save addr as beg of next var
         C     R7,VARLST_LAST_@
         BNH   RX_LIST_LOOP      could be sep at last pos
*
FIN_RX_LIST    DS 0H
         LT    R1,VARLST_GM_@
         BZ    DONE_ARGS_PASSED
         L     R2,VARLST_L
         BAS   R11,FM
*
DONE_ARGS_PASSED DS 0H
         mvc   msg(l'lit_fin_msg),lit_fin_msg
         BAS   R11,QUEUE_IT
         MVC   MSG,MSGINIT        move spaces to msg
*
         lt    r1,efpl@           was this RX CALL?
         bz    NO_EVALBLOCK         if zero then it was OS
*        L     R1,EFPL@           GET POINTER TO ORIGINAL PARM LIST
         USING EFPL,R1            SET ADDRESSABILITY
         L     R2,EFPLEVAL        GET -> TO EVALUATION BLOCK
         L     R2,0(,R2)          GET ACTUAL ADDRESS OF BLOCK
         USING EVALBLOCK,R2       SET ADDRESSABILITY
         L     R0,EVALBLOCK_EVSIZE
         C     R0,F20
         BL    NO_EVALBLOCK
         LA    R14,MSG
         MVC   EVALBLOCK_EVLEN,F4
         MVC   EVALBLOCK_EVDATA(4),0(R14)     EVALUATION BLOCK
NO_EVALBLOCK DS 0H
         LA    R15,0
         B     GOBACK_FM_WORKAREA
*
SA_STG_GM_FAIL DS 0H
         lh    r15,h16
         B     GOBACK_NOFM
*
NO_ARGS_PASSED DS 0H
         mvc   rc,h8
         b     do_fm_wk
*
NOPARM_passed ds 0h
irx_mods_not_loaded ds 0h
         mvc   rc,h12
         b     do_fm_wk
*
GOBACK_FM_WORKAREA DS 0H
         mvc   rc,h0
         b     do_fm_wk
*
do_fm_wk ds 0h
         LA    R2,LOCAL_WORKAREA_LENGTH  SIZE OF OUR LOCAL WORK AREA
         LR    R1,R9
         BAS   R11,FM
         lh    r15,rc
*
GOBACK_NOFM DS 0H
         PR                       RETURN TO CALLER
*
QUEUE_IT DS    0H
*
* QUEUE LINE ONTO REXX DATA STACK
*
         ST    R11,SAV_R11
*        XR    R0,R0               DON'T SPECIFY AN ENVIRONMENT BLOCK
         L     R0,ENVB@            SET R0 TO THE ADDR OF ENVBLOCK
         LA    R1,IRPARMS          POINT TO PARAMETER LIST
         L     R15,IRXSTK@        GET ADDRESS OF IRXSTK
         BALR  R14,R15             CALL REXX STACK ACCESS ROUTI NE
         L     R11,SAV_R11
         BR    R11                DONE_QUEUED
*
*  ON ENTRY REQUIRE R3 POINT TO THE RX VAR NAME
*   AND R4 CONTAINS THE NAME LENGTH
*  RETRIEVE THE RX VAR
*   FIRST FETCH INTO A ZERO LENGTH AREA, EXPECTING SHVTRUNC
*   AND THE ACTUAL LNG IS PLACED INTO SHVVALL
*   OBTAIN STG FOR THE REAL VALUE + 1
*   AND RE-FETCH INTO GM AREA
FETCH_RX_VAR DS 0H
         ST    R11,SAV_R11
         XC    SHVBUFL,SHVBUFL    SET FETCH AREA TO ZERO LNG
         XC    RX_FETCH_RETRY_CT,RX_FETCH_RETRY_CT
         MVC   SHVVALA,msg@       ACTUALLY DO NOT USE MSG
         MVI   SHVCODE,SHVFETCH   WANT TO GET THIS VARIABLE
FETCH_RX_VAR_RETRY DS 0H
         L     R15,IRXEXCO@       ADDRESS OF IRXEXCOM ROUTINE
         CALL  (15),(IRXEXLIT,0,0,SHVBLOCK),VL,MF=(E,EXCOPLST)
*        cli   SHVRET,x'00'       WE GET THE RX VAR
         tm    SHVRET,x'ff'       WE GET THE RX VAR
         Bz    FETCH_RX_VAR_OK    IF SO, THEN XIT
*                                 (not expected on first pass)
         TM    SHVRET,SHVTRUNC    VAL NAME BUT BUF TOO SMALL
         BZ    FETCH_RX_VAR_ERR   NOT 'BUF TOO SMALL' SO XIT
*
         CLC   RX_FETCH_RETRY_CT,F0   only get 1 try
         BH    FETCH_RX_VAR_ERR
*
         LT    R2,SHVVALL         LOAD THE ACTUAL VAR LNG ret by 1st
         BZ    FETCH_RX_VAR_ERR   RX VAR HAS ZERO LNG, SO XIT
         LA    R2,1(R2)           GET 1 EXTRA BYTE for pre-pend $
         ST    R2,SHVBUFL         STORE IT FOR RE FETCH
         ST    R2,VAR_LEN         STORE IT FOR RE FETCH
         BAS   R11,GM             gm stg for this rx var
         LTR   R15,R15
         BNZ   FETCH_RX_VAR_ERR
         ST    R1,VAR_GM_ADDR     1 EXTRA BYTE ON BEG OF GM AREA
         LA    R1,1(R1)            TO BE USED TO RETURN A RX VAR CHG
         ST    R1,SHVVALA          SO POINT TO THE 2ND BYTE IN GM
*                                  AND FETCH TO THAT AREA
         L     R1,RX_FETCH_RETRY_CT  add 1 to count
         LA    R1,1(R1)
         ST    R1,RX_FETCH_RETRY_CT
         B     FETCH_RX_VAR_RETRY  and retry feth with proper length
*
FETCH_RX_VAR_ERR DS 0H
         LA    R15,8              return 8: fail
         B     FETCH_RX_VAR_FIN
*        YOU HAVE TO SET R4 TO THE REAL VAR NAME LENGTH!!!!
*
FETCH_RX_VAR_OK DS 0H
         XR    R15,R15            return0: success
FETCH_RX_VAR_FIN DS 0H
         L     R11,SAV_R11
         BR    R11
*
B2C      DS 0H
         CVD   R15,DWORD
P2C      DS 0H
         UNPK  HLDSTR,DWORD+4(4)
         OI    HLDSTR+7,X'F0'
         BR    R11
***
GM_wk    DS 0H
         STORAGE OBTAIN,LENGTH=(R2),COND=YES LCL WORK AREA
         BR    R11
*
* use this routine for gm after establishing the workarea using
gm       ds    0h
         st    r11,sav_r11_gm
*
         bas   r11,gm_wk
*
         ltr   r15,r15
         bnz   gm_arnd_set_x00_done
         c     r2,f8192
         bnl   gm_arnd_set_x00_done
         stm   r4,r5,sav_r4_r5
         lr    r4,r1
         lr    r5,r2
         la    r14,spaces
         xr    r15,r15           pad (zero lng) with x'00'
         mvcl  r4,r14
         lm    r4,r5,sav_r4_r5
         xr    r15,r15
gm_arnd_set_x00_done ds 0h
         l     r11,sav_r11_gm
         BR    R11
*
***
FM       DS 0H
         STORAGE RELEASE,LENGTH=(R2),ADDR=(R1)    RELEASE WORK AREA
         BR    R11
*
*
LOAD_IRX_mods  DS 0H
         xr    r15,r15
         LOAD  EP=IRXEXCOM        LOAD REXX VARIABLE ACCESS ROUTINE
         LTR   15,15              WAS LOAD SUCCESSFUL?
         Bnz   load_irx_xit       YES
         ST    r0,IRXEXCO@         SAVE FOR OTHER USES
*
         LOAD  EP=IRXSTK          LOAD REXX VARIABLE ACCESS ROUTINE
         LTR   15,15              WAS LOAD SUCCESSFUL?
         Bnz   load_irx_xit
         ST    r0,IRXSTK@         SAVE FOR OTHER USES
load_irx_xit ds 0h
         BR    11                 RETURN TO CALLER
*
***
         LTORG
*
* MISCELLANEOUS CONSTANTS
*
MIN_ARGS DC    F'1'               SET A MIN OF EXPECTED ARGS
MAX_ARGS DC    F'3'  SET A MAX OF EXPECTED ARGS
L_HV     DC    XL4'FFFFFFFF'      LIT TO SIGNAL NO MORE ARGS IN ARGTABL
F0       DC    F'0'
F1       DC    F'1'
F4       DC    F'4'
F20      DC    F'20'
F8192    DC    F'8192'
H0       dc    h'0'
H4       dc    h'4'
H8       dc    h'8'
H12      dc    h'12'
H16      dc    h'16'
H125     dc    h'125'
SPACES   DC    CL8' '             SPACES CONSTANT
IRXEXLIT     dc CL8'IRXEXCOM'      PROGRAM NAME CONSTANT
lit_envblock dc cl8'ENVBLOCK'     PROGRAM NAME CONSTANT
LIT_QUEUE    DC CL8'QUEUE'
LIT_GOT_LST DC C'$$$ PARM PASSED REXX VARIABLE:NAME:'
LIT_BAD_LST DC C'!!! REXX LIST NAME INVALID   :NAME:'
LIT_GOT_VAR DC C'$$$ GOT RX VARIABLE @________:NAME:'
LIT_BAD_VAR DC C'!!!INVALID VARIABLE @________:NAME:'
lit_fin_msg DC C'$$$ finished execution.'
*                                     21            35
* ###
         TITLE 'RXVARSLS - LOCAL WORK AREA'
LOCAL_WORKAREA DSECT
*
X2CX49   DS    6F
DWORD    DS    D
$DBLWD   DS    D
EBCDCFLD DS    D
HEXFIELD DS    F
HLDSTR   DS    CL8
***
PARMAP   ds    f
PARMA    ds    f
PARMAL   ds    h
***
RX_FETCH_RETRY_CT DS F
ARGS_CT  DS    F
ARGS_GD  DS    F
ARGS_BD  DS    F
*        DS    F
DBLWRK   DS    0D
FULLWRK1 DS    F
FULLWRK2 DS    0F
HALFWRK1 DS    H
HALFWRK2 DS    0H
BYTEWRK1 DS    X
BYTEWRK2 DS    X
*
SAV_R0   DS    F                 SAVE REG 1  as env block ptr (if any)
SAV_R1      DS    F              SAVE REG 1  as parm addr
SAV_R11     DS    F              SAVE REG 11 ON BAS INSTR
SAV_R11_gm  DS    F              SAVE REG 11 ON BAS INSTR
sav_r4_r5 ds   2f                SAVE REG 14 reg5 in gm clear
*
SAVEAREA DS    18F
*
irxexcom_parms    ds 0d
EXCOPLST          DS 0d
irxexcom_lit_name ds cl8
irxexcom_adr1     ds f
irxexcom_adr3     ds f
irxexcom_shv_blk  ds cl(SHVBLEN)
irxexcom_len      equ *-irxexcom_parms
*
EFPL@    DC    F'0'               -> TO EFPL (SAVED AT FUNCTION ENTRY)
ENVB@    DC    F'0'               -> TO ENVB (SAVED AT ENTRY)      @ANZ
IRXEXCO@ Ds    A                  -> IRXEXCOM ENTRY ADDRESS
IRXSTK@  DS    A                   ADDRESS OF REXX STACK ROUTINE
RECBUF@  DC    F'0'               -> TO RECORD BUFFER AREA
RETURNTO DC    F'0'               R14 SAVE FOR OPEN/READ/WRIT/CLOS ETC
LVL1R14  DC    F'0'               R14 SAVE - LEVEL 1 SUBROUTINES
MSGLEN   DC    H'0'               LENGTH OF RETURN MESSAGE (MSG@)
RECBUFL  DC    H'0'               LENGTH OF RECORD BUFFER (RECBUF@)
MYJOBID  DS    CL8                JOB ID (1ST CHAR OVERLAID WITH "X")
MYJOBNM  DS    CL8                JOB nm (1ST CHAR OVERLAID WITH "X")
DDNAME   DS    CL8                SPACE PADDED DDNAME
*
MSG@     DC    F'0'               -> TO ERROR MSG TEXT
MSGINIT  DS    CL1
MSG      DS    CL256
MSG_LEN  EQU   *-MSG
         DS    CL35               BUFFER
*
VARLST_NM DS    CL256              RX VAR NAME HOLDING LIST OF RX VARS
VARLST_GM_@ DS  F                  ADDR OF ACTUAL RX VAR LIST
VARLST_@  DS    F                  ADDR OF ACTUAL RX VAR LIST
VARLST_L  DS    F                  LNG  OF ACTUAL RX VAR LIST
VARLST_CUR_@ DS F
VARLST_LAST_@ DS F
*
* WORK AREA FOR EACH RX VAR IN LIST
VARNAME   DS    CL256              AREA WHERE VARIABLE NAME IS RETURNED
VARNAME_L DS    F
VAR_GM_ADDR DS  F                   ADDR OF GM AREA FOR VARS
VAR_LEN     DS  F                   VAR LENGTH
*
NEW_VAR_NAME DS CL252
NEW_VAR_NAME_LEN DS  H
*
rc       ds    h
         DS    0F
*OURSHVBL DC  XL(EXCOPLSTN)'00'
OURSHVBL DC  XL(irxexcom_len)'00'
*
IRPARMS  DS    0A                  PARAMETER LIST FOR IRX ROUTINES
IRPARM1  DS    A                   ADDRESS OF PARAMETER 1
IRPARM2  DS    A                   ADDRESS OF PARAMETER 2
IRPARM3  DS    A                   ADDRESS OF PARAMETER 3
IRPARM4  DS    A                   ADDRESS OF PARAMETER 4
*                                  PARAMETERS USED BY IRXSTK
         ds 0d
IRFUNCT  DS    CL8                 PARAMETER 1: FUNCTION TO PERFORM
IRSTRADR DS    f                   PARAMETER 2: ptr to data to queue
IRSTRLEN DS    f                   PARAMETER 3: data lng
IRRETCD  DS    f                   PARAMETER 4: RETURN CODE
*                                  set high bit on to indicate end
*
LOCAL_WORKAREA_LENGTH EQU *-LOCAL_WORKAREA   TOTAL LENGTH OF AREA
*
         TITLE 'RXVARSLS - IRXEFPL Dsect'
         PRINT GEN
         IRXEFPL
         TITLE 'RXVARSLS - IRXEVALB Dsect'
         IRXEVALB
         TITLE 'RXVARSLS - IRXARGTB Dsect'
         IRXARGTB
         TITLE 'RXVARSLS - IRXSHVB Dsect'
         IRXSHVB
         TITLE 'RXVARSLS - IRXENVB Dsect'
         IRXENVB
         TITLE 'RXVARSLS - IRXEXTE Dsect'
         IRXEXTE
* not really needed but very cool JES
STCB     DSECT
         DS    XL188
STCBJSAB DS    A
         DS    XL4
         IAZJSAB DSECT=YES
*
* THE FOLLOWING ARE NEEDED BY THE JES CALL
         IHAASCB
*
         IHAASSB
*
         IHAPSA
*
         IKJTCB
*
         END
###END RXVARSLS
$$$BEG RXVARS
  TITLE 'RXVARS - REXX Function To READ / WRITE REXX VARS'
RXVARS   CSECT
RXVARS   AMODE 31
RXVARS   RMODE ANY
*
R0       EQU   0                  REGISTER EQUATES
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6                  -> SHVBLOCK (also used as a work reg)
R7       EQU   7
R8       EQU   8                  -> ARGUMENT LIST
R9       EQU   9                  -> LOCAL WORK AREA
R10      EQU   10                 BASE REGISTER 3
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
*
*
         USING RXVARS,R10
         BAKR  R14,0              SAVE CALLER'S REGS & RETURN LOC
         LR    R10,R15            SET 1ST BASE REG
         LR    R4,R1              PARK PARM POINTER (R1) IN R4
         LR    R5,R0              PARK ENV BLOCK PTR (R0) IN R5    @ANZ
         LA    R2,LOCAL_WORKAREA_LENGTH  SIZE OF OUR LOCAL WORK AREA
         STORAGE OBTAIN,LENGTH=(R2),COND=YES LCL WORK AREA
         LTR   R15,R15
         BNZ   SA_STG_GM_FAIL
*
         LR    R9,R1              SET R9 W R1 GM STG@ OF LOCAL WORKAREA
         USING LOCAL_WORKAREA,R9  SET ADDRESSABILITY
         LR    R2,R9
         LA    R3,LOCAL_WORKAREA_LENGTH
         SR    R15,R15            PAD OF X'00' & ZERO LENGTH
         MVCL  R2,R14             INIT WORKAREA TO BINARY ZERO
         LA    R15,SAVEAREA       SET -> TO OUR SAVE AREA
         ST    R13,4(R15)         CHAIN BACKWARD ->
         ST    R15,8(R13)         CHAIN FORWARD ->
         LR    R13,R15            THIS SETS UP OUR SA IN CASE WE CALL
*
         LA    R6,OURSHVBL        INIT -> TO OUR SHARED VAR BLK
         USING SHVBLOCK,R6        SET ADDRESSABILITY
         MVI   MSGINIT,C' '       INIT MSG AREA TO SPACES
         MVC   MSG,MSGINIT
* NOT REALLY NEEDED BUT COOOL JES STUFF
         IAZXJSAB READ,JOBID=MYJOBID,JOBNAME=MYJOBNM
*
         LR    R1,R4              RESTORE PARM (R1) FROM SAVED REG
         USING EFPL,R1            SET ADDRESSABILITY
         ST    R1,EFPL@           KEEP POINTER AROUND JUST IN CASE
         L     R8,EFPLARG         GET -> TO ARGUMENT LIST
         USING ARGTABLE_ENTRY,R8  SET ADDRESSABILITY
         DROP  R1                 DROP EFPL ADDRESSABILITY
*
*R5 already -> environment block -- loaded from R0 at entry to RXVARS
*
         USING ENVBLOCK,R5        SET ADDRESSABILITY TO ENVBLOCK   @ANZ
         ST    R5,ENVB@           SAVE ENVIRONMENT BLOCK POINTER   @ANZ
         L     R5,ENVBLOCK_IRXEXTE EXTERNAL ENTRY VECTOR ADDRESS   @ANZ
         USING IRXEXTE,R5         SET ADDRESSABILITY TO EXTE       @ANZ
         L     R0,IRXEXCOM        IRXEXCOM ROUTINE ADDRESS         @ANZ
         ST    R0,IRXEXCO@        SAVE ROUTINE ADDRESS FOR LATER USE
         DROP  R5                 DROP ENVBLOCK ADDRESSABILITY     @ANZ
         XR    R7,R7              COUNT OF ARGS
         L     R5,ARGTABLE_ARGSTRING_PTR  GET ADDR OF REQUEST ARG
         C     R5,L_HV            IF ADDRESS IS ALL X'FF'
         BE    NO_ARGS_PASSED     NO ARG PASSED,ERROR
*
ARGS_LOOP EQU *
         LM    R3,R4,ARGTABLE_ARGSTRING_PTR  GET ADDR & LENGTH OF ARG
         C     R3,L_HV            IF ADDRESS IS ALL X'FF'
         BE    DONE_ARGS_PASSED   DONE ARG PASSED
*
         LA    R7,1(R7)           COUNT OF ARGS
*        CH    R4,=H'##'          HERE WE WOULD TEST THE ARG LNG
*        BH    BAD_ARG_LNG        IT'S AN ERROR
*        WE ALSO HAVE A PTR TO IT IN R3 SO WE COULD USE IT
         STM   R3,R4,SHVNAMA      @NAME & @LENGTH OF VARIABLE NAME
         LA    R0,MSG_LEN         MAX LEN OF THE RECEIVE BUF
         ST    R0,SHVBUFL
         LA    R0,MSG             GET -> RECEIVE BUF
         ST    R0,SHVVALA
         MVI   SHVCODE,SHVFETCH   WANT TO GET THIS VARIABLE
         L     R15,IRXEXCO@       ADDRESS OF IRXEXCOM ROUTINE
         CALL  (15),(IRXEXLIT,0,0,OURSHVBL),VL,MF=(E,EXCOPLST)
         TM    SHVRET,SHVBADN+SHVBADV+SHVBADF+SHVNEWV
         BZ    VAR_OK             DID WE GET THE VARIABLE OK?
*
VAR_FETCH_ERROR EQU *
         LA    R3,NEW_VAR_NAME
         L     R4,NEW_VAR_NAME_LEN
*        YOU HAVE TO SET R4 TO THE REAL VAR NAME LENGTH!!!!
*
VAR_OK   EQU *
STORE_VAR EQU  *
         STM   R3,R4,SHVNAMA
         LA    R0,MSG             ADDRESS OF VAR DATA
         ST    R0,SHVVALA
         LA    R0,MSG_LEN         LENGTH OF VARIABLE DATA
         ST    R0,SHVVALL
         MVI   SHVCODE,SHVSTORE   REQUEST: STORE A VARIABLE
         L     R15,IRXEXCO@       ADDR OF IRXEXCOM ROUTINE
         CALL  (15),(IRXEXLIT,0,0,OURSHVBL),VL,MF=(E,EXCOPLST)
*
         TM    SHVRET,SHVBADN+SHVBADV+SHVBADF  CHECK ERROR BITS
         BZ    VAR_STORE_ERROR    IF ALL OK, CONTINUE
*        WE ALSO HAVE A PTR TO IT IN R3 SO WE COULD USE IT
VAR_STORE_ERROR EQU *
VAR_next        EQU *
         LA    R8,ARGTABLE_NEXT   BUMP TO NEXT ARGUMENT
         C     R8,L_HV
         BE    DONE_ARGS_PASSED
         C     R7,MAX_ARGS
         BH    MAX_OF_ARGS
         B     ARGS_LOOP
DONE_ARGS_PASSED EQU *
         C     R7,MIN_ARGS
         BL    NO_ENOUGH_ARGS
         B     FIN_PROCESS_ARGS
MAX_OF_ARGS    EQU *
*        WE KNOW THAT R8 IS NOT L_HV SO WE HAVE MORE ARGS THAN EXPECTED
         B     FIN_PROCESS_ARGS
*+*+
NO_ENOUGH_ARGS EQU *
*        WE HAVE PROCESSED LESS THAN THE MIN EXPECTED ARGS
         B     FIN_PROCESS_ARGS
FIN_PROCESS_ARGS EQU *
         L     R1,EFPL@           GET POINTER TO ORIGINAL PARM LIST
         USING EFPL,R1            SET ADDRESSABILITY
         L     R2,EFPLEVAL        GET -> TO EVALUATION BLOCK
         L     R2,0(,R2)          GET ACTUAL ADDRESS OF BLOCK
         USING EVALBLOCK,R2       SET ADDRESSABILITY
         L     R0,EVALBLOCK_EVSIZE
         C     R0,F20
         BL    NO_EVALBLOCK
         LA    R14,MSG
         MVC   EVALBLOCK_EVLEN,F4
         MVC   EVALBLOCK_EVDATA(4),0(R14)     EVALUATION BLOCK
NO_EVALBLOCK EQU *
         LA    R15,0
         B     GOBACK
         DROP  R2,R1
*
SA_STG_GM_FAIL EQU *
         LA    R15,16
         B     GOBACK_NOFM
NO_ARGS_PASSED EQU *
         LA    R15,8
         B     GOBACK
GOBACK   DS    0H
         LA    R2,LOCAL_WORKAREA_LENGTH  SIZE OF OUR LOCAL WORK AREA
         STORAGE RELEASE,LENGTH=(R2),ADDR=(R9)    RELEASE WORK AREA
*
         SLR   R15,R15            MAKE SURE RETURN CODE IS ZERO
GOBACK_NOFM EQU *
         PR                       RETURN TO CALLER
         DROP  R6                 DROP SHVBLOCK ADDRESSABILITY
*
         LTORG
*
* MISCELLANEOUS CONSTANTS
*
MIN_ARGS DC    F'1'               SET A MIN OF EXPECTED ARGS
MAX_ARGS DC    F'3'  SET A MAX OF EXPECTED ARGS
L_HV     DC    XL4'FFFFFFFF'      LIT TO SIGNAL NO MORE ARGS IN ARGTABL
F0       DC    F'0'
F4       DC    F'4'
F20      DC    F'20'
SPACES   DC    CL8' '             SPACES CONSTANT
IRXEXLIT DC    CL8'IRXEXCOM'      PROGRAM NAME CONSTANT
*
* ###
         TITLE 'RXVARS - LOCAL WORK AREA'
LOCAL_WORKAREA DSECT
DBLWRK   DS    0D
FULLWRK1 DS    F
FULLWRK2 DS    0F
HALFWRK1 DS    H
HALFWRK2 DS    0H
BYTEWRK1 DS    X
BYTEWRK2 DS    X
*
SAVEAREA DS    18F
*
EXCOPLST DS    4F                 PARM LIST AREA FOR IREXCOM CALL
MSG@     DC    F'0'               -> TO ERROR MSG TEXT
EFPL@    DC    F'0'               -> TO EFPL (SAVED AT FUNCTION ENTRY)
ENVB@    DC    F'0'               -> TO ENVB (SAVED AT ENTRY)      @ANZ
IRXEXCO@ DC    F'0'               -> IRXEXCOM ENTRY ADDRESS
RECBUF@  DC    F'0'               -> TO RECORD BUFFER AREA
RETURNTO DC    F'0'               R14 SAVE FOR OPEN/READ/WRIT/CLOS ETC
LVL1R14  DC    F'0'               R14 SAVE - LEVEL 1 SUBROUTINES
MSGLEN   DC    H'0'               LENGTH OF RETURN MESSAGE (MSG@)
RECBUFL  DC    H'0'               LENGTH OF RECORD BUFFER (RECBUF@)
MYJOBID  DS    CL8                JOB ID (1ST CHAR OVERLAID WITH "X")
MYJOBNM  DS    CL8                JOB nm (1ST CHAR OVERLAID WITH "X")
DDNAME   DS    CL8                SPACE PADDED DDNAME
*
MSGINIT  DS    CL1
MSG      DS    CL125
MSG_LEN  EQU   *-MSG
*
NEW_VAR_NAME DS CL252
NEW_VAR_NAME_LEN DS  H
         DS    0F
OURSHVBL DC  XL(SHVBLEN)'00'           OUR SHARED VARIABLE BLK STORAGE
*
LOCAL_WORKAREA_LENGTH EQU *-LOCAL_WORKAREA   TOTAL LENGTH OF AREA
*
         TITLE 'RXVARS - IRXEFPL Dsect'
         PRINT GEN
         IRXEFPL
         TITLE 'RXVARS - IRXEVALB Dsect'
         IRXEVALB
         TITLE 'RXVARS - IRXARGTB Dsect'
         IRXARGTB
         TITLE 'RXVARS - IRXSHVB Dsect'
         IRXSHVB
         TITLE 'RXVARS - IRXENVB Dsect'
         IRXENVB
         TITLE 'RXVARS - IRXEXTE Dsect'
         IRXEXTE
* not really needed but very cool JES
STCB     DSECT
         DS    XL188
STCBJSAB DS    A
         DS    XL4
         IAZJSAB DSECT=YES
*
* THE FOLLOWING ARE NEEDED BY THE JES CALL
         IHAASCB
*
         IHAASSB
*
         IHAPSA
*
         IKJTCB
*
         END
###END RXVARS
$$$BEG EXPLJMP
*PROCESS COMPAT(NOCASE,MACROCASE)                          Ver1
*        yregs
         sysstate archlvl=2
EXPLJMP  csect
EXPLJMP  amode 31
EXPLJMP  rmode 31
*
         yregs
*&Name Start            nope.... this does not resolve
*        J     S&SysNdx The Assembler knows where to go:
        J     BEGIN
PROLOG   LOCTR
         DC    C'SAMPLE01'
         DC    C'AsmDate && Time: &SysDatC &SYSTIME'
         DC    C'Ver 1.2.3'
         DC    C'All rights reserved'
         DC    C'on System &System_ID.' ... information
PROLOG_L equ *-PROLOG

CODEBG1  LOCTR
BEGIN    DS    0H
*S&SysNdx DS    0H        nope.... this does not resolve
         using data,12
         save  (14,12)       save z/os's regs
         larl  12,data       use this instead of lr and ahi
*        LR    R12,R15
*        AHI   R12,data-BEGIN

         getmain r,lv=worksize
         st    13,4(1)
         lr    13,1
         using (wareas,wareasend),13
*  ...
         xc    buffer,buffer
         larl  r1,prolog
         using prolog,r1
         mvc   BUFFER(PROLOG_L),prolog
         drop  r1
         xr    r1,r1
         xr    r2,r2
         trt   buffer,scantab2
         jas   r14,do_jmp
do_jmp   b     0(r2,r14)
BRTAB    j     NONE
         j     ALPHA
         j     digit
exrl_jmp jnop  *-*
NONE     ds 0h
         xr    r0,r0
digit    ds 0h
         xr    r0,r0
ALPHA    ds 0h
         xr    r0,r0
         LArl  R10,jxhEND      Establish BRANCH ADDRESS when cond met
         L     R4,jxhIDX       Establish INDEX (wk reg increased by
         L     R6,jxhINCR      1ST of EVEN/ODD - INCR VALUE  and comp
         L     R7,jxhCOMP   to 2ND of EVEN/ODD - COMP VALUE)
jxhLOOP  EQU   *
         bxh   R4,R6,0(R10)  * Add INCR to IDX, BRANCH if IDX > COMP
         j     jxhLOOP         LOOP until IDX goes HIGH
jxhEND   ds    0h
*  ...
         mvc   cmd_tbl,cmd_tbl_lit   really don't need this
         la    8,cmd_tbl_lit
         larl  9,do_PING
         st    9,4(8)
         la    8,16(8)
         larl  9,do_LINK
         st    9,4(8)
*
         LLILL 6,C'AB' is like:SR 1,1
*                              ICM 1,B'0011',=C'AB'
*
         lhi   6,23    load hw immediate fw into reg
         lhi   6,-23   load hw immediate fw into reg
*
         CLFI  6,X'107429B3'  CL 6,=X'107429B3
*
         iilf  6,23    insert immediate fw into reg
         iilf  7,8
         CIJL  6,-99,TooSmall
         CRJNE 6,7,NotSame
same     ds    0h
*        nop   *        can't use in relative addr
         jnop  *
NotSame  ds    0h
*        nop   *
         jnop  *
TooSmall ds    0h
         CR    6,7 Compare
         LOCRL 6,7 Load if c(R6)<c(R7)
         iilf  6,23    insert immediate fw into reg
         iilf  7,8
         iilf  4,8
         iilf  5,8
         CR    4,5 Compare
         LOCRE 6,7
*
         xc    socr_val,socr_val
         iilf  6,23    insert immediate fw into reg
         iilf  7,8
         CR    6,7 Compare
         STOCE 6,socr_val
         iilf  4,8
         iilf  5,8
         CR    4,5 Compare
         STOCE 6,socr_val
*
         iilf  7,2
         mvi   cn_nm,c' '
         mvc   cn_nm+1(l'cn_nm-1),cn_nm
         mvc   cn_nm(4),cmd_PING
* which is better?
         mvi   oplit1,c' '
         mvc   oplit,oplit1
         mvi   oplit,c' '
         mvc   oplit+1(l'oplit-1),oplit
top_of_lop ds 0h
         mvc   CN_NM,CN_LIT
         LA    8,cmd_tbl_lit
SRCH_4_CMD DS 0H
         CLC   CN_NM(4),0(8)
         JE    CN_GOT_CMD
         CLC   0(4,8),CMD_END    CMD_END LIT IS X0 AS IS END OF TBL
         JE    CN_NOT_CMD
         AHI   8,16
         J     SRCH_4_CMD
*
CN_GOT_CMD  DS 0H
         MVC   CMD_TBL_X,4(8)   SAVE THE BR ADDR OF CMD SUBRTN
         l     9,8(8)           get adr of literal
         l     10,12(8)         get lng of literal
         bctr  10,0             reduce 1 for exrl
         exrl  10,mvc_msg       mv from literal to fnd_it_msg len=r10
         l     15,cmd_tbl_x
         basr  14,15
         xr    15,15
         j     CN_TRY_SRCH_2
*
mvc_msg  mvc   fnd_it_msg(0),0(9)  make sure lng is forced to zero
*                                   because the ex/exrl or's the
*                                   reg contents with the inst lng
CN_NOT_CMD  DS 0H
         MVC   CMD_TBL_X,4(8)   SAVE THE BR ADDR OF CMD SUBRTN
         l     9,8(8)
         l     10,12(8)
         bctr  10,0
         exrl  10,mvc_msg
         l     15,cmd_tbl_x       this is zeros
*
*        basr  14,15               so this is a s0c1
*        here is another version of srch_4_cmd
CN_TRY_SRCH_2 ds 0h
         LArl  R9,CN_NOT_CMD2 Establish BRANCH ADDRESS when cond met
         la    R8,CMD_TBL_LIT
         iilf  R6,cmd_tbl_ent_lng     EVEN/ODD - INCR VALUE  and comp
         la    R7,CMD_TBL_lnt2lst_cmd(8)
*    bxh - br idx high - branches to add when the idx (incrmenting ptr)
*                        goes hig to the comp value (lst cmd addr)
cn_bxh_top2 ds 0h
         CLC   CN_NM(4),0(8)
         JE    CN_GOT_CMD2
         bxh   R8,R6,0(R9)  * Add INCR to IDX, BRANCH if IDX not lt
         j     cn_bxh_top2     LOOP until IDX goes HIGH
CN_GOT_CMD2 ds  0h
         MVC   CMD_TBL_X,4(8)   SAVE THE BR ADDR OF CMD SUBRTN
         l     9,8(8)           get adr of literal
         l     10,12(8)         get lng of literal
         bctr  10,0             reduce 1 for exrl
         exrl  10,mvc_msg       mv from literal to fnd_it_msg len=r10
         l     15,cmd_tbl_x
         basr  14,15
         xr    15,15
         j     CN_TRY_SRCH_3
*
CN_NOT_CMD2 ds  0h            here because we have looped thru tbl
*
         iilf  15,-1
         j     CN_TRY_SRCH_3
*        here is another version of srch_4_cmd
CN_TRY_SRCH_3 ds 0h
         LArl  R9,cn_bxh_top3
         xr    R6,R6
         iilf  R8,cmd_tbl_ent_lng     EVEN/ODD rmdr/quotient
         iilf  R7,CMD_TBL_ALLENT_LNG
         dr    r6,r8
         la    r8,CMD_TBL_LIT
*    bxh - br idx high - branches to add when the idx (incrmenting ptr)
*                        goes hig to the comp value (lst cmd addr)
cn_bxh_top3 ds 0h
         CLC   CN_NM(4),0(8)
         JE    CN_GOT_CMD3
         la    r8,CMD_TBL_ENT_LNG(r8)
         bctr  R7,R9           cnt in r7, b to r9 when ct>0
         j     CN_NOT_CMD3     out of loop - nf - jmpGH
CN_GOT_CMD3 ds  0h
         MVC   CMD_TBL_X,4(8)   SAVE THE BR ADDR OF CMD SUBRTN
         l     9,8(8)           get adr of literal
         l     10,12(8)         get lng of literal
         bctr  10,0             reduce 1 for exrl
         exrl  10,mvc_msg       mv from literal to fnd_it_msg len=r10
         l     15,cmd_tbl_x
         basr  14,15
         xr    15,15
         j     end_it
*
CN_NOT_CMD3 ds  0h            here because we have looped thru tbl
*
         iilf  15,-1
         j     end_it
*   bypass this stuff
try_LINK ds    0h
         la    8,cmd_tbl
         clc   0(4,8),cn_nm
         jne   try_PING
         l     9,4(8)
         larl  15,try_fin
         br    9
try_PING ds    0h
         la    8,8(8)
         clc   0(4,8),cn_nm
         jne   try_fin
         l     9,4(8)
         larl  15,try_fin
         br    9
*   more here
try_fin  ds    0h
         la    8,8(8)
         mvc   cn_nm(4),cmd_LINK
         jct   r7,top_of_lop
*
         mvi   cn_nm,c' '
         mvc   cn_nm+1(l'cn_nm-1),cn_nm
*
* at termination:
*
end_it   ds    0h
         crjl  15,15,doterm     compare reg and jmp
         cije  15,0,doterm      compare reg to imm and jmp
*        ltr   15,15
*        jz    doterm
err0     ds    0h
         la    15,8
*
doterm   ds    0h
         lr    1,13
         l     0,fsize
         l     13,4(13)
         freemain r,lv=(0),a=(1)
         return (14,12),,rc=0
*
do_PING  ds    0h
         mvc   oplit(l'fnd_PING_LIT),fnd_PING_LIT
         mvc   oplit+l'fnd_PING_LIT+1(l'cn_nm),cn_nm
         br    14
*
do_LINK  ds    0h
         mvc   oplit(l'fnd_LINK_LIT),fnd_LINK_LIT
         mvc   oplit+l'fnd_LINK_LIT+1(l'cn_nm),cn_nm
         br    14
*
*
do_CEMT  ds    0h
do_CEDA  ds    0h
do_LCNC  ds    0h
do_PLAY  ds    0h
do_JRND  ds    0h
do_CRND  ds    0h
         mvc   oplit(l'fnd_OTHR_LIT),fnd_OTHR_LIT
         br    14
*
data     ds    0f
fsize    dc    a(worksize)
*
CMD_TBL_LIT DS 0F
CMD_PING DC     CL4'PING',a(do_PING),a(fnd_PING_LIT),a(l'fnd_PING_LIT)
cmd_tbl_ent_lng equ *-CMD_PING
CMD_LINK DC     CL4'LINK',a(do_LINK),a(fnd_LINK_LIT),a(l'fnd_LINK_LIT)
CMD_CEMT DC     CL4'CEMT',a(do_CEMT),a(fnd_OTHR_LIT),a(l'fnd_OTHR_LIT)
CMD_CEDA DC     CL4'CEDA',a(do_CEDA),a(fnd_OTHR_LIT),a(l'fnd_OTHR_LIT)
CMD_LCNC DC     CL4'LCNC',a(do_LCNC),a(fnd_OTHR_LIT),a(l'fnd_OTHR_LIT)
CMD_PLAY DC     CL4'PLAY',a(do_PLAY),a(fnd_OTHR_LIT),a(l'fnd_OTHR_LIT)
CMD_JRND DC     CL4'JRND',a(do_JRND),a(fnd_OTHR_LIT),a(l'fnd_OTHR_LIT)
CMD_TBL_lnt2lst_cmd   EQU *-CMD_TBL_LIT
CMD_CRND DC     CL4'CRND',a(do_CRND),a(fnd_OTHR_LIT),a(l'fnd_OTHR_LIT)
CMD_TBL_ALLENT_LNG EQU *-CMD_TBL_LIT
CMD_END  DC     XL4'00000000',f'0',a(fnd_TBLX_LIT),a(l'fnd_TBLX_LIT)
CMD_TBL_LIT_LNG EQU *-CMD_TBL_LIT
*
tst_msg  dc    c'*** THIS IS A TEST MSG ***'
fnd_PING_LIT dc    c'FOUND PING'
fnd_LINK_LIT dc    c'FOUND LINK'
fnd_OTHR_LIT dc    c'FOUND OTHER'
fnd_TBLX_LIT dc    c'NOTHING FOUND'
*
CN_LIT   dc  cl16'PING0001'
*
         dc    0f     set alignment on fw
jxhIDX   DC    XL4'0000009E'   INDEX VALUE, to be INCREMENTED
jxhINCR  DC    XL4'00000002'   INCR VALUE for EVEN PAIR REG
jxhCOMP  DC    XL4'000000AA'   COMP VALUE for ODD  PAIR REG
*
SCANTAB2 DC    256X'00'
         ORG   SCANTAB2+C'0'      If numeric, set value in
         DC    10X'0c'              register 2 to 08
         ORG   SCANTAB2+C'.'      If alphabetic, set value in
         DC    x'04'               register 2 to 04
         ORG   SCANTAB2+C':'
         DC    X'08'
         ORG
         ltorg
wareas   dsect
save     ds    36f'0'
cn_nm    ds    cl16
CMD_TBL_X ds   f
socr_val  ds   f
fnd_it_msg ds    cl16
fnd_PING ds    cl16
fnd_LINK ds    cl16
fnd_OTHR ds    cl16
cmd_tbl  ds    xl(cmd_tbl_lit_lng)   Not really needed
*
oplit1   ds    xl1
oplit    ds    cl255
*
BUFFER   DS    CL80
wareasend ds   0h
worksize equ   *-save
         end   EXPLJMP
###END EXPLJMP
$$$BEG EXPLCVT
P0       DC    PL1'0'
P1       DC    PL1'1'
P99999   DC    PL3'99999'
ERRTRAN  DC    X'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
PJL      DC    CL2'.J'
XFF      DC    XL4'FFFFFFFF'
*
X2CX49   DS    6F
DWORD    DS    D
$DBLWD   DS    D
EBCDCFLD DS    D
HEXFIELD DS    F
HLDSTR   DS    CL8
***
B2C      EQU   *
         CVD   R15,DWORD
P2C      EQU   *
         UNPK  HLDSTR,DWORD+4(4)
         OI    HLDSTR+6,X'F0'
         BR    R9
***
* THIS IS THE ERROR ROUTINE TO FORMAT THE ERROR CODE RETURNED FROM THE
* SVC IF THERE IS AN ERROR ON ALLOCATION.
*
X2CX     EQU   *
FORMERR  EQU   *
         STM   R4,R9,X2CX49
         XR    R6,R6
         LA    R6,8
         ST    R15,HEXFIELD
         LA    R4,HEXFIELD
         LA    R5,EBCDCFLD
*
CONVERT  EQU   *
         SLR   R8,R8
         IC    R8,0(R4)
         SRDL  R8,4
         STC   R8,0(R5)
         LA    R5,1(R5)
         SLR   R8,R8
         SLDL  R8,4
         STC   R8,0(R5)
         LA    R5,1(R5)
         LA    R4,1(R4)
         BCT   R6,CONVERT
*
         TR    EBCDCFLD(8),ERRTRAN
         LM    R4,R9,X2CX49
         BR    R9
*
###END EXPLCVT
$$$BEG RXPOST
*-------------------------------------------------------------------
*
* REXXPOST  THX DB2_DINO
* ========
* REXX FUNCTION TO ISSUE A POST AGAINST AN ECB.
*
* USED LIKE THIS:
*
*    VAL = RXPOST(ECBADDR)
*
* NOTE THAT THE ECBADDR MUST BE IN BINARY - I.E.
*
*    ECBADDR = X2C(1E409A24)
*
* THE RETURNED VALUE IS ZERO.
*
*-------------------------------------------------------------------
         EJECT
         REGSMAC
REXXPOST CSECT
REXXPOST AMODE 31
REXXPOST RMODE ANY
         STM   R14,R12,12(R13)     STORE CALLERS REGS
         LAE   R12,R0              CLEAR BASE ACCESS REGISTER
         LR    R12,R15             SET BASE REGISTER TO ENTRY POINT
         USING REXXPOST,R12
         L     R10,=A(WORKALEN)
         STORAGE OBTAIN,LENGTH=(10),ADDR=(8),                          X
               BNDRY=PAGE,LOC=(BELOW,ANY)
         LM    R0,R1,20(R13)       RESTORE CALLERS ENV BLOCK
         ST    R13,4(R8)           SAVE BACKWARD SA PTR
         ST    R8,8(R13)           SAVE FORWARDS SA PTR
         LR    R13,R8              ESTABLISH NEW SA
         USING WORKAREA,R13
*
         ST    R0,AENV             SAVE ENVIRONMENT BLOCK
         ST    R1,AEFPL            SAVE EFPL ADDRESS
         LM    R2,R3,16(R1)        GET PARM LIST AND EVAL BLOCK ADDR
         ST    R2,APARMS           SAVE PARAMETER LIST ADDRESS
         ST    R3,AEVALBLK         ADDRESS OF EVBLK PTR
         L     R3,0(R3)            ADDRESS OF EVBLK
         ST    R3,EVALBLK
*
* PROCESS REXX PARMS
         XR    R5,R5               PARM COUNTER
DOPARMS  DS    0H
         LM    R3,R4,0(R2)         R3 = ADDR, R4 = LENGTH
         C     R3,=A(X'FFFFFFFF')
         BNE   MNGPARMS
         C     R4,=A(X'FFFFFFFF')
         BNE   MNGPARMS
         WTO   'REXXPOST - MISSING ECB ADDRESS PARAMETER'
         B     RC0
MNGPARMS DS    0H
         LTR   R5,R5               IS THIS PARM 1 (ECB ADDR)?
         BE    CHKLEN              NOPE - IGNORE IT THEN
         WTO   'REXXPOST - TOO MANY PARMS'
         B     RC0
CHKLEN   DS    0H
         C     R4,=F'4'            CORRECT LENGTH?
         BE    DOPOST              YUP - DO THE POST
         WTO   'REXXPOST - PARM LENGTH IS WRONG'
         B     RC0
DOPOST   DS    0H
         L     R3,0(R3)            GET ECB ADDRESS
         POST  (R3)
*
RC0      DS    0H
         XR    R4,R4
         L     R5,EVALBLK
         ST    R4,8(R5)            SAVE ACTUAL RETURNED DATA LENGTH
THEEND   DS    0H
         L     R4,=A(WORKALEN)
         LR    R5,R13
         L     R13,4(R13)          RESTORE CALLER'S R13
         STORAGE RELEASE,LENGTH=(4),ADDR=(5)
         XR    R15,R15             SET RC AND...
         LR    R0,R15              ...REASON
         L     R14,12(R13)         RESTORE R14
         LM    R1,R12,24(R13)      RESTORE R1-R12 (RETAIN R15 AND R0)
         BR    R14                 BYEEEEE....
*
* CONSTANTS
*
         LTORG
WA_L     DC    A(WORKALEN)         LENGTH OF OUR WORKAREA
*
* OUR WORK AREA
*
WORKAREA DSECT
SAVEAREA DS    18F                 STANDARD SAVEAREA
*
AENV     DS    F                   ADDRESS OF THE ENVIRONMENT BLOCK
AEFPL    DS    F                   ADDRESS OF EFPL
APARMS   DS    F                   ADDRESS OF PARAMETER LIST
AEVALBLK DS    F                   ADDRESS OF EVAL BLOCK PTR
EVALBLK  DS    F                   ADDRESS OF EVALUATION BLOCK
WORKALEN EQU   *-SAVEAREA
         END REXXPOST
###END RXPOST
$$$BEG RXPAUSE
*----------------------------------------------------------------------
*
* PAUSE THX TO DB2_DINO
* =====
* REXX CALLED MODULE TO SUSPEND A PROCESS FOR A PERIOD OF TIME. WE'RE
* USING THE STIMER BINTVL, SO MINIMUM RESOLUTION IS 10MS. CALLED LIKE
* THIS:
*
*     X = PAUSE(N)
*
* WHERE THE DELAY IS N X 10MS
*
* ALWAYS RETURNS 0.
*
*----------------------------------------------------------------------
         EJECT
         REGSMAC
PAUSE    CSECT
PAUSE    AMODE 31
PAUSE    RMODE 31
         STM   R14,R12,12(R13)  SAVE CALLERS REGS
         LR    R11,R15          ESTABLISH BASE ADDRESSABILITY
         USING PAUSE,R11
         L     R0,WA_L          LENGTH OF OUR WORKAREA
         STORAGE OBTAIN,LENGTH=(0),BNDRY=PAGE,LOC=ANY
         LR    R14,R1
         LM    R0,R1,20(R13)    RESTORE CALLERS R0 AND R1
         ST    R13,4(,R14)
         ST    R14,8(,R13)
         LR    R13,R14
         USING WA,R13
*
* DONE LINKAGE
*
GETPARM  DS    0H
         ST    R0,AENV          SAVE REXX ENVIRONMENT BLOCK POINTER
         ST    R1,AEFPL         SAVE EFPL ADDRESS
         LM    R2,R3,16(R1)     GET PARM LIST AND EVAL BLOCK
         ST    R2,APARMS
         ST    R3,AEVALBLK
         XR    R5,R5            ZERO PARM COUNTER
DOPARMS  DS    0H
         LM    R3,R4,0(R2)      R3 = ADDR, R4 = LENGTH
         C     R3,=A(X'FFFFFFFF')
         BNE   CALCMOVE         NOT END OF PARMS
         C     R4,=A(X'FFFFFFFF')
         BE    NOPARMS          OOPS - NO PARMS - SET 1
CALCMOVE DS    0H
         LTR   R5,R5            PARM 1?
         BNE   PARMERR          NOPE - TOO MANY PARMS
         XR    R7,R7            ZERO TOTAL
         LA    R0,1             SET DIGIT MULTIPLIER
         BCTR  R3,0             DROP THE PTR BY 1
DECLOOP  DS    0H
         XR    R9,R9            GET NEXT CHAR OF INPUT
         IC    R9,0(R4,R3)
         S     R9,=A(X'000000F0') TURN IT INTO A DIGIT
         MR    R8,R0            APPLY DIGIT MULTIPLIER
         AR    R7,R9            AND ADD IT TO THE TOTAL
         MHI   R0,10            MULTIPLY THE MULTIPLIER BY 10
         BCT   R4,DECLOOP       DO ALL DIGITS
         LTR   R7,R7            PARM VALUE = 0?
         BNE   SAVEPARM         NOPE
NOPARMS  DS    0H
         LA    R7,1             SET TO 1 (=10MS)
SAVEPARM DS    0H
         ST    R7,DELAY         AND SAVE
         B     DOWAIT
PARMERR  DS    0H
         WTO   'PARM ERROR'
         LA    R2,8
         B     SETRC
*
DOWAIT   DS    0H
         STIMER WAIT,BINTVL=DELAY
         LA    R2,0
*
SETRC    DS    0H
         L     R1,AEVALBLK      GET POINTER TO EVALBLK
         L     R1,0(R1)         GET ADDR EVALBLK
         LA    R3,16(R1)        GET ADDR OF OUTPUT BUFFER
         A     R2,=A(X'000000F0') - TURN RC (0 OR 8) INTO CHAR
         STCM  R2,B'0001',0(R3) AND SAVE IT
         LA    R4,1
         ST    R4,8(R1)         AND SAVE THE LENGTH
THE_END  DS    0H
         L     R4,WA_L          GET LENGTH OF WORK AREA
         LR    R5,R13           SAVE WORK AREA ADDRESS
         L     R13,4(R13)       RESTORE CALLERS SAVE AREA
         STORAGE RELEASE,ADDR=(5),LENGTH=(4)
         LM    R14,R12,12(R13)  RESTORE THE REST OF CALLER
         XR    R15,R15          RC = 0
         XR    R0,R0            RSN = 0
         BR    R14              BYEEE
*
         LTORG
WA_L     DC    A(WRKLEN)
*
WA       DSECT
SAVEAREA DS    18F              STANDARD SAVE AREA
*
AENV     DS    F                ADDRESS OF ENV
AEFPL    DS    F                ADDRESS OF EFPL
APARMS   DS    F                ADDRESS OF CALLERS PARMS
AEVALBLK DS    F                PTR TO ADDRESS OF EVALUATION BLOCK
*
DELAY    DS    F                PAUSE FOR DELAY X 10MS
*
WRKLEN   EQU   *-SAVEAREA
         END   PAUSE
###END RXPAUSE
$$$BEG ENUMRXVR
***********************************************************************
*
*  This routine returns the names of all current REXX variables and
*  queues them on the REXX data stack.  The names are selected based
*  on a prefix given in the parameter field.
*
*  Particularly useful if a stem (varname.) is given as the argument.
*
*  Invocation:  CALL 'wherever.load(ENUMRXVR)' 'variable-prefix'
*
***********************************************************************
         PRINT NOGEN
ENUMRXVR CSECT
ENUMRXVR AMODE 31
ENUMRXVR RMODE ANY
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         SAVE  (14,12),,ENUMRXVR_&SYSDATE._&SYSTIME
         LR    R12,R15
         USING ENUMRXVR,R12
         LR    R2,R1               Save parameter address
         LA    R0,SIZDATD
         GETMAIN R,LV=(0)
         ST    R1,8(,R13)
         ST    R13,4(,R1)
         LR    R13,R1
         USING DATD,R13
         MVI   FLAGS,0             Random initializations
         L     R4,0(,R2)           Get address of parm string
         LH    R3,0(,R4)           R3 = length of parm
         LA    R4,2(,R4)           R4 = address of parm
         LOAD  EP=IRXSTK                Get address of IRXSTK routine
         ST    R0,@IRXSTK               Save it
         LOAD  EP=IRXEXCOM              Get address of IRXEXCOM routine
         ST    R0,@IRXEXCO              Save it
*
***********************************************************************
*                                                                     *
* Invoke the IRXEXCOM routine to retrieve all variable names.         *
*                                                                     *
* Reference: TSO/E Version 2 REXX Reference, pp. 240-246              *
*                                                                     *
***********************************************************************
*
* Build the SHVBLOCK
*
* To store the argument value, we try using ARGWA, a 512-byte area
* that is already part of our workarea, to avoid unnecessary GETMAINs.
*
* If that doesn't turn out to be big enough, we'll have to GETMAIN,
* but it's best to avoid that.
*
CONTINUE DS    0H
         XC    VARNAME(L'VARNAME),VARNAME
         XC    SHVBLOCK(SHVBLEN),SHVBLOCK
         MVI   SHVCODE,SHVNEXTV    Fetch "next" variable
         LA    R1,L'VARNAME
         ST    R1,SHVUSER          Length of name buffer
         LA    R1,VARNAME
         ST    R1,SHVNAMA          Address of name buffer
         LA    R1,1
         ST    R1,SHVBUFL          Length of dummy value buffer
         LA    R1,DUMBUF
         ST    R1,SHVVALA          Address of dummy value buffer
*                 SHVNAML will contain the length of the name returned
         LA    R14,=CL8'IRXEXCOM'  IRXEXCOM parm 1
         XR    R15,R15             IRXEXCOM parm 2
         LR    R0,R15              Parm 3 must be same as Parm 2
         LA    R1,SHVBLOCK         IRXEXCOM parm 4
         STM   R14,R1,IRPARMS
         OI    IRPARM4,X'80'
         XR    R0,R0               Don't specify an environment block
         L     R15,@IRXEXCO        Get address of IRXEXCOM
         LA    R1,IRPARMS          Point to parameter list
         BALR  R14,R15             Call REXX arg access routine
         LTR   R15,R15             Check RC
         BM    BADEXCOM
         TM    SHVRET,SHVLVAR      If no more variables
         BO    ENDIT               then finished
*
* Compare variable prefix here...
*
         LTR   R15,R3
         BZ    QUEUEIT             If no prefix given, accept all
         BCTR  R15,0               Else reduce length for execute
         EX    R15,CLCNAME         If prefix doesn't match
         BNE   CONTINUE            then continue
QUEUEIT  DS    0H
*
* Queue line onto REXX data stack
*
         MVC   IRFUNCT,=CL8'QUEUE'
         LA    R1,VARNAME
         ST    R1,IRSTRADR
         L     R1,SHVNAML
         ST    R1,IRSTRLEN
         XR    R1,R1
         ST    R1,IRRETCD
         LA    R14,IRFUNCT
         LA    R15,IRSTRADR
         LA    R0,IRSTRLEN
         LA    R1,IRRETCD
         STM   R14,R1,IRPARMS
         OI    IRPARM4,X'80'
         XR    R0,R0               Don't specify an environment block
         LA    R1,IRPARMS          Point to parameter list
         L     R15,@IRXSTK         Get address of IRXSTK
         BALR  R14,R15             Call REXX stack access routi ne
         LTR   R15,R15             Check rc
         BNZ   BADSTK
STACKOK  DS    0H                  R15 = 0
         B     CONTINUE
         SPACE 1
ENDIT    DS    0H
         LR    R1,R13
         L     R13,4(,R13)
         ST    R15,16(,R13)        Store return code in save area
         LA    R0,SIZDATD
         FREEMAIN R,LV=(0),A=(1)
         LM    R14,R12,12(R13)
         BR    R14
         SPACE 1
ERROR    DS    0H
         L     R15,=F'-1'          Load error code
         B     ENDIT
         SPACE 1
BADEXCOM DS    0H
         LA    R1,1111             U1111 for error in IRXEXCOM
         ABEND (1)
         SPACE 1
BADSTK   DS    0H
         LR    R1,R15              Make abend code the return code
         ABEND (1)
         SPACE 1
         EJECT
CLCNAME  CLC   0(*-*,R4),VARNAME   Executed: compare variable prefix
         EJECT
DATD     DSECT
SAVEAREA DS    18F
@IRXSTK  DS    A                   Address of REXX stack routine
@IRXEXCO DS    A                   Address of REXX access routine
FLAGS    DC    X'00'               Flags
*        EQU   B'10000000'          Reserved
*        EQU   B'01000000'          Reserved
*        EQU   B'00100000'          Reserved
*        EQU   B'00010000'          Reserved
*        EQU   B'00001000'          Reserved
*        EQU   B'00000100'          Reserved
*        EQU   B'00000010'          Reserved
*        EQU   B'00000001'          Reserved
*
VARNAME  DS    CL256               Area where variable name is returned
DUMBUF   DS    CL1                 We don't care about the value
*
IRPARMS  DS    0A                  Parameter list for IRX routines
IRPARM1  DS    A                   Address of parameter 1
IRPARM2  DS    A                   Address of parameter 2
IRPARM3  DS    A                   Address of parameter 3
IRPARM4  DS    A                   Address of parameter 4
*                                  Parameters used by IRXSTK
IRFUNCT  DS    CL8                 Parameter 1: function to perform
IRSTRADR DS    CL8                 Parameter 2: address of string
IRSTRLEN DS    CL8                 Parameter 3: length of string
IRRETCD  DS    CL8                 Parameter 4: return code
*                                  Parameters used by IRXEXCOM
*
***********************************************************************
*                                                                     *
* Copied from 'SYS1.MACLIB(IRXSHVB)'.                                 *
*                                                                     *
***********************************************************************
*
SHVBLOCK DS    0D                     SHARED VARIABLE REQUEST BLOCK
SHVNEXT  DS  A                        Chain pointer to next SHVBLOCK
SHVUSER  DS  F                        Used during "FETCH NEXT"
*                                      Contains length of buffer
*                                      pointed to by SHVNAMA
SHVCODES DS  0F
SHVCODE  DS  CL1                      Function code - indicates type
*                                      of variable access request
SHVRET   DS  XL1                      Return codes
         DS  H'0'                     Reserved (should be 0)
SHVBUFL  DS  F                        Length of fetch value buffer
SHVNAMA  DS  A                        Address of variable name
SHVNAML  DS  F                        Length of variable name
SHVVALA  DS  A                        Address of value buffer
SHVVALL  DS  F                        Length of value buffer
*                                      (Set on fetch)
SHVBLEN  EQU *-SHVBLOCK               Length of SHVBLOCK
         SPACE 1
**********************************************************************/
*   SHARED VARIABLE REQUEST BLOCK - function codes                   */
**********************************************************************/
         SPACE 1
SHVFETCH EQU   C'F'            Copy value of shared variable
SHVSTORE EQU   C'S'            Set variable from given value
SHVDROPV EQU   C'D'            Drop variable
SHVSYFET EQU   C'f'            Symbolic name retrieve
SHVSYSET EQU   C's'            Symbolic name set
SHVSYDRO EQU   C'd'            Symbolic name drop
SHVNEXTV EQU   C'N'            Fetch "next" variable
SHVPRIV  EQU   C'P'            Fetch private information
         SPACE 1
**********************************************************************/
*        SHARED VARIABLE REQUEST BLOCK - return codes (SHVRET)       */
**********************************************************************/
        SPACE 1
SHVCLEAN EQU   X'00'           Execution was OK
SHVNEWV  EQU   X'01'           Variable did not exist
SHVLVAR  EQU   X'02'           Last variable transferred ("N")
SHVTRUNC EQU   X'04'           Truncation occurred for "Fetch"
SHVBADN  EQU   X'08'           Invalid variable name
SHVBADV  EQU   X'10'           Invalid value specified
SHVBADF  EQU   X'80'           Invalid function code (SHVCODE)
         SPACE 1
**********************************************************************/
*        R15 return codes                                            */
**********************************************************************/
         SPACE 1
SHVRCOK  EQU    0              Entire Plist chain processed
SHVRCINV EQU   -1              Invalid entry conditions
SHVRCIST EQU   -2              Insufficient storage available
         SPACE 1
SIZDATD  EQU   *-DATD
         END
###END ENUMRXVR
$$$BEG EXBXPDYN
*PROCESS COMPAT(NOCASE,MACROCASE)
         SYSSTATE ARCHLVL=2
EXBXPDYN AMODE 31
EXBXPDYN RMODE ANY
EXBXPDYN CSECT
         YREGS
         SAVE (14,12)    SAVE CALLER REGS
         LR   12,15      R12 = BASE
         USING GETDSN,12
         LA   1,RSA      R1 -> NEW REG SAVE AREA
         ST   13,4(,1)    CHAIN BACK
         LR   13,1       R13 -> RSA
*
         LTR  15,1
         BZ   NOPARM
*
         ST   R15,PARM_ADR     ST PARM LENGTH
*
*
         LA   15,INFODDL
         MVC  INFODD(L'INFODDL),INFODDL
         LA   15,INRTDSN
         LOAD EP=BPXWDYN
         LR   15,0       R15 -> BPXWDYN
         SR   0,0        R0 = 0
         CALL (15),(INFODD,INRTDSN),VL
         DELETE EP=BPXWDYN
*
NOPARM   DS   0H
         L    13,4(,13)   R13 -> OLD REG SAVE AREA
         RETURN (14,12),RC=(15)
*
PARM_ADR DS    F
*
* PARM AREA IS ALL LOCATED IN THE CALLERS
*  ON ENTRY, R1 CONTAINS A PTR TO THIS EXTERNAL PARM LIST
*  USE THAT ADDR TO POINT AT THE FOLLOWING PARM DSECT
*  CALLER HAS 16 BYTE AREA SYNCRONIZED ON FW BOUNDRY
*  FIRST PARM IS 8 BYTE VALUE - NAME OF THIS PGM
*  SECOND PARM POINTER TO THE BXPWDYN KEY REQUEST
*  THIRD  PARM POINTER TO THE BXPWDYN RESPONSE AREA
*
EYEC    DC    CL8'EXBXPDYN'
        DC    0D
RSA     DS    18F
*
        LTORG
*
EXBXPDYN_PARMS DSECT
PARM_EYEC_ADR DS CL8
PARM_DDN_ADR  DS F
PARM_DSN_ADR  DS F
*
* BP
*INFODDL DC    C'INFO DD(MYDSN)'
*INRTDSN DC    AL2(45),C'INRTDSN',XL38'00'
*
BXPWDYN_PARMS DSECT
INFODD  DC    XL80'00'
INFODDL DC    C'INFO DD(MYDSN)'
        DC    0D
INRTDSN DC    AL2(45),C'INRTDSN',XL38'00'
        END
###END EXBXPDYN
$$$BEG EXPLVSAM
EXPLVSAM TITLE 'EXAMPLE READ OF VSAM KSDS'
*********************************************************************
*                                                                   *
*        THIS PROGRAM WILL ACCEPT THE A SINGLE PARMATER IN THE FORM *
*        LLL,XX,KKK...                                              *
* WHERE  LLL IS A 3 DIGIT VSAM KEYLENGTH                            *
*        XX IS EQ OR GE  AS KEY COMPARISON DIRECTIVE                *
*        KKK... IS THE RECORD KEY 1 - 117                           *
*********************************************************************
INDSCT   DSECT
IND_KEY_L  DS    CL3
IND_COMMA1 DS   CL1
IND_KEY_COMP     CL2
IND_COMMA1 DS   CL1
IND_KEY          CL118
*
VSAM_REC DSECT
EZAAREA  DS    0C
*
TESTDCBD DCBD DSORG=PS,DEVD=DA
*
*
* DYNAMIC STORAGE THAT MUST RESIDE BELOW 16MB LINE DUE TO DCB & EXIT
* LIST RESTRICTIONS.  GET SEPARATE STORAGE FOR THIS.
DCB_WORKAREA DSECT
SYSPR_DCB DS   XL(SYSPREND) DCB LNG QS  ACTUAL QSAM DCB
* EACH ENTRY IN DCB EXIT LIST IS FOUR BYTES.
SY_EXL      DS    X         LAST ENTRY IN EXIT LIST AND FOR DCB OPENX
SY_EXLOPEN  DS    AL3       ADDRESS OF 24-BIT DCB OPEN EXIT ROUTINE
SYPENLIST DS    XL(LSPROPPL) LEN OPEN PARAMETER LIST
*
*
CLOLIST  DS    XL(LSPRCLPL) LEN CLOS PARAMETER LIST
* THE FOLLOWING IS EXECUTABLE CODE TO BRANCH ABOVE THE 16MB LINE.
         DS    0H
OPEN24   DS    XL(LENOPEN24)   DCB OPEN EXIT BELOW 16MB LINE
ADOPEN31 DS    A         ADDRESS OF DCB OPEN EXIT ABOVE THE LINE
LENAREA  EQU   *-DCB_WORKAREA
*
*********************************************************************
** REGISTER USAGE
**  R0  WORK FOR MANY INST
**  R1 PASS PARM ADDR AND WORK AND TRT
**  R2 WORK AND USED BY TRT
**  R3 BASE1
**  R4 R5 WORK AND USED FOR EVEN ODD
**  R6 R7 WORK AND USED FOR EVEN ODD
**  R8 WORK
**  R9 WORK AND USED FOR SR LINKAGE
**  R10 DCBPTR AND WORK
**  R11 USED FOR AUTO STORAGE
**  R12 BASE2
**  R13 SAVEAREA
**  R14 WORK
**  R15 PASS DATA IN REG TO SR AND WORK
         REGSMAC
**
MYDYN_S  INITSTG USEREG=11
*
         COPY PASSPAR1
*
PTR_PARM_PLUS1 DS F
PARM_PLUS1L    DS H
*
EZAFDBK  DS    F
EZAKEYLEN DS   H
EZAKEY   DS    XL255
         ORG   EZAKEY
EZAAPPLID DS   CL8
EZATYPE  DS    CL1
EZARESV  DS    XL3
EZATRAN  DS    XL4
         ORG   EZAKEY+255
*
P_IND_KEY_LEN DS PL3
*
PACKDATA DS    D                  PACKED DECIMAL AREA FOR LENGTHS
$DBLWD   DS    D
$TIMEB   DS    F
$DATEB   DS    F
$DATE    DS    CL8
$TIME    DS    CL8
MSGAREA1   DS    CL1
MSGAREA    DS    CL80
PARMS_AREA DS 0F
P_SYSID    DS F
P_CMD      DS F
*
COUNT    DS    CL6    CHAR AREA FOR FDBK
DISFDBK  DS    F      FDBK AREA FOR VSAM SHOWCB FEEDBACK FW
$SAVE    DS    18F
VSAM_SA    DS 18D
MYACB      DS 0F
         ORG   MYACB+LEN_MYACB
MYRPL      DS 0F
         ORG   MYRPL+LEN_MYACB
REST_MYDYN DS  0F
         ORG   MYDYN_S+4096-256
STOPARM  DS    256XL1
*
EXPLVSAM CSECT
EXPLVSAM RMODE ANY
EXPLVSAM AMODE 31
LBLPGM   INITMAC 3,EQU=R,ID=EXPLVSAM
         ST    R1,PARMAP
         XR    R1,R1
         ST    R13,SAVRD
         STORAGE OBTAIN,LENGTH=LENAREA,LOC=BELOW  GET DCB & ETC.
         ST    R1,PTR_DCB_WORKAREA
         LR    R10,R1
         USING DCB_WORKAREA,R10
*
         MVC   SYSPR_DCB,MODSPRDCB CREATE DCB BELOW THE LINE
         MVC   SYPENLIST,MODSPRPEN  BUILD OPEN PARAMETER LIST
*   OPEN USES NORMAL RSA CONVENTIONS
         OPEN  (SYSPR_DCB),MF=(E,SYPENLIST) LIST IS BELOW THE LINE
*        OPEN  (SYSPRINT,(OUTPUT))
         LA    R14,SYSPR_DCB
         USING IHADCB,R14
         MVC   H_SYSPRINT_LRECL,DCBLRECL
         DROP  R14
         DROP  R10
*
         SPACE
         L     R2,PARMAP
         LTR   R2,R2
         BZ    BADPARM
         XR    R3,R3
         LH    R3,0(R2)
         LTR   R3,R3
         BZ    BADPARM
         CH    R3,H125
         BH    BADPARM
         CH    R3,H8
         BL    BADPARM
         LA    R4,2(R2)
         USING INDSCT,R4
         LA    R6,IND_KEY_LEN
         LA    R7,2               L OF IND_KEY (3) - 1 FOR EXECUTE
         EX    R7,PACKINST         PACK INTO AREA
         CVB   R7,PACKDATA         CONVERT TO BINARY
         STH   R7,EZAKEYLEN
         LTR   R7,R7
         BZ    BADPARM
         SH    R3,H8
         BNP   BADPARM
         C     R3,R7
         BL    BADPARM
         CHI   R7,H'117'   MAX KEY_L FROM INITIAL PARM
         BH    BADPARM
         BCTR  R7,0
         EX    R7,MVC_VSAMKEY
***
         XR    R0,R0
         XR    R1,R1
         TIME
         ST    R0,$TIMEB
         ST    R0,$DBLWD+4
         OI    $DBLWD+7,X'0F'
         UNPK  $TIME,$DBLWD
         XC    $DBLWD,$DBLWD
         ST    R1,$DATEB
         ST    R1,$DBLWD+4
         OI    $DBLWD+7,X'0F'
         UNPK  $DATE,$DBLWD
         MVC   MSGAREA,BEGINMSG
         MVC   MSGAREA+58(5),$DATE+3
         MVC   MSGAREA+65(2),$TIME+1
         MVI   MSGAREA+67,C':'
         MVC   MSGAREA+68(2),$TIME+3
         MVI   MSGAREA+70,C':'
         MVC   MSGAREA+71(2),$TIME+5
         MVI   MSGAREA+73,C'.'
***
         L     R6,F16
         LR    R7,R4
CVRTLOOP EQU   *
         CLI   0(R7),X'40'
         BNE   NOTBLNK
         MVI   0(R7),X'00'
NOTBLNK  EQU   *
         LA    R7,1(R7)
         BCT   R6,CVRTLOOP
***
         MVC   MSGAREA+20(8),INDKEY
         MVC   MSGAREA+30(8),INID
         LA    R8,MSGAREA
         BAL   R9,PRINTIT
***
         XR    R15,R15              * OPEN THE EZCONFG DS
         OPEN  EXPLACB
         LTR   R15,R15
         BNZ   ERROPN
         LA    R5,DISAREA           * SET UP ADDRESSABILITY
         USING MSGPNDDS,R5           * TO EZCONFG
         MVI   DISARG,X'01'
         MVC   DISARG+1(16),INDEST
         XR    R15,R15
         POINT RPL=EXPLRPLA
         LTR   R15,R15
         BNZ   NOTFND
TOPOFLOP EQU   *
         XR    R15,R15
         GET   RPL=EXPLRPLA
         LTR   R15,R15
         BNZ   DONEGET
         CLC   MPKDEST(16),INDEST
         BNE   DONEGET
         AP    INCNT,P1
         CP    INCNT,P1
         BH    PAST1ST
         LA    R8,MSGPEND
         BAL   R9,PRINTIT
*
PAST1ST  EQU   *
         MVC   MSGPND+9(8),MPDEST
         MVC   MSGPND+22(8),MPSNDR
         MVC   MSGPND+36(4),MPSEQ#
         LA    R8,MSGPND
         BAL   R9,PRINTIT
         MVC   MSGPND,SPACES
         B     TOPOFLOP
DONEGET  EQU   *
         CP    INCNT,P1
         BNL   MSGDONE
NOTFND   EQU   *
         LA    R8,NOMSGMSG
         BAL   R9,PRINTIT
         B     MSGDONE
ERROPN   EQU   *
         MVC   MSGAREA,OPNMSG * MOVE THE MESSAGE TO PRINT
DISPJ500 EQU   *
         LA    R8,MSGAREA
         BAL   R9,PRINTIT
         BAL   R9,VSAMERR
MSGDONE  EQU   *
BADPARM  EQU   *
         CLOSE (EXPLACB) * CLOSE ALL THE FILES
         B     DOCLOSE
*
*
NOSTG    EQU   *
EXITRC8  EQU   *
         XR    R15,R15
         LA    R15,8
         B     BYL15
*
*
OPEN31   EQU   *         ENTRY POINT OF DCB OPEN EXIT ABOVE THE LINE
         BSM   0,R14     SWITCH TO 24-BIT MODE AND RETURN TO OPEN
*
DOCLOSE  EQU   *
         MVC   MSGAREA(L'ENDMSG),ENDMSG
         BAS   R9,WRTMSG
         L     R9,PTR_DCB_WORKAREA
         USING DCB_WORKAREA,R9
         CLOSE (SYSPR_DCB),MF=(E,CLOLIST)
         IC    R15,XC
BYL15    EQU   *
         RTNMAC  RC=(15)
NORTNCD  EQU   *
         RTNMAC
*
*
INITRTN  EQU   *
* PLACE ANY INITIALIZATION PROCESSING HERE
         MVC   WRTSTR_LLNG,H_SYSPRINT_LRECL
         MVI   MSGAREA1,X'40'
         MVC   MSGAREA,MSGAREA1
         MVC   SAV_MSGAREA,MSGAREA
         MVI   XC,X'00'
         XC    EZAFDBK,EZAFDBK
         XC    EZAKEY,EZAKEY
         XC    EZATYPE,EZATYPE
***
         BR    R9
*
***
VSAMERR  EQU   *
         SHOWCB AREA=DISFDBK,LENGTH=4,RPL=(R2),FIELDS=(FDBK)
         L     R2,DISFDBK
         CVD   R2,$DBLWD
         OI    $DBLWD+7,X'0F'
         UNPK  COUNT,$DBLWD+5(3)
         MVC   VSAMSG+25(6),COUNT
         LA    R8,SHOWMSG
         BAL   R9,PRINTIT
         LA    R8,VSAMSG
         BAL   R9,PRINTIT
         BR    R9
*
MVCPARM  MVC   MSGAREA+19(0),0(R1)
MVC2MSG  MVC   MSGAREA(0),0(R9)
***
PRINTIT  EQU   *
         MVC   MSGAREA,0(R8)
WRTMSG   EQU   *
         STM   R10,R1,WRTMSG_SAVR10_1
         L     R10,PTR_DCB_WORKAREA
         USING DCB_WORKAREA,R10
         LA    R1,SYSPR_DCB
         PUT   (1),MSGAREA
         DROP  R10
         MVC   MSGAREA,MSGAREA1
         LM    R10,R1,WRTMSG_SAVR10_1
         BR    R9
*
         EJECT
$MODID   DC    CL18'&SYSDATE.-&SYSTIME'
PACKINST PACK  PACKDATA,0(0,6)    CONVERT TO PACKED FORMAT
MVC_VSAM_KEY MVC VSAM_KEY,IND_KEY   MOVE THE VSAM KEY FROM PARM
*                   0....5....1....5....2....5....3....5....4....5....5
VSAMSG   DC    CL80'### VSAM ERROR FEEDBACK =      . ACTION WAS       '
BEGINMSG DC    CL80'DISOSS MSG PEND FOR                     BEING PROCEX
               SSED.'
MSGPND   DC    CL80'MSG DEST=         FRM=         SEQ#='
MSGPEND  DC    CL80'SEARCH IS POSITIVE. PENDING MESSAGES ARE LISTED BELX
               OW.'
NOMSGMSG DC    CL80'SEARCH IS NEGITIVE. NO MESSAGES ARE PENDING.'
*
OPNMSG   DC    CL80'*** ERROR OPENING EZCONFG DATASET. NOTHING DONE.'
SHOWMSG  DC    CL80'*** ERROR DURING SHOWCB. RESULTS ARE UNKNOWN.'
*
SPACE8   DC    CL8' '
         ORG   SPACE8+5
SPACE3   DC    CL3' '
F0       DC    F'0'
         ORG   F0-2
H0       DS    H
F4       DC    F'4'
         ORG   F4+2
H4       DS    H
F8       DC    F'5'
         ORG   F8+2
H8       DS    H
F16      DC    F'16'
         ORG   F16+2
H16      DS    H
F125     DC    F'125'
         ORG   F125+2
H125     DS    H
P1       DC    PL1'1'
*
EXPLACB  ACB   AM=VSAM,DDNAME=EZCONFG,MACRF=(KEY,DIR,NRS,IN),          X
               MF=(L,(3),LEN_MYACB)
*
EXPLRPLA RPL   ACB=EXPLACB,AM=VSAM,AREA=DISAREA,AREALEN=170,           X
               ARG=DISARG,RECLEN=170,KEYLEN=16,                        X
               OPTCD=(KEY,DIR,NUP,MVE,GEN),                            X
               MF=(L,(3),LEN_MYRPL)
NOPRMSG  DC    C'NO PARM PROVIDED OR ZERO LENGTH'
PRMSG    DC    C'PARM PROVIDED>'
ENDMSG   DC    C'PROCESSING FINISHED NORMALLY'
L_ENDMSG EQU   *-ENDMSG
ERRTRAN  DC    X'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
***
INV_ENDMSG DS  CL(L'ENDMSG)
***
L_EXPLPSPM DC A(*-EXPLPSPM)
MODSPRPEN OPEN (,OUTPUT),MF=L,MODE=31 MODEL OPEN PARAMETER LIST
LSPROPPL EQU   *-MODSPRPEN
*
MODSPRCLO CLOSE (),MF=L,MODE=31    MODEL OPEN PARAMETER LIST
LSPRCLPL EQU   *-MODSPRCLO
*
* THE FOLLOWING IS THE MODEL FOR THE DCB OPEN EXIT ROUTINE ENTRY POINT
* WE COPY THIS CODE TO THE WORK AREA, WHICH IS BELOW THE LINE.  THE
* BSM SETS THE CURRENT ADDRESSING MODE (24) IN BIT 0 OF R14 WITHOUT
* CHANGING ANYTHING ELSE IN R14.  IT ALSO SWITCHES TO 31-BIT DUE TO
* BIT 0 IN R15 AND BRANCHES TO THE ADDRESS IN R15.
MODOPEN24 L    R15,ADOPEN31-OPEN24(,R15) ENTRY PT TO DCB OPEN EXIT RTN
         BSM   R14,R15        SAVE AMODE, SWITCH TO 31-BIT AND BRANCH
LENOPEN24 EQU  *-MODOPEN24
*
SYSPR_BEGINMSG DC   C'THIS IS A TEST FOR QSAM ABOVE TO SYSPRINT'
*
* DCB MODEL FOR SYSPRINT, WHICH IS ABOVE THE LINE.
MODSPRDCB DCB  DSORG=PS,DDNAME=SYSPRINT,MACRF=(PM)
SYSPREND EQU   *-MODSPRDCB
*
*SYSUT1   DCB   MACRF=R,BLKSIZE=96,LRECL=96,KEYLEN=44,RECFM=F,
*              DSORG=PS,EXLST=JFCBPTR,DDNAME=SYSUT1,EODAD=DONERD
*YSUT1   DCB   MACRF=PM,LRECL=80,RECFM=FB,                            X
*              DSORG=PS,EXLST=JFCBPTR,DDNAME=SYSUT1
***
         LTORG
         END
         LTORG
         END
###END EXPLVSAM
$$$BEG USETSYD
***********************************************************************
*                                                                     *
*   THE PURPOSE OF THIS PROGRAM IS TO SET A SYSTEM DUMP ENTRY IN      *
*     PLTPI                                                       CEM *
*                                                                     *
***********************************************************************
DFHEISTG DSECT
         SPACE 3
R0       EQU   0
R1       EQU   1
R2       EQU   2
BASE     EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R14      EQU   14
R15      EQU   15
         SPACE 2
*WORKAREA DSECT
DFHEISTG DSECT
SAV_RET_FMT_TM_9 DS F
RESP1    DS    F
RESP2    DS    F
X2CX49   DS    6F
DWORD    DS    D
PACKDATA DS    D
$DBLWD   DS    D
EBCDCFLD DS    D
HEXFIELD DS    F
         DS    F
NUM_SYD_ENTRIES DS F
*
TSQ_OP_1 DS    CL1
MYABSTM8 DS    PL8   FOR CNC GET TIME ROUTINE
MYABSTM  DS    PL8
MYABSTM1 DS    PL8
*
SYS_DMP_ENTRY DS  CL8
P_NUM_DUMPS DS PL2
*
TSQ_OP_90 DS   CL90
TSQ_OP_END_EQU EQU *
         ORG   TSQ_OP_90
TIMER_ENT_CN_JDT DS CL8
         DS    CL1
TIMER_ENT_CN_TOD DS CL8
         DS    CL1
JOBNAME  DS    CL8
         DS    CL1
APPLID   DS    CL8
OP_MSG_1 DS    CL1
OP_MSG   DS    CL54
         ORG   TSQ_OP_END_EQU
WRKEND   EQU   *-SAV_RET_FMT_TM_9
*
USETSYD CSECT
         MVI   TSQ_OP_1,X'40'
         MVC   TSQ_OP_90,TSQ_OP_1
         BAS   R9,GET_FORMAT_TIME
         EXEC CICS ASSIGN APPLID(APPLID)
         EXEC CICS INQUIRE SYSTEM JOBNAME(JOBNAME)
         MVC   OP_MSG,USETSYD_START
         BAS   R9,WRTLINE
*
         LA    R8,SYD_ENTRIES
TOPOFLST DS 0H
         MVC   OP_MSG,OP_MSG_1
         MVC   SYS_DMP_ENTRY,SP8
         CLC   END_ENTRIES,0(R8)
         BE    FIN_SYD
         CLC   SP8,0(R8)
         BE    ENT_SP_BYPASS
         MVC   SYS_DMP_ENTRY,0(R8)
         PACK  PACKDATA,8(2,R8)    CONVERT TO PACKED FORMAT
         CVB   R7,PACKDATA         CONVERT TO BINARY
         CIBL  R7,99,NUM_LT_99
*        BL    NUM_LT_99
         IILF  R7,99
NUM_LT_99 DS   0H
         LTR   R7,R7
         BP    NUM_GT_0
         XR    R7,R7
NUM_GT_0 DS    0H
         ST    R7,NUM_SYD_ENTRIES
         EXEC CICS SET SYSDUMPCODE(SYS_DMP_ENTRY) SYSDUMP LOCAL        X
              MAXIMUM(NUM_SYD_ENTRIES) ADD                             X
              RESP(RESP1) RESP2(RESP2)
         CLC   RESP1,DFHRESP(NORMAL)
         BNE   FMT_RESP
*
         MVC   OP_MSG,USETSYD_NORMAL
         MVC   OP_MSG+19(8),0(R8)
         MVC   OP_MSG+29(2),6(R8)
         BAS   R9,WRTLINE
*
ENT_SP_BYPASS DS 0H
         LA    R8,10(R8)
         B     TOPOFLST
*
FMT_RESP DS    0H
         MVC   OP_MSG,USETSYD_INVREQ
         MVC   OP_MSG+16(8),0(R8)
         L     R15,RESP1
         CVD   R15,DWORD
         UNPK  EBCDCFLD,DWORD+4(4)
         OI    EBCDCFLD+7,X'F0'
         MVC   OP_MSG+30(5),EBCDCFLD+3
         L     R15,RESP2
         CVD   R15,DWORD
         UNPK  EBCDCFLD,DWORD+4(4)
         OI    EBCDCFLD+7,X'F0'
         MVC   OP_MSG+41(5),EBCDCFLD+3
         BAS   R9,WRTLINE
*
         LA    R8,10(R8)
         B     TOPOFLST
*
FIN_SYD  DS    0H
RETURN   EQU   *
         MVC   OP_MSG,USETSYD_END
         BAS   R9,WRTLINE
*
RETURN1  EQU   *
         EXEC CICS RETURN
*
*
GET_FORMAT_TIME DS 0H
         ST   R9,SAV_RET_FMT_TM_9
         ZAP   MYABSTM,PZERO       GET_FORMAT_TIME
         EXEC CICS ASKTIME ABSTIME(MYABSTM)
         EXEC CICS FORMATTIME ABSTIME(MYABSTM)                         X
              YYYYDDD(TIMER_ENT_CN_JDT) DATESEP('-')                   X
              TIME(TIMER_ENT_CN_TOD) TIMESEP(':')                      X
              NOHANDLE
*
         L    R9,SAV_RET_FMT_TM_9
         BR    R9
*
WRTLINE  EQU   *
DOTD     EQU   *
         EXEC  CICS WRITEQ TD QUEUE(TSQ_OUT_DEST) LENGTH(H90)          X
              FROM(TSQ_OP_90)                                          X
              RESP(RESP1) RESP2(RESP2)
         MVC   OP_MSG,OP_MSG_1
         BR    R9
X2CX     EQU   *
FORMERR  EQU   *
         STM   R4,R9,X2CX49
         XR    R6,R6
         LA    R6,8
         ST    R15,HEXFIELD
         LA    R4,HEXFIELD
         LA    R5,EBCDCFLD
*
CONVERT  EQU   *
         SLR   R8,R8
         IC    R8,0(R4)
         SRDL  R8,4
         STC   R8,0(R5)
         LA    R5,1(R5)
         SLR   R8,R8
         SLDL  R8,4
         STC   R8,0(R5)
         LA    R5,1(R5)
         LA    R4,1(R4)
         BCT   R6,CONVERT
*
         TR    EBCDCFLD(8),ERRTRAN
         LM    R4,R9,X2CX49
         BR    R9
*
UWRKLEN  DC    Y(WRKEND)
H90      DC    H'90'
PZERO    DC    PL1'0'
TSQ_OUT_DEST  DC    CL4'CSSL'
TRT_WAS_LIT   DC    CL4'WAS'
USETSYD_START DC CL45'USETSYD - STARTING!'
USETSYD_NORMAL DC CL45'USETSYD - NORMAL -'  19
USETSYD_INVREQ DC CL45'USETSYD -INVREQ:16      :RSP1:30    RSP2:41   :'
USETSYD_ERROR DC CL45'USETSYD - ERROR  -'
USETSYD_UNKN DC CL45'USETSYD - UNKNOWN-'
USETSYD_END  DC CL45'USETSYD - ENDING!'
ERRTRAN  DC    X'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
SP8      DC    CL8' '
*
SYD_ENTRIES DC   0D
MN0115      DC   CL8'MN0115  ',CL2'02'
EMPTY1      DC   CL8'        ',CL2'00'
            DC   CL8'LD0002  ',CL2'00'
END_ENTRIES DC   XL8'FFFFFFFFFFFFFFFF',CL2'00'
         END
###END USETSYD
$$$BEG EXPLCICS
* FOR EACH EXEC CICS CALL MACRO EXPANDS TO
*  DFHECALL MACRO WHICH IS STD SYSTEM CALL
*  R0  UNDEFINED
*  R1  POINTS TO ADDR OF PARM LIST
*  R14 POINTS TO RETURN POINT IN YOUR PGM
*  R15 POINTS TO ADDR OF ENTRY  PT IN EXEC INTF
* DFHEAI MUST BE LINK EDITED WITH YOUR PGM FOR EXEC INTF RESOLUTION
* EXEC CICS RETURN WILL EXIT YOUR PGM OR DFHEIRET IS INSERTED BY
*  THE TRANSLATOR IF NO EXEC RETURN FOUND
* DFHEIRET INSERTED BY TRANSLATOR AT END OF PGM
*  THIS MACRO: RESTORES REGS
*              RETURNS VIA R14
* DFHECALL BUILDS THE PARM LIST IN DYN STG FOR REENTRANCY
* DFHEIENT INSERTED BY TRANSLATOR AFTER FIRST CSECT
*  THIS MACRO: SAVES REGS
*              GETMAIN STG FOR DFHEISTG
*              SETS BASE REG (R3 DEFAULT)
*              SETS DYN STG REG (R13 DEFAULT)
*              SETS EIB REG (R11 DEFAULT)
* DFHEISTG INSERTED BY TRANSLATOR
*              DEFINES STG PARM LIST
*              DEFINES STG FOR REG SAVE AREA
*              INCLUDES YOUR VARS WHEN YOU CODE THE DFHEISTG MACRO
* DFHEIEND INSERTED BY TRANSLATOR TO ID END OF EIDSA
* DFHEIBLK INSERTED BY TRANSLATOR DEFINES EIB DSECT
* MULTIPLE BASE REGS DEFINED BY DFHEIENT (CODEREG DATAREG EIBREG)
* DFHEIPLR IS THE REG VAR ASSIGNED TO FIRST EIBREG OR DEFAULT
*REG 1                      PASSED ADDR OF PARMS
*REG 3                      BASE REGISTER (CMD LVL)
*REG 11                     PTR TO EIB (SET BY DFHEIENT)
*REG 13                     PTR TO DFHEISTG (SET BY DFHEIENT(
* DFHEIENT ALLOWS FOR PARAMETERS:
*    CODEREGS=(1,...,N) OR R3 BY DEFAULT
*    EIBREG=(N) OR R11/RB BY DEFAULT
*    DATAREG=(N) OR R13/RD BY DEFAULT
*
         REGSMAC
MYDSECT  DSECT
MYMF1    DS    F
*
* DFHEISTG GENERATES A DSECT WHICH ANCHORS THE EXEC INTF. THE MACRO
*  WILL GENERATE A PREFIX AREA TO YOUR OWN DATA, FOLLOWING THE DSECT
*  STATEMENT. IN THIS PREFIX AREA, THE DFHEIPLR (R13), THE DFHEIBP
*  FW POINTER AND DFHEICAP (COMMAREA) POINTERS ARE INITIALIZED BY
*  CICS.
*
DFHEISTG DSECT
DWORD    DS    D
FWORD    DS    F
HWORD    DS    H
HWD      DS    0H
*
CVTH     DS    CL8
*
MYMSG1   DS    CL1
MYMSG    DS    CL80
MYTIME   DS    CL8
MYABSTM  DS    PL8
MYFJDT   DS    CL6
MYFTIME  DS    PL4
SAVETRAN DS    CL4
L_BEGNLNE DS   H
ENDOFEIS DS    CL8          SET TO ENDOFEIS
********************************************************************
*
* THE FIRST CSECT IS GOING TO BE USED BY THE TRANSLATOR TO INSERT
*  THE  DFHEIENT MACRO. YOU COULD HAVE ALSO CODED YOUR OWN  DFHEIENT
*  IN ORDER TO SPECIFY CODE AND DATA REGISTERS. THE MACRO GENERATES
*  THE ACTUAL EIBLK DSECT AND THEN INITIALIZES THE EXPECTED DYN STG
*  AND VARIOUS POINTERS IN THE AREA GENERATED BY DFHEISTG.
EXPLCICS DFHEIENT
         B     MAIN000
         SPACE 2
*****    GBLC  &SYSDATE
         DC    C'EXPLCICS'
         DC    C'&SYSDATE'
         SPACE 1
MAIN000  DS    0H
         IILF  R15,L'BEGNLNE
         STH   R15,L_BEGNLNE
         EXEC CICS ENTER TRACENUM(TR198) FROM(BEGNLNE)                 *
             FROMLENGTH(L_BEGNLNE) NOHANDLE
         MVC   ENDOFEIS,L_ENDOFEIS
         MVI   MYMSG1,X'40'
BUFLEN   EQU   133 DEFINE THE BUFFER LENGTH
         MVI BUFFER,C' ' CLEAR A BUFFER TO BLANKS
         MVC BUFFER+1(BUFLEN-1),BUFFER RIPPLE THE FIRST BLANK
*
         L     R5,DFHEICAP
*   DEF: R11 IS EIB
*        R13 IS DYN STG
*
         EXEC  CICS HANDLE CONDITION ERROR(ERROR01)
         EXEC  CICS GETMAIN FLENGTH(F4080)                             *
               SET(R10)                                                *
               NOSUSPEND
         USING MYDSECT,R10
         MVC   SAVETRAN,EIBTRNID  SAVE THE INITIATING TXN
         ZAP   MYABSTM,PZERO
         EXEC CICS ASKTIME ABSTIME(MYABSTM)
         EXEC CICS FORMATTIME ABSTIME(MYABSTM)                         *
              YYDDD(MYFJDT) TIMESEP TIME(MYFTIME)
*          @@@
         MVC   MYMSG,BEGNLNE
         BAS   R9,WRTLINE
*
         MVC   MYMSG,TIMELNE
         MVC   MYMSG+4(6),MYFJDT
         MVC   MYMSG+13(8),MYFTIME
         BAS   R9,WRTLINE
*
*
DONEIN   EQU   *
         MVC   MYMSG,ENDMSG
         BAS   R9,WRTLINE
*
RETURN   EQU   *
         EXEC  CICS RETURN
         SPACE
CVTCNT   EQU   *
         CVD   R8,DWORD
         UNPK  CVTH,DWORD+3(5)
         OI    CVTH+4,X'F0'
         XR    R8,R8
         BR    R9
*        %%%%%
WRTLINE  EQU   *
DOTD     EQU   *
         EXEC  CICS WRITEQ TD QUEUE('CSSL') FROM(MYMSG) LENGTH(H80)
         MVC   MYMSG,MYMSG1
         BR    R9
ERROR01  DS    0H
         MVC   MYMSG,ERR1LNE
         BAS   R9,WRTLINE
         B     RETURN
ERROR02  DS    0H
         MVC   MYMSG,ERR2LNE
         BAS   R9,WRTLINE
         B     RETURN
         EJECT
F4080    DC    F'4080'
HNEG1    DC    H'-1'
H0       DC    H'0'
H20      DC    H'20'
H80      DC    H'80'
H4080    DC    H'4096'
*CEMTBLA  DC    A(CEMVALUE)
         SPACE
PZERO    DC    PL1'0'
SP80     DC    CL80' '
*
BUFFER   DS    CL(BUFLEN)
L_ENDOFEIS DC  CL8'ENDOFEIS'
BEGNLNE  DC    CL80'*** BEGIN EXPLCICS ***'
TIMELNE  DC    CL80'***          ++++        '
ENDMSG   DC    CL80'*** END   EXPLCICS ***'
STGMSG   DC    CL80'$$$ STORAGE FOR COND GETMAIN NOT AVAILABLE. BYE.'
ERR1LNE  DC    CL80'$$$ ERROR IN INITIALIZATION OF ROUTINE ERROR 1'
ERR2LNE  DC    CL80'$$$ ERROR IN PROCESSING ERROR 2'
TR198    DC    H'198'
*                   0         0         0         0         0    5'
         SPACE 3
         LTORG
         DC    C'****'
         DC    C'EXPLCICS - CIGNA * CPCW *'
         DC    C' '
         DC    C'DATE='
         DC    C'&SYSDATE'
         DC    C' '
         DC    C'TIME='
         DC    C'&SYSTIME'
         DC    C' '
         DC    C'TCEM'
         DC    C'****'
*        EXTRN CEMVALUE
         END
###END EXPLCICS
$$$BEG EXPLKXBL
NECESSARY ADDITIONS FOR BASLESS KIX PGMS

*ASM     XOPTS(NOPROLOG NOEPILOG)
         SYSSTATE ARCHLVL=OSREL
.........
*
SAVE     DFHEISTG DSECT
DYNAMIC STORAGE DEFINIITIONS
...
         DFHEIEND
*
UCEMPARS CSECT
UCEMPARS AMODE 31
UCEMPARS RMODE ANY
      DFHEIENT DATAREG=13,EIBREG=11,STATREG=3,STATIC=STATR,CODEREG=0
         J     MAIN000
         DC    C'UCEMPARS'
         DC    C'&SYSDATE'
         SPACE 1
MAIN000  DS    0H
*
         CIJNE R4,CA_EQU_LENGTH,NOPARM
         EXEC  CICS ADDRESS COMMAREA(R10)
         LTR   R1,R10
         JZ    NOPARM
*
*  R1 NOW POINTS TO ACTUAL PARM
*  R2 WILL HOLD THE SEARCH DIRECTION (0 FOR DCND OR 1 FOR ACND)
*  R3 IS THE BASE REG
*  R4 HOLDS PARM LENGTH, WILL NEXT HOLD NEEDLE ADDR
*  R5 WILL HOLD ADDR OF NEEDLE HW LENGTH. USED IN EX ON CLC INST
*  R6 HOLDS HAYSTACK ADDR
*  R7 HOLD ADDR OF HAYSTACK LW LENGHT
*  R8 USED TO HOLD FIRST POSITION IN THE HAYSTACK
*  R9 ((R6+R7)-R5) GIVES LAST (OR FIRST IS DECENDING) COMPARE ADDR
*  R10 COMMAREA
*  R0,R15 ARE WORKREGS
*
         USING MYCOM_A,R10
....
CODE GOES HERE
...
*   CICS STATIC STORAGE AREA NEEDS LABEL AS SPECIFIED ON DFHEIENT
STATR    DS    0D
LITERALS
         LTORG
         END
###END EXPLKXBL
$$$BEG CMQXPA#
         MACRO
&NAME    CMQXPA &LIST=NO
         PUSH  PRINT
         AIF   ('&LIST' EQ 'YES').XPBLST
         PRINT OFF
.**********************************************************************
.* do NOT use this macro - it has changed   ***************************
.* use SYS1.TSK.GMQS.SCSQMACS in your asm syslib **********************
.**********************************************************************
.* note - this is a copied version from   *****************************
.*        TUKD.TSK.MQS.R600.SCSQMACS(CMQXPA)***************************
.*        used to asm the csqcapx module following maint to source ****
.**********************************************************************
.**                                                                  **
.**                  WebSphere MQ for z/OS                           **
.**                                                                  **
.**  MACRO NAME:     CMQXPA                                          **
.**                                                                  **
.**  DESCRIPTION:    API Crossing Exit Parameter                     **
.**                                                                  **
.**********************************************************************
.**  @START_COPYRIGHT@                                               **
.**  Statement:     Licensed Materials - Property of IBM             **
.**                                                                  **
.**                 5655-F10                                         **
.**                 (C) Copyright IBM Corporation. 1993, 2002        **
.**                                                                  **
.**  Status:        Version 5 Release 3                              **
.**  @END_COPYRIGHT@                                                 **
.**********************************************************************
.**                                                                  **
.**  FUNCTION:       This file declares the structure MQXP, which    **
.**                  is used by exits.                               **
.**                                                                  **
.**  PROCESSOR:      Assembler                                       **
.**                                                                  **
.**********************************************************************
.XPBLST  ANOP
         LCLC &LNAME
&LNAME   SETC '&NAME'
         AIF ('&NAME' NE '').NAMED
&LNAME   SETC 'MQXP'
.NAMED   ANOP
*
*
&LNAME                  DSECT
                        DS   0D        Force doubleword alignment
&LNAME._STRUCID         DS   CL4       Control block id = XP
&LNAME._VERSION         DS   F         Control block Version = 1
&LNAME._EXITID          DS   F         Identifier of the exit being
*                                       invoked
&LNAME._EXITREASON      DS   F         Reason for this invocation of
*                                       the exit
&LNAME._EXITRESPONSE    DS   F         Response from this
*                                       invocation of the exit
&LNAME._EXITCOMMAND     DS   F         Callers API command
&LNAME._EXITPARMCOUNT   DS   F         Number of parameters to API call
                        DS   F         Reserved
&LNAME._EXITUSERAREA    DS   CL16      User work area, passed
*                                       not used by MQM
*
&LNAME._LENGTH          EQU  *-&LNAME._STRUCID
                        ORG  &LNAME._STRUCID
&LNAME._AREA            DS   CL(&LNAME._LENGTH)  Area for structure
*
******************************************************************
*
*
&LNAME._COPYPLIST       DSECT
                        DS  0D         Force doubleword alignment
&LNAME._PXPB            DS   AL4       Ptr to exit parm block
&LNAME._PCOPYPARM       DS 11AL4       Copy of original plist
*
                        ORG  &LNAME._PCOPYPARM
&LNAME._PCOPYPARM1      DS   AL4       Copy of 1st parameter
&LNAME._PCOPYPARM2      DS   AL4       Copy of 2nd parameter
&LNAME._PCOPYPARM3      DS   AL4       Copy of 3rd parameter
&LNAME._PCOPYPARM4      DS   AL4       Copy of 4th parameter
&LNAME._PCOPYPARM5      DS   AL4       Copy of 5th parameter
&LNAME._PCOPYPARM6      DS   AL4       Copy of 6th parameter
&LNAME._PCOPYPARM7      DS   AL4       Copy of 7th parameter
&LNAME._PCOPYPARM8      DS   AL4       Copy of 8th parameter
&LNAME._PCOPYPARM9      DS   AL4       Copy of 9th parameter
&LNAME._PCOPYPARM10     DS   AL4       Copy of 10th parameter
&LNAME._PCOPYPARM11     DS   AL4       Copy of 11th parameter
*
&LNAME._COPYPLIST_LENGTH  EQU  *-&LNAME._PXPB
                          ORG  &LNAME._PXPB
&LNAME._COPYPLIST_AREA    DS   CL(&LNAME._COPYPLIST_LENGTH)
*
*
                          GBLC      &MQXCON   Defined to prevent
*                                              multiple declaration
                          AIF       ('&MQXCON' EQ 'Y').MQXMISS
*
&MQXCON                   SETC  'Y'
*
                          CMQXA
*
.MQXMISS                  ANOP
                          POP PRINT
                          MEND
###END CMQXPA#
$$$BEG CMQXA#
         MACRO
         CMQXA  &EQUONLY=YES,&LIST=NO
.**********************************************************************
.* do NOT use this macro - it has changed   ***************************
.* use SYS1.TSK.GMQS.SCSQMACS in your asm syslib **********************
.**********************************************************************
.* note - this is a copied version from   *****************************
.*        TUKD.TSK.MQS.R600.SCSQMACS(CMQXA) ***************************
.*        used to asm the csqcapx module following maint to source ****
.**********************************************************************
.**                                                                  **
.**                  WebSphere MQ for z/OS                           **
.**                                                                  **
.**  FILE NAME:      CMQXA                                           **
.**                                                                  **
.**  DESCRIPTION:    Constants for Exits and MQCD                    **
.**                                                                  **
.**********************************************************************
.**  @START_COPYRIGHT@                                               **
.**  Statement:     Licensed Materials - Property of IBM             **
.**                                                                  **
.**                 5655-L82                                         **
.**                 (C) Copyright IBM Corporation. 1993, 2005        **
.**                                                                  **
.**  Status:        Version 6 Release 0                              **
.**  @END_COPYRIGHT@                                                 **
.**********************************************************************
.**                                                                  **
.**  FUNCTION:       This file declares the named constants          **
.**                  for exits and MQCD.                             **
.**                                                                  **
.**  PROCESSOR:      Assembler                                       **
.**                                                                  **
.**********************************************************************
         PUSH  PRINT
         AIF   ('&LIST' EQ 'YES').LIST2
         AIF   ('&LIST' EQ 'NO').LIST1
         PRINT ON
         MNOTE 4,'INVALID MACRO FORMAT, LIST=NO ASSUMED'
.LIST1   ANOP
         PRINT OFF
         AGO   .LIST3
.LIST2   ANOP
         PRINT ON
.LIST3   ANOP
.*
         GBLC  &MQXACOPY
         AIF   ('&MQXACOPY' EQ 'YES').DONE
&MQXACOPY SETC 'YES'
.*
.*****************************************************************
.**  Values Related to MQCD Structure                            **
.*****************************************************************
.* Structure Version Number
MQCD_VERSION_1 EQU 1
MQCD_VERSION_2 EQU 2
MQCD_VERSION_3 EQU 3
MQCD_VERSION_4 EQU 4
MQCD_VERSION_5 EQU 5
MQCD_VERSION_6 EQU 6
MQCD_VERSION_7 EQU 7
MQCD_VERSION_8 EQU 8
MQCD_CURRENT_VERSION EQU 8
.*
.* Structure Length
MQCD_LENGTH_4 EQU 940
MQCD_LENGTH_5 EQU 952
MQCD_LENGTH_6 EQU 1048
MQCD_LENGTH_7 EQU 1148
MQCD_LENGTH_8 EQU 1240
MQCD_CURRENT_LENGTH EQU 1240
.*
.* Channel Types
MQCHT_SENDER EQU 1
MQCHT_SERVER EQU 2
MQCHT_RECEIVER EQU 3
MQCHT_REQUESTER EQU 4
MQCHT_ALL EQU 5
MQCHT_CLNTCONN EQU 6
MQCHT_SVRCONN EQU 7
MQCHT_CLUSRCVR EQU 8
MQCHT_CLUSSDR EQU 9
.*
.* Channel Compression
MQCOMPRESS_NOT_AVAILABLE EQU -1
MQCOMPRESS_NONE EQU 0
MQCOMPRESS_RLE EQU 1
MQCOMPRESS_ZLIBFAST EQU 2
MQCOMPRESS_ZLIBHIGH EQU 4
MQCOMPRESS_SYSTEM EQU 8
MQCOMPRESS_ANY EQU X'0FFFFFFF'
.*
.* Transport Types
MQXPT_ALL EQU -1
MQXPT_LOCAL EQU 0
MQXPT_LU62 EQU 1
MQXPT_TCP EQU 2
MQXPT_NETBIOS EQU 3
MQXPT_SPX EQU 4
MQXPT_DECNET EQU 5
MQXPT_UDP EQU 6
.*
.* Put Authority
MQPA_DEFAULT EQU 1
MQPA_CONTEXT EQU 2
MQPA_ONLY_MCA EQU 3
MQPA_ALTERNATE_OR_MCA EQU 4
.*
.* Channel Data Conversion
MQCDC_SENDER_CONVERSION EQU 1
MQCDC_NO_SENDER_CONVERSION EQU 0
.*
.* MCA Types
MQMCAT_PROCESS EQU 1
MQMCAT_THREAD EQU 2
.*
.* NonPersistent-Message Speeds
MQNPMS_NORMAL EQU 1
MQNPMS_FAST EQU 2
.*
.* SSL Client Authentication
MQSCA_REQUIRED EQU 0
MQSCA_OPTIONAL EQU 1
.*
.* KeepAlive Interval
MQKAI_AUTO EQU -1
.*
.*****************************************************************
.**  Values Related to MQCXP Structure                           **
.*****************************************************************
.* Structure Identifier
MQCXP_STRUC_ID EQU C'CXP '
.*
.* Structure Version Number
MQCXP_VERSION_1 EQU 1
MQCXP_VERSION_2 EQU 2
MQCXP_VERSION_3 EQU 3
MQCXP_VERSION_4 EQU 4
MQCXP_VERSION_5 EQU 5
MQCXP_VERSION_6 EQU 6
MQCXP_CURRENT_VERSION EQU 6
.*
.* Exit Response 2
MQXR2_PUT_WITH_DEF_ACTION EQU 0
MQXR2_PUT_WITH_DEF_USERID EQU 1
MQXR2_PUT_WITH_MSG_USERID EQU 2
MQXR2_USE_AGENT_BUFFER EQU 0
MQXR2_USE_EXIT_BUFFER EQU 4
MQXR2_DEFAULT_CONTINUATION EQU 0
MQXR2_CONTINUE_CHAIN EQU 8
MQXR2_SUPPRESS_CHAIN EQU 16
MQXR2_STATIC_CACHE EQU 0
MQXR2_DYNAMIC_CACHE EQU 32
.*
.* Capability Flags
MQCF_NONE EQU X'00000000'
MQCF_DIST_LISTS EQU X'00000001'
.*
.*****************************************************************
.**  Values Related to MQDXP Structure                           **
.*****************************************************************
.* Structure Identifier
MQDXP_STRUC_ID EQU C'DXP '
.*
.* Structure Version Number
MQDXP_VERSION_1 EQU 1
MQDXP_CURRENT_VERSION EQU 1
.*
.* Exit Response
MQXDR_OK EQU 0
MQXDR_CONVERSION_FAILED EQU 1
.*
.*****************************************************************
.**  Values Related to MQWDR Structure                           **
.*****************************************************************
.* Structure Identifier
MQWDR_STRUC_ID EQU C'WDR '
.*
.* Structure Version Number
MQWDR_VERSION_1 EQU 1
MQWDR_VERSION_2 EQU 2
MQWDR_CURRENT_VERSION EQU 2
.*
.* Structure Length
MQWDR_LENGTH_1 EQU 124
MQWDR_LENGTH_2 EQU 136
MQWDR_CURRENT_LENGTH EQU 136
.*
.* Queue Manager Flags
MQQMF_REPOSITORY_Q_MGR EQU X'00000002'
MQQMF_CLUSSDR_USER_DEFINED EQU X'00000008'
MQQMF_CLUSSDR_AUTO_DEFINED EQU X'00000010'
MQQMF_AVAILABLE EQU X'00000020'
.*
.*****************************************************************
.**  Values Related to MQWQR Structure                           **
.*****************************************************************
.* Structure Identifier
MQWQR_STRUC_ID EQU C'WQR '
.*
.* Structure Version Number
MQWQR_VERSION_1 EQU 1
MQWQR_VERSION_2 EQU 2
MQWQR_CURRENT_VERSION EQU 2
.*
.* Structure Length
MQWQR_LENGTH_1 EQU 200
MQWQR_LENGTH_2 EQU 208
MQWQR_CURRENT_LENGTH EQU 208
.*
.* Queue Flags
MQQF_LOCAL_Q EQU X'00000001'
MQQF_CLWL_USEQ_ANY EQU X'00000040'
MQQF_CLWL_USEQ_LOCAL EQU X'00000080'
.*
.*****************************************************************
.**  Values Related to MQWXP Structure                           **
.*****************************************************************
.* Structure Identifier
MQWXP_STRUC_ID EQU C'WXP '
.*
.* Structure Version Number
MQWXP_VERSION_1 EQU 1
MQWXP_VERSION_2 EQU 2
MQWXP_VERSION_3 EQU 3
MQWXP_CURRENT_VERSION EQU 3
.*
.* Cluster Workload Flags
MQWXP_PUT_BY_CLUSTER_CHL EQU X'00000002'
.*
.* Cluster Cache Types
MQCLCT_STATIC EQU 0
MQCLCT_DYNAMIC EQU 1
.*
.*****************************************************************
.**  Values Related to MQXP Structure                            **
.*****************************************************************
.* Structure Identifier
MQXP_STRUC_ID EQU C'XP  '
.*
.* Structure Version Number
MQXP_VERSION_1 EQU 1
.*
.* Exit Commands
MQXC_MQOPEN EQU 1
MQXC_MQCLOSE EQU 2
MQXC_MQGET EQU 3
MQXC_MQPUT EQU 4
MQXC_MQPUT1 EQU 5
MQXC_MQINQ EQU 6
MQXC_MQSET EQU 8
MQXC_MQBACK EQU 9
MQXC_MQCMIT EQU 10
.*
.*****************************************************************
.**  Values Related to MQXWD Structure                           **
.*****************************************************************
.* Structure Identifier
MQXWD_STRUC_ID EQU C'XWD '
.*
.* Structure Version Number
MQXWD_VERSION_1 EQU 1
.*
.*****************************************************************
.**  General Values Related to Exits                             **
.*****************************************************************
.*
.* Exit Identifiers
MQXT_API_CROSSING_EXIT EQU 1
MQXT_API_EXIT EQU 2
MQXT_CHANNEL_SEC_EXIT EQU 11
MQXT_CHANNEL_MSG_EXIT EQU 12
MQXT_CHANNEL_SEND_EXIT EQU 13
MQXT_CHANNEL_RCV_EXIT EQU 14
MQXT_CHANNEL_MSG_RETRY_EXIT EQU 15
MQXT_CHANNEL_AUTO_DEF_EXIT EQU 16
MQXT_CLUSTER_WORKLOAD_EXIT EQU 20
MQXT_PUBSUB_ROUTING_EXIT EQU 21
.*
.* Exit Reasons
MQXR_BEFORE EQU 1
MQXR_AFTER EQU 2
MQXR_CONNECTION EQU 3
MQXR_INIT EQU 11
MQXR_TERM EQU 12
MQXR_MSG EQU 13
MQXR_XMIT EQU 14
MQXR_SEC_MSG EQU 15
MQXR_INIT_SEC EQU 16
MQXR_RETRY EQU 17
MQXR_AUTO_CLUSSDR EQU 18
MQXR_AUTO_RECEIVER EQU 19
MQXR_CLWL_OPEN EQU 20
MQXR_CLWL_PUT EQU 21
MQXR_CLWL_MOVE EQU 22
MQXR_CLWL_REPOS EQU 23
MQXR_CLWL_REPOS_MOVE EQU 24
MQXR_AUTO_SVRCONN EQU 27
MQXR_AUTO_CLUSRCVR EQU 28
MQXR_SEC_PARMS EQU 29
.*
.* Exit Responses
MQXCC_OK EQU 0
MQXCC_SUPPRESS_FUNCTION EQU -1
MQXCC_SKIP_FUNCTION EQU -2
MQXCC_SEND_AND_REQUEST_SEC_MSG EQU -3
MQXCC_SEND_SEC_MSG EQU -4
MQXCC_SUPPRESS_EXIT EQU -5
MQXCC_CLOSE_CHANNEL EQU -6
MQXCC_FAILED EQU -8
.*
.* Exit User Area Value
         AIF   ('&EQUONLY' EQ 'YES').SKIP1
MQXUA_NONE DC XL16'00'
.SKIP1   ANOP
.*
.*****************************************************************
.**  Values Related to MQXCNVC Function                          **
.*****************************************************************
.*
.* Conversion Options
MQDCC_DEFAULT_CONVERSION EQU X'00000001'
MQDCC_FILL_TARGET_BUFFER EQU X'00000002'
MQDCC_INT_DEFAULT_CONVERSION EQU X'00000004'
MQDCC_SOURCE_ENC_NATIVE EQU X'00000010'
MQDCC_SOURCE_ENC_NORMAL EQU X'00000010'
MQDCC_SOURCE_ENC_REVERSED EQU X'00000020'
MQDCC_SOURCE_ENC_UNDEFINED EQU X'00000000'
MQDCC_TARGET_ENC_NATIVE EQU X'00000100'
MQDCC_TARGET_ENC_NORMAL EQU X'00000100'
MQDCC_TARGET_ENC_REVERSED EQU X'00000200'
MQDCC_TARGET_ENC_UNDEFINED EQU X'00000000'
MQDCC_NONE EQU X'00000000'
.*
.* Conversion Options Masks and Factors
MQDCC_SOURCE_ENC_MASK EQU X'000000F0'
MQDCC_TARGET_ENC_MASK EQU X'00000F00'
MQDCC_SOURCE_ENC_FACTOR EQU 16
MQDCC_TARGET_ENC_FACTOR EQU 256

.*
.DONE    ANOP
         POP   PRINT
.**********************************************************************
.**  End of CMQXA                                                    **
.**********************************************************************
         MEND
###END CMQXA#
$$$BEG DFHXCOPT
***********************************************************************
* 20170913- copy from cics 5.4 - trace turned on and size incr 64K    *
* 2011202 - SURROGCHK: NO  linked to ttex.tsk.g.r320.put.excilib      *
*           this auth lib version is used by tibco                    *
*           SURROGCHK: YES linked to ttex.tsk.f.r320.put.excilib      *
*           this is the normal version used by normal exci traffic    *
*                                                                     *
* tted.tsk.g.r320.put.excilib has surrogchk=n                         *
*                                                                     *
* 2010119 - SURROGCHK: NO  linked to ttep.tsk.e.tcem.pdse to fix      *
*           processing problem on USYS                                *
*                                                                     *
* note - SURROGCHK: should have been coded as NO                      *
*                                                                     *
***********************************************************************
*                                                                     *
* MODULE NAME = DFHXCOPT                                              *
*                                                                     *
* DESCRIPTIVE NAME = CICS TS  External CICS Interface (EXCI)          *
*                             Options Module                          *
*                                                                     *
*                                                                     *
*                                                                     *
*        Licensed Materials - Property of IBM                         *
*                                                                     *
*        "Restricted Materials of IBM"                                *
*                                                                     *
*        5655-Y04                                                     *
*                                                                     *
*        (C) Copyright IBM Corp. 1993, 2016"                          *
*                                                                     *
*                                                                     *
*                                                                     *
*                                                                     *
*  STATUS = 7.1.0                                                     *
*                                                                     *
* FUNCTION = To provide the EXCI interface with required options.     *
*        An explanation of each option, the permitted values and the  *
*        defaults are described below.                                *
*                                                                     *
* NOTES :                                                             *
*    DEPENDENCIES = S/390                                             *
*    RESTRICTIONS = None                                              *
*    REGISTER CONVENTIONS = Not Applicable                            *
*    MODULE TYPE = Table                                              *
*    PROCESSOR = Assembler                                            *
*    ATTRIBUTES = Not Applicable                                      *
*                                                                     *
*------------------------------------------------------------------ *
*                                                                     *
* DESCRIPTION                                                         *
*         This sample table should be used to pass options to the     *
*         EXCI interface. There is no suffixed version of this table, *
*         DFHXCPRH will load the first DFHXCOPT it finds in the       *
*         STEPLIB concatenation.                                      *
*                                                                     *
*         The permitted options are:                                  *
*                                                                     *
*           TIMEOUT:    Specifies (in hundredths of a second) how     *
*                       long DFHXCPRH will wait for a DPL call to     *
*                       complete. The default is ZERO which will wait *
*                       indefinitely.                                 *
*                                                                     *
*           TRACE:      Specifies if internal tracing is required,    *
*                       and if so, the level of tracing.              *
*                       Acceptable values are OFF, 1 and 2.           *
*                       OFF: Only exception trace entries will be     *
*                            written to the internal trace table.     *
*                       1  : Exception and level 1 entries will be    *
*                            written to the internal trace table.     *
*                       2  : Exception, level 1 and level 2 entries   *
*                            will be written to the internal trace    *
*                            table.                                   *
*                       3  : Exception, level 1, 2 and level 3 entries*
*                            will be written to the internal trace    *
*                            table.                                   *
*                       The default for the TRACE parameter is OFF    *
*                                                                     *
*           TRACESZE:   The size (in K) of the internal trace table.  *
*                       This should still be specified, even for      *
*                       TRACE=OFF because exception trace entries     *
*                       will still be be written. The default trace   *
*                       table size is 16K, which is also the minimum. *
*                                                                     *
*           DURETRY:    Specifies (in seconds) the length of time     *
*                       that the EXCI interface will attempt to       *
*                       take an SDUMP, should one occur, and SDUMP    *
*                       is busy. An attempt will be made every 5      *
*                       seconds, up to the DURETRY time.              *
*                       The default for DURETRY is 30 seconds.        *
*                                                                     *
*           TRAP:       Specifies if the service module DFHXCTRA is   *
*                       to be used. Acceptable values are ON and OFF, *
*                       the default being OFF.                        *
*                                                                     *
*           GTF:        Specifies that all trace entries that would   *
*                       normally be written to the internal trace     *
*                       table are ALSO written to GTF, if GTF tracing *
*                       is active. Acceptable values are ON and OFF,  *
*                       the default being OFF.                        *
*                                                                     *
*           MSGCASE:    Specifies whether messages should be output   *
*                       in mixed case, or uppercase. Allowable values *
*                       are MIXED and UPPER. The default is MIXED.    *
*                                                                     *
*                                                                     *
*           CICSSVC:    Specifies the CICS type 3 SVC number being    *
*                       used for MRO communication.                   *
*                       Values can be 0, or a number in the range     *
*                       200 - 255 inclusive. The default is 216.      *
*                                                                     *
*                       The value 0 means that the External CICS      *
*                       Interface will obtain the CICS SVC number     *
*                       being used for MRO by means of an SSI VERIFY  *
*                       request.
*                                                                     *
*                       If no MRO CICS regions have ever logged on to *
*                       DFHIRP in the local MVS during the life of    *
*                       the IPL, you must specify a non zero SVC      *
*                       number. If you specify 0 the External CICS    *
*                       Interface requests the SVC from MVS which     *
*                       will fail if no CICS region has logged on to  *
*                       DFHIRP.                                       *
*                                                                     *
*                       A non zero value is required in MVS images    *
*                       that do not run any CICS regions, and the     *
*                       client program is issuing DPL requests to a   *
*                       server CICS region that resides in another    *
*                       MVS. In these circumstances, the client       *
*                       program logs on to the local DFHIRP using the *
*                       locally defined SVC and communicates with the *
*                       remote CICS region using XCF/MRO.             *
*                                                                     *
*                       THE LATEST CICS RELEASE LEVEL OF THE CICS SVC *
*                       (DFHCSVC) SHOULD ALWAYS BE USED BY ALL CICS   *
*                       SYSTEMS USING MRO IN THE SAME MVS, OR BY EXCI *
*                       BATCH PROGRAMS IN THAT SAME MVS.              *
*                                                                     *
*           CONFDATA:   Specifies whether or not to allow commarea    *
*                       data to be output in an EXCI trace given that *
*                       the data may be classified in nature.         *
*                       Acceptable values are SHOW and HIDETC with    *
*                       SHOW being the default.                       *
*                       SHOW means do not supress the trace data.     *
*                       HIDETC means suppress the trace data.         *
*                                                                     *
*           SURROGCHK:  Specifies whether a surrogate-user security   *
*                       check is to be performed when a userid is     *
*                       supplied in the EXCI parameter list.          *
*                       NO means do not perform a check.              *
*                       YES means that a check is performed that      *
*                       the user executing EXCI has READ access to    *
*                       the resource "userid.DFHEXCI" in the SURROGAT *
*                       resource class, where "userid" is the userid  *
*                       in the DFHXCIS parameter list.                *
*                       The default is YES.                           *
*                                                                     *
*           ABENDBKOUT: Specifies whether a transactional EXCI        *
*                       task is to force a rollback of the            *
*                       global uow after an abend.                    *
*                       DFHMIRS will invoke RM to call MVS RRS        *
*                       to force a rollback after such an abend       *
*                                                                     *
*           XCFGROUP:   Specifies the name of the cross-system        *
*                       coupling facility (XCF) group to be joined    *
*                       by the client program. The default XCF        *
*                       group name is DFHIR000                        *
*                                                                     *
*          LOCALCCSID:  Specifies a value for the CCSID of the EXCI   *
*                       client used for codepage conversion for       *
*                       containers. The default is 037.               *
*                                                                     *
*---------------------------------------------------------------------*
*                                                                     *
* CHANGE ACTIVITY :                                                   *
*        $MOD(DFHXCOPT),COMP(IRC),PROD(CICS TS ):                     *
*                                                                     *
*     PN= REASON REL YYMMDD HDXXIII : REMARKS                         *
*    $L0= 660    410 930310 HD5KASR: Create sample options table.     *
*    $01= A66310 410 950605 HDBGNRB : Migrate PN66310 from SPA R410   *
*    $03= A17426 650 060228 HDBGNRB : Migrate PK17426 from SPA R640   *
*    $P0= M84543 410 931117 HD5KASR: Alter the description of CICSSVC *
*    $P1= M95900 510 951205 HD2JPEH : Add surrogate-user check        *
*    $P4= D15156 650 060411 HD1MA   : Add XCFGROUP and description    *
*        R000363 710 160622 HD2GJST : Add Localccisd and trace lvl 3  *
*        R130820 710 160823 HD2GJST : Change CICSSVC defaault to 216  *
*                                                                     *
***********************************************************************
***********************************************************************
         DFHXCO TYPE=CSECT,                                            *
               TIMEOUT=0,             No timeout                       *
               TRACE=3,               off,on,1,2,3                     *
               TRACESZE=64,           16K trace table                  *
               DURETRY=30,            Retry SDUMPS for 30 seconds      *
               TRAP=OFF,              DFHXCTRA - OFF                   *
               GTF=OFF,               GTF - OFF                        *
               MSGCASE=MIXED,         Mixed case messages              *
               CICSSVC=200,           Default CICS Type 3 SVC number   *
               CONFDATA=SHOW,         Show user commarea data in trace *
               ABENDBKOUT=NO,         No global backout            @03A*
               XCFGROUP=DFHIR000,     XCFGROUP name                @P4A*
               SURROGCHK=YES,         Perform surrogate-user check @P1C*
               LOCALCCSID=37          Codepage for containers    @R363A
         END   DFHXCOPT
###END DFHXCOPT
$$$BEG CA1DLINK
*ASM XOPTS(EXCI)
***********************************************************************
*   PROGRAM: CA1DLINK - INTERFACE BETWEEN REXX EXEC AND CICS          *
*   LANGUAGE: ASSEMBLER                                               *
*                                                                     *
*   FUNCTION: PROVIDE CICS EXCI DYNAMIC PROGRAM LINK                  *
*                                                                     *
*   FORMAT OF CALL FROM REXX:                                         *
*     CA1DLINK(PROGRAM(PROGRAM_NAME) ,                                *
*              APPLID(VTAM_APPLID) ,                                  *
*              COMMAREA(CA_NAME) ,          OPTIONAL                  *
*              LENGTH(CA_LENGTH) ,          OPTIONAL                  *
*              DATALENGTH(CA_DATALENGTH) ,  OPTIONAL                  *
*              TRANSID(TRANS_ID)            OPTIONAL                  *
*                                                                     *
*   WHERE:                                                            *
*     PROGRAM_NAME IS THE CICS PROGRAM NAME TO BE CALLED              *
*     VTAM_APPLID IS THE VTAM APPLID FOR THE CICS REGION TO ROUTE     *
*       THE REQUEST TO.                                               *
*     CA_NAME IS THE REXX VARIABLE NAME WHICH IS THE COMMAREA DATA    *
*       IF NOT SPECIFIED, THEN ASSUME NO COMMAREA TO BE RETURNED.     *
*     CA_LENGTH IS THE LENGTH OF THE COMMAREA                         *
*       IF NOT SPECIFIED THEN ASSUME LENGTH OF REXX COMMAREA VARIABLE.*
*     CA_DATALENGTH IS THE LENGTH OF THE COMMAREA TO BE PASSED        *
*       STARTING WITH THE FIRST CHARACTER OF THE COMMAREA.            *
*     TRANS_ID IS THE TRANSACTION NAME FOR THE MIRROR TRANSACTION.    *
*       CSMI USED IF NOT ENTERED                                      *
*                                                                     *
*   REXX VARIABLES USED:                                              *
*     CA_NAME WILL BE REPLACED UPON SUCCESSFUL EXECUTION OF THE       *
*       CALLED PROGRAM WITH THE RETURNED COMMAREA.                    *
*     EXCI_RESP IS THE RESP CODE RETURNED BY THE EXCI.  FORMAT IS     *
*       DECIMAL NUMERIC.                                              *
*     EXCI_RESP2 IS THE RESP2 CODE RETURNED BY THE EXCI.  FORMAT IS   *
*       DECIMAL NUMERIC.                                              *
*     EXCI_ABCODE IS THE ABCODE RETURNED BY THE EXCI.  FORMAT IS      *
*       4 BYTES CHARACTER.                                            *
*     EXCI_MESSAGE IS ANY MESSAGE RETURNED BY THE EXCI.  THIS AREA    *
*       WILL CONTAIN A NULL STRING IF CICS DOES NOT RETURN A MESSAGE. *
*                                                                     *
*   RETURN CODES: (RESULT)                                            *
*     -1 = PROGRAM NAME NOT SPECIFIED OR INVALID                      *
*     -2 = VTAM APPLID NOT SPECIFIED OR INVALID                       *
*     -3 = COMMAREA NOT AVAILABLE                                     *
*     -4 = LOAD OF IRXEXCOM FAILED                                    *
*     -5 = INVALID PARAMETER TYPE ENTERED                             *
*     -6 = TRANSID INVALID                                            *
*     -7 = LENGTH INVALID                                             *
*     -8 = DATALENGTH INVALID                                         *
*     -9 = INVALID REXX NAME FOR COMMAREA SPECIFIED                   *
*      0 = PROGRAM RECEIVED NORMAL RETURN FROM EXEC CICS EXCI         *
*          EXCI_... VARIABLES CONTAIN RESULTING RETURN CODES          *
*          (SEE EXTERNAL CICS INTERFACE FOR RETURNED VARIABLES.)      *
*                                                                     *
*   REGISTER USAGE:                                                   *
*      1 - WORK REGISTER                                              *
*      2 - POINTER TO PARAMETERS PASSED BY REXX                       *
*      9 - BRANCH AND LINK REGISTER TO SUBROUTINES                    *
*     12 - BASE REGISTER                                              *
*     13 - DFHEISTG REGISTER (DYNAMIC STORAGE AREA)                   *
*     14 - WORK REGISTER                                              *
*     15 - WORK REGISTER                                              *
***********************************************************************
***********************************************************************
*   INCLUDE THE STANDARD COPYBOOKS FOR EXCI DSECTS                    *
***********************************************************************
          COPY DFHXCRCD
          EJECT
          COPY DFHXCPLD
          EJECT
***********************************************************************
*   INCLUDE THE REXX COPYBOOKS FOR DSECTS                             *
***********************************************************************
          IRXSHVB                 SHARED VARIABLE BLOCK
          EJECT
          IRXEVALB                EVALUATION BLOCK
          EJECT
          IRXEFPL                 EXTERNAL FUNCTION PARAMETER LIST
          EJECT
          IRXARGTB                PARSED PARAMETER ARGUMENT LIST
          EJECT
***********************************************************************
*        CA1DLINK PROGRAM START                                       *
***********************************************************************
CA1DLINK DFHEIENT CODEREG=(12),DATAREG=(13)
CA1DLINK AMODE 31
CA1DLINK RMODE ANY
         LR    2,1                SET R2 TO PARM REG
         USING EFPL,2             SET ADDRESSABILITY
         L     1,DFHEISTG+4       LOAD OLD SAVEAREA ADDRESS
         L     1,20(0,1)          LOAD REXX ENVBLOCK ADDRESS
         ST    1,ENVBADDR         SAVE REXX ENVBLOCK ADDRESS
***********************************************************************
*        MAIN CODE FOR PROGRAM                                        *
***********************************************************************
         SR    1,1                CLEAR WORK REGISTER
         ST    1,RETCODE          SET ZERO RETURN CODE
         ST    1,BUFADDR          SET ZERO ADDRESS
         BAL   9,LOAD_IRXEXCOM    GO GET IRXEXCOM ROUTINE ADDRESS
         BAL   9,PARSEPRM         GO PARSE PARAMETERS
         BAL   9,GETBUFF          GET BUFFER FOR COMMAREA
         L     1,CANAMEP          LOAD POINTER TO COMMAREA NAME
         LTR   1,1                ANY POINTER THERE?
         BZ    CALL               ..NO, SKIP GETTING COMMAREA
         BAL   9,GETCA            GET COMMAREA FROM REXX
CALL     DS    0H
         BAL   9,CALLCICS         ISSUE EXCI LINK TO CICS
         BAL   9,REXXOUT          GO FORMAT AND WRITE REXX VARIABLES
***********************************************************************
*        RETURN PARSE ERROR TO CALLER                                 *
***********************************************************************
RETURN   DS    0H
         L     1,RETCODE          LOAD RESPONSE CODE
         BAL   9,CVT_NUM          CONVERT TO REXX VALUE
         L     3,EFPLEVAL
         L     3,0(0,3)           LOAD EVALBLOCK ADDRESS
         USING EVALBLOCK,3        ESTABLISH ADDRESSABILITY
         L     14,EVALBLOCK_EVSIZE                LOAD BLOCK SIZE
         SLL   14,3                               MULTIPLY BY 8
         S     14,=F'16'                          REDUCE BY 16
         C     14,=F'16'                          IS AREA > 16?
         BL    RETURN9                      ..NO, DO NOT SET EVALBLOCK
         MVC   EVALBLOCK_EVDATA(16),CHARNUM       MOVE IN VALUE
         MVC   EVALBLOCK_EVLEN,CHARNUM_LEN        SET LENGTH OF VALUE
         DROP  3
RETURN9  DS    0H
***********************************************************************
*        RETURN TO CALLER                                             *
***********************************************************************
         BAL   9,FREEBUFF         FREE AREA FOR COMMAREA
         SR    15,15              SET RETURN CODE TO ZERO
         DFHEIRET RCREG=(15)
         EJECT
***********************************************************************
*   GETMAIN AREA TO BE USED FOR COMMAREA                              *
*                                                                     *
*   REGISTER USAGE:                                                   *
*      0 - LENGTH OF AREA TO GETMAIN                                  *
*      1 - RETURNED ADDRESS OF AREA                                   *
*      9 - RETURN TO CALLER ADDRESS                                   *
*     14 - WORK REGISTER                                              *
*     15 - WORK REGISTER AND RETURN CODE                              *
***********************************************************************
GETBUFF  DS    0H
         L     0,=F'32768'        GET AREA FOR MAX COMMAREA
         GETMAIN R,LV=(0)         GET THE AREA
         ST    1,BUFADDR          SAVE BUFFER AREA ADDRESS
         BR    9                  RETURN TO CALLER
         SPACE 2
***********************************************************************
*   FREEMAIN AREA USED FOR COMMAREA                                   *
*                                                                     *
*   REGISTER USAGE:                                                   *
*      0 - LENGTH OF AREA TO FREEMAIN                                 *
*      1 - ADDRESS OF AREA TO FREEMAIN                                *
*      9 - RETURN TO CALLER ADDRESS                                   *
*     14 - WORK REGISTER                                              *
*     15 - WORK REGISTER AND RETURN CODE                              *
***********************************************************************
FREEBUFF DS    0H
         L     0,=F'32768'        GET AREA FOR MAX COMMAREA
         L     1,BUFADDR          LOAD ADDRESS OF BUFFER
         LTR   1,1                IS THERE AN ADDRESS TO FREE?
         BZR   9                  ..NO, RETURN TO CALLER
         FREEMAIN R,LV=(0),A=(1)  FREE THE AREA
         BR    9                  RETURN TO CALLER
         EJECT
***********************************************************************
*   FORMAT SHVBLOCKS AND WRITE REXX VARIABLES                         *
*                                                                     *
*   REGISTER USAGE:                                                   *
*      0 - LENGTH OF AREA TO FREEMAIN                                 *
*      1 - ADDRESS OF AREA TO FREEMAIN                                *
*      9 - RETURN TO CALLER ADDRESS AND BRANCH AND LINK REGISTER      *
*     14 - WORK REGISTER                                              *
*     15 - WORK REGISTER                                              *
***********************************************************************
REXXOUT  DS    0H
*
*        FORMAT BLOCK 0 (EXCI_RESP)
*
         ST    9,REXXOUT_RET      SAVE RETURN ADDRESS
         LA    14,EXCI_RESP       LOAD NAME POINTER
         ST    14,NAMEPTR         SAVE
         L     14,EXCI_RESP_L     LOAD NAME LENGTH
         ST    14,NAMELEN         SAVE
         L     1,RCRESP           LOAD VALUE POINTER
         BAL   9,CVT_NUM          CONVERT TO REXX VALUE
         MVC   RCRESPC,CHARNUM    SAVE CHARACTER VALUE OF RCRESP
         LA    14,RCRESPC         POINT TO CHARACTER AREA
         ST    14,VALUPTR         SAVE
         L     14,CHARNUM_LEN     LOAD VALUE LENGTH
         ST    14,VALULEN         SAVE
         SR    14,14              SET 0 BLOCK INDICATOR
         ST    14,SHVBKID         SAVE
         BAL   9,FORMAT_SHVB      GO FORMAT BLOCK
*
*        FORMAT BLOCK 1 (EXCI_RESP2)
*
         LA    14,EXCI_RESP2      LOAD NAME POINTER
         ST    14,NAMEPTR         SAVE
         L     14,EXCI_RESP2_L    LOAD NAME LENGTH
         ST    14,NAMELEN         SAVE
         L     1,RCRESP2          LOAD VALUE POINTER
         BAL   9,CVT_NUM          CONVERT TO REXX VALUE
         MVC   RCRESP2C,CHARNUM   SAVE CHARACTER VALUE OF RCRESP
         LA    14,RCRESP2C        POINT TO RETURNED VALUE
         ST    14,VALUPTR         SAVE
         L     14,CHARNUM_LEN     LOAD VALUE LENGTH
         ST    14,VALULEN         SAVE
         L     14,SHVBKID         LOAD CURRENT BLOCK INDICATOR
         LA    14,1(14)           INCREMENT BY 1
         ST    14,SHVBKID         SAVE
         BAL   9,FORMAT_SHVB      GO FORMAT BLOCK
*
*        FORMAT BLOCK 2 (EXCI_ABCODE)
*
         LA    14,EXCI_ABCODE     LOAD NAME POINTER
         ST    14,NAMEPTR         SAVE
         L     14,EXCI_ABCODE_L   LOAD NAME LENGTH
         ST    14,NAMELEN         SAVE
         LA    14,RCABCODE        LOAD VALUE POINTER
         ST    14,VALUPTR         SAVE
         L     14,=F'4'           LOAD VALUE LENGTH
         ST    14,VALULEN         SAVE
         L     14,SHVBKID         LOAD CURRENT BLOCK INDICATOR
         LA    14,1(14)           INCREMENT BY 1
         ST    14,SHVBKID         SAVE
         BAL   9,FORMAT_SHVB      GO FORMAT BLOCK
*
*        FORMAT BLOCK 3 (EXCI_MESSAGE)
*
         LA    14,EXCI_MESSAGE    LOAD NAME POINTER
         ST    14,NAMEPTR         SAVE
         L     14,EXCI_MESSAGE_L  LOAD NAME LENGTH
         ST    14,NAMELEN         SAVE
         LA    14,RCMSGPTR        LOAD VALUE POINTER
         ST    14,VALUPTR         SAVE
         L     14,RCMSGLEN        LOAD MESSAGE LENGTH
         ST    14,VALULEN         SAVE VALUE LENGTH
         L     14,SHVBKID         LOAD CURRENT BLOCK INDICATOR
         LA    14,1(14)           INCREMENT BY 1
         ST    14,SHVBKID         SAVE
         BAL   9,FORMAT_SHVB      GO FORMAT BLOCK
*
*        FORMAT BLOCK 4 (COMMAREA)
*
         L     15,CA_LENGTH       LOAD COMMAREA LENGTH
         LTR   15,15              ANY AREA SPECIFIED?
         BZ    REXXOUT9           ..NO, FINISHED FORMATTING
         L     14,CANAMEP         LOAD PTR TO NAME
         ST    14,NAMEPTR         SAVE
         L     14,CANAMEL         LOAD LENGTH OF NAME
         ST    14,NAMELEN         SAVE
         L     14,BUFADDR         LOAD PTR TO COMMAREA
         ST    14,VALUPTR         SAVE
         L     14,CA_LENGTH       LOAD VALUE LENGTH
         ST    14,VALULEN         SAVE
         L     14,SHVBKID         LOAD CURRENT BLOCK INDICATOR
         LA    14,1(14)           INCREMENT BY 1
         ST    14,SHVBKID         SAVE
         ST    14,SHVBKID         SAVE
         BAL   9,FORMAT_SHVB      GO FORMAT BLOCK
REXXOUT9 DS    0H
         BAL   9,WRITE_REXX       GO WRITE REXX VARIABLES
         L     9,REXXOUT_RET      LOAD RETURN ADDRESS
         BR    9                  RETURN TO CALLER
         EJECT
***********************************************************************
*   PARSE PARAMETERS PASSED FROM REXX                                 *
*                                                                     *
*   FORMAT FOR CALL FROM REXX EXEC IS:                                *
*                                                                     *
*   X = CA1DLINK( PROGRAM(PGMNAME),                                   *
*                 APPLID(APPL_ID),                                    *
*                 COMMAREA(CA_VARNAME),           OPTIONAL            *
*                 TRANSID(TRAN_ID),               OPTIONAL            *
*                 DATALENGTH(DATA_LENGTH_VALUE),  OPTIONAL            *
*               )                                                     *
*                                                                     *
*   WHERE:                                                            *
*                                                                     *
*     PGMNAME IS THE NAME OF THE CICS PROGRAM TO LINK TO              *
*     CA_VARNAME IS THE NAME OF THE REXX VARIABLE WHICH IS THE        *
*       THE COMMAREA                                                  *
*     TRAN_ID IS THE TRANSACTION ID FOR THE MIRROR                    *
*     APPL_ID IS THE VTAM APPLID OF THE CICS REGION TO ROUTE TO       *
*     DATA_LENGTH_VALUE IS THE DATALENGTH TO PASS FOR THE COMMAREA    *
*                                                                     *
*   REGISTER USAGE:                                                   *
*      0 - WORK REGISTER                                              *
*      1 - WORK REGISTER                                              *
*      3 - ARGUMENT TABLE POINTER                                     *
*      4 - ARGUMENT POINTER                                           *
*      5 - ARGUMENT LENGTH                                            *
*      6 - WORK REGISTER                                              *
*      7 - WORK REGISTER                                              *
*      9 - RETURN REGISTER                                            *
*     15 - WORK REGISTER                                              *
***********************************************************************
PARSEPRM DS    0H
         L     3,EFPLARG          POINT TO ARGS TABLE
         USING ARGTABLE_ENTRY,3   ESTABLISH ADDRESSABILITY
*        INITIALIZE FIELDS
         MVC   PGMNAME,=CL8' '    CLEAR AREA WITH BLANKS
         MVC   APPLID,=CL8' '     CLEAR AREA WITH BLANKS
         MVC   TRANSID,=CL4' '    CLEAR AREA WITH BLANKS
         SR    15,15              CLEAR REG 15
         ST    15,RETCODE         SET GOOD RETURN CODE
         ST    15,CANAMEP         SAVE IN CA NAME PTR
         ST    15,CANAMEL         SAVE IN CA NAME LENGTH
         ST    15,CA_LENGTH       SAVE IN LENGTH VALUE
         ST    15,CA_DATALENGTH   SAVE IN DATALENGTH VALUE
         ST    15,CA_RETVD_LEN    SAVE RETRIEVED COMMAREA LENGTH
PARS001  DS    0H                 START OF LOOP
         CLC   ARGTABLE_ARGSTRING_PTR(8),=XL8'FFFFFFFFFFFFFFFF'
         BE    PARS080            ALL PARAMETERS PROCESSED
         L     4,ARGTABLE_ARGSTRING_PTR     LOAD POINTER TO ARGUMENT
         L     5,ARGTABLE_ARGSTRING_LENGTH  LOAD ARGUMENT LENGTH
         LTR   5,5                TEST FOR ZERO LENGTH
         BZ    PARS070            ZERO LENGTH, GO TO NEXT ARGUMENT
         LR    6,4                SAVE STARTING ADDRESS
         SR    7,7                CLEAR PARM PIECE LENGTH
PARS002  DS    0H                 START OF LOOP
         CLI   0(4),C' '          LOOK FOR LEADING BLANKS
         BNE   PARS003            NOT A BLANK, CONTINUE
         LA    4,1(0,4)           BLANK SKIP IT
         LR    6,4                SAVE NEW STARTING POSITION
         BCT   5,PARS002          GO LOOK AT NEXT CHARACTER
         B     PARS070            NO MORE CHARACTERS LEFT
PARS003  DS    0H
         CLI   0(4),C'('          LOOK FOR OPEN PAREN
         BE    PARS010            FOUND OPEN PAREN
         LA    4,1(0,4)           POINT TO NEXT CHARACTER
         LA    7,1(0,7)           INCREASE COUNT OF CHARS
         BCT   5,PARS003          LOOK AT NEXT CHARACTER
         B     PARS070            NO '(' FOUND, GO TO NEXT ARGUMENT
PARS010  DS    0H
         CLC   =CL7'PROGRAM',0(6) PROGRAM PARAMETER?
         BNE   PARS011            NO, CHECK FOR NEXT TYPE
         MVI   TYPEFLG,C'P'       SET FOR PROGRAM NAME
         B     PARS020            GO CHECK FOR VALUE
PARS011  DS    0H
         CLC   =CL8'COMMAREA',0(6) COMMAREA PARAMETER?
         BNE   PARS012            NO, CHECK FOR NEXT TYPE
         MVI   TYPEFLG,C'C'       SET FOR COMMAREA NAME
         B     PARS020            GO CHECK FOR VALUE
PARS012  DS    0H
         CLC   =CL6'APPLID',0(6)  APPLID PARAMETER?
         BNE   PARS013            NO, CHECK FOR NEXT TYPE
         MVI   TYPEFLG,C'A'       SET FOR APPLID NAME
         B     PARS020            GO CHECK FOR VALUE
PARS013  DS    0H
         CLC   =CL10'DATALENGTH',0(6)  DATALENGTH PARAMETER?
         BNE   PARS014            NO, CHECK FOR NEXT TYPE
         MVI   TYPEFLG,C'D'       SET FOR DATALENGTH NAME
         B     PARS020            GO CHECK FOR VALUE
PARS014  DS    0H
         CLC   =CL6'LENGTH',0(6)  LENGTH PARAMETER?
         BNE   PARS015            NO, CHECK FOR NEXT TYPE
         MVI   TYPEFLG,C'L'       SET FOR LENGTH NAME
         B     PARS020            GO CHECK FOR VALUE
PARS015  DS    0H
         CLC   =CL7'TRANSID',0(6) TRANSID PARAMETER?
         BNE   PARS016            NO, INVALID PARAMETER TYPE
         MVI   TYPEFLG,C'T'       SET FOR TRANSID NAME
         B     PARS020            GO CHECK FOR VALUE
PARS016  DS    0H
         MVC   RETCODE,=F'-5'     SET INVALID PARAMETER TYPE
         B     PARS099
PARS020  DS    0H
         LA    4,1(0,4)           POINT TO NEXT CHARACTER
         LR    6,4                SAVE STARTING ADDRESS
         SR    7,7                CLEAR PARM PIECE LENGTH
         BCT   5,PARS021          DECREASE COUNT BY 1
         B     PARS070            NONE, GO TO NEXT ARGUMENT
PARS021  DS    0H
         CLI   0(4),C')'          LOOK FOR CLOSE PAREN
         BE    PARS030            FOUND CLOSE PAREN
         LA    4,1(0,4)           POINT TO NEXT CHARACTER
         LA    7,1(0,7)           INCREASE COUNT OF CHARS
         BCT   5,PARS021          LOOK AT NEXT CHARACTER
         B     PARS070            NO ')' FOUND, GO TO NEXT ARGUMENT
PARS030  DS    0H
         CLI   TYPEFLG,C'P'       PROGRAM PARAMETER?
         BNE   PARS031            NO, GO TO THE NEXT TYPE
         LTR   7,7                ANY CHARACTERS FOUND?
         BZ    PARS050            NO, INVALID PROGRAM NAME
         C     7,=F'8'            IS NAME > 8 CHARACTERS
         BH    PARS050            YES, INVALID PROGRAM NAME
         BCTR  7,0                DECREASE FOR EX INSTRUCTION
         EX    7,MVCPGMN          SAVE PROGRAM NAME
         B     PARS040            GO TO NEXT ARGUMENT
MVCPGMN  MVC   PGMNAME(0),0(6)    SAVE PROGRAM NAME
PARS031  DS    0H
         CLI   TYPEFLG,C'A'       APPLID PARAMETER?
         BNE   PARS032            NO, GO TO THE NEXT TYPE
         LTR   7,7                ANY CHARACTERS FOUND?
         BZ    PARS051            NO, INVALID APPLID
         C     7,=F'8'            IS NAME > 8 CHARACTERS
         BH    PARS051            YES, INVALID APPLID
         BCTR  7,0                DECREASE FOR EX INSTRUCTION
         EX    7,MVCAPPL          SAVE APPLID NAME
         B     PARS040            GO TO NEXT ARGUMENT
MVCAPPL  MVC   APPLID(0),0(6)     SAVE APPLID NAME
PARS032  DS    0H
         CLI   TYPEFLG,C'T'       TRANSID PARAMETER?
         BNE   PARS033            NO, GO TO THE NEXT TYPE
         LTR   7,7                ANY CHARACTERS FOUND?
         BZ    PARS052            NO, INVALID TRANSID
         C     7,=F'4'            IS NAME > 4 CHARACTERS
         BH    PARS052            YES, INVALID TRANSID
         BCTR  7,0                DECREASE FOR EX INSTRUCTION
         EX    7,MVCTRAN          SAVE TRANSID NAME
         B     PARS040            GO TO NEXT ARGUMENT
MVCTRAN  MVC   TRANSID(0),0(6)    SAVE TRANSID NAME
PARS033  DS    0H
         CLI   TYPEFLG,C'C'       COMMAREA PARAMETER?
         BNE   PARS034            NO, GO TO THE NEXT TYPE
         LTR   7,7                ANY CHARACTERS SPECIFIED?
         BZ    PARS055            NO, REXX NAME NOT SPECIFIED
         ST    6,CANAMEP          SAVE PTR TO CA NAME
         ST    7,CANAMEL          SAVE CA NAME LENGTH
         B     PARS040
PARS034  DS    0H
         CLI   TYPEFLG,C'L'       LENGTH PARAMETER?
         BNE   PARS035            NO, GO TO THE NEXT ARGUMENT
         LTR   7,7                ANY CHARACTERS SPECIFIED?
         BZ    PARS053            NO, DEFAULT TO NO LENGTH ENTERED
         C     7,=F'5'            MORE THAN 5 CHARACTERS SPECIFIED?
         BH    PARS053            YES, INVALID LENGTH SPECIFIED
         BCTR  7,0
         EX    7,PACKINST         PACK INTO AREA
         CVB   7,PACKDATA         CONVERT TO BINARY
         C     7,=F'32768'        IS LENGTH > 32768?
         BH    PARS053            YES, INVALID LENGTH SPECIFIED
         ST    7,CA_LENGTH        SET TO IGNORE LENGTH
         B     PARS040            GO TO NEXT ARGUMENT
PACKINST PACK  PACKDATA,0(0,6)    CONVERT TO PACKED FORMAT
PARS035  DS    0H
         CLI   TYPEFLG,C'D'       DATALENGTH PARAMETER?
         BNE   PARS040            NO, GO TO THE NEXT ARGUMENT
         LTR   7,7                ANY CHARACTERS SPECIFIED?
         BZ    PARS054            NO, INVALID DATALENGTH
         C     7,=F'5'            MORE THAN 5 CHARACTERS SPECIFIED?
         BH    PARS054            YES, INVALID DATALENGTH
         BCTR  7,0
         EX    7,PACKINST         PACK INTO AREA
         CVB   7,PACKDATA         CONVERT TO BINARY
         C     7,=F'32768'        IS LENGTH > 32768?
         BH    PARS054            YES, INVALID DATALENGTH
         ST    7,CA_DATALENGTH    SET TO IGNORE DATALENGTH
         B     PARS040            GO TO NEXT ARGUMENT
PARS040  DS    0H
         LA    4,1(0,4)           POINT TO NEXT CHARACTER
         BCT   5,PARS002          LOOK AT NEXT CHARACTER
         B     PARS070            NO ')' FOUND, GO TO NEXT ARGUMENT
PARS050  DS    0H
         MVC   RETCODE,=F'-1'     INVALID PROGRAM NAME SPECIFIED
         B     PARS099
PARS051  DS    0H
         MVC   RETCODE,=F'-2'     INVALID APPLID SPECIFIED
         B     PARS099
PARS052  DS    0H
         MVC   RETCODE,=F'-6'     INVALID TRANSID SPECIFIED
         B     PARS099
PARS053  DS    0H
         MVC   RETCODE,=F'-7'     INVALID LENGTH SPECIFIED
         B     PARS099
PARS054  DS    0H
         MVC   RETCODE,=F'-8'     INVALID DATALENGTH SPECIFIED
         B     PARS099
PARS055  DS    0H
         MVC   RETCODE,=F'-9'     INVALID COMMAREA REXX NAME SPECIFIED
         B     PARS099
PARS070  DS    0H
         LA    3,8(0,3)           POINT TO NEXT ARGUMENT
         B     PARS001            PROCESS NEXT ARGUMENT
PARS080  DS    0H
         CLC   PGMNAME,=CL8' '    WAS PROGRAM NAME ENTERED?
         BNE   PARS081            YES, CONTINUE
         MVC   RETCODE,=F'-1'     SET RETURN CODE
         B     PARS099            RETURN ERROR CODE
PARS081  DS    0H
         CLC   APPLID,=CL8' '     WAS APPLID ENTERED?
         BNE   PARS082            YES, CONTINUE
         MVC   RETCODE,=F'-2'     SET RETURN CODE
         B     PARS099            RETURN ERROR CODE
PARS082  DS    0H
         CLC   CA_LENGTH,=F'0'    WAS LENGTH SPECIFIED?
         BE    PARS099            ..NO, DO NOT CHECK DATALENGTH
         CLC   CA_DATALENGTH,=F'0'  WAS DATALENGTH SPECIFIED?
         BNE   PARS084            ..NO, THEN SET DATALENGTH TO LENGTH
         MVC   CA_LENGTH,CA_DATALENGTH  SET DATALENGTH = LENGTH
         B     PARS099
PARS084  DS    0H                 LENGTH SPECIFIED
         CLC   CA_LENGTH,CA_DATALENGTH  MAKE SURE LENGTH ^< DATALENGTH
         BNL   PARS099            LENGTHS SPECIFIED ARE OK
         MVC   RETCODE,=F'-8'     SET INVALID DATALENGTH SPECIFIED
         B     PARS099            RETURN ERROR CODE
PARS099  DS    0H
         CLC   RETCODE,=F'0'      PARSE ERRORS?
         BNE   RETURN             ..YES, RETURN ERROR CODE
         BR    9                  RETURN TO CALLER
***********************************************************************
*   GET ADDRESS TO IRXEXCOM ROUTINE                                   *
*                                                                     *
*   REGISTER USAGE:                                                   *
*      0 - ENTRY POINT OF LOADED ROUTINE                              *
*      1 - WORK REGISTER                                              *
*      9 - RETURN TO CALLER ADDRESS                                   *
*     14 - WORK REGISTER                                              *
*     15 - RETURN CODE FROM LOAD                                      *
***********************************************************************
LOAD_IRXEXCOM  DS 0H
         LOAD  EP=IRXEXCOM        LOAD REXX VARIABLE ACCESS ROUTINE
         LTR   15,15              WAS LOAD SUCCESSFUL?
         BZ    LOAD1              YES
         MVC   RETCODE,=F'-4'     SET LOAD ERROR RETURN CODE
         B     RETURN             RETURN ERROR MESSAGE
LOAD1    DS    0H
         LR    15,0               LOAD ENTRY POINT ADDRESS
         ST    15,IRXEXCOM_ADDR   SAVE FOR OTHER USES
         BR    9                  RETURN TO CALLER
***********************************************************************
*   CALL IRXEXCOM TO RETRIEVE REXX VARIABLE CONTENTS                  *
*                                                                     *
*   REGISTER USAGE:                                                   *
*      1 - WORK REGISTER                                              *
*      4 - POINTER TO SHVBLOCK                                        *
*      9 - RETURN TO CALLER ADDRESS                                   *
*     14 - WORK REGISTER                                              *
*     15 - BRANCH REGISTER AND RETURN CODE                            *
***********************************************************************
GETCA    DS    0H
         LA    4,IRXSHVB0         POINT TO FIRST SHVBLOCK
         USING SHVBLOCK,4         ESTABLISH ADDRESSABILITY
         SR    14,14              CLEAR REGISTER
         ST    14,SHVNEXT         SET NO MORE SHVBLOCKS
         ST    14,SHVUSER         INITIALIZE USER FIELD
         MVI   SHVCODE,SHVFETCH   SET CODE TO FETCH VARIABLE
         L     14,CANAMEP         LOAD VAR NAME PTR
         ST    14,SHVNAMA         SAVE IN SHVBLOCK
         L     14,CANAMEL                    LOAD VAR NAME LENGTH
         ST    14,SHVNAML         SET VARIABLE NAME LENGTH
         L     14,BUFADDR         LOAD COMMAREA BUFFER PTR
         ST    14,SHVVALA         SAVE IN SHVBLOCK
         L     14,=F'32768'       LOAD COMMAREA BUFFER LENGTH
         ST    14,SHVBUFL         SAVE IN SHVBLOCK
         LA    1,IRXNAME          POINT TO IRXNAME PARAMETER
         ST    1,EXP1ADDR         SAVE IN 1ST ADDRESS
         SR    1,1                CLEAR REG 1
         ST    1,EXP2ADDR         SAVE IN 2ND ADDRESS
         ST    1,EXP3ADDR         SAVE IN 3RD ADDRESS
         LA    1,IRXSHVB0         POINT TO SHVBLOCK
         ST    1,EXP4ADDR         SAVE IN 4TH ADDRESS
         LA    1,ENVBADDR         POINT TO CALLERS ENVIRONMENT BLOCK
         ST    1,EXP5ADDR         SAVE IN 5TH ADDRESS
         LA    1,RETCODE          POINT TO RETURN CODE AREA
         O     1,=X'80000000'     SET LAST ADDRESS
         ST    1,EXP6ADDR         SAVE IN 5TH ADDRESS
         LA    1,EXCOMPRM         POINT TO PARAMETER ADDRESSES
         L     15,IRXEXCOM_ADDR   LOAD ADDRESS OF IRXEXCOM
         BASSM 14,15              GO GET THE REXX VARIABLE
         LTR   15,15              SUCCESSFUL?
         BNZ   GETCA90            ..NO, SET ERROR AND RETURN
         CLI   SHVRET,SHVCLEAN    INDIVIDUAL RETURN CODE GOOD?
         BNE   GETCA90            ..NO, SET ERROR AND RETURN
         CLI   SHVRET,SHVNEWV     VARIABLE DID NOT EXIST?
         BE    GETCA89            ..YES, SET TO ZERO LENGTH
         L     14,SHVVALL         LOAD RETRIEVED LENGTH
         ST    14,CA_RETVD_LEN    SAVE FOR LATER USE
GETCA89  DS    0H
         BR    9                  RETURN TO CALLER
GETCA90  DS    0H
         L     14,=F'-3'          SET INVALID COMMAREA RETURN CODE
         ST    14,RETCODE         SAVE IT IN RETCODE
         B     RETURN             RETURN ERROR CODE
         DROP  4
***********************************************************************
*   FORMAT SHARED VARIABLE BLOCK FOR STORE REQUEST                    *
*                                                                     *
*   REGISTER USAGE:                                                   *
*      0 - LENGTH OF AREA TO FREEMAIN                                 *
*      1 - ADDRESS OF AREA TO FREEMAIN                                *
*      9 - RETURN TO CALLER ADDRESS AND BRANCH AND LINK REGISTER      *
*     14 - WORK REGISTER                                              *
*     15 - WORK REGISTER                                              *
***********************************************************************
FORMAT_SHVB    DS 0H
         L     14,SHVBKID         LOAD SHVB ID TO FORMAT
         SLL   14,5               MULTIPLY BY 32 (LENGTH OF BLOCK)
         LA    4,IRXSHVB0         POINT TO FIRST BLOCK
         AR    4,14               ADD DISPLACEMENT
         LTR   14,14              ANY DISPLACEMENT?
         BZ    FORMAT1            ..NO SKIP CHAIN POINTER SET
         LR    15,4               LOAD SHVBLOCK ADDRESS
         S     15,=F'32'          POINT TO PRECEEDING BLOCK
         USING SHVBLOCK,15        ESTABLISH ADDRESSABILITY
         ST    4,SHVNEXT          SET CHAIN POINTER IN PREV BLOCK
         DROP  15
FORMAT1  DS    0H
         USING SHVBLOCK,4         ESTABLISH ADDRESSABILITY
         SR    14,14              ZERO REGISTER
         ST    14,SHVNEXT         SET NO MORE SHVBLOCKS
         ST    14,SHVUSER         INITIALIZE USER FIELD
         MVI   SHVCODE,SHVSTORE   SET CODE TO STORE VARIABLE
         L     14,NAMEPTR         LOAD VARIABLE NAME PTR
         ST    14,SHVNAMA         SAVE IN SHVBLOCK
         L     14,NAMELEN         LOAD VARIABLE NAME LEN
         ST    14,SHVNAML         SAVE IN SHVBLOCK
         L     14,VALUPTR         LOAD VALUE PTR
         ST    14,SHVVALA         SAVE IN SHVBLOCK
         L     14,VALULEN         LOAD VALUE LENGTH
         ST    14,SHVVALL         SAVE IN SHVBLOCK
         DROP  4
         BR    9                  RETURN TO CALLER
***********************************************************************
*   CALL IRXEXCOM TO STORE A REXX VARIABLE CONTENTS                   *
*                                                                     *
*   REGISTER USAGE:                                                   *
*      1 - WORK REGISTER                                              *
*      9 - RETURN TO CALLER ADDRESS                                   *
*     14 - WORK REGISTER                                              *
*     15 - BRANCH REGISTER AND RETURN CODE                            *
***********************************************************************
WRITE_REXX  DS 0H
         LA    1,IRXNAME          POINT TO IRXNAME PARAMETER
         ST    1,EXP1ADDR         SAVE IN 1ST ADDRESS
         SR    1,1                CLEAR REG 1
         ST    1,EXP2ADDR         SAVE IN 2ND ADDRESS
         ST    1,EXP3ADDR         SAVE IN 3RD ADDRESS
         LA    1,IRXSHVB0         POINT TO SHVBLOCK
         ST    1,EXP4ADDR         SAVE IN 4TH ADDRESS
         LA    1,ENVBADDR         POINT TO CALLERS ENVIRONMENT BLOCK
         ST    1,EXP5ADDR         SAVE IN 5TH ADDRESS
         LA    1,RETCODE          POINT TO RETURN CODE AREA
         O     1,=X'80000000'     SET LAST ADDRESS
         ST    1,EXP6ADDR         SAVE IN 5TH ADDRESS
         LA    1,EXCOMPRM         POINT TO PARAMETER ADDRESSES
         L     15,IRXEXCOM_ADDR
         BASSM 14,15              GO WRITE THE REXX VARIABLES
         BR    9                  RETURN TO CALLER
***********************************************************************
*   ROUTINE TO ISSUE EXCI LINK TO CICS                                *
*                                                                     *
*   REGISTER USAGE:                                                   *
*      1 - WORK REGISTER                                              *
*      3 - POINTER TO EVALBLOCK TO RETURN TO REXX                     *
*      7 - POINTER TO COMMAREA TO PASS                                *
*      9 - RETURN TO CALLER ADDRESS                                   *
*     14 - WORK REGISTER                                              *
*     15 - BRANCH REGISTER AND RETURN CODE                            *
***********************************************************************
CALLCICS DS    0H
         L     1,CANAMEP          SEE IF THERE IS A COMMAREA
         LTR   1,1
         BZ    CALL3              ..NO, DON'T USE COMMAREA
         CLC   CA_LENGTH,=F'0'    CHECK TO SEE IF LENGTH SPECIFIED
         BNE   CALL1              USE LENGTH SPECIFIED
         L     14,CA_RETVD_LEN    LOAD COMMAREA RETRIEVED LENGTH
         ST    14,CA_LENGTH       SET COMMAREA LENGTH TO REXX VARIABLE
         ST    14,CA_DATALENGTH   SET COMMAREA DATALENGTH TO REXX VAR
CALL1    DS    0H
         CLC   TRANSID,=CL4' '    IS TRANSID SPECIFIED?
         BNE   CALL2              ..YES, CALL WITH TRANSID SPECIFIED
         L     7,BUFADDR          LOAD POINTER TO COMMAREA
         EXEC CICS LINK PROGRAM(PGMNAME)                               X
               RETCODE(RCAREA)                                         X
               COMMAREA(0(0,7))                                        X
               LENGTH(CA_LENGTH+2)                                     X
               DATALENGTH(CA_DATALENGTH+2)                             X
               APPLID(APPLID)                                          X
               SYNCONRETURN
         B     CALLEND            CONTINUE
CALL2    DS    0H
         L     7,BUFADDR          LOAD POINTER TO COMMAREA
         EXEC CICS LINK PROGRAM(PGMNAME)                               X
               RETCODE(RCAREA)                                         X
               COMMAREA(0(0,7))                                        X
               LENGTH(CA_LENGTH+2)                                     X
               DATALENGTH(CA_DATALENGTH+2)                             X
               APPLID(APPLID)                                          X
               TRANSID(TRANSID)                                        X
               SYNCONRETURN
         B     CALLEND            CONTINUE
CALL3    DS    0H
         CLC   TRANSID,=CL4' '    IS TRANSID SPECIFIED?
         BNE   CALL4              ..YES, CALL WITH TRANSID SPECIFIED
         EXEC CICS LINK PROGRAM(PGMNAME)                               X
               RETCODE(RCAREA)                                         X
               APPLID(APPLID)                                          X
               SYNCONRETURN
         B     CALLEND            CONTINUE
CALL4    DS    0H
         EXEC CICS LINK PROGRAM(PGMNAME)                               X
               RETCODE(RCAREA)                                         X
               APPLID(APPLID)                                          X
               TRANSID(TRANSID)                                        X
               SYNCONRETURN
***********************************************************************
*        RETURN RETCODE AREAS IN EVALBLOCK                            *
***********************************************************************
CALLEND  DS    0H
         BR    9                  RETURN TO CALLER
***********************************************************************
*   CONVERT BINARY NUMBERS TO REXX NUMBERS                            *
*                                                                     *
*   1 CONTAINS NUMBER TO CONVERT ON ENTRY.                            *
*                                                                     *
*   ON EXIT VARIABLES CHARNUM CONTAINS THE NUMBER                     *
*                     CHARNUM_LEN CONTAINS THE LENGTH                 *
*                                                                     *
*   REGISTER USAGE:                                                   *
*      1 - WORK REGISTER - VALUE TO CONVERT                           *
*      7 - WORK REGISTER - POINTER TO CONVERTED NUMBER (INPUT)        *
*      8 - WORK REGISTER - POINTER TO CONVERTED NUMBER (OUTPUT)       *
*      9 - RETURN TO CALLER ADDRESS                                   *
*     14 - WORK REGISTER                                              *
*     15 - WORK REGISTER - COUNT OF RESULTING CHARACTERS              *
***********************************************************************
CVT_NUM  DS    0H
         LTR   1,1                CHECK FOR ZERO
         BZ    CVT_NUM0           IT'S ZERO
         CVD   1,PACKDATA         CONVERT TO DECIMAL
         UNPK  CHARNUM,PACKDATA   UNPACK DATA
         OI    CHARNUM+15,X'F0'   SET TO NUMERIC CHARACTER
         LA    7,CHARNUM          POINT TO FIRST CHAR POSITION
         LR    8,7                POINT TO FIRST CHAR POSITION
         SR    15,15              SET COUNT TO ZERO
         L     14,=F'15'          SET COUNT OF CHARACTERS
         LTR   1,1                CHECK FOR NEGATIVE NO
         BNM   CVT_NUM1           ..NOT MINUS NO SIGN NEEDED
         MVI   0(8),C'-'          MOVE IN MINUS SIGN
         LA    8,1(0,8)           SET TO NEXT CHARACTER POSITION
         LA    15,1(0,15)         ADD 1 TO COUNT
CVT_NUM1 DS    0H
         LA    7,1(0,7)           INCREMENT POSITION TO NEXT CHAR
         CLI   0(7),C'0'          IS THE CHARACTER ZERO?
         BNE   CVT_NUM2           1ST NON ZERO DETECTED
         BCT   14,CVT_NUM1        CHECK THE NEXT CHARACTER
         DC    H'0'               SHOULD NEVER GET HERE
CVT_NUM2 DS    0H
         AR    15,14              ADJUST FINAL COUNT
         BCTR  14,0               DECREASE COUNT
         EX    14,MOVE_CVT        MOVE CHARACTERS
         ST    15,CHARNUM_LEN     SAVE FINAL COUNT
         BR    9                  RETURN TO CALLER
MOVE_CVT MVC   0(0,8),0(7)        SHIFT CHARACTERS TO LEFT
CVT_NUM0 DS    0H
         MVI   CHARNUM,C'0'       SET TO ZERO
         MVC   CHARNUM_LEN,=F'1'  SET LENGTH TO 1
         BR    9                  RETURN TO CALLER
***********************************************************************
*        CONSTANTS AND LITERALS                                       *
***********************************************************************
IRXNAME  DC    CL8'IRXEXCOM'      'IRXEXCOM' CHARACTER STREAM
EXCI_RESP      DC CL9'EXCI_RESP'  'EXCI_RESP' REXX VARIABLE NAME
EXCI_RESP_L    DC F'9'            'EXCI_RESP' REXX VARIABLE NAME LEN
EXCI_RESP2     DC CL10'EXCI_RESP2' 'EXCI_RESP2' REXX VAR NAME
EXCI_RESP2_L   DC F'10'            'EXCI_RESP2' REXX VAR NAME LEN
EXCI_ABCODE    DC CL11'EXCI_ABCODE' 'EXCI_ABCODE' REXX VAR NAME
EXCI_ABCODE_L  DC F'11'             'EXCI_ABCODE' REXX VAR NAME LEN
EXCI_MESSAGE   DC CL12'EXCI_MESSAGE' 'EXCI_MESSAGE' REXX VAR NAME
EXCI_MESSAGE_L DC F'12'              'EXCI_MESSAGE' REXX VAR NAME LEN
EDIT_PATTERN   DC X'40202020202020202020202020202120' EDIT PATTERN
         LTORG
***********************************************************************
*        DYNAMIC STORAGE AREAS FOR PROGRAM                            *
***********************************************************************
*
DFHEISTG DSECT
***********************************************************************
*        RETURN CODE AREA FOR EXCI RETURN CODES                       *
***********************************************************************
RCAREA   DS    0CL(EXCI_EXEC_RETURN_CODE__LEN)
RCRESP   DS    F                  RETCODE RESP AREA
RCRESP2  DS    F                  RETCODE RESP2 AREA
RCABCODE DS    F                  RETCODE ABCODE AREA
RCMSGLEN DS    F                  RETCODE MSGLEN AREA
RCMSGPTR DS    F                  RETCODE MSGPTR AREA
***********************************************************************
*        PARAMETER LIST FOR IRXEXCOM CALL                             *
***********************************************************************
EXCOMPRM DS    0F                 IRXEXCOM PARAMETER LIST
EXP1ADDR DS    F                  ADDRESS OF 1ST PARAMETER
EXP2ADDR DS    F                  ADDRESS OF 2ND PARAMETER
EXP3ADDR DS    F                  ADDRESS OF 3RD PARAMETER
EXP4ADDR DS    F                  ADDRESS OF 4TH PARAMETER
EXP5ADDR DS    F                  ADDRESS OF 5TH PARAMETER
EXP6ADDR DS    F                  ADDRESS OF 6TH PARAMETER
***********************************************************************
*        PARSE PARAMETER AREAS FROM REXX CALL                         *
***********************************************************************
RETCODE                   DS F    RETURN CODE FROM IRXEXCOM
CANAMEP  DS    F                  CA VARIABLE NAME PTR
CANAMEL  DS    F                  CA VARIABLE NAME LENGTH
IRXEXCOM_ADDR             DS F    IRXEXCOM ADDRESS FOR EXECUTION
PGMNAME                   DS CL8  CICS PROGRAM NAME
TRANSID                   DS CL4  CICS TRANSACTION ID
APPLID                    DS CL8  CICS APPLID
CA_LENGTH                 DS F    COMMAREA LENGTH
CA_DATALENGTH             DS F    DATA LENGTH OF COMMAREA
***********************************************************************
*        MISCELLANEOUS AREAS                                          *
***********************************************************************
ENVBADDR DS    F                  REXX ENVIRONMENT BLOCK ADDRESS
BUFADDR  DS    F                  COMMAREA BUFFER ADDRESS
DATALEN  DS    F                  LENGTHS IN BINARY FORMAT
NAMEPTR  DS    F                  PTR TO REXX VAR NAME
NAMELEN  DS    F                  LENGTH OF REXX VAR NAME
VALUPTR  DS    F                  PTR TO VARIABLE VALUE
VALULEN  DS    F                  LENGTH OF VARIABLE VALUE
SHVBKID  DS    F                  SHVBLOCK INDICATOR
REXXOUT_RET DS F                  SAVEAREA FOR RETURN ADDRESS
CHARNUM_LEN DS F                  CHARACTER COUNT FOR RETURNED VALUE
CA_RETVD_LEN DS F                 COMMAREA RETRIEVED LENGTH
IRXP2    DS    CL4                IRXEXCOM PARAMETER 2
IRXSHVB0 DS    CL32               IRXEXCOM PARAMETER 4 (SHVBLOCK)
IRXSHVB1 DS    CL32               IRXEXCOM PARAMETER 4 (SHVBLOCK)
IRXSHVB2 DS    CL32               IRXEXCOM PARAMETER 4 (SHVBLOCK)
IRXSHVB3 DS    CL32               IRXEXCOM PARAMETER 4 (SHVBLOCK)
IRXSHVB4 DS    CL32               IRXEXCOM PARAMETER 4 (SHVBLOCK)
CHARNUM  DS    CL16               CHARACTER DATA FOR RETURNED VALUE
RCRESPC  DS    CL16               RESP CHARACTER DATA
RCRESP2C DS    CL16               RESP2 CHARACTER DATA
PACKDATA DS    D                  PACKED DECIMAL AREA FOR LENGTHS
TYPEFLG  DS    C                  TYPE OF PARAMETER FLAG
         END   CA1DLINK
###END CA1DLINK
$$$BEG DFH$AXNC
*ASM XOPTS(EXCI)
***********************************************************************
*                                                                     *
* MODULE NAME = DFH$AXNC                                              *
*                                                                     *
* DESCRIPTIVE NAME = Assembler Sample Batch client sample which       *
*                    uses channels and containers                     *
*                                                                     *
*                                                                     *
*                                                                     *
*        Licensed Materials - Property of IBM                         *
*                                                                     *
*        "Restricted Materials of IBM"                                *
*                                                                     *
*        5655-Y04                                                     *
*                                                                     *
*        (C) Copyright IBM Corp. 2016, 2016"                          *
*                                                                     *
*                                                                     *
*                                                                     *
*                                                                     *
*  STATUS = 7.1.0                                                     *
*                                                                     *
* FUNCTION =  This module shows users how to code a simple batch type *
*             application program using the EXCI call level and EXEC  *
*             level batch Dpl API.  This assembler version will use   *
*             the API to call into a target CICS region and invoke    *
*             the EXCI sample server program resident on the system   *
*             to perform tasks according to a message sent via a      *
*             container. Appropriate to each task, the return         *
*             containers will contain data specific to the call-type  *
*             requested.                                              *
*                                                                     *
* NOTES :                                                             *
*    DEPENDENCIES = S/390                                             *
*    REGISTER CONVENTIONS = R3,R4    Base registers.                  *
*                           R5       Message length                   *
*                           R6       Message pointer.                 *
*                           R7       For arithmetic.                  *
*                           R8       Used in amode switch.            *
*                           R9       -->EXEC return area.             *
*                           R11      -->Call level return area.       *
*                           R12      -->Dpl return area.              *
*    MODULE TYPE = Executable                                         *
*    PROCESSOR = Assembler                                            *
*    ATTRIBUTES = Read only, Serially Reusable,                       *
*                                                                     *
*-------------------------------------------------------------------- *
*                                                                     *
* ENTRY POINT = DFH$AXNC                                              *
*                                                                     *
* DESCRIPTION :   The program is simply broken down into three        *
*                 sections.  Section I performs a single EXEC level   *
*                 EXCI call into the target CICS region, while        *
*                 Sections II and III together include the code       *
*                 required to manually set up a Pipe connection to a  *
*                 remote CICS, and to perform multiple Dpl calls via  *
*                 this single connection.  The following is a basic   *
*                 outline of each section's logic;                    *
*                                                                     *
*    SECTION_I:   Set up a request container which tells the server   *
*                 the type and number of the invocation.              *
*                                                                     *
*                 A container is set up with some EBCDIC data to      *
*                 send to the server. An EXEC CICS LINK is then       *
*                 performed to pass the channel to the server.        *
*                                                                     *
*                 If this succeeds, a second channel is set up and    *
*                 a container is added which contains ASCII data.     *
*                 Use is made of codepage conversion in containers    *
*                 to convert EBCDIC to ASCII. This is not strictly    *
*                 necessary, but is performed for illustrative        *
*                 purposes.                                           *
*                                                                     *
*                 End of Section I processing.                        *
*                                                                     *
*                                                                     *
*                 The EXEC level EXCI call requires very little effort*
*                 in the setting up of many parameters, as is         *
*                 exemplified in the simplicity of this section, and  *
*                 as it performs an Init_User, Allocate, Open, Dpl,   *
*                 Close and Deallocate Pipe call form every invocation*
*                 it's use is generally limited to 'single shot' Dpl  *
*                 calls of this type.                                 *
*                                                                     *
*   SECTION_II:   Set up and perform the Init_User call.              *
*                                                                     *
*                 Set up and perform the Allocate_Pipe call.          *
*                                                                     *
*                 Set up and perform the Open_Pipe call.              *
*                                                                     *
*                 If the Pipe has been successfully created then      *
*                 get the data in containers from the target CICS     *
*                 region.                                             *
*                                                                     *
*                 Perform Section III for backout purposes.           *
*                                                                     *
*                                                                     *
*                 With the Call level EXCI link, care must be taken   *
*                 to allocate storage for call level specific         *
*                 parameters such as the User token and Pipe Token,   *
*                 as well as others i.e. version number, userid (for  *
*                 security purposes) the Allocate option and Dpl      *
*                 option bits, the unit of work id, and also both high*
*                 and low level return code areas.  It is obvious that*
*                 the Call level EXCI link requires more setting up,  *
*                 but because the user can decide how to go about     *
*                 allocating or using pipes, a greater flexibility and*
*                 efficiency can be achieved for multiple Dpl calls,  *
*                 as exemplified here.                                *
*                                                                     *
*   SECTION III:  Delete the two channels which have been used. This  *
*                 is good practise and ensures that storage is tidied *
*                 up properly.                                        *
*                                                                     *
*                 Set up and perform the closing DPl Request.         *
*                                                                     *
*                 Set up and perform the Close_Pipe call.             *
*                                                                     *
*                 Set up and perform the Deallocate_Pipe call.        *
*                                                                     *
*                 Exit.                                               *
*                                                                     *
*                                                                     *
*                 Section III will be called regardless of the degree *
*                 of success achieved by processing in Section II, as *
*                 no assumptions can be made if any part of Section II*
*                 fails as to how far successful processing occured.  *
*                                                                     *
*  INPUT PARAMETERS:                                                  *
*                                                                     *
*    The only input to this program is supplied by the JCL PARM       *
*    parameter.  This must contain the applid of the target CICS      *
*    region and, optionally, the userid under which the DPL program   *
*    must run, separated from the applid by a single comma.           *
*    If the applid is omitted, a default of DBDCCICS is used.         *
*    If the userid is omitted, the default is the userid of the       *
*    job within which this program is executing.                      *
*    The parameters must be passed in the form                        *
*            APPLID,USERID                                            *
*                                                                     *
*------------------------------------------------------------------ *
*                                                                     *
* CHANGE ACTIVITY :                                                   *
**                                                                    *
*        $MOD(DFH$AXNC),COMP(SAMPLES),PROD(CICS TS ):                 *
*                                                                     *
*    REASON  REL YYMMDD HDXXIII : REMARKS                             *
*    R000363 710 160623 HDAFDRB : Initial coding (story 113471)       *
***********************************************************************
*
*=====================================================================*
*   Include the standard copybook for EXCI return codes and DSECTS.   *
*=====================================================================*
*
          COPY DFHXCRCD
*
*=====================================================================*
*   Include the standard copybook for EXCI Parameter list equates.    *
*=====================================================================*
*
          COPY DFHXCPLD
*
*=====================================================================*
*                                                                     *
*         >>>>>>>>>>>>>> MAINLINE CODE <<<<<<<<<<<<<<<<               *
*                                                                     *
*=====================================================================*
DFH$AXNC AMODE 31
DFH$AXNC RMODE 24
DFH$AXNC DFHEIENT CODEREG=(R3,R4)
         MVC   TARGET_USERID,BLANKS         Blank target userid
         MVC   MSG32(18),MSGPARM            Set up Parm message
         MVC   MSG32E(28),MSGLAST
         MVC   MSG32A(7),NOAPP              Parameters None
*
*=====================================================================*
*   Retrieve the target CICS Applid and Userid, passed in PARM.       *
*=====================================================================*
*                                           *=========================*
         L     R1,0(,R1)                    | R1-->JCL Plist.         |
         XR    R7,R7                        | Clear R7                |
         ICM   R7,B'0011',0(R1)             |  Pick up parm length    |
         BZ    NOPARM                       | Was a CICS name passed? |
         MVC   TARGET_SYSTEM(8),BLANKS      | Yes: Pad with blanks    |
         LA    R6,2(,R1)          -> Character at PARM start
         LA    R2,2-1(,R1)        -> Character before PARM start
         LA    R15,2-1(R7,R1)     -> Last PARM character
         LA    R14,1              Set scan increment
SCANAPPL DS    0H                 Scan through source applid
         BXH   R2,R14,ENDAPPL     Exit loop at end of PARM
         CLI   0(R2),C','         Is there a comma?
         BNE   SCANAPPL           No, keep searching
ENDAPPL  DS    0H                 End of applid found
         LR    R7,R2              Save address reached
         SR    R7,R6              Subtract start address
         BNP   DONEAPPL           If zero length, no applid
         LA    R0,L'TARGET_SYSTEM Set length of target field
         CR    R7,R0              Is PARM too long?
         BNH   SETAPPL            No, use length found
         LR    R7,R0              Truncate to target length
SETAPPL  DS    0H                 Set up target applid
         BCTR  R7,0                         |  decrement length       |
         EX    R7,GETNAME                   |  Retrieve CICS name     |
DONEAPPL DS    0H                 Finished applid
         LA    R6,1(,R2)          Start of next PARM (userid)
SCANUSER DS    0H                 Scan through source userid
         BXH   R2,R14,ENDUSER     Exit loop at end of PARM
         CLI   0(R2),C','         Is there a comma?
         BNE   SCANUSER           No, keep searching
ENDUSER  DS    0H                 End of userid reached
         LR    R7,R2              Save address reached
         SR    R7,R6              Subtract start address
         BNP   DONEUSER           No userid text left
         LA    R0,L'TARGET_USERID Set length of target field
         CR    R7,R0              Is PARM too long?
         BNH   SETUSER            No, use length found
         LR    R7,R0              Truncate to target length
SETUSER  DS    0H                 Set up target userid
         BCTR  R7,0               Decrement length
         EX    R7,GETUSER         Copy target userid
DONEUSER DS    0H                 Finished with userid
         CLI   TARGET_SYSTEM,C' ' Was a target applid found?
         BE    NOPARM             No, use default
         MVC   MSG32A(7),FILLAPP  Set up message
         MVC   MSG32B(8),TARGET_SYSTEM   Set Up Message Applid
         CLI   TARGET_USERID,C' ' Was a target userid found?
         BE    NOUPARM            No
USERMSG  DS    0H
         MVC   MSG32C(11),FILLUSD Set up message
         MVC   MSG32D(8),TARGET_USERID  Set up Message Userid
         B     OPENSYS                      |  Continue...            |
GETNAME  MVC   TARGET_SYSTEM(0),2(R1)       |
GETUSER  MVC   TARGET_USERID(0),0(R6)       |
NOPARM   DS    0H                           | No: Default CICSname.   |
         MVC   TARGET_SYSTEM(8),DEFAULT_SYSTEM                        |
         MVC   MSG32B,BLANKS      Blank out Applid in Message
         CLI   TARGET_USERID,C' ' Was a target userid found?
         BNE   USERMSG            Yes
NOUPARM  DS    0H                 No Userid parameter
         MVC   MSG32C,NOUSD       Set Message Userid to blank
         MVC   MSG32D,BLANKS      Blank Out Userid in Message
*                                           *_________________________*
*=====================================================================*
*   Set the output SYSPRINT log open.                                 *
*=====================================================================*
*
OPENSYS  DS    0H                           *=========================*
         MVC   DCBPARM,OUTPUT               | load DCB                |
         LA    R7,DCBPARM                   |                         |
         MVC   OPENPARM,OPENLIST            | Initialise plist        |
         LA    R1,OPENPARM                  | Address Plist           |
         OPEN ((R7),(OUTPUT)),              | Call macro.             |*
               MODE=31,                     |                         |*
               MF=(E,(1))                   *_________________________*
*
*=====================================================================*
*   Put out Entry message.                                            *
*=====================================================================*
*
         MVC   PRTRECORD(80),MSG00          *=========================*
         L     R15,=A(X'80000000'+PRINT)    |                         |
         BALR  R14,R15                      | Msg='   '               |
         MVC   PRTRECORD(80),MSG01          |                         |
         L     R15,=A(X'80000000'+PRINT)    | Msg='EXCI Sample...'    |
         BALR  R14,R15                      *_________________________*
         MVC   PRTRECORD(80),MSG02          |                         |
         L     R15,=A(X'80000000'+PRINT)    | Msg='    '              |
         BALR  R14,R15                      *_________________________*
         MVC   PRTRECORD(80),MSG32          |                         |
         L     R15,=A(X'80000000'+PRINT)    | Msg='Parameters:   '    |
         BALR  R14,R15                      *_________________________*
*
*=====================================================================*
*   Clear Working Storage;                                            *
*=====================================================================*
*                                              *======================*
         LA    R9,EXEC_RETAREA                 | R9--> EXEC returns   |
         USING EXCI_EXEC_RETURN_CODE,R9        |                      |
         LA    R11,CALL_RETAREA                | R11-->Call returns   |
         USING EXCI_RETURN_CODE,R11            |                      |
         LA    R12,DPL_RETAREA                 | R12--> DPL returns   |
         USING EXCI_DPL_RETAREA,R12            *______________________*
         XC    CLEAR_START(CLEAR_LEN),CLEAR_START
         MVC   STOREYE(8),=C'STORAGE:'
         MVC   TOKENEYE(8),=C'TOKENS:-'
         XC    CALL,CALL
         MVC   PARMEYE(8),=C'CPLIST :'
         MVC   EXECEYE(8),=C'EXECRet:'
         MVC   EXCIEYE(8),=C'EXCIRet:'
         MVC   DPL_EYE(8),=C'DPL_Ret:'
*
*=====================================================================*
*                                                                     *
*   SECTION I:                                                        *
*                                                                     *
*   First set up a request_type container. This will also create a    *
*   channel. This  container is  used by  the  server  program  to    *
*   distinguish  between  an  EXEC  or a  CALL  interface  request.   *
*   A  second  container  is  then  put onto the channel with some    *
*   EBCDIC data.                                                      *
*                                                                     *
*   Following a link to the server program, a  second  channel is set *
*   up with containers. Use is made of container codepage translation *
*   to convert data into UTF-8 format.                                *
*                                                                     *
*=====================================================================*
*
         MVC   PRTRECORD(80),MSG02           *========================*
         L     R15,=A(X'80000000'+PRINT)     |                        |
         BALR  R14,R15                       | Msg='*    *'           |
         MVC   PRTRECORD(80),MSG03           |                        |
         L     R15,=A(X'80000000'+PRINT)     |                        |
         BALR  R14,R15                       | Msg='EXEC call...'     |
         MVC   PRTRECORD(80),MSG04           |                        |
         L     R15,=A(X'80000000'+PRINT)     | Msg='Setting up parms' |
         BALR  R14,R15                       *________________________*
*
*=====================================================================*
*   Set up the Outbound containers on channel FIRST_CHANNEL
*=====================================================================*
*                                                                     *
*
*=====================================================================*
* Set the request as LINK1 in container REQUEST_TYPE. This will also  *
* create the channel called FIRST_CHANNEL.                            *
*=====================================================================*

         EXEC CICS PUT CONTAINER('REQUEST_TYPE')                       *
               CHANNEL('FIRST_CHANNEL   ')                             *
               FROM('LINK1')                                           *
               RETCODE(EXEC_RETAREA)
*
*=====================================================================*
*   Did the PUT fail?  Check the Return Codes.                        *
*=====================================================================*
*
         CLC   EXEC_RESP,ZERO
         BNE   PUTFAIL
*                                                                     *
*=====================================================================*
*   Put another container into the channel. It contains EBCDIC data.  *
*=====================================================================*
*
         MVC   PUT_AREA(33),=CL33'     Here are some data in EBCDIC'
         MVC   PUT_LENGTH,=F'33'
         EXEC CICS PUT CONTAINER('EBCDIC_DATA')                        *
               CHANNEL('FIRST_CHANNEL   ')                             *
               FROM(PUT_AREA)                                          *
               FLENGTH(PUT_LENGTH)                                     *
               DATATYPE(1019)                                          *
               RETCODE(EXEC_RETAREA)
*
*=====================================================================*
*   Did the PUT fail?  Check the Return Codes.                        *
*=====================================================================*
*
         CLC   EXEC_RESP,ZERO
         BNE   PUTFAIL
         B     LINKPROG
*
*=====================================================================*
*   YES:  output reason and abort processing.                         *
*=====================================================================*
*
PUTFAIL DS    0H                          *===========================*
         MVC   SAVED_RESP,EXEC_RESP       | Save a copy of rc         |
         MVC   PRTRECORD(80),MSG10        | Msg='A put has failed'    |
         L     R15,=A(X'80000000'+PRINT)  |                           |
         BALR  R14,R15                    |                           |
         L     R5,EXEC_RESP               | Convert Return codes to   |
         CVD   R5,WORK1                   |   displayable Decimal.    |
         UNPK  WORK2,WORK1                |    !                      |
         OI    WORK2+7,X'F0'              |    !                      |
         MVC   ERRMSG(16),MSG11           | Msg='*    Resp='          |
         MVC   ERRMSG1(8),WORK2           | EXEC_RESP                 |
         L     R5,EXEC_RESP2              |    !                      |
         CVD   R5,WORK1                   |    !                      |
         UNPK  WORK2,WORK1                |    !                      |
         OI    WORK2+7,X'F0'              |    !                      |
         MVC   ERRMSG2(10),MSG12          | Msg='*   Resp2='          |
         MVC   ERRMSG3(8),WORK2           | EXEC_RESP2                |
         MVC   ERRMSG4(16),MSG13          | Msg='*   Abend:'          |
         MVC   ERRMSG5(8),MSG00           | blank out all 8 bytes.    |
         MVC   ERRMSG5(4),EXEC_ABCODE     | EXEC_ABCODE               |
         MVC   ERRMSG6(16),MSG14          |                           |
         MVC   PRTRECORD(80),ERRMSG       | Msg=Return codes.         |
         L     R15,=A(X'80000000'+PRINT)  |                           |
         BALR  R14,R15                    | Has CICS issued a message?|
         CLC   EXEC_MSG_PTR,ZERO          |                           |
         BE    PUTNOMSG                   | No: Continue.             |
PUTMSG   MVC   PRTRECORD(80),MSG15        | Yes: Msg='A message...'   |
         L     R15,=A(X'80000000'+PRINT)  |                           |
         BALR  R14,R15                    |                           |
         MVC   PRTRECORD(80),MSG02        | Msg='*    *'              |
         L     R15,=A(X'80000000'+PRINT)  |                           |
         BALR  R14,R15                    |                           |
         L     R5,EXEC_MSG_PTR            | Get message pointer and   |
         L     R6,EXEC_MSG_LEN            | length                    |
PUTLOOP  DS    0H                         |                           |
         LR    R8,R6                      | Start with length = msg l |
         LA    R7,80                      |                           |
         CR    R6,R7                      | Is it > 80 ?              |
         BL    PUTSMLMS                   |                           |
         LA    R8,80                      | Yes - move first 80       |
PUTSMLMS DS    0H                         | No - move whole message   |
         BCTR  R8,0                       | Less one for MVC          |
         EX    R8,PUTMSG1                 | Move in message           |
         L     R15,=A(X'80000000'+PRINT)  |                           |
         BALR  R14,R15                    | Send message              |
         MVC   PRTRECORD(80),MSG00        | Clear buffer              |
         LA    R5,80(,R5)                 | Bump message pointer      |
         SR    R6,R7                      | and decrement length      |
         BP    LOOP                       | Loop if more message      |
         MVC   PRTRECORD(80),MSG02        | Msg='*    *'              |
         L     R15,=A(X'80000000'+PRINT)  |                           |
         BALR  R14,R15                    |                           |
PUTNOMSG MVC   PRTRECORD(80),MSG16        | Yes: Msg='Aborting...'    |
         L     R15,=A(X'80000000'+PRINT)  |                           |
         BALR  R14,R15                    |                           |
         B     EXIT                       |                           |
PUTMSG1  MVC   PRTRECORD(0),0(R5)         *___________________________*
*                                                                     *
*=====================================================================*
*   Perform LINK request.                                             *
*=====================================================================*
*                                                                     *
LINKPROG DS    0H
         EXEC CICS LINK PROGRAM(TARGET_PROGRAM)                        *
               TRANSID(TARGET_TRANSID)                                 *
               APPLID(TARGET_SYSTEM)                                   *
               CHANNEL('FIRST_CHANNEL   ')                             *
               RETCODE(EXEC_RETAREA)                                   *
               SYNCONRETURN
*
*=====================================================================*
*   Did the call fail?  Check the Return Codes.                       *
*=====================================================================*
*
         CLC   EXEC_RESP,ZERO
         BNE   LINKFAIL
*
*=====================================================================*
*   NO:  Put out a message and get response container.                *
*=====================================================================*
*
CHECK1   DS    0H
*                                         *===========================*
         MVC   PRTRECORD(80),MSG05        | Msg='Link worked ok'      |
         L     R15,=A(X'80000000'+PRINT)  |                           |
         BALR  R14,R15                    |                           |
         MVC   PRTRECORD(80),MSG35        | Msg='Checking response'   |
         L     R15,=A(X'80000000'+PRINT)  |                           |
         BALR  R14,R15                    |                           |
*
*=====================================================================*
*   Check the response container to see that we are OK to continue    *
*=====================================================================*
*
         MVC   GET_LENGTH,=F'100'
         XC    GET_AREA,GET_AREA
*
         EXEC CICS GET CONTAINER('EXCI_RESPONSE')                      *
               CHANNEL('FIRST_CHANNEL   ')                             *
               INTO(GET_AREA)                                          *
               FLENGTH(GET_LENGTH)                                     *
               RETCODE(EXEC_RETAREA)
*
         CLC   GET_AREA(2),=C'OK'
         BE    OKSOFAR1                   | OK so far, continue
         MVC   PRTRECORD(80),MSG34        | Msg='Response not OK'     |
         L     R15,=A(X'80000000'+PRINT)  |                           |
         BALR  R14,R15                    |                           |
         MVC   PRTRECORD(80),MSG16        | Msg='Aborting       '     |
         L     R15,=A(X'80000000'+PRINT)  |                           |
         BALR  R14,R15                    |                           |
         B     EXIT                       | So exit                   |
*
*=====================================================================*
*   The LINK  was successful, so  we can  continue processing. Now    *
*   put a container  containing UTF-8  data  into a  new  channel.    *
*   We do this by putting the container with EBCDIC data, then get    *
*   it into  the  UTF-8  codepage  then  putting  it  again.  This    *
*   demonstrates  the use  of containers  as a  means  of codepage    *
*   conversion.                                                       *

*   A new channel is used for this. This is not necessary, but is     *
*   done so as to illustrate the use of multiple channels.            *
*=====================================================================*
*
OKSOFAR1 DS    0H
*
         MVC   PRTRECORD(80),MSG38        | Msg='Response OK      '   |
         L     R15,=A(X'80000000'+PRINT)  |                           |
         BALR  R14,R15                    |                           |
*
*=====================================================================*
*   Delete the response container to be tidy.                         *
*=====================================================================*
*
         EXEC CICS DELETE CONTAINER('EXCI_RESPONSE')                   *
               CHANNEL('FIRST_CHANNEL   ')                             *
               RETCODE(EXEC_RETAREA)
*
         EXEC CICS PUT CONTAINER('REQUEST_TYPE2')                      *
               CHANNEL('FIRST_CHANNEL   ')                             *
               FROM('LINK2')                                           *
               RETCODE(EXEC_RETAREA)
*
*=====================================================================*
*   The PUT container  call above  put the  wrong container into the  *
*   wrong channel. This can be corrected by using the MOVE container  *
*   command.                                                          *
*                                                                     *
*   MOVE the container to the correct channel. The MOVE also provides *
*   the opportunity to rename a container.                            *
*=====================================================================*
*
         EXEC CICS MOVE CONTAINER('REQUEST_TYPE2')                     *
               AS('REQUEST_TYPE')                                      *
               CHANNEL('FIRST_CHANNEL   ')                             *
               TOCHANNEL('SECOND_CHANNEL  ')                           *
               RETCODE(EXEC_RETAREA)
*
         MVC   PUT_AREA(32),=CL32'     More data in this container'
         MVC   PUT_LENGTH,=F'32'
         EXEC CICS PUT CONTAINER('ASCII_DATA')                         *
               CHANNEL('SECOND_CHANNEL  ')                             *
               FROM(PUT_AREA)                                          *
               FLENGTH(PUT_LENGTH)                                     *
               DATATYPE(1019)                                          *
               RETCODE(EXEC_RETAREA)
*
*=====================================================================*
*   Using the INTOCCSID parameter on the GET CONTAINER causes the     *
*   contents of the container to be codepage  translated into the     *
*   specified codepage.                                               *
*=====================================================================*
*
         MVC   GET_LENGTH,=F'100'
         XC    GET_AREA,GET_AREA
*
         EXEC CICS GET CONTAINER('ASCII_DATA')                         *
               CHANNEL('SECOND_CHANNEL  ')                             *
               INTO(GET_AREA)                                          *
               FLENGTH(GET_LENGTH)                                     *
               INTOCCSID(UTF8)                                         *
               RETCODE(EXEC_RETAREA)
*
*=====================================================================*
*   Using the FROMCCSID parameter on the PUT CONTAINER causes the     *
*   contents  of the  container  to be  treated  as  being in the     *
*   specified codepage.                                               *
*=====================================================================*
*
         EXEC CICS PUT CONTAINER('ASCII_DATA')                         *
               CHANNEL('SECOND_CHANNEL  ')                             *
               FROM(GET_AREA)                                          *
               FROMCCSID(UTF8)                                         *
               DATATYPE(1019)                                          *
               RETCODE(EXEC_RETAREA)
*                                                                     *
*=====================================================================*
*   Perform LINK request.                                             *
*=====================================================================*
*
LINKPRO2 DS    0H
         EXEC CICS LINK PROGRAM(TARGET_PROGRAM)                        *
               TRANSID(TARGET_TRANSID)                                 *
               APPLID(TARGET_SYSTEM)                                   *
               CHANNEL('SECOND_CHANNEL  ')                             *
               RETCODE(EXEC_RETAREA)                                   *
               SYNCONRETURN
*
*=====================================================================*
*   Did the call fail?  Check the Return Codes.                       *
*=====================================================================*
*
         CLC   EXEC_RESP,ZERO
         BNE   LINKFAIL
*
*=====================================================================*
*   Check the response container to see if we are OK to continue.     *
*=====================================================================*
*
         XC    GET_AREA,GET_AREA
         MVC   GET_LENGTH,=F'100'
*
         EXEC CICS GET CONTAINER('EXCI_RESPONSE')                      *
               CHANNEL('SECOND_CHANNEL  ')                             *
               INTO(GET_AREA)                                          *
               FLENGTH(GET_LENGTH)                                     *
               RETCODE(EXEC_RETAREA)
*
         CLC   GET_AREA(2),=C'OK'
         BE    OKSOFAR2                   | OK so far, continue
         MVC   PRTRECORD(80),MSG34        | Msg='Response not OK'     |
         L     R15,=A(X'80000000'+PRINT)  |                           |
         BALR  R14,R15                    |                           |
         MVC   PRTRECORD(80),MSG16        | Msg='Aborting       '     |
         L     R15,=A(X'80000000'+PRINT)  |                           |
         BALR  R14,R15                    |                           |
         B     EXIT                       | So exit                   |
*
OKSOFAR2 DS    0H
*
*=====================================================================*
*   Delete the response container to be tidy.                         *
*=====================================================================*
*
         EXEC CICS DELETE CONTAINER('EXCI_RESPONSE')                   *
               CHANNEL('SECOND_CHANNEL  ')                             *
               RETCODE(EXEC_RETAREA)
*
         MVC   PRTRECORD(80),MSG06        | Msg='Link worked ok'      |
         L     R15,=A(X'80000000'+PRINT)  |                           |
         BALR  R14,R15                    |                           |
         MVC   PRTRECORD(80),MSG35        | Msg='Checking container'  |
         L     R15,=A(X'80000000'+PRINT)  |                           |
         BALR  R14,R15                    |                           |
         B     SECTION2                   | OK so far, continue
*
*
*=====================================================================*
*   YES:  LINK failed so output reason and abort processing.          *
*=====================================================================*
*
LINKFAIL DS    0H                         *===========================*
         MVC   SAVED_RESP,EXEC_RESP       | Save a copy of rc         |
         MVC   PRTRECORD(80),MSG09        | Msg='The link has failed' |
         L     R15,=A(X'80000000'+PRINT)  |                           |
         BALR  R14,R15                    |                           |
         L     R5,EXEC_RESP               | Convert Return codes to   |
         CVD   R5,WORK1                   |   displayable Decimal.    |
         UNPK  WORK2,WORK1                |    !                      |
         OI    WORK2+7,X'F0'              |    !                      |
         MVC   ERRMSG(16),MSG11           | Msg='*    Resp='          |
         MVC   ERRMSG1(8),WORK2           | EXEC_RESP                 |
         L     R5,EXEC_RESP2              |    !                      |
         CVD   R5,WORK1                   |    !                      |
         UNPK  WORK2,WORK1                |    !                      |
         OI    WORK2+7,X'F0'              |    !                      |
         MVC   ERRMSG2(10),MSG12          | Msg='*   Resp2='          |
         MVC   ERRMSG3(8),WORK2           | EXEC_RESP2                |
         MVC   ERRMSG4(16),MSG13          | Msg='*   Abend:'          |
         MVC   ERRMSG5(8),MSG00           | blank out all 8 bytes.    |
         MVC   ERRMSG5(4),EXEC_ABCODE     | EXEC_ABCODE               |
         MVC   ERRMSG6(16),MSG14          |                           |
         MVC   PRTRECORD(80),ERRMSG       | Msg=Return codes.         |
         L     R15,=A(X'80000000'+PRINT)  |                           |
         BALR  R14,R15                    | Has CICS issued a message?|
         CLC   EXEC_MSG_PTR,ZERO          |                           |
         BE    NOMSG1                     | No: Continue.             |
MSG1     MVC   PRTRECORD(80),MSG15        | Yes: Msg='A message...'   |
         L     R15,=A(X'80000000'+PRINT)  |                           |
         BALR  R14,R15                    |                           |
         MVC   PRTRECORD(80),MSG02        | Msg='*    *'              |
         L     R15,=A(X'80000000'+PRINT)  |                           |
         BALR  R14,R15                    |                           |
         L     R5,EXEC_MSG_PTR            | Get message pointer and   |
         L     R6,EXEC_MSG_LEN            | length                    |
LOOP     DS    0H                         |                           |
         LR    R8,R6                      | Start with length = msg l |
         LA    R7,80                      |                           |
         CR    R6,R7                      | Is it > 80 ?              |
         BL    SMLMSG                     |                           |
         LA    R8,80                      | Yes - move first 80       |
SMLMSG   DS    0H                         | No - move whole message   |
         BCTR  R8,0                       | Less one for MVC          |
         EX    R8,PRTMSG1                 | Move in message           |
         L     R15,=A(X'80000000'+PRINT)  |                           |
         BALR  R14,R15                    | Send message              |
         MVC   PRTRECORD(80),MSG00        | Clear buffer              |
         LA    R5,80(,R5)                 | Bump message pointer      |
         SR    R6,R7                      | and decrement length      |
         BP    LOOP                       | Loop if more message      |
         MVC   PRTRECORD(80),MSG02        | Msg='*    *'              |
         L     R15,=A(X'80000000'+PRINT)  |                           |
         BALR  R14,R15                    |                           |
NOMSG1   MVC   PRTRECORD(80),MSG16        | Yes: Msg='Aborting...'    |
         L     R15,=A(X'80000000'+PRINT)  |                           |
         BALR  R14,R15                    |                           |
         B     EXIT                       |                           |
PRTMSG1  MVC   PRTRECORD(0),0(R5)         *___________________________*
*
SECTION2 DS    0H
*=====================================================================*
*                                                                     *
*   SECTION II:                                                       *
*                                                                     *
*   This section performs the required Initialise User, Allocate Pipe *
*   and Open  pipe calls  prior to a looping  section  of  sequential *
*   DPL calls to the TARGET_PROGRAM  program passing  containers each *
*   time and checking a response container.                           *
*                                                                     *
*   No checks are made as to how  successful the Initialise_User, and *
*   Allocate_Pipe calls have been in this sample, as the check at the *
*   Open_Pipe call will  suffice in this simple linear context of the *
*   call API.                                                         *
*                                                                     *
*=====================================================================*
*
         MVC   PRTRECORD(80),MSG38        | Msg='Response OK      '   |
         L     R15,=A(X'80000000'+PRINT)  |                           |
         BALR  R14,R15                    |                           |
*
         MVC   PRTRECORD(80),MSG02       |                            |
         L     R15,=A(X'80000000'+PRINT) | Msg=''*     *'             |
         BALR  R14,R15                   |                            |
         MVC   PRTRECORD(80),MSG17       |                            |
         L     R15,=A(X'80000000'+PRINT) | Msg='CALL level processor' |
         BALR  R14,R15                   *____________________________*
*
*=====================================================================*
*   Initialise User call;                                             *
*=====================================================================*
*                                         *===========================*
INITUSER DS    0H                         |  START OF PARAMETERS:     |
         MVC   VERSION,=AL4(VERSION_1)    |  Set up version num       |
         MVC   EXCI_CALL,=AL4(INIT_USER)  |  Load Call-type and       |
*                                         *___________________________*
*
*
         CALL  DFHXCIS,                                                *
               (VERSION,                                               *
               CALL_RETAREA,                                           *
               U_TOKEN,                                                *
               EXCI_CALL,                                              *
               APPLICATION),                                           *
               VL,                                                     *
               MF=(E,PARM_LIST)
*
         MVC   PRTRECORD(80),MSG18        *===========================*
         L     R15,=A(X'80000000'+PRINT)  | Msg='Initialise user call'|
         BALR  R14,R15                    *___________________________*
*
*=====================================================================*
*   Allocate Pipe call;                                               *
*=====================================================================*
*                                         *===========================*
ALOCPIPE DS    0H                         |  START OF PARAMETERS:     |
*
         MVC   EXCI_CALL,=AL4(ALLOCATE_PIPE) Load call-type and       |
         MVC   OPTIONS,=AL1(SPECIFIC_PIPE) | Set specific pipe        |
*                                         *___________________________*
*
*
         CALL  DFHXCIS,                                                *
               (VERSION,                                               *
               CALL_RETAREA,                                           *
               U_TOKEN,                                                *
               EXCI_CALL,                                              *
               P_TOKEN,                                                *
               TARGET_SYSTEM,                                          *
               OPTIONS),                                               *
               VL,                                                     *
               MF=(E,PARM_LIST)
*
         MVC   PRTRECORD(80),MSG19        *===========================*
         L     R15,=A(X'80000000'+PRINT)  | Msg='Allocate pipe call'  |
         BALR  R14,R15                    *___________________________*
*
*=====================================================================*
*   Open Pipe call;                                                   *
*=====================================================================*
*                                         *===========================*
OPENPIPE DS    0H                         |  START OF PARAMETERS:     |
         MVC   EXCI_CALL,=AL4(OPEN_PIPE)  |  Load call-type and       |
*                                         *___________________________*
*
*
         CALL  DFHXCIS,                                                *
               (VERSION,                                               *
               CALL_RETAREA,                                           *
               U_TOKEN,                                                *
               EXCI_CALL,                                              *
               P_TOKEN),                                               *
               VL,                                                     *
               MF=(E,PARM_LIST)
*
         MVC   PRTRECORD(80),MSG20        *===========================*
         L     R15,=A(X'80000000'+PRINT)  | Mgs='Open pipe call'      |
         BALR  R14,R15                    *___________________________*
*
*=====================================================================*
*   Is the Link set up correctly?  If not, then abort the Dpl.        *
*=====================================================================*
*
CHCKLINK DS    0H
         ICM   R5,15,EXCI_RESPONSE
         BZ    DPLREQ
CONNFAIL DS    0H                         *===========================*
         MVC   SAVED_RESP,EXCI_RESPONSE   | Save a copy of response   |
         MVC   PRTRECORD(80),MSG22        | Msg='The link has failed' |
         L     R15,=A(X'80000000'+PRINT)  |                           |
         BALR  R14,R15                    |                           |
         L     R5,EXCI_RESPONSE           | Convert Return codes to   |
         CVD   R5,WORK1                   |   displayable Decimal.    |
         UNPK  WORK2,WORK1                |    !                      |
         OI    WORK2+7,X'F0'              |    !                      |
         MVC   ERRMSG(16),MSG23           | Msg='*   Response='       |
         MVC   ERRMSG1(8),WORK2           | EXCI_RESPONSE             |
         L     R5,EXCI_REASON             |    !                      |
         CVD   R5,WORK1                   |    !                      |
         UNPK  WORK2,WORK1                |    !                      |
         OI    WORK2+7,X'F0'              |    !                      |
         MVC   ERRMSG2(10),MSG24          | Msg='*   reason='         |
         MVC   ERRMSG3(8),WORK2           | EXCI_REASON               |
         L     R5,EXCI_SUB_REASON1        |    !                      |
         CVD   R5,WORK1                   |    !                      |
         UNPK  WORK2,WORK1                |    !                      |
         OI    WORK2+7,X'F0'              |    !                      |
         MVC   ERRMSG4(16),MSG25          | Msg='*   Subreason='      |
         MVC   ERRMSG5(8),WORK2           | EXCI_SUB_REASON1          |
         MVC   ERRMSG6(16),MSG14          | Msg='      *'             |
         MVC   PRTRECORD(80),ERRMSG       | Msg=Return codes.         |
         L     R15,=A(X'80000000'+PRINT)  |                           |
         BALR  R14,R15                    |                           |
         MVC   PRTRECORD(80),MSG16        | Msg='Aborting...'         |
         L     R15,=A(X'80000000'+PRINT)  |                           |
         BALR  R14,R15                    |                           |
         B     SECTION3                   |                           |
*                                         *___________________________*
DPLREQ   DS    0H
*=====================================================================*
*                                                                     *
*   Dpl Request;                                                      *
*                                                                     *
*   This is the multiple Dpl looping section which includes all code  *
*   to read in several containers and print messages to the SYSPRINT  *
*   log.                                                              *
*                                                                     *
*=====================================================================*
*
         MVC   PRTRECORD(80),MSG21        *===========================*
         L     R15,=A(X'80000000'+PRINT)  | Msg='Connect successful'  |
         BALR  R14,R15                    |                           |
*                                         *___________________________*
*=====================================================================*
*   Set up Outbound channel with parameters                           *
*=====================================================================*
*                                                                     *
*=====================================================================*
*   Dpl request;                                                      *
*      No UOWid is passed on the call. A zero value is specified      *
*      for  this  parameter, which  causes a  null address to be      *
*      placed in the parameter list and passed to DFHXCIS.            *
*                                                                     *
*      A userid  is passed  if one was  provided  as the  second      *
*      positional parameter in  the PARM field, otherwise a zero      *
*      value is  passed, as  above. This  causes the current job      *
*      userid to be used by the EXCI processor.                       *
*=====================================================================*
*                                         *===========================*
DPLCALL  DS    0H                         |  START OF PARAMETERS:     |
         MVC   VERSION,=AL4(VERSION_3)    |  Set up version for call  |
         MVC   EXCI_CALL,=AL4(DPL_REQUEST) | Load call-type and       |
         MVC   OPTIONS,=AL1(SYNCONRETURN) |  Set SYNCONRETURN         |
         MVC   CHANNEL(16),FIRST_CHANNEL  |  Set up channel name      |
*                                         *___________________________*
*
         EXEC CICS PUT CONTAINER('REQUEST_TYPE')                       *
               CHANNEL('FIRST_CHANNEL   ')                             *
               FROM('CALL1')                                           *
               RETCODE(EXEC_RETAREA)
*
MORE_DPL DS    0H
         SR    R2,R2              Clear userid pointer
         CLI   TARGET_USERID,C' ' Is there a userid?
         BE    DPLUSER            No, leave pointer null
         LA    R2,TARGET_USERID   Yes, point to supplied userid
DPLUSER  DS    0H                 Userid pointer is set
         CALL  DFHXCIS,                                                *
               (VERSION,                                               *
               CALL_RETAREA,                                           *
               U_TOKEN,                                                *
               EXCI_CALL,                                              *
               P_TOKEN,                                                *
               TARGET_PROGRAM,                                         *
               CHANNEL,                                                *
               0,                                                      *
               0,                                                      *
               TARGET_TRANSID,                                         *
               0,                                                      *
               (R2),                                                   *
               DPL_RETAREA,                                            *
               OPTIONS,                                                *
               0,                                                      *
               0,                                                      *
               0),                                                     *
               VL,                                                     *
               MF=(E,PARM_LIST)
*
*=====================================================================*
*   Did the Dpl Request succeed? We must check both the call and the  *
*   Dpl return codes to be certain that it did.                       *
*   End processing if either is non-zero.                             *
*=====================================================================*
*
CHCKDPL  DS    0H
         MVC   SAVED_RESP,EXCI_RESPONSE   | Save a copy of rc         |
         CLC   EXCI_RESPONSE,ZERO
         BNE   DPL_FAIL
         MVC   SAVED_RESP,EXCI_DPL_RESP   | Save a copy of rc         |
         CLC   EXCI_DPL_RESP,ZERO
         BNE   DPL_FAIL
         B     CHK_SERV
DPL_FAIL DS    0H                         *===========================*
         MVC   PRTRECORD(80),MSG00        |                           |
         MVC   PRTRECORD(80),MSG26        | Msg='The Dpl has failed'  |
         L     R15,=A(X'80000000'+PRINT)  |                           |
         BALR  R14,R15                    |                           |
         MVC   PRTRECORD(80),MSG27        | Msg='Link return codes..' |
         L     R15,=A(X'80000000'+PRINT)  |                           |
         BALR  R14,R15                    |                           |
         L     R5,EXCI_RESPONSE           | Convert Return codes to   |
         CVD   R5,WORK1                   |   displayable Decimal.    |
         UNPK  WORK2,WORK1                |    !                      |
         OI    WORK2+7,X'F0'              |    !                      |
         MVC   ERRMSG(16),MSG23           | Msg='*   Response='       |
         MVC   ERRMSG1(8),WORK2           | EXCI_RESPONSE             |
         L     R5,EXCI_REASON             |    !                      |
         CVD   R5,WORK1                   |    !                      |
         UNPK  WORK2,WORK1                |    !                      |
         OI    WORK2+7,X'F0'              |    !                      |
         MVC   ERRMSG2(10),MSG24          | Msg='*   reason='         |
         MVC   ERRMSG3(8),WORK2           | EXCI_REASON               |
         L     R5,EXCI_SUB_REASON1        |    !                      |
         CVD   R5,WORK1                   |    !                      |
         UNPK  WORK2,WORK1                |    !                      |
         OI    WORK2+7,X'F0'              |    !                      |
         MVC   ERRMSG4(16),MSG25          | Msg='*   Subreason='      |
         MVC   ERRMSG5(8),WORK2           | EXCI_SUB_REASON1          |
         MVC   ERRMSG6(16),MSG14          | Msg='      *'             |
         MVC   PRTRECORD(80),ERRMSG       | Msg=Return codes.         |
         L     R15,=A(X'80000000'+PRINT)  |                           |
         BALR  R14,R15                    |                           |
         MVC   PRTRECORD(80),MSG28        | Msg='Dpl return codes..'  |
         L     R15,=A(X'80000000'+PRINT)  |                           |
         BALR  R14,R15                    |                           |
         L     R5,EXCI_DPL_RESP           | Convert Return codes to   |
         CVD   R5,WORK1                   |   displayable Decimal.    |
         UNPK  WORK2,WORK1                |    !                      |
         OI    WORK2+7,X'F0'              |    !                      |
         MVC   ERRMSG(16),MSG11           | Msg='*    Resp='          |
         MVC   ERRMSG1(8),WORK2           | EXCI_DPL_RESP             |
         L     R5,EXCI_DPL_RESP2          |    !                      |
         CVD   R5,WORK1                   |    !                      |
         UNPK  WORK2,WORK1                |    !                      |
         OI    WORK2+7,X'F0'              |    !                      |
         MVC   ERRMSG2(10),MSG12          | Msg='*   Resp2='          |
         MVC   ERRMSG3(8),WORK2           | EXCI_DPL_RESP2            |
         MVC   ERRMSG4(16),MSG13          | Msg='*   Abend:'          |
         MVC   ERRMSG5(8),MSG00           | blank out all 8 bytes.    |
         MVC   ERRMSG5(4),EXCI_DPL_ABCODE | EXCI_DPL_ABCODE           |
         MVC   ERRMSG6(16),MSG14          |                           |
         MVC   PRTRECORD(80),ERRMSG       | Msg=Return codes.         |
         L     R15,=A(X'80000000'+PRINT)  |                           |
         BALR  R14,R15                    | Has CICS issued a message?|
         CLC   EXCI_MSG_PTR,ZERO          |                           |
         BE    NOMSG2                     | No: Continue.             |
MSG2     MVC   PRTRECORD(80),MSG15        | Yes: Msg='A message...'   |
         L     R15,=A(X'80000000'+PRINT)  |                           |
         BALR  R14,R15                    |                           |
         MVC   PRTRECORD(80),MSG02        | Msg='*    *'              |
         L     R15,=A(X'80000000'+PRINT)  |                           |
         BALR  R14,R15                    |                           |
         L     R5,EXCI_MSG_PTR            | Get ptr to message        |
         LH    R6,0(,R5)                  | Get the length            |
         LA    R7,4                       |                           |
         SR    R6,R7                      | Subtract LLBB from length |
         LA    R5,4(,R5)                  | Bump ptr past the LLBB    |
LOOP2    DS    0H                         |                           |
         LR    R8,R6                      | Start with length = msg l |
         LA    R7,80                      |                           |
         CR    R6,R7                      | Is it > 80 ?              |
         BL    SMLMSG2                    |                           |
         LA    R8,80                      | Yes - move first 80       |
SMLMSG2  DS    0H                         | No - move whole message   |
         BCTR  R8,0                       | Less one for MVC          |
         EX    R8,PRTMSG1                 | Move in message           |
         L     R15,=A(X'80000000'+PRINT)  |                           |
         BALR  R14,R15                    | Send message              |
         MVC   PRTRECORD(80),MSG00        | Clear buffer              |
         LA    R5,80(,R5)                 | Bump message pointer      |
         SR    R6,R7                      | and decrement length      |
         BP    LOOP2                      | Loop if more message      |
EXMSG2   MVC   PRTRECORD(80),MSG02        | Msg='*    *'              |
         L     R15,=A(X'80000000'+PRINT)  |                           |
         BALR  R14,R15                    |                           |
NOMSG2   MVC   PRTRECORD(80),MSG16        | Yes: Msg='Aborting...'    |
         L     R15,=A(X'80000000'+PRINT)  |                           |
         BALR  R14,R15                    |                           |
         B     SECTION3                   |                           |
PRTMSG2  MVC   PRTRECORD(0),0(R6)         *___________________________*
*
*=====================================================================*
*   Now, the Dpl was a success, but also check the server return code *
*   for a serious error.  End processing if it is found.              *
*=====================================================================*
*
CHK_SERV DS    0H                         *===========================*
         CLC   CALL,RET_ERROR             |                           |
         BNE   PRT_CON1                   |                           |
         MVC   SAVED_RESP,RET_ERROR       |                           |
         MVC   PRTRECORD(80),MSG07        |                           |
         L     R15,=A(X'80000000'+PRINT)  | Msg='Server response'     |
         BALR  R14,R15                    |                           |
         MVC   PRTRECORD(80),MSG08        |                           |
         L     R15,=A(X'80000000'+PRINT)  | Msg='Serious error'       |
         BALR  R14,R15                    |                           |
         B     SECTION3                   *___________________________*
*
*=====================================================================*
*   The call was good;                                                *
*   Get the EBCDIC_DATA container and write a message.
*=====================================================================*
*
PRT_CON1 DS    0H
         CLC   CHANNEL(16),=C'SECOND_CHANNEL  '
         BE    PRT_CON2
*
         XC    GET_AREA,GET_AREA
         MVC   GET_LENGTH,=F'100'
*
         EXEC CICS GET CONTAINER('EXCI_RESPONSE')                      *
               CHANNEL('FIRST_CHANNEL   ')                             *
               INTO(GET_AREA)                                          *
               FLENGTH(GET_LENGTH)                                     *
               RETCODE(EXEC_RETAREA)
*
         CLC   GET_AREA(2),=C'OK'
         BNE   DPLNOTOK                   | OK so far, continue
*
         MVC   GET_LENGTH,=F'100'
         XC    GET_AREA,GET_AREA
*
         EXEC CICS GET CONTAINER('EBCDIC_DATA')                        *
               CHANNEL('FIRST_CHANNEL   ')                             *
               INTO(GET_AREA)                                          *
               FLENGTH(GET_LENGTH)                                     *
               RETCODE(EXEC_RETAREA)
*                                         *===========================*
         MVC   PRTRECORD(80),MSG36        |                           |
         L     R15,=A(X'80000000'+PRINT)  | Msg=Container received    |
         BALR  R14,R15                    *___________________________*
*
         MVC   CHANNEL(16),SECOND_CHANNEL
*
         EXEC CICS PUT CONTAINER('REQUEST_TYPE')                       *
               CHANNEL('SECOND_CHANNEL  ')                             *
               FROM('CALL2')                                           *
               RETCODE(EXEC_RETAREA)
*                                         *===========================*
         B     MORE_DPL                   | Now get the other channel |
*                                         *___________________________*
*
DPLNOTOK DS    0H
         MVC   PRTRECORD(80),MSG34        | Msg='Response not OK'     |
         L     R15,=A(X'80000000'+PRINT)  |                           |
         BALR  R14,R15                    |                           |
         MVC   PRTRECORD(80),MSG16        | Msg='Aborting       '     |
         L     R15,=A(X'80000000'+PRINT)  |                           |
         BALR  R14,R15                    |                           |
         B     SECTION3                   | So exit                   |
*
*=====================================================================*
*   Now check the second channel                                      *
*=====================================================================*
*                                                                     *
PRT_CON2  DS    0H
*
         XC    GET_AREA,GET_AREA
         MVC   GET_LENGTH,=F'100'
*
         EXEC CICS GET CONTAINER('EXCI_RESPONSE')                      *
               CHANNEL('SECOND_CHANNEL  ')                             *
               INTO(GET_AREA)                                          *
               FLENGTH(GET_LENGTH)                                     *
               RETCODE(EXEC_RETAREA)
*
         CLC   GET_AREA(2),=C'OK'
         BE    DPLOK                      | OK so far, continue
*
         MVC   PRTRECORD(80),MSG34        | Msg='Response not OK'     |
         L     R15,=A(X'80000000'+PRINT)  |                           |
         BALR  R14,R15                    |                           |
         MVC   PRTRECORD(80),MSG16        | Msg='Aborting       '     |
         L     R15,=A(X'80000000'+PRINT)  |                           |
         BALR  R14,R15                    |                           |
         B     SECTION3                   | So exit                   |
*
DPLOK    DS    0H
         MVC   GET_LENGTH,=F'100'
         XC    GET_AREA,GET_AREA
*
         EXEC CICS GET CONTAINER('ASCII_DATA')                         *
               CHANNEL('SECOND_CHANNEL  ')                             *
               INTO(GET_AREA)                                          *
               FLENGTH(GET_LENGTH)                                     *
               INTOCCSID(UTF8)                                         *
               RETCODE(EXEC_RETAREA)
*                                         *===========================*
         MVC   PRTRECORD(80),MSG37        |                           |
         L     R15,=A(X'80000000'+PRINT)  | Msg=Container received    |
         BALR  R14,R15                    *___________________________*
*
SECTION3 DS    0H
*=====================================================================*
*                                                                     *
*   Processing is complete, so  tidy up by deleting  the channels     *
*   used. This will also delete any containers on those channels.     *
*   The Link will then be finished with, so it will be terminated     *
*   by issuing Close, and Deallocate pipe calls.                      *
*                                                                     *
*=====================================================================*
*
*=====================================================================*
*   Delete the channels used.                                         *
*=====================================================================*
*
         EXEC CICS DELETE CHANNEL('FIRST_CHANNEL   ')                  *
               RETCODE(EXEC_RETAREA)
*
         EXEC CICS DELETE CHANNEL('SECOND_CHANNEL  ')                  *
               RETCODE(EXEC_RETAREA)
*
         MVC   PRTRECORD(80),MSG29        *===========================*
         L     R15,=A(X'80000000'+PRINT)  | Msg='Channels have been   |
         BALR  R14,R15                    *______deleted' ____________*
*
*=====================================================================*
*   Close Pipe call;                                                  *
*=====================================================================*
*                                         *===========================*
CLOSPIPE DS    0H                         |  START OF PARAMETERS:     |
         MVC   EXCI_CALL,=AL4(CLOSE_PIPE) |  Load call-type and       |
         MVC   VERSION,=AL4(VERSION_1)    |  Put version back to 1    |
*                                         *___________________________*
*
         CALL  DFHXCIS,                                                *
               (VERSION,                                               *
               CALL_RETAREA,                                           *
               U_TOKEN,                                                *
               EXCI_CALL,                                              *
               P_TOKEN),                                               *
               VL,                                                     *
               MF=(E,PARM_LIST)
*
         MVC   PRTRECORD(80),MSG30        *===========================*
         L     R15,=A(X'80000000'+PRINT)  | Msg='Close pipe call'     |
         BALR  R14,R15                    *___________________________*
*
*=====================================================================*
*   Deallocate Pipe call;                                             *
*=====================================================================*
*                                         *===========================*
DEALPIPE DS    0H                         |  START OF PARAMETERS:     |
         MVC   EXCI_CALL,=AL4(DEALLOCATE_PIPE) Load call-type &       |
*                                         *___________________________*
*
*
         CALL  DFHXCIS,                                                *
               (VERSION,                                               *
               CALL_RETAREA,                                           *
               U_TOKEN,                                                *
               EXCI_CALL,                                              *
               P_TOKEN),                                               *
               VL,                                                     *
               MF=(E,PARM_LIST)
*
         MVC   PRTRECORD(80),MSG31        *===========================*
         L     R15,=A(X'80000000'+PRINT)  | Msg='Deallocate pipe call'|
         BALR  R14,R15                    *___________________________*
*
*=====================================================================*
*   Return caller's registers and return to caller                    *
*=====================================================================*
*
EXIT     DS    0H
         MVC   PRTRECORD(80),MSG02        *===========================*
         L     R15,=A(X'80000000'+PRINT)  | Msg='*        *'          |
         BALR  R14,R15                    |                           |
         MVC   PRTRECORD(80),MSG33        |                           |
         L     R15,=A(X'80000000'+PRINT)  | Msg='*===End of EXCI ===*'|
         BALR  R14,R15                    *___________________________*
*
*=====================================================================*
*   Set the output SYSPRINT log closed.                               *
*=====================================================================*
*
         MVC   CLSEPARM,CLSELIST
         LA    R1,CLSEPARM
         CLOSE OUTPUT,                                                 *
               MODE=31,                                                *
               MF=(E,(1))
*
*=====================================================================*
*   Set Register 15 to return code and exit.                          *
*=====================================================================*
*
         L     R15,SAVED_RESP
         DFHEIRET RCREG=(15)
*
*=====================================================================*
*   PRINT subroutine for outputting anything to the SYSPRINT log.     *
*=====================================================================*
*
PRINT    DS    0H                      *==============================*
         ST    R14,RET_ADDR            | Store return address         |
         L     R8,=A(PRINT10)          | Get 24 bit address           |
         BSM   R8,R8                   | Switch to Amode 24           |
PRINT10  DS    0H                      |                              |
*                                      |                              |
         PUT   DCBPARM,PRTRECORD       | Output Print record.         |
*                                      |                              |
         N     R8,=X'80000000'         | Isolate saved amode          |
         O     R8,=A(PRINT20)          | Add address to it            |
         BSM   0,R8                    | Switch back to original mode |
PRINT20  DS    0H                      |                              |
         L     R14,RET_ADDR            | Retrieve return address      |
         BR    R14                     *______________________________*
*
*=====================================================================*
*                                                                     *
*    Constants.                                                       *
*                                                                     *
*=====================================================================*
*
*                                    *===============================*
TARGET_INFO    DS 0F                 |Target Variable Constants.     |
TARGET_PROGRAM DC CL8'DFH$AXNS'      |  Server program name .        |
TARGET_TRANSID DC CL4'EXCI'          |  Name of Target Transaction.  |
DEFAULT_SYSTEM DC CL8'DBDCCICS'      |  If no CICS name is passed    |
FIRST_CHANNEL  DC CL16'FIRST_CHANNEL   '  | Channel name             |
SECOND_CHANNEL  DC CL16'SECOND_CHANNEL  ' | Channel name             |
*                                    |                               |
*                                    *_______________________________*
*
*                                    *===============================*
EXEC_INFO    DS 0F                   |EXEC level specific information|
EXEC_DAT_LEN DC  AL2(18)             |  Outbound length(EXEC call)   |
EXEC_COM_LEN DC  AL2(18)             |  Inbound length(EXEC call)    |
*                                    |                               |
*                                    *_______________________________*
*
*                                    *===============================*
CALL_INFO    DS 0F                   |Call level specific information|
APPLICATION  DC CL8'BATCHCLI'        |  Client program name.         |
*                                    |                               |
*                                    *_______________________________*
*
*                                    *===============================*
PROG_INFO    DS 0F                   |Program specific variables.    |
ZERO         DC F'0'                 |                               |
BLANKS       DC CL8'        '        |                               |
NOUSD        DC CL11'           '    | Blank Userid in message       |
NOAPP        DC CL7'       '         | No Parameters provided        |
FILLAPP      DC CL7'APPLID='         |                               |
FILLUSD      DC CL11'    USERID='    |                               |
MSGPARM      DC CL18'*     Parameters: '                             |
MSGLAST      DC CL28'                           *'                   |
UTF8         DC F'1208'              |                               |
RET_ERROR    DC F'16'                | Serious error detected        |
*                                    |                               |
*                                    *_______________________________*
*
*                                    *===============================*
*                                    |DCB for SYSPRINT output file.  |
OUTPUT   DCB   DSORG=PS,             | Physical sequential           | X
               DDNAME=SYSPRINT,      | DDNAME                        | X
               MACRF=(PM),           | PUT MOVE                      | X
               LRECL=80,             | LOGICAL RECORD LENGTH         | X
               RECFM=F               | FIXED BLOCK W ASCII CC        |
DCBLEN   EQU   *-OUTPUT              | Length of storage needed.     |
*                                    |                               |
*                                    *_______________________________*
*
*                                    *===============================*
*                                    |List form of 31 bit open macro |
OPENLIST OPEN  OPENLIST,             |                               | X
               MODE=31,              |                               | X
               MF=L                  |                               |
OPENLEN  EQU   *-OPENLIST            | Length of storage needed      |
*                                    *_______________________________*
*                                    *===============================*
*                                    |List form of 31 bit close macro|
CLSELIST CLOSE CLSELIST,             |                               | X
               MODE=31,              |                               | X
               MF=L                  |                               |
CLSELEN  EQU   *-CLSELIST            | Length of storage needed      |
*                                    *_______________________________*
*
*====================================================================*
*    Messages for output to the SYSPRINT log.                        *
*====================================================================*
*
MESSAGES DS 0F
MSG00    DC CL80' '
MSG01    DC CL40'*===================== EXCI Sample Batch'
         DC CL40' Client Program =======================*'
MSG02    DC CL40'*                                       '
         DC CL40'                                       *'
MSG03    DC CL40'*  EXEC Level Processor.                '
         DC CL40'                                       *'
MSG04    DC CL40'*    Setting up the EXEC level call.    '
         DC CL40'                                       *'
MSG05    DC CL40'*    The Link Request with channel FIRST'
         DC CL40'_CHANNEL has completed successfully.   *'
MSG06    DC CL40'*    The Link Request with channel SECON'
         DC CL40'D_CHANNEL has completed successfully.  *'
MSG07    DC CL40'*    Server Response:                   '
         DC CL40'                                       *'
MSG08    DC CL40'*      A serious error was detected.    '
         DC CL40'                                       *'
MSG09    DC CL40'*    The Link Request has failed.  Retur'
         DC CL40'n codes are;                           *'
MSG10    DC CL40'*    A PUT_CONTAINER command has failed.'
         DC CL40' Return codes are;                     *'
MSG11    DC CL16'*        Resp = '
MSG12    DC CL10'  Resp2 = '
MSG13    DC CL14'  Abend Code: '
MSG14    DC CL16'               *'
MSG15    DC CL40'*    A message was received from the tar'
         DC CL40'get CICS region:                       *'
MSG16    DC CL40'*    >>>> Aborting further processing <<'
         DC CL40'<<                                     *'
MSG17    DC CL40'*  CALL Level Processor.                '
         DC CL40'                                       *'
MSG18    DC CL40'*    Initialise_User call complete.     '
         DC CL40'                                       *'
MSG19    DC CL40'*    Allocate_Pipe call complete.       '
         DC CL40'                                       *'
MSG20    DC CL40'*    Open_Pipe call complete.           '
         DC CL40'                                       *'
MSG21    DC CL40'*    The connection has been successful.'
         DC CL40'                                       *'
MSG22    DC CL40'*    The connection has been unsuccessfu'
         DC CL40'l.  Return codes are:                  *'
MSG23    DC CL16'*    Response = '
MSG24    DC CL10' Reason = '
MSG25    DC CL14' Subreason = '
MSG26    DC CL40'*      The Dpl request has failed.      '
         DC CL40'                                       *'
MSG27    DC CL40'*      Link return codes are:           '
         DC CL40'                                       *'
MSG28    DC CL40'*      Dpl return codes are:            '
         DC CL40'                                       *'
MSG29    DC CL40'*    Channels have been deleted.        '
         DC CL40'                                       *'
MSG30    DC CL40'*    Close_Pipe call complete.          '
         DC CL40'                                       *'
MSG31    DC CL40'*    Deallocate_Pipe call complete.     '
         DC CL40'                                       *'
MSG33    DC CL40'*=================== End of EXCI Sample '
         DC CL40'Batch Client Program ==================*'
MSG34    DC CL40'*    Response container does not contain'
         DC CL40' OK.                                   *'
MSG35    DC CL40'*    Checking response container sent by'
         DC CL40' server.                               *'
MSG36    DC CL40'*    Container EBCDIC_DATA was received '
         DC CL40'correctly in channel FIRST_CHANNEL.    *'
MSG37    DC CL40'*    Container ASCII_DATA was received c'
         DC CL40'orrectly in channel SECOND_CHANNEL.    *'
MSG38    DC CL40'*    Response OK, continue processing.  '
         DC CL40'                                       *'
*
*====================================================================*
*                                                                    *
*    Definitions for Working Storage.                                *
*                                                                    *
*====================================================================*
*
DFHEISTG     DSECT
CLEAR_START  DS 0F
STOREYE      DS 8C                   *===============================*
*                                    |Storage for Tokens;            |
TOKENEYE     DS 8C                   |                               |
U_TOKEN      DS F                    |  User token storage.          |
P_TOKEN      DS F                    |  Pipe token storage.          |
*                                    |                               |
*                                    *_______________________________*
*                                    *===============================*
*                                    |                               |
VERSION      DS F                    |  Vehicle for Version num      |
EXCI_CALL    DS F                    |  Vehicle for call type.       |
CALL_RETCODE DS F                    |  Return Code Area.            |
RET_ADDR     DS F                    |  Print routine return address.|
SAVED_RESP   DS F                    |  Save area for return code    |
OPTIONS      DS XL1                  |  Vehicle for dpl,aloc opts.   |
*                                    *_______________________________*
*
*                                    *===============================*
*                                    | Storage allocation (Return    |
*                                    |    Codes and parameters.)     |
EXECEYE      DS 8C                   |                               |
EXEC_RETAREA DS CL(EXCI_EXEC_RETURN_CODE__LEN)                       |
             DS 0D
PARMEYE      DS 8C                   |                               |
* Reserve storage for CALL API parm list. Use list form of CALL macro
* for DPL call which has the largest number of parameters.
PARM_LIST    CALL ,                                                    *
               (VERSION,                                               *
               CALL_RETAREA,                                           *
               U_TOKEN,                                                *
               EXCI_CALL,                                              *
               P_TOKEN,                                                *
               TARGET_PROGRAM,                                         *
               CHANNEL,                                                *
               0,                                                      *
               0,                                                      *
               TARGET_TRANSID,                                         *
               0,                                                      *
               0,                                                      *
               DPL_RETAREA,                                            *
               OPTIONS,                                                *
               0,                                                      *
               0,                                                      *
               0),                                                     *
               VL,                                                     *
               MF=L
EXCIEYE      DS 8C                   |                               |
CALL_RETAREA DS CL(EXCI_RETURN_CODE__LEN)                            |
DPL_EYE      DS 8C                   |                               |
DPL_RETAREA  DS CL(EXCI_DPL_RETAREA__LEN)                            |
*                                    |                               |
CLEAR_LEN    EQU *-CLEAR_START       |                               |
*                                    *_______________________________*
GET_AREA     DS CL100
GET_LENGTH   DS F
*
CALL         DS F
CHANNEL      DS 16C                  |  Channel name                 |
             DS 0D                   |                               |
WORK1        DS D                    |  Workarea1 for conversion.    |
WORK2        DS D                    |  Workarea2 for conversion.    |
             DS 0F                   |  Error Msg storage.           |
ERRMSG       DS 16C                  |                               |
ERRMSG1      DS 8C                   |  first code area.             |
ERRMSG2      DS 10C                  |                               |
ERRMSG3      DS 8C                   |  second code area.            |
ERRMSG4      DS 14C                  |                               |
ERRMSG5      DS 8C                   |  third/abend code area.       |
ERRMSG6      DS 16C                  |                               |
MSG32        DS 18C                  |  Set up Parameter message     |
MSG32A       DS 7C                   |                               |
MSG32B       DS 8C                   |                               |
MSG32C       DS 11C                  |                               |
MSG32D       DS 8C                   |                               |
MSG32E       DS 28C                  |                               |
TARGET_SYSTEM DS CL8                 |  Applid of Target CICS        |
TARGET_USERID DS CL8                 |  Userid on Target CICS        |
*                                    |                               |
*                                    *_______________________________*
*
*
*                                    *===============================*
*                                    |                               |
PRTRECORD    DS 80C                  | Output buffer for printing.   |
DCBPARM  DS  CL(DCBLEN)              | Allocation for DCB.           |
OPENPARM DS  CL(OPENLEN)             | Allocation for open plist     |
CLSEPARM DS  CL(CLSELEN)             | Allocation for Close plist    |
*                                    |                               |
*                                    *_______________________________*
PUT_LENGTH   DS F
PUT_AREA     DS CL64
             DFHREGS
             END DFH$AXNC
###END DFH$AXNC
$$$BEG EXPLSORT
*PROCESS COMPAT(NOCASE,MACROCASE)                          Ver1
         sysstate archlvl=2
EXPLSORT csect
EXPLSORT amode 31
EXPLSORT rmode 31
*
         yregs
         J     BEGIN
PROLOG   LOCTR
         DC    C'EXPLSORT'
         DC    C'AsmDate && Time: &SYSDATE &SYSTIME'
         DC    C'Ver 0.1'
         DC    C'All rights reserved'
CODEBG1  LOCTR
BEGIN    DS    0H
         using data,12
         save  (14,12)       save z/os's regs
         larl  12,data       use this instead of lr and ahi
*        LR    R12,R15
*        AHI   R12,data-BEGIN

         getmain r,lv=worksize
         st    13,4(1)
         lr    13,1
         using (wareas,wareasend),13
*  ...
         mvc   maxct,=f'10'   max ent to sort
         l     r9,maxct
         ahi   r9,-1
         st    r9,maxct_less_1
         xr    r9,r9          loop count
         la    r8,tblbeg      addr of in stg tbl
inittbl_loop ds 0h
         mvc   0(16,r8),tblent  for testing - print the stg tbl
         ic    r7,tblent_l-1(r8)   incr last byte for unique data
         la    r7,1(r7)         add 1
         stc   r7,tblent_l-1(r8)   stc back
         la    r9,1(r9)         bump loop ctr
         la    r8,l'tblent(r8)  point to next stg tbl ent
         c     r9,maxct         at max?
         jl    inittbl_loop     no, then loop
*
         xr    r9,r9           loop count
         la    r8,tblbeg       addr of in stg tbl
*
top_sort_loop ds 0h
         mvc   tmp,0(r8)       move cur stg tbl ent to tmp
         la    r6,1(r9)        inner loop starts at cur elm plus 1
         lr    r7,r8           use r7 to iterate down/up the list
         ahi   r7,tblent_l     ptr to loop thru next tst elm
chk_nxt_top  ds 0h
         mvc   tmp2,0(r7)       tst tmp (cur elm) against the nxt elm
         clc   tmp,tmp2        tst tmp (cur elm) against the nxt elm
*        clc   tmp,0(r7)       tst tmp (cur elm) against the nxt elm
         jl    chk_nxt_go_nxt    if tmp is lower, then no chg to order
*                              fnd nxt elm lower than tmp (cur elm)
         mvc   0(tblent_l,r8),0(r7)  move lower to cur ent
         mvc   0(l'tblbeg,r7),tmp    replace cur with tmp (higher)
         mvc   tmp,0(r8)             replace tmp with new low in cur
*
chk_nxt_go_nxt ds 0h
         la    r6,1(r6)
         ahi   r7,tblent_l     ptr to next tst elm
         c     r6,maxct
         jl    chk_nxt_top
*
         la    r9,1(r9)
         ahi   r8,tblent_l     ptr to next tst elm
         c     r9,maxct_less_1   if we are at last elm
         jl    top_sort_loop       then we are sorted
*
* rotate thru valid cnc name character values
         mvi   cnc_val_chr,x'ef'   start pos is out of ranges
         la    r8,val_cnc_e1       start of tbl
         st    r8,cnc_val_chr_cur_tbl_ent      save it as cur pos
* ...
cnc_get_val_chr ds  0h
         ic    r15,cnc_val_chr
         la    r15,1(r15)
         stc   r15,cnc_val_chr
cnc_get_nxt_val_chr_top ds 0h
         l     r8,cnc_val_chr_cur_tbl_ent
         clc   cnc_val_chr,1(r8)            each tbl ent has beg val
*                                         and a high value
         jnh     cnc_got_nxt_val_chr
*
         la    r8,val_cnc_e_l(r8)        if high, then get nxt tbl
         cli   0(r8),x'ff'               at x'ff' we at at end
         je    cnc_tbl_end
*
         mvc   cnc_val_chr,0(r8)            each tbl ent has beg val
         st    r8,cnc_val_chr_cur_tbl_ent
*
cnc_got_nxt_val_chr ds 0h
*
cnc_tbl_end ds 0h
*
* at termination:
*
         clrje 15,15,doterm
*        ltr   15,15
*        jz    doterm
err0     ds    0h
         la    15,8
*
doterm   ds    0h
         lr    1,13
         l     0,fsize
         l     13,4(13)
         freemain r,lv=(0),a=(1)
         return (14,12),,rc=0
*
data     ds    0f
fsize    dc    a(worksize)
tblent   dc    cl16'test123456789000'
tblent_l equ   l'tblent
val_cnc_chars ds  0f
val_cnc_e1    dc  c'0',c'9'   f0-f9
val_cnc_e2    dc  c'.',c'<'   4b-4c
val_cnc_e3    dc  c'|',c'&&'  4f-50
val_cnc_e4    dc  c'!',c'$'   5a-5b
val_cnc_e5    dc  c';',c';'   5e-5e
val_cnc_e6    dc  c'-',c'/'   60-61
val_cnc_e7    dc  c',',c'?'   6b-6f
val_cnc_e8    dc  c':',c'@'   7a-7c
val_cnc_e9    dc  c'=',c'"'   7e-7f
*
val_cnc_e10   dc  c'a',c'i'   81-89
val_cnc_e11   dc  c'j',c'r'   91-99
val_cnc_e12   dc  c's',c'z'   a2-a9
val_cnc_e13   dc  c'A',c'I'   c1-c9
val_cnc_e14   dc  c'J',c'R'   d1-d9
val_cnc_e15   dc  c'S',c'Z'   e2-e9
val_cnc_ff    dc  x'ff',x'ff' ff-ff
val_cnc_e_l   equ *-val_cnc_ff
*
* abcdefghi
*          jklmnopqr
*                   stuvwxyz
* ABCDEFGHI
*          JKLMNOPQR
*                   STUVWXYZ
* 0123456789
*
*
* .<|&!$;-/,%_>?:#@="
* 44455556666666777774
* BCF0ABE01BCDEFABCEF0
         ltorg
wareas   dsect
save     ds    36f'0'
maxct    ds    f
maxct_less_1  ds    f
tmp      ds    cl16
tmp2     ds    cl16
tblbeg   ds    16cl16
tblbeg_l   equ *-tblbeg
tblend   ds    cl16
         ds    0d
cnc_val_chr_cur_tbl_ent ds f
cnc_val_chr  ds  cl1
wareasend ds   0h
worksize equ   *-save
         end   EXPLSORT
###END EXPLSORT
$$$BEG EXPBLESS
*PROCESS COMPAT(NOCASE,MACROCASE)                          Ver1
         sysstate archlvl=2
EXPBLESS csect
EXPBLESS amode 31
EXPBLESS rmode 31
*
         yregs
         J     BEGIN
PROLOG   LOCTR
         DC    C'SAMPLE01'
         DC    C'AsmDate && Time: &SYSDATE &SYSTIME'
         DC    C'Ver 1.2.3'
         DC    C'All rights reserved'
CODEBG1  LOCTR
BEGIN    DS    0H
         using data,12
         save  (14,12)       save z/os's regs
         larl  12,data       use this instead of lr and ahi
*        LR    R12,R15
*        AHI   R12,data-BEGIN

         getmain r,lv=worksize
         st    13,4(1)
         lr    13,1
         using (wareas,wareasend),13
*  ...
*
*
* at termination:
*
         clrje 15,15,doterm
*        ltr   15,15
*        jz    doterm
err0     ds    0h
         la    15,8
*
doterm   ds    0h
         lr    1,13
         l     0,fsize
         l     13,4(13)
         freemain r,lv=(0),a=(1)
         return (14,12),,rc=0
*
data     ds    0f
fsize    dc    a(worksize)
*
         ltorg
wareas   dsect
save     ds    36f'0'
wareasend ds   0h
worksize equ   *-save
         end   EXPBLESS
###END EXPBLESS
$$$BEG EXPSYSPR
* MINIMUM SYSPRINT ABOVE CODE  (REVISED 2016/12/06)
*  DCB MUST BE IN 24 BIT STG, BUT WE CAN EXECUTE CODE IN 31 BIT
*   MY_STATIC   START OF 24 BIT DBC AREA IN CSECT
*   MYDCB_SYP   DCB POINTS TO THE DCBE
*   MYDCBE_SYP  HAS RMODE31=BUFF WHICH LOCATES IO BUFFS IN 31 BIT
*   MYOPEN      MODE=31 TELLS OPEN TO USE 31 BIT ADDR
*               MF=L LIST FORM - ANY EXECUTE FORM REF MUST BE
*                    CONSISTANT IN MODE=31 - OTHERWISE ABENDS
*               OPEN MODE=24 HAS 1 FW 1 BYTE FOR OPTIONS, THEN 24
*                            BIT DCB ADDR
*               OPEN MODE=31 HAS 2 FW 1ST FW FOR OPTIONS, THEN 31
*                            BIT DCB ADDR IN2ND FW
*               NOTE: LAST (ONLY?) OPTION MUST HAVE HIGH ORDER
*                     (BIT 0) SET ON
*  SEQUENCE:
*   GM 24 BIT WORK AREA FOR DCB USE
*   THIS CSECT HAS DCB (AND OTHER STATIC DATA) AS PART OF THE PGM
*     WE COPY THE DCB/DCBE/OPEN/CLOSE CODE INTO 24 BIT DYN STG
*   THE OPEN IS CODED AS LIST FORM, AND COPIED TO THE 24 DYN STG
*   MVI THE X'80 TO THE FIRST BYTE IN OPTION AREA, OF LAST DCB
*     CODED ON THE OPEN (OPEN CAN HAVE 1 TO MANY DCB CODED)
*   MAKE SURE MODE ON LIST AND EXECUTE ARE CONSISTANT
*   PUT FROM 31 BIT BUFFER STG MANAGED BY IO ROUTINE OR NONE
*   REG 1 ADDR OF NEXT BUFFER WILL BE LOCATED BASED ON THE
*     RMODE31=BUFF CODE
*   CLOSE MACRO FOR ONE TO MANY (MODE MUST BE CONSISTENT)
*   YOU DO NOT HAVE TO OPEN AND CLOSE THE SAME LIST OF DCBS
*
*
         SYSSTATE ARCHLVL=2
EXPSYSPR CSECT
EXPSYSPR RMODE ANY
EXPSYSPR AMODE 31
         YREGS
*  NO BASE REG USED
*  R2 TMP BASE REG FOR STATIC STG
*  R11 BASE REG FOR 24 BIT DBC DYN STG
*  R12 BASE REG CSECT STATIC STG
*  R13 BASE REG FOR 31 BIT DYN STG
         J     BEGIN
PROLOG   LOCTR
THIS_PGM DC    C'EXPSYSPR'
         DC    C'ASMDATE && TIME: &SYSDATE &SYSTIME'
         DC    C'VER 0.0.1'
CODEBG1  LOCTR
BEGIN    DS    0H
         SAVE  (14,12)       SAVE Z/OS'S REGS
*
         LARL R12,MY_STATIC
         USING MY_STATIC,R12
*
*  GET THIS PGMS DYNAMIC STORAGE
         GETMAIN R,LV=WORKSIZE,LOC=31
         CIJNE   R15,0,NOSTG
*
         ST    13,4(1)
         LR    13,1
         USING (WAREAS,WAREASEND),13
* HOUSE KEEP
         XC    RC,RC
         MVI   MSGAREA1,X'40'
         MVC   MSGAREA,MSGAREA1
*
* FIRST - GET THE 24 BIT STG FOR DCB/DCBE/OPEN/CLOSE
         GETMAIN R,LV=AREALEN,LOC=24
         CIJNE   R15,0,NO24STG
         LR R11,R1
*
* SECOND - ESTABLISH ADDRESSABILITY
          USING    MY_24_DCB,R11      ADDR 24BIT
SYP_DCBD  USING    IHADCB,INDCB_SYP INDCB IS IN MY_24_DCB
SYP_DCBE  USING    DCBE,INDCBE_SYP    INDCBE IS IN MY_24_DCB
*
* THIRD  - COPY THE DCB FROM CSECT TO 24 BIT AREA
* BASELESS  METHOD BELOW OR AREALEN TOO LARGE
         LA   R2,MYDCB_SYP
         LA  R3,AREALEN
         LA  R4,SYP_DCBD.IHADCB
         LR  R5,R3
         MVCL R4,R2
*  IF WE DON'T SET BASE REG, THEN WE CAN'T ACCESS STATIC FLDS
* ALTERNATE METHOD ABOVE USES BASE REG
*  THIS METHOD BELOW REQUIRE A BASE REG TO ADDR MYDCB_SYP IN STATIC
*        MVC SIN_DCBD.IHADCB(AREALEN),MYDCB_SYP COPY DCB AND DCBE
         MVC   END_31_LIT(L'END_31_STATIC),END_31_STATIC
*
*
* FORTH  - GET THE 24 BIT ADDR OF DCBE AND MVC IT TO 24 BIT DCB
         LA R0,SYP_DCBE.DCBE    DCBE ADDR IN SIN_DCBD IN DYN 31 STG
         ST R0,SYP_DCBD.DCBDCBE  DCBE ADDR SAVED DSECT IN DYN 31 STG
*
*
* FIFTH  - SET THE LAST DBC OPTION WITH HIGH ORDER BIT X'80'
*        OI    INOPEN,X'80' SET HIGH ORDER BIT OF LAST ENTRY
*               IN THE OPEN LIST, TO 1 (INDICATE LAST ENTRY)
*
* SIXTH  - OPEN THE 24 BIT DCBS USING EXECUTE FORM, POINTING TO THE
*          24 BIT LIST FORM COPY
         OPEN (SYP_DCBD.IHADCB,(OUTPUT)),                              *
               MODE=31,MF=(E,INOPEN)
         LTR R15,R15 BRANCH IF DDNAME SEEMS NOT
         JNZ BAD_OPEN TO BE DEFINED
*
         MVC   MSGAREA_LRECL,SYP_DCBD.DCBLRECL
*
         MVC   MSGAREA(L'BEG_MSG),BEG_MSG
*
         LARL  R2,THIS_PGM
         MVC   MSGAREA+10(L'THIS_PGM),0(R2)
*
* SEVENTH -CLOSE THE 24 BIT DCBS USING EXECUTE FORM, POINTING TO THE
*           24 BIT LIST FORM COPY OF THE OPEN MACRO
         JAS   R9,PUT_OUTPUT
*
         J   EOD
*    MORE
*
* NOTE 1: CODE THIS SYNADAF AREA FOR IO ERRORS QSAM
*
* I/O ERROR ROUTINE FOR INDCB
IOE_SIN  SYNADAF ACSMETH=QSAM GET MESSAGE AREA
         MVI 6(R1),X'80' SET WTO MCS FLAGS
         MVC 8(16,R1),=CL16'I/O ERROR' PUT PHRASE ON BIN FLDS
         MVC 128(4,R1),=X'00000020' SET ROUTCDE=11 (WTP)
         WTO MF=(E,4(R1)) WRITE MESSAGE TO USER
         SYNADRLS        RELEASE SYNADAF AREA,FALL THRU
         J    ERR8
*
* NOTE 2: CODE THIS EOD     AREA FOR IO EOD ON INPUT DCB
*
* THE GET MACRO BRANCHES HERE AFTER ALL RECORDS HAVE BEEN READ
EOD      DS    0H
*
         MVC   MSGAREA(L'END_MSG),END_MSG
         LARL  R2,THIS_PGM
         MVC   MSGAREA+10(L'THIS_PGM),0(R2)
         JAS   R9,PUT_OUTPUT
*
* EIGHTH -CLOSE THE 24 BIT DCBS USING EXECUTE FORM, POINTING TO THE
*          24 BIT LIST FORM COPY - MODE MUST BE CONSISTENT
*
         CLOSE (SYP_DCBD.IHADCB),MF=(E,INCLOSE),MODE=31
         J    FIN_IT
* FREEPOOL NOT NEEDED DUE TO RMODE31=BUFF (I.E. DYN STG AREA)
BAD_OPEN DS 0H
         MVI   RC+3,X'15'
         J    DO_TERM
*
FIN_IT   DS   0H
         MVI   RC+3,X'00'
         J     DO_TERM
*
ERR8     DS    0H
         MVI   RC+3,X'08'
         J     DO_TERM
*
NO24STG  DS    0H
         ST    R15,RC
         J     DO_TERM1
*
DO_TERM  DS    0H
         LR    1,11
         LA    0,AREALEN
         FREEMAIN R,LV=(0),A=(1)
*
DO_TERM1 DS    0H
         L     R2,RC
         LR    1,13
         L     0,FSIZE
         L     13,4(13)
         FREEMAIN R,LV=(0),A=(1)
         LR    R15,R2
NOSTG    DS    0H
         RETURN (14,12),,RC=(15)
*
* REST OF PROGRAM
*
* NOTE 3: PUT MOVE MODE FROM PGM 31 BIT DYN STG
*
PUT_OUTPUT DS 0H
         ST  R9,SAV_R9
*
         MVC   MSGAREA_LRECL,SYP_DCBD.DCBLRECL
*
         PUT INDCB_SYP,MSGAREA
         MVC MSGAREA,MSGAREA1
         L   R9,SAV_R9
         BR  R9
*
***
*
* NOTE 4: THE FOLLOWING IS INPGM 31 BIT STATIC STORAGE -
*         WE COPY STATIC DATA FROM HERE (INLC DCB AND LTORG DATA)
*
*
*        PART OF THE CSECT; COPIED TO 24 BIT
MY_STATIC DS 0D
BEG_VAR_IN_STATIC DC C'>>>BEG THIS IS IN THE STATIC AREA<<<'
*   USE LAR TO GET REL ADDR FOR USING THEN MVC INSTEAD OF MVCL
*
*  SYSPRINT STATIC DATA - DCB IS FOR SYSPRING PUT MOVE
*    WHICH MEANS THAT THE PUT MACRO ACTUALLY MOVES THE CONTENTS
*    TO A BUFFER, AND WRITES IT INTO THE OUTPUT BUFFER.
*                                                     ,
*    PUT LOCATE WILL RETURN TO YOU, THE NEXT OUTPUT BUFFER
*    LOCATION. YOU FILL IT IN. AS THE BUFFER AREA (BLKSIZE) IS
*    FILLED TO FULL, (OR YOU ISSUE CLOSE) THE IO ROUTINE WILL WRITE
*    THE BUFFER TO THE DEVICE. THIS MEANS THAT IN PUT LOCATE MODE
*    YOU WOULD ISSUE THE PUT COMMAND AND THEN FILL IN THE BUFFER
*    WHOSE ADDR IS RETURNED BY PUT INTO REG1.
*
*
* NOTE 5: THIS IS THE STATIC DCDB TO BE COPIED TO 24 BIT STG
*
MYDCB_SYP  DCB DDNAME=SYSPRINT,MACRF=PM,RECFM=FB,DSORG=PS,             *
               DCBE=MYDCBE_SYP
MYDCB_SYP_L EQU *-MYDCB_SYP
*
* DCB EODAD  AND SYNAD ROUTINES:
* THIS EODAD/SYNAD ROUTINE ENTRY POINT SPECIFIED IN THE DCB MUST
* BELOW THE LINE. IF YOU WISH THE ENTRY POINT TO RESIDE ABOVE THE
* LINE, USE THE EODAD/SYNAD PARAMETER OF THE DCBE MACRO
*
MYDCBE_SYP  DCBE SYNAD=IOE_SIN,BLKSIZE=0,RMODE31=BUFF
MYDCBE_SYP_L EQU *-MYDCBE_SYP
*
*
* NOTE 6: OPEN LIST FORM AREA FROM STATIC DCB: COPIED TO 24 BIT STG
*
* OPEN BOTH INPUT AND OUTPUT
MYOPEN   OPEN  (,),MF=L,MODE=31
MYOPEN_L EQU *-MYOPEN
*
MYCLOSE  CLOSE (,),MF=L,MODE=31
MYCLOSE_L EQU *-MYCLOSE
*
         DS 0D
*
* EYE CATCHER FOR 24 BIT DYN
END_24_BIT_MSG DC C'<<<END_OF_24_STG>>>'
AREALEN EQU *-MYDCB_SYP
*
         DS 0D      JUST FOR ALIGNMENT; NOT REQUIRED
*
*
FSIZE    DC    A(WORKSIZE)
END_31_STATIC DC C'<<<END_OF_31_STG>>>'
*
*             0....5....1....5....2....5....3....5....4....5....E....5
BEG_MSG  DC C'*** BEGIN          AT'
END_MSG  DC C'*** END            AT'
END_VAR_IN_STATIC DC C'>>>THIS IS IN THE STATIC AREA END<<<'
STATIC_CSECT_DATA_LENGTH EQU *-MY_STATIC
*
*  LTORG HAS GOT TO BE PART OF THE CSECT: SO INCLUDE IT
*   BEFORE CODING THE DYN STG AND/OR DSECT AREA
*   COULD DO LOCTR DOR CODE - ????
         LTORG
*
* NOTE 7: DSECT AREA FOR USING REFERENCE - DCB/DCBE/DSA AREA IN 31 BIT
*
*
*  THE FOLLOWING ARE DSECT AREA
*  DCBD AND IHADCBE MACROS GENERATE DESECTS FOR USING DIRECTIVES
            DCBD     DSORG=QS,DEVD=DA     GENERATES A DSECT
            IHADCBE            DCBE IS TO BE ABOVE 16 MB LINE
*
* NOTE 8: DSECT AREA FOR USING REF 24 BIT- DCB/DCBE/OPEN LIST FORM
*
* THIS DSECT WILL BE USED TO REFERENCE THE 24 BIT DCB/DCBE/OPEN
* DSA AREA GM 24 BIT FOR THIS
MY_24_DCB DSECT
INDCB_SYP  DS XL(MYDCB_SYP_L)
INDCBE_SYP DS XL(MYDCBE_SYP_L)
INOPEN     DS XL(MYOPEN_L)
INCLOSE    DS XL(MYCLOSE_L)
         DS    0D
END_24_LIT DS  CL32    '<<<END_OF_24_STG>>>'
*
*
* NOTE 9: DSECT AREA FOR USING REFERENCE - DSA 31 BIT STG
*
* THIS PROGRAMS 31 BIT STORAGE
* DSA AREA GM 31 BIT FOR THIS
WAREAS   DSECT
SAVE     DS    36F'0'
*
SAV_R9   DS    F
RC       DS    F
MSGAREA_LRECL DS H
MSGAREA1 DS    CL1
MSGAREA  DS    CL(255)
         DS    0D
*
END_31_LIT DS  CL32    '<<<END_OF_31_STG>>>'
WAREASEND DS   0H
WORKSIZE EQU   *-SAVE
*
         END   EXPSYSPR
###END EXPSYSPR
$$$BEG EXPSYSIN
* MINIMUM SYSIN  ABOVE CODE  (REVISED 2016/12/06)
*  DCB MUST BE IN 24 BIT STG, BUT WE CAN EXECUTE CODE IN 31 BIT
*   MY_STATIC   START OF 24 BIT DBC AREA IN CSECT
*   MYDCB_SYP   DCB POINTS TO THE DCBE
*   MYDCBE_SYP  HAS RMODE31=BUFF WHICH LOCATES IO BUFFS IN 31 BIT
*   MYOPEN      MODE=31 TELLS OPEN TO USE 31 BIT ADDR
*               MF=L LIST FORM - ANY EXECUTE FORM REF MUST BE
*                    CONSISTANT IN MODE=31 - OTHERWISE ABENDS
*               OPEN MODE=24 HAS 1 FW 1 BYTE FOR OPTIONS, THEN 24
*                            BIT DCB ADDR
*               OPEN MODE=31 HAS 2 FW 1ST FW FOR OPTIONS, THEN 31
*                            BIT DCB ADDR IN2ND FW
*               NOTE: LAST (ONLY?) OPTION MUST HAVE HIGH ORDER
*                     (BIT 0) SET ON
*  SEQUENCE:
*   GM 24 BIT WORK AREA FOR DCB USE
*   THIS CSECT HAS DCB (AND OTHER STATIC DATA) AS PART OF THE PGM
*     WE COPY THE DCB/DCBE/OPEN/CLOSE CODE INTO 24 BIT DYN STG
*   THE OPEN IS CODED AS LIST FORM, AND COPIED TO THE 24 DYN STG
*   MVI THE X'80 TO THE FIRST BYTE IN OPTION AREA, OF LAST DCB
*     CODED ON THE OPEN (OPEN CAN HAVE 1 TO MANY DCB CODED)
*   MAKE SURE MODE ON LIST AND EXECUTE ARE CONSISTANT
*   PUT FROM 31 BIT BUFFER STG MANAGED BY IO ROUTINE OR NONE
*   REG 1 ADDR OF NEXT BUFFER WILL BE LOCATED BASED ON THE
*     RMODE31=BUFF CODE
*   CLOSE MACRO FOR ONE TO MANY (MODE MUST BE CONSISTENT)
*   YOU DO NOT HAVE TO OPEN AND CLOSE THE SAME LIST OF DCBS
*
*
         SYSSTATE ARCHLVL=2
EXPSYSIN CSECT
EXPSYSIN RMODE ANY
EXPSYSIN AMODE 31
         YREGS
*  NO BASE REG USED
*  R2 TMP BASE REG FOR STATIC STG
*  R11 BASE REG FOR 24 BIT DBC DYN STG
*  R12 BASE REG CSECT STATIC STG
*  R13 BASE REG FOR 31 BIT DYN STG
         J     BEGIN
PROLOG   LOCTR
         DC    C'EXPSYSIN'
         DC    C'ASMDATE && TIME: &SYSDATE &SYSTIME'
         DC    C'VER 0.0.1'
CODEBG1  LOCTR
BEGIN    DS    0H
         SAVE  (14,12)       SAVE Z/OS'S REGS
*
         LARL R12,MY_STATIC
         USING MY_STATIC,R12
*
*  GET THIS PGMS DYNAMIC STORAGE
         GETMAIN R,LV=WORKSIZE,LOC=ANY
         CIJNE   R15,0,NOSTG
*
         ST    13,4(1)
         LR    13,1
         USING (WAREAS,WAREASEND),13
* HOUSE KEEP
         XC    RC,RC
*
         GETMAIN R,LV=AREALEN,LOC=BELOW
         CIJNE   R15,0,NO24STG
*
         LR R11,R1
          USING    MY_24_DCB,R11      ADDR 24BIT
SIN_DCBD  USING    IHADCB,INDCB_SIN INDCB IS IN MY_24_DCB
SIN_DCBE  USING    DCBE,INDCBE_SIN    INDCBE IS IN MY_24_DCB
* BASELESS  METHOD BELOW OR IF STATIC AREA IS TOO LARGE FOR MVC
*        LARL R2,MYDCB_SIN
*        LA  R3,AREALEN
*        LA  R4,SIN_DCBD.IHADCB
*        LR  R5,R3
*        MVCL R2,R4
*  IF WE DON'T SET BASE REG, THEN WE CAN'T ACCESS STATIC FLDS
* ALTERNATE METHOD ABOVE USES BASE REG
*  THIS METHOD BELOW REQUIRE A BASE REG TO ADDR MYDCB_SIN IN STATIC
         MVC SIN_DCBD.IHADCB(AREALEN),MYDCB_SIN COPY DCB AND DCBE
         MVC   END_31_LIT(L'END_31_STATIC),END_31_STATIC
*
*
         LA R0,SIN_DCBE.DCBE    DCBE ADDR IN SIN_DCBD IN DYN 31 STG
         ST R0,SIN_DCBD.DCBDCBE  DCBE ADDR SAVED DSECT IN DYN 31 STG
*
*        OI    INOPEN,X'80' SET HIGH ORDER BIT OF LAST ENTRY
*
         OPEN (SIN_DCBD.IHADCB,),                                      *
               MODE=31,MF=(E,INOPEN)
         LTR R15,R15 BRANCH IF DDNAME SEEMS NOT
         JNZ BAD_OPEN TO BE DEFINED
*
               MODE=31,MF=(E,INOPEN)
*
* LOOP TO READ ALL THE RECORDS
LOOP     GET INDCB_SIN    GET ADDRESS OF A RECORD IN R1
         LH  R2,SIN_DCBD.DCBLRECL
         BCTR R2,0
         EXRL R2,MVC_REC
*... PROCESS A RECORD
         J LOOP          BRANCH TO READ NEXT RECORD
SHOULD_NEVER_GET_HERE DS 0H
         J   ERR8
*    MORE
MVC_REC  MVC IN_REC(0),0(R1)
* I/O ERROR ROUTINE FOR INDCB
IOERROR  SYNADAF ACSMETH=QSAM GET MESSAGE AREA
         MVI 6(R1),X'80' SET WTO MCS FLAGS
         MVC 8(16,R1),=CL16'I/O ERROR' PUT PHRASE ON BIN FLDS
         MVC 128(4,R1),=X'00000020' SET ROUTCDE=11 (WTP)
         WTO MF=(E,4(R1)) WRITE MESSAGE TO USER
         SYNADRLS        RELEASE SYNADAF AREA,FALL THRU
         J    ERR8
* THE GET MACRO BRANCHES HERE AFTER ALL RECORDS HAVE BEEN READ
EOD      DS  0H
         CLOSE (SIN_DCBD.IHADCB),MF=(E,INCLOSE),MODE=31
         J    FIN_IT
* FREEPOOL NOT NEEDED DUE TO RMODE31=BUFF (I.E. DYN STG AREA)
BAD_OPEN DS 0H
         MVI   RC+3,X'15'
         J    DO_TERM
*
FIN_IT   DS   0H
         MVI   RC+3,X'00'
         J     DO_TERM
ERR8     DS    0H
         MVI   RC+3,X'08'
         J     DO_TERM
*
DO_TERM  DS    0H
         L     R2,RC
         LR    1,13
         L     0,FSIZE
         L     13,4(13)
         FREEMAIN R,LV=(0),A=(1)
         LR    R15,R2
         RETURN (14,12),,RC=(15)
*
* REST OF PROGRAM
*
*        PART OF THE CSECT; COPIED TO 24 BIT
MY_STATIC DS 0D
BEG_VAR_IN_STATIC DC C'>>>BEG THIS IS IN THE STATIC AREA<<<'
*   USE LAR TO GET REL ADDR FOR USING THEN MVC INSTEAD OF MVCL
MYDCB_SIN DCB DDNAME=INPUT,MACRF=GL,RECFM=FB,DSORG=PS,                 *
               DCBE=MYDCBE_SIN
MYDCB_SIN_L EQU *-MYDCB_SIN
* GET (LOCATE MODE) MACRO RETURNS ADDR OF REC BUF IN R1
*     THE RECORD LENGTH IS PLACED IN THE DCBLRECL FIELD.
* DCB EODAD  AND SYNAD ROUTINES:
* THIS EODAD/SYNAD ROUTINE ENTRY POINT SPECIFIED IN THE DCB MUST
* BELOW THE LINE. IF YOU WISH THE ENTRY POINT TO RESIDE ABOVE THE
* LINE, USE THE EODAD/SYNAD PARAMETER OF THE DCBE MACRO
*
MYDCBE_SIN  DCBE EODAD=EOD,SYNAD=IOERROR,BLKSIZE=0,RMODE31=BUFF
MYDCBE_SIN_L EQU *-MYDCBE_SIN
*
MYOPEN   OPEN (,)MF=L,MODE=31
MYOPEN_L EQU *-MYOPEN
*
MYCLOSE  CLOSE (,),MF=L,MODE=31
MYCLOSE_L EQU *-MYCLOSE
*
         DS 0D
END_24_STATIC DC C'<<<END_OF_24_STG>>>'
AREALEN EQU *-MYDCB_SIN
*
         DS 0D      JUST FOR ALIGNMENT; NOT REQUIRED
FSIZE    DC    A(WORKSIZE)
END_31_STATIC DC C'<<<END_OF_31_STG>>>'
END_VAR_IN_STATIC DC C'>>>THIS IS IN THE STATIC AREA END<<<'
STATIC_CSECT_DATA_LENGTH EQU *-MY_STATIC
*
*
         LTORG
*
SIN_DCBD    DCBD     DSORG=QS,DEVD=DA     GENERATES A DSECT
SIN_DCBE    IHADCBE            DCBE IS TO BE ABOVE 16 MB LINE
*
* DSA AREA GM 24 BIT FOR THIS
MY_24_DCB DSECT
INDCB_SIN  DS XL(MYDCB_SIN_L)
INDCBE_SIN DS XL(MYDCBE_SIN_L)
INOPEN     DS XL(MYOPEN_L)
INCLOSE    DS XL(MYCLOSE_L)
         DS    0D
END_24_LIT DS  CL32    '<<<END_OF_24_STG>>>'
*
* DSA AREA GM 31 BIT FOR THIS
WAREAS   DSECT
SAVE     DS    36F'0'
         DS    0D
RC       DS    F
IN_REC   DS CL(256)
END_31_LIT DS  CL32    '<<<END_OF_31_STG>>>'
WAREASEND DS   0H
WORKSIZE EQU   *-SAVE
*
         END   EXPSYSIN
###END EXPSYSIN
$$$BEG EXPSYSP2
* MINIMUM SYSPRINT ABOVE CODE  (REVISED 2016/12/06)
*  DCB MUST BE IN 24 BIT STG, BUT WE CAN EXECUTE CODE IN 31 BIT
*   MY_STATIC   START OF 24 BIT DBC AREA IN CSECT
*   MYDCB_SIN   DCB POINTS TO THE DCBE
*   MYDCBE_SIN  HAS RMODE31=BUFF WHICH LOCATES IO BUFFS IN 31 BIT
*   MYDCB_SYP   DCB POINTS TO THE DCBE
*   MYDCBE_SYP  HAS RMODE31=BUFF WHICH LOCATES IO BUFFS IN 31 BIT
*   MYOPEN      MODE=31 TELLS OPEN TO USE 31 BIT ADDR
*   MYCLOSE     MODE=31 TELLS OPEN TO USE 31 BIT ADDR
*               MF=L LIST FORM - ANY EXECUTE FORM REF MUST BE
*                    CONSISTANT IN MODE=31 - OTHERWISE ABENDS
*               OPEN MODE=24 HAS 1 FW 1 BYTE FOR OPTIONS, THEN 24
*                            BIT DCB ADDR
*               OPEN MODE=31 HAS 2 FW 1ST FW FOR OPTIONS, THEN 31
*                            BIT DCB ADDR IN2ND FW
*               NOTE: LAST (ONLY?) OPTION MUST HAVE HIGH ORDER
*                     (BIT 0) SET ON
*  SEQUENCE:
*   GM 24 BIT WORK AREA FOR DCB USE
*   THIS CSECT HAS DCB (AND OTHER STATIC DATA) AS PART OF THE PGM
*     WE COPY THE DCB/DCBE/OPEN/CLOSE CODE INTO 24 BIT DYN STG
*   THE OPEN IS CODED AS LIST FORM, AND COPIED TO THE 24 DYN STG
*   MVI THE X'80 TO THE FIRST BYTE IN OPTION AREA, OF LAST DCB
*     CODED ON THE OPEN (OPEN CAN HAVE 1 TO MANY DCB CODED)
*   MAKE SURE MODE ON LIST AND EXECUTE ARE CONSISTANT
*   PUT FROM 31 BIT BUFFER STG MANAGED BY IO ROUTINE OR NONE
*   REG 1 ADDR OF NEXT BUFFER WILL BE LOCATED BASED ON THE
*     RMODE31=BUFF CODE
*   CLOSE MACRO FOR ONE TO MANY (MODE MUST BE CONSISTENT)
*   YOU DO NOT HAVE TO OPEN AND CLOSE THE SAME LIST OF DCBS
*
*
         SYSSTATE ARCHLVL=2
EXPSYSP2 CSECT
EXPSYSP2 RMODE ANY
EXPSYSP2 AMODE 31
         YREGS
*  NO BASE REG USED
*  R2 TMP BASE REG FOR STATIC STG
*  R11 BASE REG FOR 24 BIT DBC DYN STG
*  R12 BASE REG CSECT STATIC STG
*  R13 BASE REG FOR 31 BIT DYN STG
         J     BEGIN
PROLOG   LOCTR
THIS_PGM DC    C'EXPSYSP2'
         DC    C'ASMDATE && TIME: &SYSDATE &SYSTIME'
         DC    C'VER 0.0.1'
CODEBG1  LOCTR
BEGIN    DS    0H
         SAVE  (14,12)       SAVE Z/OS'S REGS
*
         LARL R12,MY_STATIC
         USING MY_STATIC,R12
*
*  GET THIS PGMS DYNAMIC STORAGE
         GETMAIN R,LV=WORKSIZE,LOC=31
         CIJNE   R15,0,NOSTG
*
         ST    13,4(1)
         LR    13,1
         USING (WAREAS,WAREASEND),13
* HOUSE KEEP
         XC    RC,RC
         MVI   MSGAREA1,X'40'
         MVC   MSGAREA,MSGAREA1
         MVC   IN_REC,MSGAREA1
*
* FIRST - GET THE 24 BIT STG FOR DCB/DCBE/OPEN/CLOSE
         GETMAIN R,LV=AREALEN,LOC=24
         CIJNE   R15,0,NO24STG
*
         LR R11,R1
          USING    MY_24_DCB,R11      ADDR 24BIT
SIN_DCBD  USING    IHADCB,INDCB_SIN INDCB IS IN MY_24_DCB
SIN_DCBE  USING    DCBE,INDCBE_SIN    INDCBE IS IN MY_24_DCB
*
SYP_DCBD  USING    IHADCB,INDCB_SYP INDCB IS IN MY_24_DCB
SYP_DCBE  USING    DCBE,INDCBE_SYP    INDCBE IS IN MY_24_DCB
* BASELESS  METHOD BELOW OR AREALEN TOO LARGE
         LA   R2,MYDCB_SIN
         LA  R3,AREALEN
         LA  R4,SIN_DCBD.IHADCB
         LR  R5,R3
         MVCL R4,R2
*  IF WE DON'T SET BASE REG, THEN WE CAN'T ACCESS STATIC FLDS
* ALTERNATE METHOD ABOVE USES BASE REG
*  THIS METHOD BELOW REQUIRE A BASE REG TO ADDR MYDCB_SIN IN STATIC
*        MVC SIN_DCBD.IHADCB(AREALEN),MYDCB_SIN COPY DCB AND DCBE
         MVC   END_24_LIT(L'END_24_STATIC),END_24_STATIC
         MVC   END_31_LIT(L'END_31_STATIC),END_31_STATIC
*         TIME  DEC,TIMEDATE,ZONE=LT,LINKAGE=SYSTEM
         MVC    E_LIST1_STG,LIST1
         TIME  DEC,TIMEDATE,LINKAGE=SYSTEM,MF=(E,E_LIST1_STG),         X
               DATETYPE=YYYYMMDD
*
         MVC   BEG_TIMEDATE,TIMEDATE
*
         LA R0,SIN_DCBE.DCBE    DCBE ADDR IN SIN_DCBD IN DYN 31 STG
         ST R0,SIN_DCBD.DCBDCBE  DCBE ADDR SAVED DSECT IN DYN 31 STG
*
         LA R0,SYP_DCBE.DCBE    DCBE ADDR IN SIN_DCBD IN DYN 31 STG
         ST R0,SYP_DCBD.DCBDCBE  DCBE ADDR SAVED DSECT IN DYN 31 STG
*
         OI    INOPEN+8,X'80' SET HIGH ORDER BIT OF LAST ENTRY
*               IN THE OPEN LIST, TO 1 (INDICATE LAST ENTRY)
         OPEN (SIN_DCBD.IHADCB,,SYP_DCBD.IHADCB,(OUTPUT)),             *
               MODE=31,MF=(E,INOPEN)
         LTR R15,R15 BRANCH IF DDNAME SEEMS NOT
         JNZ BAD_OPEN TO BE DEFINED
         MVC   MSGAREA(L'BEG_MSG),BEG_MSG
*
         LA    R15,BEG_TIMEDATE
         JAS   R9,FMT_TIME
*
         LARL  R2,THIS_PGM
         MVC   MSGAREA+10(L'THIS_PGM),0(R2)
         MVC   MSGAREA+23(10),$DATE_FMT
         MVC   MSGAREA+35(11),$TIME_FMT
         JAS   R9,PUT_OUTPUT
*
* LOOP TO READ ALL THE RECORDS
LOOP     GET INDCB_SIN    GET ADDRESS OF A RECORD IN R1
         LH  R2,SIN_DCBD.DCBLRECL
         BCTR R2,0
         EXRL R2,MVC_INREC
         LH  R2,SYP_DCBD.DCBLRECL
         BCTR R2,0
         EXRL R2,MVC_OUTREC
         JAS R9,PUT_OUTPUT
*... PROCESS A RECORD
         J LOOP          BRANCH TO READ NEXT RECORD
SHOULD_NEVER_GET_HERE DS 0H
         J   ERR8
*    MORE
MVC_INREC  MVC IN_REC(0),0(R1)
MVC_OUTREC  MVC MSGAREA(0),IN_REC
* I/O ERROR ROUTINE FOR INDCB
IOE_SIN  SYNADAF ACSMETH=QSAM GET MESSAGE AREA
         MVI 6(R1),X'80' SET WTO MCS FLAGS
         MVC 8(16,R1),=CL16'I/O ERROR' PUT PHRASE ON BIN FLDS
         MVC 128(4,R1),=X'00000020' SET ROUTCDE=11 (WTP)
         WTO MF=(E,4(R1)) WRITE MESSAGE TO USER
         SYNADRLS        RELEASE SYNADAF AREA,FALL THRU
         J    ERR8
* THE GET MACRO BRANCHES HERE AFTER ALL RECORDS HAVE BEEN READ
EOD      DS    0H
*         TIME  DEC,TIMEDATE,ZONE=LT,LINKAGE=SYSTEM
         MVC    E_LIST1_STG,LIST1
         TIME  DEC,TIMEDATE,LINKAGE=SYSTEM,MF=(E,E_LIST1_STG),         X
               DATETYPE=YYYYMMDD
*
         MVC   END_TIMEDATE,TIMEDATE
         LA    R15,END_TIMEDATE
         JAS   R9,FMT_TIME
*
         MVC   MSGAREA(L'END_MSG),END_MSG
*
         LARL  R2,THIS_PGM
         MVC   MSGAREA+10(L'THIS_PGM),0(R2)
         MVC   MSGAREA+23(10),$DATE_FMT
         MVC   MSGAREA+35(11),$TIME_FMT
         JAS   R9,PUT_OUTPUT
*
        CLOSE (SIN_DCBD.IHADCB,,SYP_DCBD.IHADCB),MF=(E,INCLOSE),MODE=31
         J    FIN_IT
* FREEPOOL NOT NEEDED DUE TO RMODE31=BUFF (I.E. DYN STG AREA)
BAD_OPEN DS 0H
         MVI   RC+3,X'15'
         J    DO_TERM
*
FIN_IT   DS   0H
         MVI   RC+3,X'00'
         J     DO_TERM
*
ERR8     DS    0H
         MVI   RC+3,X'08'
         J     DO_TERM
*
NO24STG  DS    0H
         ST    R15,RC
         J     DO_TERM1
*
DO_TERM  DS    0H
         LR    1,11
         LA    0,AREALEN
         FREEMAIN R,LV=(0),A=(1)
*
DO_TERM1 DS    0H
         L     R2,RC
         LR    1,13
         L     0,FSIZE
         L     13,4(13)
         FREEMAIN R,LV=(0),A=(1)
         LR    R15,R2
NOSTG    DS    0H
         RETURN (14,12),,RC=(15)
*
* REST OF PROGRAM
PUT_OUTPUT DS 0H
         ST  R9,SAV_R9
         PUT INDCB_SYP,MSGAREA
         MVC MSGAREA,MSGAREA1
         L   R9,SAV_R9
         BR  R9
*
***
* CONVERT VALUE IN R15 TO %02X DISPLAY X STRING IN EBCDCFLD
*    R15 IS NOT ALTERED
*
X2CX_R15  DS    0H
         STM   R4,R9,X2CX49
         XR    R6,R6
         LA    R6,8
         ST    R15,HEXFIELD
         LA    R4,HEXFIELD
         LA    R5,EBCDCFLD
*
CONVERT_R15  EQU   *
         SLR   R8,R8
         IC    R8,0(R4)
         SRDL  R8,4
         STC   R8,0(R5)
         LA    R5,1(R5)
         SLR   R8,R8
         SLDL  R8,4
         STC   R8,0(R5)
         LA    R5,1(R5)
         LA    R4,1(R4)
         JCT   R6,CONVERT_R15
*
         TR    EBCDCFLD(8),HEXTRAN
         LM    R4,R9,X2CX49
         BR    R9
*
* FORMAT TIME FROM TIMEDATA FLD POINTED TO BY R15
*  TIME MACRO PRODUCES TIME DATE 16 BYTE FLD WHERE
*   OFFSET 0 LENGTH 4 HHMMSSTT
*          4          PPPP0000
*          8          YYYYMMDD
*          12         ZEROES
FMT_TIME  DS 0H
         ST    R9,SAV9_FMT_TIME
         ST    R15,X_FROM_A
         IILF  R15,4
         STH   R15,FROM_HEX_STR_L
         ARK   R9,R15,R15
         STH   R9,TO_CHAR_STR_L
*
* ESTABLISH ADDR OF FMT_TIME FROM AND TO FLD LNG ADDRESSES
         LA    R15,FROM_HEX_STR_L
         ST    R15,X_FROM_L_A
         LA    R15,TO_CHAR_STR_L
         ST    R15,X_TO_L_A
*        LA    R15,TIMEDATE
*        ST    R15,X_FROM_A
         LA    R15,$TIME
         ST    R15,X_TO_A
         LA    R15,X2CX_PRM_ADR
         JAS  R9,X2CX
         MVC   $TIME_FMT(2),$TIME
         MVC   $TIME_FMT+2(1),COLON
         MVC   $TIME_FMT+3(2),$TIME+2
         MVC   $TIME_FMT+5(1),COLON
         MVC   $TIME_FMT+6(2),$TIME+4
         MVC   $TIME_FMT+8(1),DOT
         MVC   $TIME_FMT+9(2),$TIME+6
*
         IILF  R15,4
         STH   R15,FROM_HEX_STR_L
         ARK   R9,R15,R15
         STH   R9,TO_CHAR_STR_L
*
* ESTABLISH ADDR OF FMT_TIME FROM AND TO FLD LNG ADDRESSES
         LA    R15,FROM_HEX_STR_L
         ST    R15,X_FROM_L_A
         LA    R15,TO_CHAR_STR_L
         ST    R15,X_TO_L_A
*
         L     R15,X_FROM_A   HOLDS START OF TIME FLDSO
         LA    R15,8(R15)     ADDR THE YYYYMMDD FLD
         ST    R15,X_FROM_A
         LA    R15,TO_CHAR_STR_L
         ST    R15,X_TO_L_A
         LA    R15,$DATE
         ST    R15,X_TO_A
         LA    R15,X2CX_PRM_ADR
         JAS  R9,X2CX
         MVC   $DATE_FMT(4),$DATE
         MVC   $DATE_FMT+4(1),FWDSLASH
         MVC   $DATE_FMT+5(2),$DATE+4
         MVC   $DATE_FMT+7(1),FWDSLASH
         MVC   $DATE_FMT+8(2),$DATE+6
*
         L     R9,SAV9_FMT_TIME
         BR    R9
***
* CONVERT VALUE IN R15 TO %02X DISPLAY X STRING IN EBCDCFLD
*
X2CX     EQU   *
         STM   R4,R9,X2CX49
         LTR   R4,R15
         JNP   NO_X2CX
*
         L     R5,4(R4)          GET PTR TO HW X SRC LNG
         XR    R6,R6
         ICM   R6,B'0011',0(R5)  GET THE LNG
         JNP   NO_X2CX
*
         L     R5,12(R4)          GET PTR TO HW X SRC LNG
         XR    R7,R7
         ICM   R7,B'0011',0(R5)  GET THE LNG
         JNP   NO_X2CX
*
         SLL   R6,1              MULTIPLY BY 2
         CRJNE R6,R7,BAD_X2CX
*
         SRL   R6,1              GET ORIGINAL VALUE BACK
*
         L     R5,8(R4)       GET ADR OF THE TGT CHAR FLD
         L     R4,0(R4)          GET ADR OF SRC HEX FLD
         LA    R9,TABLE     TRANSLATE TO CHAR FORM
         AHI   R9,-240
*
CONVERT  EQU   *
         CIJL  R6,4,CONVERT1
         MVC   MYXSTR(4),0(R4)
         UNPK  MYCHAR,MYXSTR(5) UNPACK HEX STREAM
         TR    MYCHAR,0(R9)     TRANSLATE TO CHAR FORM
         MVC   0(8,R5),MYCHAR
         AHI   R5,8
         AHI   R4,4
         AHI   R6,-3
         J     CONVERT2
CONVERT1 DS    0H
         XR    R8,R8            CLEAR REG
         IC    R8,0(R4)         INSERT CHAR IN 25-32
         SRDL  R8,4             SHIFT OUT 29-32 INTO R9
         STC   R8,0(R5)         STORE SHIFTED 25-28 AS X'0X'
         TR    0(1,R5),HEXTRAN  TRANSLATE ALL 00 THRU 0F
*                                     TO->    F0 - F9,C1 - C6
         LA    R5,1(R5)         ADVANCE PTR TO NEXT POS
         XR    R8,R8            CLEAR REG
         SLDL  R8,4             SHIFT IN THE 29-32
         STC   R8,0(R5)         STORE IT
         TR    0(1,R5),HEXTRAN  TRANSLATE ALL 00 THRU 0F TO
*                                     TO->    F0 - F9,C1 - C6
         LA    R5,1(R5)         ADVANCE ANOTHER
         LA    R4,1(R4)         ADVANCE NEXT
CONVERT2 DS    0H
         JCT   R6,CONVERT       REDUCE COUNTER
*
         XR    R15,R15
         J     OK_X2CX
BAD_X2CX EQU   *
         LA    R15,8
         J     OK_X2CX
NO_X2CX  EQU   *
         LA    R15,4
         J     OK_X2CX
OK_X2CX  EQU   *
         LM    R4,R9,X2CX49
         BR    R9
*
***
*
*        PART OF THE CSECT; COPIED TO 24 BIT
MY_STATIC DS 0D
BEG_VAR_IN_STATIC DC C'>>>BEG THIS IS IN THE STATIC AREA<<<'
*   USE LAR TO GET REL ADDR FOR USING THEN MVC INSTEAD OF MVCL
MYDCB_SIN DCB DDNAME=INPUT,MACRF=GL,RECFM=FB,DSORG=PS,                 *
               DCBE=MYDCBE_SIN
MYDCB_SIN_L EQU *-MYDCB_SIN
* GET (LOCATE MODE) MACRO RETURNS ADDR OF REC BUF IN R1
*     THE RECORD LENGTH IS PLACED IN THE DCBLRECL FIELD.
* DCB EODAD  AND SYNAD ROUTINES:
* THIS EODAD/SYNAD ROUTINE ENTRY POINT SPECIFIED IN THE DCB MUST
* BELOW THE LINE. IF YOU WISH THE ENTRY POINT TO RESIDE ABOVE THE
* LINE, USE THE EODAD/SYNAD PARAMETER OF THE DCBE MACRO
*
MYDCBE_SIN DCBE EODAD=EOD,SYNAD=IOE_SIN,BLKSIZE=0,RMODE31=BUFF
MYDCBE_SIN_L EQU *-MYDCBE_SIN
*
*  SYSPRINT STATIC DATA
*
MYDCB_SYP  DCB DDNAME=OUTPUT,MACRF=PM,RECFM=FB,DSORG=PS,               *
               DCBE=MYDCBE_SYP
MYDCB_SYP_L EQU *-MYDCB_SYP
* GET (LOCATE MODE) MACRO RETURNS ADDR OF REC BUF IN R1
*     THE RECORD LENGTH IS PLACED IN THE DCBLRECL FIELD.
* DCB EODAD  AND SYNAD ROUTINES:
* THIS EODAD/SYNAD ROUTINE ENTRY POINT SPECIFIED IN THE DCB MUST
* BELOW THE LINE. IF YOU WISH THE ENTRY POINT TO RESIDE ABOVE THE
* LINE, USE THE EODAD/SYNAD PARAMETER OF THE DCBE MACRO
*
MYDCBE_SYP  DCBE SYNAD=IOE_SIN,BLKSIZE=0,RMODE31=BUFF
MYDCBE_SYP_L EQU *-MYDCBE_SYP
*
* OPEN BOTH INPUT AND OUTPUT
MYOPEN   OPEN  (,,,),MF=L,MODE=31
MYOPEN_L EQU *-MYOPEN
MYCLOSE  CLOSE (,,,),MF=L,MODE=31
MYCLOSE_L EQU *-MYCLOSE
*
         DS    0D
* EYE CATCHER FOR 24 BIT DYN
END_24_STATIC DC C'<<<END_OF_24_STG>>>'
AREALEN EQU *-MYDCB_SIN
*
         DS 0D      JUST FOR ALIGNMENT; NOT REQUIRED
*
LIST1     TIME  LINKAGE=SYSTEM,MF=L
TIME_END  EQU   *-LIST1
*
* X2CX TRANSLATE TABLE
HEXTRAN  DC    X'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
XFF      DC    XL4'FFFFFFFF'
*
TABLE   DC C'0123456789ABCDEF'
*
FSIZE    DC    A(WORKSIZE)
END_31_STATIC DC C'<<<END_OF_31_STG>>>'
*
*             0....5....1....5....2....5....3....5....4....5....E....5
FWDSLASH DC C'/'
COLON    DC C':'
DOT      DC C'.'
BEG_MSG  DC C'*** BEGIN          AT'
END_MSG  DC C'*** END            AT'
END_VAR_IN_STATIC DC C'>>>THIS IS IN THE STATIC AREA END<<<'
STATIC_CSECT_DATA_LENGTH EQU *-MYDCB_SIN
*
*
         LTORG
*
            DCBD     DSORG=QS,DEVD=DA     GENERATES A DSECT
            IHADCBE            DCBE IS TO BE ABOVE 16 MB LINE
*
* DSA AREA GM 24 BIT FOR THIS
MY_24_DCB DSECT
INDCB_SIN  DS XL(MYDCB_SIN_L)
INDCBE_SIN DS XL(MYDCBE_SIN_L)
*
INDCB_SYP  DS XL(MYDCB_SYP_L)
INDCBE_SYP DS XL(MYDCBE_SYP_L)
INOPEN     DS XL(MYOPEN_L)
INCLOSE    DS XL(MYCLOSE_L)
         DS    0D
END_24_LIT DS  CL32    '<<<END_OF_24_STG>>>'
*
*
*
*
*
*
*
*
*
*
*
*
*
*
* DSA AREA GM 31 BIT FOR THIS
WAREAS   DSECT
SAVE     DS    36F'0'
*
SAV9_FMT_TIME  DS  F
*
SAV_R9   DS    F
RC       DS    F
IN_REC   DS    CL(255)
MSGAREA1 DS    CL1
MSGAREA  DS    CL(255)
         DS    0D
E_LIST1_STG DS  XL(TIME_END)
*
TIMEDATE      DS    CL16         TIME AND DATE RETURNED
BEG_TIMEDATE  DS    CL16         TIME AND DATE RETURNED
END_TIMEDATE  DS    CL16         TIME AND DATE RETURNED
*
$DATE     DS    CL8          TIME AND DATE RETURNED
$TIME     DS    CL8          TIME AND DATE RETURNED
$DATE_FMT DS    CL10         YYYY/MM/DD
$TIME_FMT DS    CL11         HH:MM:SS.TT
*
X2CX49   DS    6F
X2CX_PRM_ADR DS 0F
X_FROM_A DS    F
X_FROM_L_A DS  F
X_TO_A   DS    F
X_TO_L_A DS    F
*
FROM_HEX_STR_L  DS    H      HOLD LNG OF X SRC
TO_CHAR_STR_L   DS    H      HOLD LNG OD CX DEST
*FROM_HEX_STR  DS    XL40
*TO_CHAR_STR   DS    XL80
*
DWORD    DS    D
$DBLWD   DS    D
EBCDCFLD DS    D
HEXFIELD DS    F
*
MYCHAR  DS XL9 CHAR DATA
*
MYXSTR  DS XL4  CHAR DATA
MYXSTR1 DS XL1
*
END_31_LIT DS  CL32    '<<<END_OF_31_STG>>>'
WAREASEND DS   0H
WORKSIZE EQU   *-SAVE
*
         END   EXPSYSP2
###END EXPSYSP2
$$$BEG EXPSYSPZ
* MINIMUM SYSPRINT ABOVE CODE  (REVISED 2016/12/06)
*  SEE: TTED.TSK.D.TCEM.ASM(EXPSYSPR)
*
*  THIS PROGRAM EXPECTS A FW PARAMETER USED TO ADDRESS AN OPEN
*   SYSPRINT DCB.
*  TEST THE CONCEPT THAT WE OPEN A SYSPRINT DCB, AND THEN SEND
*   A REFERENCE TO THAT DCB SO THAT SUBTASKS CAN WRITE TO IT
*
         SYSSTATE ARCHLVL=2
EXPSYSPZ CSECT
EXPSYSPZ RMODE ANY
EXPSYSPZ AMODE 31
         YREGS
*  NO BASE REG USED
*  R2 TMP BASE REG FOR STATIC STG
*  R11 BASE REG FOR 24 BIT DBC DYN STG
*  R12 BASE REG CSECT STATIC STG
*  R13 BASE REG FOR 31 BIT DYN STG
         J     BEGIN
PROLOG   LOCTR
THIS_PGM DC    C'EXPSYSPZ'
         DC    C'ASMDATE && TIME: &SYSDATE &SYSTIME'
         DC    C'VER 0.0.1'
CODEBG1  LOCTR
BEGIN    DS    0H
         SAVE  (14,12)       SAVE Z/OS'S REGS
*
         CIJNE  R1,4,BADPARM0  ONE PARM - ADDR OF PARM LIST
*
         LR     R11,R1      SAVE PARM ADR
         LARL R12,MY_STATIC
         USING MY_STATIC,R12
*
*  GET THIS PGMS DYNAMIC STORAGE
         LR    R11,R1       SAVE PTR TO PARM
         GETMAIN R,LV=WORKSIZE,LOC=31
         CIJNE R15,0,BADPARM0
*
         ST    13,4(1)
         LR    13,1
         USING (WAREAS,WAREASEND),13
         ST    R11,WAREA_SAVE_PARM_A
* HOUSE KEEP
         XC    RC,RC
         MVI   MSGAREA1,X'40'
         MVC   MSGAREA,MSGAREA1
* WORK ON PARM AREA
         USING PARM_AREA_BEG,R11
         CLC   PA_SHARED_EYEC,=C'SYSZ'
         JNE   BADPARM
*
         L     R12,PA_SHARED_STG_L
         CIJNE R12,PA_S_AREALNG,BADPARM
         L     R12,PA_SHARED_STG_A
         CIJE  R12,0,BADPARM
         USING PA_S_BEG,R12
         DROP  R11
*  GET THE COMMON DBC ADDR  (DCB/DCBE/OPEN)
         L     R11,PA_SHARED_SYSPRINT_DCB_A
         CIJNE R11,PA_S_AREALNG,BADPARM
*
* SECOND - ESTABLISH ADDRESSABILITY
          USING    MY_24_DCB,R11      ADDR 24BIT
SYP_DCBD  USING    IHADCB,INDCB_SYP INDCB IS IN MY_24_DCB
SYP_DCBE  USING    DCBE,INDCBE_SYP    INDCBE IS IN MY_24_DCB
*
* THIRD  - COPY THE DCB FROM CSECT TO 24 BIT AREA
* BASELESS  METHOD BELOW OR AREALEN TOO LARGE
         LA   R2,MYDCB_SYP
         LA  R3,AREALEN
         LA  R4,SYP_DCBD.IHADCB
         LR  R5,R3
         MVCL R4,R2
*  IF WE DON'T SET BASE REG, THEN WE CAN'T ACCESS STATIC FLDS
* ALTERNATE METHOD ABOVE USES BASE REG
*  THIS METHOD BELOW REQUIRE A BASE REG TO ADDR MYDCB_SIN IN STATIC
*        MVC SIN_DCBD.IHADCB(AREALEN),MYDCB_SIN COPY DCB AND DCBE
         MVC   END_24_LIT(L'END_24_STATIC),END_24_STATIC
         MVC   END_31_LIT(L'END_31_STATIC),END_31_STATIC
*
*
* FORTH  - GET THE 24 BIT ADDR OF DCBE AND MVC IT TO 24 BIT DCB
         LA R0,SYP_DCBE.DCBE    DCBE ADDR IN SIN_DCBD IN DYN 31 STG
         ST R0,SYP_DCBD.DCBDCBE  DCBE ADDR SAVED DSECT IN DYN 31 STG
*
*
* FIFTH  - SET THE LAST DBC OPTION WITH HIGH ORDER BIT X'80'
         OI    INOPEN+8,X'80' SET HIGH ORDER BIT OF LAST ENTRY
*               IN THE OPEN LIST, TO 1 (INDICATE LAST ENTRY)
*
* SIXTH  - OPEN THE 24 BIT DCBS USING EXECUTE FORM, POINTING TO THE
*          24 BIT LIST FORM COPY
         OPEN (SYP_DCBD.IHADCB,(OUTPUT),),                             *
               MODE=31,MF=(E,INOPEN)
         LTR R15,R15 BRANCH IF DDNAME SEEMS NOT
         JNZ BAD_OPEN TO BE DEFINED
*
         MVC   MSGAREA_LRECL,SYP_DCBD.DCBLRECL
*
         MVC   MSGAREA(L'BEG_MSG),BEG_MSG
*
         LARL  R2,THIS_PGM
         MVC   MSGAREA+10(L'THIS_PGM),0(R2)
*
* SEVENTH -CLOSE THE 24 BIT DCBS USING EXECUTE FORM, POINTING TO THE
*           24 BIT LIST FORM COPY OF THE OPEN MACRO
         JAS   R9,PUT_OUTPUT
*
         J   EOD
*    MORE
*
* NOTE 1: CODE THIS SYNADAF AREA FOR IO ERRORS QSAM
*
* I/O ERROR ROUTINE FOR INDCB
IOE_SIN  SYNADAF ACSMETH=QSAM GET MESSAGE AREA
         MVI 6(R1),X'80' SET WTO MCS FLAGS
         MVC 8(16,R1),=CL16'I/O ERROR' PUT PHRASE ON BIN FLDS
         MVC 128(4,R1),=X'00000020' SET ROUTCDE=11 (WTP)
         WTO MF=(E,4(R1)) WRITE MESSAGE TO USER
         SYNADRLS        RELEASE SYNADAF AREA,FALL THRU
         J    ERR8
*
* NOTE 2: CODE THIS EOD     AREA FOR IO EOD ON INPUT DCB
*
* THE GET MACRO BRANCHES HERE AFTER ALL RECORDS HAVE BEEN READ
EOD      DS    0H
*
         MVC   MSGAREA(L'END_MSG),END_MSG
         LARL  R2,THIS_PGM
         MVC   MSGAREA+10(L'THIS_PGM),0(R2)
         JAS   R9,PUT_OUTPUT
*
*        CLOSE (SYP_DCBD.IHADCB),MF=(E,INOPEN),MODE=31
*
* EIGHTH -CLOSE THE 24 BIT DCBS USING EXECUTE FORM, POINTING TO THE
*          24 BIT LIST FORM COPY - MODE MUST BE CONSISTENT
         CLOSE MF=(E,INOPEN),MODE=31
         J    DONE_ALL
* FREEPOOL NOT NEEDED DUE TO RMODE31=BUFF (I.E. DYN STG AREA)
BAD_OPEN DS 0H
         MVI   RC+3,X'15'
         J    DO_TERM
*
DONE_ALL DS   0H
         MVI   RC+3,X'00'
         J     DO_TERM
ERR8     DS    0H
         MVI   RC+3,X'08'
         J     DO_TERM
*
BADPARM0 DS    0H
         IIFL  R2,20
         J     FIN_ITM
*
BADPARM  DS    0H
         MVI   RC+3,X'20'
         J    DO_TERM
*
DO_TERM  DS    0H
         L     R2,RC
         LR    1,13
         L     0,FSIZE
         L     13,4(13)
         FREEMAIN R,LV=(0),A=(1)
*
FIN_IT   DS    0H
         LR    R15,R2
         RETURN (14,12),,RC=(15)
*
* REST OF PROGRAM
*
* NOTE 3: PUT MOVE MODE FROM PGM 31 BIT DYN STG
*
PUT_OUTPUT DS 0H
         ST  R9,SAV_R9
*
         MVC   MSGAREA_LRECL,SYP_DCBD.DCBLRECL
*
         PUT INDCB_SYP,MSGAREA
         MVC MSGAREA,MSGAREA1
         L   R9,SAV_R9
         BR  R9
*
***
MY_STATIC DS 0D
FSIZE    DC    A(WORKSIZE)
END_24_STATIC DC C'<<<END_OF_24_STG>>>'
END_31_STATIC DC C'<<<END_OF_31_STG>>>'
*
*             0....5....1....5....2....5....3....5....4....5....E....5
BEG_MSG  DC C'*** BEGIN          AT'
END_MSG  DC C'*** END            AT'
END_VAR_IN_STATIC DC C'>>>THIS IS IN THE STATIC AREA END<<<'
*
*  LTORG HAS GOT TO BE PART OF THE CSECT: SO INCLUDE IT
*   BEFORE CODING THE DYN STG AND/OR DSECT AREA
*   COULD DO LOCTR DOR CODE - ????
         LTORG
*
* NOTE 7: DSECT AREA FOR USING REFERENCE - DCB/DCBE     AREA IN 31 BIT
*
*
*  THE FOLLOWING ARE DSECT AREA
*  DCBD AND IHADCBE MACROS GENERATE DESECTS FOR USING DIRECTIVES
            DCBD     DSORG=QS,DEVD=DA     GENERATES A DSECT
            IHADCBE            DCBE IS TO BE ABOVE 16 MB LINE
*
* NOTE 8: DSECT AREA FOR USING REF 24 BIT- DCB/DCBE/OPEN LIST FORM
*
* THIS DSECT WILL BE USED TO REFERENCE THE 24 BIT DCB/DCBE/OPEN
* DSA AREA GM 24 BIT FOR THIS
MY_24_DCB DSECT
INDCB_SYP DS XL(DCBLNGQS)
INDCBE_SYP  DS XL(DCBEEND-DCBE)
INOPEN   OPEN (,),MF=L,MODE=31
         DS    0D
END_24_LIT DS  CL32    '<<<END_OF_24_STG>>>'
*
*
* NOTE  9: DSECT AREA FOR USING REFERENCE - PARM AREA FROM CALLER
*          CALLING PROGRAM PROVIDES THIS ADDR
*          AND THE STORAGE AREA BACKING IT
PARM_AREA DSECT
PARM_AREA_BEG DS 0D
PA_EYC    DS    CL4   SHOULD BE 'SYPZ'
PA_SHARED_STG_L DS F  SHARED STORAGE LENGTH
PA_SHARED_STG_A DS F  SHARED STORAGE ADDRESS
*
PARM_AREA_AREALNG EQU *-PARM_AREA_BEG
*
PA_SHARED_STG DSECT
PA_S_BEG            DS 0D
PA_THIS_SUBTASK_TCB DS F THIS SUBTASK TCB A OR ZERO IF NOT SUBTASK
PA_SHARED_ECB       DS F ECB ADDR FOR USE
*
PA_SHARED_SYSPRINT_DCB_A DS F ADDR OF OPEN SYSPRINT DCB FROM CALLER
*
PA_SHARED_LINKTO_PGM     DS CL8     IF SUBTASK, LINK TO PGM NAME
PA_SHARED_LINKTO_PGM_PAL DS F ZERO OR  SUBTASK, LINK TO PGM PARM LNG
PA_SHARED_LINKTO_PGM_PA  DS F ZERO OR  SUBTASK, LINK TO PGM PARM ADDR
PA_SHARED_MSGAREA        DS CL(255) MSGAREA FOR COMPLETION
*
PA_S_AREALNG EQU *-PA_S_BEG
*
* NOTE 10: DSECT AREA FOR USING REFERENCE - DSA 31 BIT STG
*
* THIS PROGRAMS 31 BIT STORAGE
* DSA AREA GM 31 BIT FOR THIS
WAREAS   DSECT
SAVE     DS    36F'0'
*
SAV_R9   DS    F
WAREA_SAVE_PARM_A DS F
RC       DS    F
MSGAREA_LRECL DS H
MSGAREA1 DS    CL1
MSGAREA  DS    CL(255)
         DS    0D
*
END_31_LIT DS  CL32    '<<<END_OF_31_STG>>>'
WAREASEND DS   0H
WORKSIZE EQU   *-SAVE
*
         END   EXPSYSPZ
###END EXPSYSPZ
$$$BEG EXPLATTH
*PROCESS COMPAT(NOCASE,MACROCASE)
         sysstate archlvl=2
EXPLATTH csect
EXPLATTH amode 31
EXPLATTH rmode 31
*
         yregs
         J     BEGIN
PROLOG   LOCTR
         DC    C'EXPLATTH'
         DC    C'AsmDate && Time: &SYSDATE &SYSTIME'
         DC    C'Ver 0.0.1'
CODEBG1  LOCTR
BEGIN    DS    0H
         using data,12
         save  (14,12)       save z/os's regs
         larl  12,data       use this instead of lr and ahi
*        LR    R12,R15
*        AHI   R12,data-BEGIN

         getmain r,lv=worksize,loc=31
         st    13,4(1)
         lr    11,1
         using (wareas,wareasend),11
*  ...
*         ATTACHX  macro
*
         XC    ECBADDR,ECBADDR
         XC    TCBADDR,TCBADDR
         MVC   WAITTIME,WAITHHMMSS
*
         LA 13,SAVE
         MVC e_ATTH_stg,SF_ATTH1
         MVC E_ATTHX_stg(ATTH_end),SF_ATTH1
*
         ATTACHX                                                       X
               PARAM=(WAITTIME),                                       X
               ECB=ECBADDR,                                            X
               EP=MYSTIM,                                              x
               MF=(E,REMOTE_PLIST),                                    X
               SF=(E,E_ATTHX_STG)
*        ATTACH EP=MYSTIM,PARAM=(WAITTIME),
*              ECB=ECBADDR
         ST    1,TCBADDR
         WAIT  1,ECB=ECBADDR
         DETACH TCBADDR
*
         XC MY_CPUTMIC,MY_CPUTMIC
         XC MY_CPUTTU,MY_CPUTTU
         XC MY_CPUTSV,MY_CPUTSV
         LA 13,SAVE
CPUMIC   CPUTIMER MIC,MY_CPUTMIC
         MVC    MY_CPUTSV,MY_CPUTMIC
         LA 13,SAVE
CPUTU    CPUTIMER MIC,MY_CPUTTU
         MVC    MY_CPUTSV,MY_CPUTTU
*  ...
*         TIME  DEC,TIMEDATE,ZONE=LT,LINKAGE=SYSTEM
         mvc    e_LIST1_stg,LIST1
         mvc    e_stmr1_stg,STIMERM1
         mvc    e_stmr2_stg,STIMERM2
         TIME  DEC,TIMEDATE,LINKAGE=SYSTEM,MF=(E,e_LIST1_stg),         x
               DATETYPE=YYYYMMDD
*        xc    e_stmr1_ID,e_stmr1_ID
         STIMERM SET,ID=e_stmr1_ID,DINTVL=l_DINTVL10,                  *
               WAIT=YES,MF=(E,e_stmr1_stg)
*
         TIME  DEC,TIMEDATE2,LINKAGE=SYSTEM,MF=(E,e_LIST1_stg),        x
               DATETYPE=YYYYMMDD
*        xc    e_stmr1_ID,e_stmr1_ID
*
* at termination:
*
         clrje 15,15,doterm
*        ltr   15,15
*        jz    doterm
err0     ds    0h
         la    15,8
*
doterm   ds    0h
         lr    1,13
         l     0,fsize
         l     13,4(13)
         freemain r,lv=(0),a=(1)
         return (14,12),,rc=0
*
data     ds    0f
fsize    dc    a(worksize)
*
SF_ATTH1  ATTACHX SF=L
ATTH_end  equ   *-SF_ATTH1
*
LIST1     TIME  LINKAGE=SYSTEM,MF=L
time_end  equ   *-LIST1
*
STIMERM1 STIMERM SET,MF=L
stmr1_end equ   *-STIMERM1
*
STIMERM2 STIMERM SET,MF=L,RELATED=ABCDEFG
stmr2_end equ   *-STIMERM2
*
l_BINTVL  dc xl4'00000001' hex 0.01 sec
l_DINTVL  dc cl8'00000001' chars hh mm ss th (tenths hundredths)
l_DINTVL10 dc cl8'00001000' is 10 seconds
l_TOD     dc cl8'00000000' is LT TOD 24hr completion time
*l_LT                          same as TOD and preferred identifer
l_MICVL   dc xl8'0000 0000 0000 2000' 64 bits
*For MICVL, the address is an 8-byte storage area containing the time
*interval. The time interval is represented as an unsigned 64-bit
*binary number; bit 51 is the low-order bit of the interval value and
*equivalent to one microsecond.
*
WAITHHMMSS DC  CL8'00001500'
*
         ltorg
wareas   dsect
save     ds    36f'0'
          ds    0d
MY_CPUTMIC ds    d
MY_CPUTTU ds     d
MY_CPUTSV ds     d
          ds    0d
e_LIST1_stg ds  xl(time_end)
          ds    0d
e_stmr1_stg ds  xl(stmr1_end)
e_stmr1_ID  ds  f
          ds    0d
e_stmr2_stg ds  xl(stmr2_end)
e_stmr2_ID  ds  f
          ds    0d
*07313264   51860000   20160204   00000000
TIMEDATE  DS    CL16         TIME AND DATE RETURNED
TIMEDATE2 DS    CL16         TIME AND DATE RETURNED
*
e_ATTH_stg ds  xl(ATTH_end)
          ds    0d
E_ATTHX_STG ATTACHX SF=L
*
E_ATTHX_STG_L  equ *-E_ATTHX_STG
*
ECBADDR DS F
TCBADDR DS F
REMOTE_PLIST   DS F
WAITTIME    DS  CL8
wareasend ds   0h
worksize equ   *-save
         end   EXPLATTH
###END EXPLATTH
$$$BEG EXPLJSYN
*PROCESS COMPAT(NOCASE,MACROCASE)                          Ver1
*
          IEFSJSYD DSECT=YES   Yes is Default
*
**************************
*
*
* sysprint dsect stuff
* MINIMUM SYSPRINT ABOVE CODE
*
* ADD THIS TO  PGM AS DSECT
*
TESTDCBD DCBD DSORG=PS,DEVD=DA
*
*
* DYNAMIC STORAGE THAT MUST RESIDE BELOW 16MB LINE DUE TO DCB & EXIT
* LIST RESTRICTIONS.  GET SEPARATE STORAGE FOR THIS.
*
DCB24_WORKAREA DSECT
*
SYSPR_DCB24 DS XL(MODSPRDCB_l) DCB LNG QS ACTUAL QSAM DCB
* EACH ENTRY IN DCB EXIT LIST IS FOUR BYTES.
SY_EXL24    DS    X         LAST ENTRY IN EXIT LIST AND FOR DCB OPENX
SY_EXL24OPEN24 DS AL3       ADDRESS OF 24-BIT DCB OPEN EXIT ROUTINE
SYPENLIST24 DS  XL(LSPROPPL) LEN OPEN PARAMETER LIST
*
*
CLOLIST24 DS   XL(LSPRCLPL) LEN CLOS PARAMETER LIST
* THE FOLLOWING IS EXECUTABLE CODE TO BRANCH ABOVE THE 16MB LINE.
         DS    0H
OPEN24   DS    XL(LENOPEN24)   DCB OPEN EXIT BELOW 16MB LINE
ADOPEN24_AD31 DS A       ADDRESS OF DCB OPEN EXIT ABOVE THE LINE
L_DCB24_WORKAREA EQU *-DCB24_WORKAREA
*
**************************
         sysstate archlvl=2
EXPLJSYN RSECT
EXPLJSYN amode 31
EXPLJSYN rmode 31
*
         J     BEGIN
         yregs
PROLOG   LOCTR
         DC    C'EXPLJSYN'
         DC    C'AsmDate && Time: &SYSDATE &SYSTIME'
         DC    C'Ver 1.2.3'
         DC    C'All rights reserved'
CODEBG1  LOCTR
BEGIN    DS    0H
         using data,12
         save  (14,12)       save z/os's regs
         larl  12,data       use this instead of lr and ahi
*        LR    R12,R15
*        AHI   R12,data-BEGIN
         STORAGE OBTAIN,LENGTH=dsa_worksize,LOC=31
         st    13,4(1)       save the r13 save area first
*        getmain r,lv=dsa_worksize
         lr    13,1
         using (wareas,wareasend),13
*  ...
*         TIME  DEC,TIMEDATE,ZONE=LT,LINKAGE=SYSTEM
*   move static mf=l area to dyn stg area
         mvc    e_LIST1_stg,TIME_MF_LIST
         TIME  DEC,timedate,LINKAGE=SYSTEM,MF=(E,e_LIST1_stg),         x
               DATETYPE=YYYYMMDD
*
**************************
*
* sysprint code initialization
* ADD THIS TO CODE SECTION 1 after GM DYNAMIC STG
*
* initialize sysprint vars
         JAS   R9,INITRTN
* initialize sysprint vars
         STORAGE OBTAIN,LENGTH=L_DCB24_WORKAREA,LOC=24 GET DCB & ETC.
         ST    R1,PTR_DCB24_WORKAREA
         LR    R10,R1
         USING DCB24_WORKAREA,R10
*
*        LA    R0,MODSPRDCB        POINT THE EXIT LIST TO THE EXIT RTN
*        STCM  R0,B'0111',SY_EXL24OPEN24 THAT IS BELOW THE LINE
*        MVI   SY_EXL24,X'85'    SET LAST ENTRY & DCB OPEN EXIT LIST
*??????? MVC   OPEN24,MODOPEN24    MOVE GLUE CODE TO BELOW LINE
*
*   new mvcl because MODSPRDCB is csect NOT base addressable
*        MVC   SYSPR_DCB24,MODSPRDCB CREATE DCB BELOW THE LINE
         la    r2,SYSPR_DCB24
         iilf  r3,l'SYSPR_DCB24
         larl  r4,MODSPRDCB
         lr    r5,r3
         MVCL  r2,r4
         LARL  R0,OPEN31           SHOW THE 24-BIT CODE WHERE THE
*        LA    R0,OPEN31           SHOW THE 24-BIT CODE WHERE THE
*        ST    R0,ADOPEN24_AD31      31-BIT CODE IS ABOVE THE LINE
*        OI    ADOPEN24_AD31,X'80' SET BIT 0 TO AMODE 31 IN ADDRESS
*
*
*        MVC   SYSPR_DCB24,MODSPRDCB CREATE DCB BELOW THE LINE
*        LA    R0,SY_EXL24
*        STCM  R0,B'0111',DCBEXLSA-IHADCB+SYSPR_DCB24
*   new larl because OPEN31    is a relative address
*        MVC   SYPENLIST24,MODSPRPEN BUILD OPEN PARAMETER LIST
         la    r2,SYPENLIST24
         iilf  r3,L'SYPENLIST24
         larl  r4,MODSPRPEN
         lr    r5,r3
         MVCL  r2,r4
*        MVC   SYPENLIST24,MODSPRPEN BUILD OPEN PARAMETER LIST
*
         OPEN  (SYSPR_DCB24),MF=(E,SYPENLIST24) LIST IS BELOW THE LINE
*
         LA    R14,SYSPR_DCB24
         USING IHADCB,R14
         MVC   WRTSTR_LLNG,DCBLRECL
         DROP  R14
         DROP  R10
*
* end sysprint code initialization
*
* end         CODE SECTION 1
*
**************************
*
* sysprint EXPL OF USAGE
*
*
         IILF  R15,4
         STH   R15,FROM_HEX_STR_L
         ARK   R9,R15,R15
         STH   R9,TO_CHAR_STR_L
*
         ST    R15,X_FROM_L_A
         LA    R15,timedate
         ST    R15,X_FROM_A
         LA    R15,TO_CHAR_STR_L
         ST    R15,X_TO_L_A
         LA    R15,$TIME
         ST    R15,X_TO_A
         LA    R15,X2CX_PRM_ADR
         jas  r9,x2cx
*
         IILF  R15,4
         STH   R15,FROM_HEX_STR_L
         ARK   R9,R15,R15
         STH   R9,TO_CHAR_STR_L
*
         ST    R15,X_FROM_L_A
         LA    R15,timedate+8
         ST    R15,X_FROM_A
         LA    R15,TO_CHAR_STR_L
         ST    R15,X_TO_L_A
         LA    R15,$DATE
         ST    R15,X_TO_A
         LA    R15,X2CX_PRM_ADR
         jas  r9,x2cx
*
         MVC   MSGAREA(L'BEGNMSG),BEGNMSG
         MVC   MSGAREA+25(8),$DATE
         MVC   MSGAREA+34(8),$TIME
         JAS   R9,WRTMSG
*
* end sysprint EXPL OF USAGE
*
**************************
*  ...
         mvc   hld_phase,lit_first
         mvc   hld_req,lit_g_b_n
         la    r7,SYMBOLAREA
*
jsymx IEFSJSYM REQUEST=GETBYNAME,SYMLISTARRAY=SYMBOLS,NUMENTRIES=3,    *
               SYMBAREA=SYMBOLAREA,SYMBAREALEN=256,DIAGDATA=SJDIAG
jsyml IEFSJSYM REQUEST=GETALL,SYMBAREA=SYMBOLAREA,SYMBAREALEN=256,     *
               RETCODE=SJSYM_RC,RSNCODE=SJSYM_RSN,DIAGDATA=SJDIAG
*
         la     r8,dsa_jsyml
         mvc    0(dsa_jsyml_l,r8),#jsyme_laddr
*        IEFSJSYM MF=(M,dsa_jsyml_laddr,COMPLETE),REQUEST=GETALL
*
         IEFSJSYM MF=(E,(r8)),                                         *
               REQUEST=GETALL,SYMBAREA=SYMBOLAREA,SYMBAREALEN=256,     *
               RETCODE=SJSYM_RC,RSNCODE=SJSYM_RSN,DIAGDATA=SJDIAG
*
* at termination:
*
         clrje 15,15,doterm
*        ltr   15,15
*        jz    doterm
err0     ds    0h
         la    15,8
*
doterm   ds    0h
         lr    1,13
         l     0,fsize
         l     13,4(13)
         freemain r,lv=(0),a=(1)
         return (14,12),,rc=0
*
*
**************************
*
PROC_SYMBS DS 0H
         using SYDHdr,r7
         using SYDEntry,r8
         STM   R7,R9,SAV_7_9
         cije  r15,0,fst_sym_ok
         mvc   msgarea(l'err_msg),err_msg
         jas   r9,x2cx_r15
         mvc   msgarea+12(8),EBCDCFLD
         lr    r15,r0
         jas   r9,x2cx_r15
         mvc   msgarea+24(8),EBCDCFLD
         mvc   msgarea+37(16),sjdiag
         JAS   R9,WRTMSG
         j     no_entries
*
fst_sym_ok ds  0h
         mvc   msgarea(l'hld_phase),hld_phase
         mvc   msgarea+7(l'hld_req),hld_req
         mvc   msgarea+7+11(l'lit_count),lit_count
***
         lh    r15,SYDEntryCount
         cijh  r15,0,got_entries
         mvc   msgarea+7+11+6(l'lit_none),lit_none
         JAS   R9,WRTMSG
         j     no_entries
*
got_entries ds 0h
         sth   r15,hld_entry_ct
         jas   r9,x2cx_r15
         mvc   msgarea+7+11+6(8),EBCDCFLD
         JAS   R9,WRTMSG
*
         xc    hld_entry_cur,hld_entry_cur
         l     r8,SYDEntryOff    offset to first end (in sys_hd)
nxt_entry ds 0h
         lh    r15,hld_entry_cur
         la    r15,1(r15)
         sth   r15,hld_entry_cur
*
         ar    r8,r7   add the r7 std_hdr addr with offset
*  r8 still points at sys entry dsect so use it
         clc   SYDEntryID,=cl4'SJSE'
         je    got_ent_hdr
         mvc   msgarea(l'bad_entry_sjse),bad_entry_sjse
         jas   r9,x2cx_r15
         mvc   msgarea+7(8),EBCDCFLD
         lr    r15,r8    show addr
         jas   r9,x2cx_r15
         mvc   msgarea+31(8),EBCDCFLD
         JAS   R9,WRTMSG
         j     no_entries  no nxt chain, so we break
*
got_ent_hdr ds 0h
         mvc   hld_symnm,SYDESYMNAME
         mvc   msgarea,SYDESYMNAME
         lh    r15,SYDESYMVALUELEN
         cijh  r15,0,got_a_sym_val_off
         mvc   msgarea+16(l'lit_was_nf),lit_was_nf
         JAS   R9,WRTMSG
         j     chk_4_nxt_entry_off
*
got_a_sym_val_off ds 0h
         mvC   msgarea+16(L'lit_of_lng),lit_of_lng
         jas   r9,x2cx_r15
         mvc   msgarea+31(8),EBCDCFLD
         JAS   R9,WRTMSG
         l     9,SYDESYMVALUEOFFSET offset from syshdr
         ar    r9,r7         a(syshdr) + offset to symbol
* symbol value is written in 80 char lines, last line being rest
chk_ent_lng ds 0h
         cijnh r15,80,mvc_w_xeq   fit it on
         mvc   msgarea(80),0(r9)
         ahi   r15,-80
         ahi   r9,80
         j     chk_ent_lng
*
mvc2msgarea mvc msgarea(0),0(r9)
*
mvc_w_xeq ds 0h
         cije  r15,0,chk_4_nxt_entry_off
         bctr  r15,0
         exrl  r15,mvc2msgarea
*
chk_4_nxt_entry_off ds 0h
         lt    r8,SYDENEXTENTRYOFF
         jnz   nxt_entry
*
         mvc   msgarea(l'fin_req),fin_req
         mvc   msgarea+9(l'hld_phase),hld_phase
         mvc   msgarea+16(l'hld_req),hld_req
         mvc   msgarea+27(l'lit_count),lit_count
         lh    r15,hld_entry_cur
         jas   r9,x2cx_r15
         mvc   msgarea+33(8),EBCDCFLD
         jas   r9,wrtmsg
*
no_entries ds 0h
         drop  r7
         drop  r8
*
         LM    R7,R9,SAV_7_9
         BR    R9
*
**************************
*
* ADD      TO CODE SECTION 2
*
OPEN31   EQU   *         ENTRY POINT OF DCB OPEN EXIT ABOVE THE LINE
         BSM   0,R14     SWITCH TO 24-BIT MODE AND RETURN TO OPEN
*
DOCLOSE  EQU   *
         L     R10,PTR_DCB24_WORKAREA
         USING DCB24_WORKAREA,R10
*   new mvcl because MODSPRCLO is NOT base addressable
         la    r2,CLOLIST24
         iilf  r3,L'CLOLIST24
         larl  r4,MODSPRCLO
         lr    r5,r3
         MVCL  r2,r4
*        MVC   CLOLIST24,MODSPRCLO BUILD OPEN PARAMETER LIST
         CLOSE (SYSPR_DCB24),MF=(E,CLOLIST24)
         BR    R9
*
*
* END      TO CODE SECTION 2
*
**************************
*********************
*
* sysprint EXPL sub routines
*
*
INITRTN  EQU   *
* PLACE ANY INITIALIZATION PROCESSING HERE
         MVC   WRTSTR_LLNG,H_SYSPRINT_LRECL
         MVI   MSGAREA1,X'40'
         MVC   MSGAREA,MSGAREA1
         MVC   SAV_MSGAREA,MSGAREA
         BR    R9
*
*
WRTMSG   EQU   *
         STM   R10,R1,WRTMSG_SAVR10_1
         L     R10,PTR_DCB24_WORKAREA
         USING DCB24_WORKAREA,R10
         LA    R1,SYSPR_DCB24
         PUT   (1),MSGAREA
         DROP  R10
         MVC   MSGAREA,MSGAREA1
         LM    R10,R1,WRTMSG_SAVR10_1
         BR    R9
***
* convert value in r15 to %02x display x string in EBCDCFLD
*    R15 is not altered
*
X2CX_R15  DS    0h
         STM   R4,R9,X2CX49
         XR    R6,R6
         LA    R6,8
         ST    R15,HEXFIELD
         LA    R4,HEXFIELD
         LA    R5,EBCDCFLD
*
CONVERT_R15  EQU   *
         SLR   R8,R8
         IC    R8,0(R4)
         SRDL  R8,4
         STC   R8,0(R5)
         LA    R5,1(R5)
         SLR   R8,R8
         SLDL  R8,4
         STC   R8,0(R5)
         LA    R5,1(R5)
         LA    R4,1(R4)
         JCT   R6,CONVERT_R15
*
         TR    EBCDCFLD(8),HEXTRAN
         LM    R4,R9,X2CX49
         BR    R9
*
***
* convert value in r15 to %02x display x string in EBCDCFLD
*
X2CX     EQU   *
         STM   R4,R9,X2CX49
         LTR   R4,R15
         JNP   NO_X2CX
*
         L     R5,4(R4)          GET PTR TO HW X SRC LNG
         XR    R6,R6
         ICM   R6,B'0011',0(R5)  GET THE LNG
         JNP   NO_X2CX
*
         L     R5,12(R4)          GET PTR TO HW X SRC LNG
         XR    R7,R7
         ICM   R7,B'0011',0(R5)  GET THE LNG
         JNP   NO_X2CX
*
         SLL   R6,1              MULTIPLY BY 2
         CRJNE R6,R7,BAD_X2CX
*
         SRL   R6,1              GET ORIGINAL VALUE BACK
*
         L     R5,8(R4)       GET ADR OF THE TGT CHAR FLD
         L     R4,0(R4)          GET ADR OF SRC HEX FLD
         LA    R9,TABLE     TRANSLATE TO CHAR FORM
         AHI   R9,-240
*
CONVERT  EQU   *
         CIJL  R6,4,CONVERT1
         MVC   MYXSTR(4),0(R4)
         UNPK  MYCHAR,MYXSTR(5) UNPACK HEX STREAM
         TR    MYCHAR,0(R9)     TRANSLATE TO CHAR FORM
         MVC   0(8,R5),MYCHAR
         AHI   R5,8
         AHI   R4,4
         AHI   R6,-3
         J     CONVERT2
CONVERT1 DS    0H
         XR    R8,R8            CLEAR REG
         IC    R8,0(R4)         INSERT CHAR IN 25-32
         SRDL  R8,4             SHIFT OUT 29-32 INTO R9
         STC   R8,0(R5)         STORE SHIFTED 25-28 AS X'0X'
         TR    0(1,R5),HEXTRAN  TRANSLATE ALL 00 THRU 0F
*                                     TO->    F0 - F9,C1 - C6
         LA    R5,1(R5)         ADVANCE PTR TO NEXT POS
         XR    R8,R8            CLEAR REG
         SLDL  R8,4             SHIFT IN THE 29-32
         STC   R8,0(R5)         STORE IT
         TR    0(1,R5),HEXTRAN  TRANSLATE ALL 00 THRU 0F TO
*                                     TO->    F0 - F9,C1 - C6
         LA    R5,1(R5)         ADVANCE ANOTHER
         LA    R4,1(R4)         ADVANCE NEXT
CONVERT2 DS    0H
         JCT   R6,CONVERT       REDUCE COUNTER
*
         XR    R15,R15
         J     OK_X2CX
BAD_X2CX EQU   *
         LA    R15,8
         J     OK_X2CX
NO_X2CX  EQU   *
         LA    R15,4
         J     OK_X2CX
OK_X2CX  EQU   *
         LM    R4,R9,X2CX49
         BR    R9
*
***
*
* sysprint EXPL sub routines
* END  OF USAGE AND SUBROUTINE
*
**************************************
*
* ADD      TO CODE SECTION 3 (CODE BUT NOT RUNABLE:
*                             LIKE TARGET OF EXECUTE STMTS (MVC))
*
MODSPRPEN OPEN (,OUTPUT),MF=L,MODE=31 MODEL OPEN PARAMETER LIST
LSPROPPL EQU   *-MODSPRPEN
*
MODSPRCLO CLOSE (),MF=L,MODE=31       MODEL OPEN PARAMETER LIST
LSPRCLPL EQU   *-MODSPRCLO
*
* THE FOLLOWING IS THE MODEL FOR THE DCB OPEN EXIT ROUTINE ENTRY POINT
* WE COPY THIS CODE TO THE WORK AREA, WHICH IS BELOW THE LINE.  THE
* BSM SETS THE CURRENT ADDRESSING MODE (24) IN BIT 0 OF R14 WITHOUT
* CHANGING ANYTHING ELSE IN R14.  IT ALSO SWITCHES TO 31-BIT DUE TO
* BIT 0 IN R15 AND BRANCHES TO THE ADDRESS IN R15.
MODOPEN24 L    R15,ADOPEN31-OPEN24(,R15) ENTRY PT TO DCB OPEN EXIT RTN
         BSM   R14,R15        SAVE AMODE, SWITCH TO 31-BIT AND BRANCH
LENOPEN24 EQU  *-MODOPEN24
*
*
*
* END      TO CODE SECTION 3
*
**************************************
*
data     ds    0f
fsize    dc    a(dsa_worksize)
SYMBOLS      DS   0D
S1           DC   CL16'A'
S2           DC   CL16'B'
S3           DC   CL16'C'
*
*jsyme IEFSJSYM MF=(L,#jsyme_laddr,0D),PLISTVER=MAX
*jsyme_l      equ *-#jsyme
*
**************************
*
* sysprint control blocks in static storage
* ADD  TO BOTTOM SECTION (STATIC SECTION I.E. DC VARS)
*
SYSPR_BEGINMSG DC   C'THIS IS A TEST FOR QSAM ABOVE TO SYSPRINT'
*
* DCB MODEL FOR SYSPRINT, WHICH IS ABOVE THE LINE.
MODSPRDCB DCB  DSORG=PS,DDNAME=SYSPRINT,MACRF=(PM)
MODSPRDCB_l EQU *-MODSPRDCB
*
**************************
* Test data
H_SYSPRINT_LRECL dc h'121'
*                0....5....1....5....2....5....3....5....4....5....5
BEGNMSG  DC    C'EXPLDYNA PROGM BEGIN AT'
lit_first     dc cl7'FIRST :'
lit_second    dc cl7'SECOND:'
lit_third     dc cl7'THIRD :'
lit_forth     dc cl7'FORTH :'
lit_g_b_n     dc cl11'GETBYNAME:'
lit_g_all     dc cl7'GETALL:'
lit_count     dc cl6'COUNT:'
lit_val       dc cl4'VAL:'
lit_of_lng    dc cl7':OF LNG:'
lit_none      dc cl15'ZERO SYMBOLS RETURNED.'
lit_was_nf    dc cl15':WAS NOT FOUND'
fin_req  dc c'FINISHED:'
err_msg  dc c'!ERROR!:R15:12      :R1:24      :DIAG:'  <<38
BAD_ENTRY_SJSE DC C'ENTRY#:7        MISSING SJSE @:31      :break'
*
*
*
* END     BOTTOM SECTION (STATIC SECTION I.E. DC VARS)
*
**************************
*
TIME_MF_LIST TIME LINKAGE=SYSTEM,MF=L
time_end  equ   *-TIME_MF_LIST
*
* x2cx translate table
HEXTRAN  DC    X'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
XFF      DC    XL4'FFFFFFFF'
*
TABLE   DC C'0123456789ABCDEF'
*
         ltorg
wareas   dsect
save     ds    36f
SJSYM_RC     DS   F
SJSYM_RSN    DS   F
SJDIAG       DS   4F
SYMBOLAREA   DS   64F
             ds   0d
dsa_jsyme    ds   xl(dsa_jsyml_l)
             ds   0d
dsa_jsyml    IEFSJSYM MF=(L,dsa_jsyme_laddr,0D),PLISTVER=MAX
dsa_jsyml_l  equ  *-dsa_jsyml
             ds   0f
hld_symnm    ds   cl16
hld_symval   ds   cl255
*
PTR_DCB24_WORKAREA ds f
WRTMSG_SAVR10_1 ds 8f
WRTSTR_LLNG  ds   h
*
MSGAREA1 ds    cl1
MSGAREA  ds    cl121
SAV_MSGAREA ds cl121
*
e_LIST1_stg ds  xl(time_end)
*07313264   51860000   20160204   00000000
timedate  DS    CL16         TIME AND DATE RETURNED
timedate_l equ  *-timedate
$DATE     DS    CL8          TIME AND DATE RETURNED
$TIME     DS    CL8          TIME AND DATE RETURNED
*
X2CX49   DS    6F
X2CX_PRM_ADR DS 0F
X_FROM_A DS    F
X_FROM_L_A DS  F
X_TO_A   DS    F
X_TO_L_A DS    F
*
FROM_HEX_STR_L  DS    H      hold lng of x src
TO_CHAR_STR_L   DS    H      hold lng od cx dest
*FROM_HEX_STR  DS    XL40
*TO_CHAR_STR   DS    XL80
*
DWORD    DS    D
$DBLWD   DS    D
EBCDCFLD DS    D
HEXFIELD DS    F
*
MYCHAR  DS XL9 CHAR DATA
*
MYXSTR  DS XL4  CHAR DATA
MYXSTR1 DS XL1
*
SAV_7_9       DS 3F
CUR_MSG_POS   ds h
hld_entry_ct  ds h
hld_entry_cur ds h
hld_phase     ds cl7
hld_req       ds cl11
*
**************************
wareasend ds   0h
dsa_worksize equ *-save
*
         end   EXPLJSYN
###END EXPLJSYN
$$$BEG EXPLPSPM
** SEE TTED.TSK.D.TCEM.ASM(EXPSYSP2)
**     FOR A MORE UNDERSTANDABLE EXAMPLE
TESTDCBD DCBD DSORG=PS,DEVD=DA
*
*
* DYNAMIC STORAGE THAT MUST RESIDE BELOW 16MB LINE DUE TO DCB & EXIT
* LIST RESTRICTIONS.  GET SEPARATE STORAGE FOR THIS.
DCB_WORKAREA DSECT
SYSPR_DCB DS   XL(SYSPREND) DCB LNG QS  ACTUAL QSAM DCB
* EACH ENTRY IN DCB EXIT LIST IS FOUR BYTES.
SY_EXL      DS    X         LAST ENTRY IN EXIT LIST AND FOR DCB OPEN
SY_EXLOPEN  DS    AL3       ADDRESS OF 24-BIT DCB OPEN EXIT ROUTINE
SYPENLIST DS    XL(LSPROPPL) LEN OPEN PARAMETER LIST
*
*
CLOLIST  DS    XL(LSPRCLPL) LEN CLOS PARAMETER LIST
* THE FOLLOWING IS EXECUTABLE CODE TO BRANCH ABOVE THE 16MB LINE.
         DS    0H
OPEN24   DS    XL(LENOPEN24)   DCB OPEN EXIT BELOW 16MB LINE
ADOPEN31 DS    A         ADDRESS OF DCB OPEN EXIT ABOVE THE LINE
LENAREA  EQU   *-DCB_WORKAREA
*
*
**
** REGISTER USAGE
**  R0  WORK FOR MANY INST
**  R1 PASS PARM ADDR AND WORK AND TRT
**  R2 WORK AND USED BY TRT
**  R3 BASE1
**  R4 R5 WORK AND USED FOR EVEN ODD
**  R6 R7 WORK AND USED FOR EVEN ODD
**  R8 WORK
**  R9 WORK AND USED FOR SR LINKAGE
**  R10 DCBPTR AND WORK
**  R11 USED FOR AUTO STORAGE
**  R12 BASE2
**  R13 SAVEAREA
**  R14 WORK
**  R15 PASS DATA IN REG TO SR AND WORK
**
         GBLC  &GCOPY
MYDYN_S  INITSTG USEREG=11
*
         COPY &GCOPY
*
         COPY PASSPAR1
*
PTR_PARM_PLUS1 DS F
PARM_PLUS1L    DS H
*
PARMS_AREA DS 0F
P_SYSID    DS F
P_CMD      DS F
*
D_TIME_USED1 DS F
D_TIME_USED2 DS F
         ORG   MYDYN_S+4096-256
STOPARM  DS    256XL1
*
EXPLPSPM CSECT
EXPLPSPM RMODE ANY
EXPLPSPM AMODE 31
LBLPGM   INITMAC 3,EQU=R,ID=EXPLPSPM
         ST    R1,PARMAP
         XR    R1,R1
         ST    R13,SAVRD
         XC    D_TIME_USED1,D_TIME_USED1
         XC    D_TIME_USED1,D_TIME_USED1
         LA    R2,D_TIME_USED1
         TIMEUSED   STORADR=(2),LINKAGE=SYSTEM,VECTOR=MIC
*
         STORAGE OBTAIN,LENGTH=LENAREA,LOC=BELOW  GET DCB & ETC.
         ST    R1,PTR_DCB_WORKAREA
         LR    R10,R1
         USING DCB_WORKAREA,R10
*
         LA    R0,OPEN24           POINT THE EXIT LIST TO THE EXIT RTN
         STCM  R0,B'0111',SY_EXLOPEN    THAT IS BELOW THE LINE
         MVI   SY_EXL,X'85'      SET LAST ENTRY & DCB OPEN EXIT LIST
         MVC   OPEN24,MODOPEN24    MOVE GLUE CODE TO BELOW LINE
         LA    R0,OPEN31           SHOW THE 24-BIT CODE WHERE THE
         ST    R0,ADOPEN31           31-BIT CODE IS ABOVE THE LINE
         OI    ADOPEN31,X'80'      SET BIT 0 TO AMODE 31 IN ADDRESS
*
         MVC   SYSPR_DCB,MODSPRDCB CREATE DCB BELOW THE LINE
         LA    R0,SY_EXL
         STCM  R0,B'0111',DCBEXLSA-IHADCB+SYSPR_DCB
*
         MVC   SYPENLIST,MODSPRPEN  BUILD OPEN PARAMETER LIST
*   OPEN USES NORMAL RSA CONVENTIONS
         OPEN  (SYSPR_DCB),MF=(E,SYPENLIST) LIST IS BELOW THE LINE
*        OPEN  (SYSPRINT,(OUTPUT))
         LA    R14,SYSPR_DCB
         USING IHADCB,R14
         MVC   H_SYSPRINT_LRECL,DCBLRECL
         DROP  R14
         DROP  R10
*
         BAS   R9,INITRTN
*        MHELP 64
         WRITMAC STRLIT='EXPLPSPM STARTING.'
         BAS   R9,GETTIME
*
         MVC   MSGAREA(L'BEGNMSG),BEGNMSG
         MVC   MSGAREA+25(5),$DATE+3
         MVC   MSGAREA+31(6),$TIME+1
         BAS   R9,GETJOBN
         BAS   R9,WRTMSG
*
         L     R1,PARMAP
         LTR   R1,R1
         BZ    NOPARM
         L     R1,0(R1)
         ST    R1,PARMAP
         LH    R15,0(R1)
         LTR   R15,R15
         BZ    NOPARM
         STH   R15,PARMAL
         BCTR  R15,0
         LA    R1,2(R1)
         ST    R1,PARMA
         EX    R15,MVCPARM
         MVC   MSGAREA(L'PRMSG),PRMSG
         XR    R15,R15
         LH    R15,PARMAL
         BAS   R9,X2CX
         MVC   MSGAREA+14(4),EBCDCFLD+4
         BAS   R9,WRTMSG
         B     WRIT_PRMMSG
*
NOPARM   EQU   *
         WRITMAC STRLIT='NO PARM PROVIDED OR ZERO LENGTH'
         B     DOCLOSE
*
MVC2STG  MVC   0(0,R1),0(R4)
WRIT_PRMMSG EQU *
         MVI   XC,X'08'
***
*** INSERT CODE HERE
         LH    R4,PARMAL
         LA    R4,1(R4)
         STORAGE OBTAIN,LENGTH=(R4),LOC=RES
         ST    R1,PTR_PARM_PLUS1
         L     R4,PARMA
         LH    R15,PARMAL
         BCTR  R15,0
         EX    R15,MVC2STG
***
         AH    R4,PARMAL
         MVI   0(R4),X'00'
* FIND THE FIRST OCCURANCE OF '=' IF ANY
         L     R4,PTR_PARM_PLUS1
         LH    R5,PARMAL
         LA    R6,L_EQ
         LA    R7,0
         LA    R0,1
         LA    R1,X'7E'
         CUSE  R4,R6
         BZ   F_CUSE_CC0   CC 0 OR BC 8
         BL   E_CUSE_NF_END_EQ_CC1   CC 1 OR BC 4
         BH   E_CUSE_NF_END_NE_CC2   CC 2 OR BC 2
*
CUSE_ERROR  EQU *
         WRITMAC STRLIT='FELL THROUGH CUSE ...SO WHAT GIVES????'
         B    WRIT_CUSE_REGS
*
F_CUSE_CC0 EQU *
         WRITMAC STRLIT='CUSE FOUND EQUAL SUBSTRINGS AT...'
         B    WRIT_CUSE_REGS
E_CUSE_NF_END_EQ_CC1 EQU *
         WRITMAC STRLIT='CUSE FOUND EQUAL AT END OF LONGER STRING...'
         B    WRIT_CUSE_REGS
E_CUSE_NF_END_NE_CC2 EQU *
         WRITMAC STRLIT='CUSE FOUND UNEQUAL AT END OF LONGER STRING...'
         B    WRIT_CUSE_REGS
WRIT_CUSE_REGS EQU *
         LR    R15,R4
         BAS   R9,X2CX
         MVC   MSGAREA+6(8),EBCDCFLD
*
         LR    R15,R5
         BAS   R9,X2CX
         MVC   MSGAREA+16(8),EBCDCFLD
*
         LR    R15,R6
         BAS   R9,X2CX
         MVC   MSGAREA+26(8),EBCDCFLD
*
         LR    R15,R7
         BAS   R9,X2CX
         MVC   MSGAREA+36(8),EBCDCFLD
         LR    R15,R2
         BAS   R9,X2CX
         MVC   MSGAREA+46(8),EBCDCFLD
         BAS   R9,WRTMSG
*
         B     DOCLOSE
*
*
NOSTG    EQU   *
EXITRC8  EQU   *
         XR    R15,R15
         LA    R15,8
         B     BYL15
*
*
OPEN31   EQU   *         ENTRY POINT OF DCB OPEN EXIT ABOVE THE LINE
         BSM   0,R14     SWITCH TO 24-BIT MODE AND RETURN TO OPEN
*
DOCLOSE  EQU   *
         MVC   MSGAREA(L'ENDMSG),ENDMSG
         BAS   R9,WRTMSG
         L     R10,PTR_DCB_WORKAREA
         USING DCB_WORKAREA,R10
* MVC ADDED 20160211
         MVC   CLOLIST,MODSPRCLO  BUILD OPEN PARAMETER LIST
         CLOSE (SYSPR_DCB),MF=(E,CLOLIST)
         LA    R2,D_TIME_USED2
         TIMEUSED   STORADR=(2),LINKAGE=SYSTEM,VECTOR=MIC
*
         IC    R15,XC
BYL15    EQU   *
         RTNMAC  RC=(15)
NORTNCD  EQU   *
         RTNMAC
*
INITRTN  EQU   *
* PLACE ANY INITIALIZATION PROCESSING HERE
         MVC   WRTSTR_LLNG,H_SYSPRINT_LRECL
         MVI   MSGAREA1,X'40'
         MVC   MSGAREA,MSGAREA1
         MVC   SAV_MSGAREA,MSGAREA
         MVI   XC,X'00'
         XC    PTR_STG_STAKB,PTR_STG_STAKB
         XC    PTR_STG_STAKA,PTR_STG_STAKA
         BR    R9
*
***
MVCPARM  MVC   MSGAREA+19(0),0(R1)
MVC2MSG  MVC   MSGAREA(0),0(R10)
WRTSTR   EQU  *
*   REG15 SET TO BEGIN ADDRESS OF A NULL TERMINATED STRING
*   REQUIRES A FW AUTOSTORAGE SAVE AREA FOR R9  WRTSTR_SAVR9
*   REQUIRES A FW AUTOSTORAGE HW VALUE FOR O/P LINE LENGTH 1-255
*                                               WRTSTR_LLNG
*
         STM  R8,R10,WRTSTR_SAVR8_10
         LR   R9,R15
         XR   R0,R0
SRST_AGN SRST R0,R9
         BC   4,WRTSTR_FND
         BC   1,SRST_AGN      SECOND REG CHANGED FOR NEXT SEARCH ADDR
***
BAD_WRTSTR EQU *
         XR    R15,R15
         BCTR  R15,0
         B     WRTSTR_RET
WRTSTR_FND EQU *
         SR    R0,R15         R0 NOW HAVE NULL POS. DERIVE LNG
         BNP   BAD_WRTSTR
         LR    R10,R15        SAVE START
         LR    R8,R0          SAVE DERIVED LENGTH
WRTSTR_TOL EQU *
         CH    R8,WRTSTR_LLNG
         BNH   WRTSTR_DO_EX
         LH    R9,WRTSTR_LLNG
         BCTR  R9,0
         EX    R9,MVC2MSG
         BAS   R9,WRTMSG
         AH    R10,WRTSTR_LLNG
         SH    R8,WRTSTR_LLNG
         B     WRTSTR_TOL
*
WRTSTR_DO_EX   EQU  *
         LTR   R9,R8
         BNP   WRTSTR_FIN
         BCTR  R9,0
         EX    R9,MVC2MSG
         BAS   R9,WRTMSG
WRTSTR_FIN EQU *
         XR    R15,R15
WRTSTR_RET EQU *
         LM    R8,R10,WRTSTR_SAVR8_10
         BR    R9
*
WRTMSG   EQU   *
         STM   R10,R1,WRTMSG_SAVR10_1
         L     R10,PTR_DCB_WORKAREA
         USING DCB_WORKAREA,R10
         LA    R1,SYSPR_DCB
         PUT   (1),MSGAREA
         DROP  R10
         MVC   MSGAREA,MSGAREA1
         LM    R10,R1,WRTMSG_SAVR10_1
         BR    R9
***
GETJOBN  EQU   *
         ST    R9,SAVR9
         LA    R9,TIOTADR
         EXTRACT (R9),'S',FIELDS=TIOT
         L     R1,TIOTADR
         MVC   JOBNAME,0(R1)
         L     R9,SAVR9
         BR    R9
*** GET THE SYSDATE SYSTIME IN ORDER TO CREATE A UNIQUE QUALIFIER
GETTIME  EQU   *
         XR    R0,R0
         XR    R1,R1
         TIME
         ST    R0,$TIMEB
         ST    R0,$DBLWD+4
         OI    $DBLWD+7,X'0F'
         UNPK  $TIME,$DBLWD
         XC    $DBLWD,$DBLWD
         ST    R1,$DATEB
         ST    R1,$DBLWD+4
         OI    $DBLWD+7,X'0F'
         UNPK  $DATE,$DBLWD
         BR    R9
***
B2C      EQU   *
         CVD   R15,DWORD
         UNPK  HLDSTR,DWORD+4(4)
         OI    HLDSTR+6,X'F0'
         XR    R15,R15
         BR    R9
***
* THIS IS THE ERROR ROUTINE TO FORMAT THE ERROR CODE RETURNED FROM THE
* SVC IF THERE IS AN ERROR ON ALLOCATION.
X2CX     EQU   *
         STM   R4,R9,X2CX49
         ST    R15,FOUR
         UNPK  EIGHT(9),FOUR(5)
         XC    EBCDCFLD,EBCDCFLD
         MVN   EBCDCFLD(8),EIGHT
         TR    EBCDCFLD,ERRTRAN
         LM    R4,R9,X2CX49
         BR    R9
*
*X2CX     EQU   *   FORMER CODE
FORMERR  EQU   *
         B     X2CX
*
         STM   R4,R9,X2CX49
         XR    R6,R6
         LA    R6,4
         ST    R15,HEXFIELD
         LA    R4,HEXFIELD
         LA    R5,EBCDCFLD
*
CONVERT  EQU   *
         SLR   R8,R8
         IC    R8,0(R4)
         SRDL  R8,4
         STC   R8,0(R5)
         LA    R5,1(R5)
         SLR   R8,R8
         SLDL  R8,4
         STC   R8,0(R5)
         LA    R5,1(R5)
         LA    R4,1(R4)
         BCT   R6,CONVERT
*
         TR    EBCDCFLD(8),ERRTRAN
         LM    R4,R9,X2CX49
         BR    R9
         LTORG
DONEEXT  EQU   *
NOEXT    EQU   *
*
         RTNMAC
*
*        PROGRAM CONSTANTS
*
*
*
*
         EJECT
$MODID   DC    CL16'&SYSDATE.-&SYSTIME'
* NEW CONSTANTS
BIN_CONST DC   FL8'95'
BIN_CONST_FD DC   FD'95'
ADR_CONST_8  DC   AD(95)
*UNICODE_CONST DC  CU1(A)
ZEROES   DC    2F'0'
FMIN1    DC    F'-1'
F254     DC    F'254'
BLANKS   DC    CL8'                '
F16      DC    F'16'
         ORG   F16
         DS    H
HW16     DS    H
F80      DC    F'80'
         ORG   F80
         DS    H
HW80     DS    H
N_X2CX   DC    XL8'0F0F0F0F0F0F0F0F'
Z123     DC    Z'123'
L_EQ     DC    C'='
L_CM     DC    C','
L_SP     DC    C' '
L_SQ     DC    C''''
L_DQ     DC    C'"'
L_LP     DC    C'('
L_RP     DC    C')'
L_NULL   DC    X'00'
*
L_SYSID  DC    C'SYSID='
SYSID_L  EQU   L'L_SYSID
L_CEMT   DC    C'CEMT '
CEMT_L   EQU   L'L_CEMT
L_CEDA   DC    C'CEDA '
CEDA_L   EQU   L'L_CEDA
L_PING   DC    C'PING '
PING_L   EQU   L'L_PING
*                0....5....1....5....2....5....3....5....4....5....5
BEGNMSG  DC    C'EXPLDYNA PROGM BEGIN AT'
NOPRMSG  DC    C'NO PARM PROVIDED OR ZERO LENGTH'
PRMSG    DC    C'PARM PROVIDED>'
ENDMSG   DC    C'PROCESSING FINISHED NORMALLY'
L_ENDMSG EQU   *-ENDMSG
ERRTRAN  DC    X'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
***
INV_ENDMSG DS  CL(L'ENDMSG)
***
L_EXPLPSPM DC A(*-EXPLPSPM)
MODSPRPEN OPEN (,OUTPUT),MF=L,MODE=31 MODEL OPEN PARAMETER LIST
LSPROPPL EQU   *-MODSPRPEN
*
MODSPRCLO CLOSE (),MF=L,MODE=31    MODEL OPEN PARAMETER LIST
LSPRCLPL EQU   *-MODSPRCLO
*
* THE FOLLOWING IS THE MODEL FOR THE DCB OPEN EXIT ROUTINE ENTRY POINT
* WE COPY THIS CODE TO THE WORK AREA, WHICH IS BELOW THE LINE.  THE
* BSM SETS THE CURRENT ADDRESSING MODE (24) IN BIT 0 OF R14 WITHOUT
* CHANGING ANYTHING ELSE IN R14.  IT ALSO SWITCHES TO 31-BIT DUE TO
* BIT 0 IN R15 AND BRANCHES TO THE ADDRESS IN R15.
MODOPEN24 L    R15,ADOPEN31-OPEN24(,R15) ENTRY PT TO DCB OPEN EXIT RTN
         BSM   R14,R15        SAVE AMODE, SWITCH TO 31-BIT AND BRANCH
LENOPEN24 EQU  *-MODOPEN24
*
SYSPR_BEGINMSG DC   C'THIS IS A TEST FOR QSAM ABOVE TO SYSPRINT'
*
* DCB MODEL FOR SYSPRINT, WHICH IS ABOVE THE LINE.
MODSPRDCB DCB  DSORG=PS,DDNAME=SYSPRINT,MACRF=(PM)
SYSPREND EQU   *-MODSPRDCB
*
*SYSUT1   DCB   MACRF=R,BLKSIZE=96,LRECL=96,KEYLEN=44,RECFM=F,
*              DSORG=PS,EXLST=JFCBPTR,DDNAME=SYSUT1,EODAD=DONERD
*YSUT1   DCB   MACRF=PM,LRECL=80,RECFM=FB,                            X
*              DSORG=PS,EXLST=JFCBPTR,DDNAME=SYSUT1
***
         LTORG
         END
###END EXPLPSPM
$$$BEG EXRELMAC
WHAT ABOUT MACROS THAT GENERATE BASE-DISPLACEMENT INSTRUCTIONS?
  RELATIVE BRANCHES MAY HAVE ELIMINATED THE NEED FOR BASE REGISTERS FOR
YOUR CODE, BUT...
  MANY IBM MACROS GENERATE BASED INSTRUCTIONS LIKE BC, LA, ST
  SOLUTION 1: ISSUE THE SYSSTATE MACRO
SYSSTATE ARCHLVL=1 ENABLES IMMEDIATE AND RELATIVE OPS
SYSSTATE ARCHLVL=2 ENABLES Z/ARCHITECTURE OPS
  SOLUTION 2: CREATE A TEMPORARY LOCAL BASE REGISTER:
         PUSH USING SAVE CURRENT USING STATUS
         BASR TEMPREG,0 ANY UNUSED REGISTER IN (2,12)
         USING *,TEMPREG TEMPORARY LOCAL ADDRESSABILITY
<MACRO INVOCATION> EXPAND THE MACRO
         POP USING RESTORES PREVIOUS USING STATUS,
* DROPS 'TEMPREG' AUTOMATICALLY
  SOME SELF-MODIFYING MACRO EXPANSIONS CAN BE PLACED IN THE SAME AREA
AS CONSTANTS AND WORK AREAS
  OR, USE MF=L FORM FOR SKELETONS, AND INLINE MF=E FORMS FOR EXECUTION
###END EXRELMAC
$$$BEG EXPLWTOA
*%INCLUDE SYSLIB(EXPLPARS)
**
* WTO TEST PROGRAMS SHOW SOME OF THE FORMAT
* PROGRAM EXPECTS A PARM.  IF PARM IS NOT EQUAL TO LENGTH OF 4
*  THEN PROGRAM ASSUMES THAT THE PARM IS A SINGLE LINE ENTRY.
* IF THE PARM LENGTH IS 4 THEN THE PROGRAM ASSUMES THAT THE PARM IS
*  A POINTER TO A STORAGE AREA.  WITHIN THAT STORAGE AREA, YOU CAN HAVE
*  A SINGLE LINE OF TEXT, OR 1 TO 10 MULTIPLE LINES OF TEXT.
* NOTE THAT SINGLE LINE MSGS ARE LIMITED TO 126 CHAR LENGTH
*      THAT MULTIPLE LINE MSGS ARE LIMITED TO 72 CHARACETERS
* MULTIPLE LINES ARE DESIGNATED BY PASSING A STORAGE AREA ADDRESS
*      WHERE EACH LINE (1 - 10) IS DESIGNATED BY <..> BRACKETS.
* LINE OVERLENGTHS ARE TRUNCATED.
*
* E.G.   MVS -R1 HAS PTR TO FW PTR
*            +FW PTR TO
*                   +-HWL,PARMSTR     (PASSES ACTUAL STRING)
*      OR
*        MVS -R1 HAS PTR TO FW PTR
*            + FW PTR TO
*               +-HWL,FW1,FW2
*                      |   +-- FW2 IS ADDR OF LNG OF STG AREA
*                      +-- FW1 IS ADDR OF STG AREA, HOLDING THE STG
*
* SUPPORTED SYMBOLICS ARE
*      $JOBNAME - CURRENT JOBNAME
*      $JOBDATE - CURRENT SYSTEM DATE
*      $JOBTIME - CURRENT SYSTEM TIME
*
EXPLWTOA CSECT
EXPLWTOA RMODE ANY
EXPLWTOA AMODE 31
         INITMAC 3,EQU=R,ID=EXPLWTOA
         LTR   R9,R1
         BZ    NOPARM
*
         XR    R1,R1
* GET DYNAMIC STORAGE
         GETMAIN R,LV=4096,SP=1,LOC=ANY
         LTR   R15,R15
         BNZ   NOSTG
         LR    R2,R1
         XC    0(8,R2),0(R2)
         USING MYAREA,R2
*
         BAL   R6,INITRTN
*
         BAL   R6,GETJOBN
         MVC   MSGAREA(8),JOBNAME
         BAL   R6,GETTIME
         MVC   MSGAREA+9(5),$DATE+3
         MVC   MSGAREA+15(6),$TIME+1
***
         BAL   R6,GETPARM
*
         TM    WTOLNCT,X'80'
         BZ    ONLY1
*
         XR    R15,R15
         IC    R15,WTOLNCT
         BZ    NOPARM
*
         BAL   R6,WTOMULT
         B     DOCLOSE
***
ONLY1    EQU   *
         BAL   R6,WTO1
         B     DOCLOSE
*
NOPARM   EQU   *
NOSTG    EQU   *
         MVI   XC,X'08'
         B     DOCLOSE
*
EXITRC8  EQU   *
         XR    R15,R15
         LA    R15,8
         B     BYL15
*
DOCLOSE  EQU   *
         XR    R15,R15
         IC    R15,XC
         LA    R1,MYAREA    TOP OF STG CHAIN
FMLOOP   L     R9,4(R1)     FW PTR
         FREEMAIN R,LV=4096,A=(R1),SP=1
         LTR   R1,R9
         BNZ   FMLOOP
BYL15    EQU   *
         RTNMAC  RC=(15)
NORTNCD  EQU   *
         RTNMAC
*
INITRTN  EQU   *
* PLACE ANY INITIALIZATION PROCESSING HERE
         MVI   XC,X'00'
         XC    WTOLNCT,WTOLNCT
         XC    WTOLNF,WTOLNF
         MVI   MSGAREA,C' '
         MVC   MSGAREA+1(MSGAREAX-1),MSGAREA
         LA    R15,WTOLNL         GET THE ADDR OF THE WTO OP AREA
         ST    R15,WTOLCUR        SAVE CURRENT PTR
*
         LA    R15,MSGAREAX
         STH   R15,MSGALNG
         BR    R6
*
GETPARM  EQU   *
         STM   R4,R9,GETPSV49  SAVE R6 - R9
         ST    R9,PARMIN      SAVE R1=R9=PTR TO PARM PTR
         L     R9,0(R9)       GET ADDR IN PARM PTR
         ST    R9,PARMA
         XR    R5,R5
         ICM   R5,B'0011',0(R9)    GET HW LENGTH OF PARM
         STH   R5,PARMAL      SAVE R1=R9=PTR TO PARM
         BZ    XNOPARM
         LA    R4,2(R9)     BUMP PTR TO ACTUAL PARM AREA
*
         CH    R5,H8       SEE IF PARM IS EQUAL TO 8 (ONLY RESTRICTION
         BE    DATAINST     TO INDICATE THAT AREA IS A STORAGE AREA
*                           B TO PROCESS STG AREA IF EQ 8
         CH    R5,H125     ELSE PARM IS SINGLE LINE OF PARM AREA
         BNH   USEPLNG      CAN NOT BE GT (EX LENGTH) 124
         LH    R5,H125
USEPLNG  EQU   *
         STH   R5,SPARML   SAVE PARMLNG
         ST    R4,SPARMA
         B     DOMVCL
*
DATAINST EQU   *
         L     R15,4(R4)   R4 WAS POINTING TO TWO FW PARMS
*                          FW1 IS PTR TO ACTUAL DATA IN STG
*                          FW2 IS PTR TO HW TOTAL LENGTH
*                          ASSUME THAT EACH LINE IS DENOTED BY <..><..>
         L     R4,0(R4)    PTR TO STG CONTAINING PARM
         ST    R4,SPARMA   SAVIT
         XR    R5,R5
         ICM   R5,B'0011',0(R15) NOW LOAD HW LNG
         BZ    XNOPARM
         CH    R5,H740
         BH    XBADPARM    PARM MUST BE IN BOUNDS OR ABORT AS BAD
         STH   R5,SPARML   SAVE PARMLNG
DOMVCL   EQU   *
         LA    R6,STOPARM  MOVE PARM TO A REENTRANT STORAGE
         LR    R7,R5
         MVCL  R6,R4
*
CHKPARM EQU   *
*                          NOW BEGION LOOKING TO FORMAT MSGS
*                          START BY REP ANY SYMBOLICS WITH ACTUAL DATA
         LA    R15,$JOBNAME
         ST    R15,NEEDLEA    4 FW REQUIRED FOR PARSE
         LA    R15,H8              NEEDLEA
         ST    R15,NEEDLEL         NEEDLEL
         LA    R15,STOPARM         HAYSTAKA
         ST    R15,HAYSTAKA        HAYSTAKL
         LA    R15,SPARML       CONTINIOUS IS REQUIRED
         ST    R15,HAYSTAKL
         MVC   PASSPL,H16     PARSE ROUTINE EXPECTS 16 BYTES FOR PARMS
         LA    R1,PASSPL
         ST    R1,PASSPLA
         LA    R1,PASSPLA
LOPJNM   EQU   *
         CALL  EXPLPARS
         LTR   R15,R15
         BZ    NOJNM
         MVC   0(8,R15),#JOBNAME
         B     LOPJNM
NOJNM    EQU   *
         LA    R15,$JOBDATE
         ST    R15,NEEDLEA
LOPJDT   EQU   *
         CALL  EXPLPARS
         LTR   R15,R15
         BZ    NOJDT
         MVC   0(8,R15),#JOBDATE
         B     LOPJDT
NOJDT    EQU   *
         LA    R15,$JOBTIME
         ST    R15,NEEDLEA
LOPJTM   EQU   *
         CALL  EXPLPARS
         LTR   R15,R15
         BZ    NOJTM
         MVC   0(8,R15),#JOBTIME
         B     LOPJTM
NOJTM    EQU   *
         CLI   SPARMA,C'<'     CHECK FOR BEGIN BRACKET
         BE    OKMULT          IF YES, PROCESS MULT LINES
*
         MVI   WTOLNCT,X'81'   INDICATE 1 LINE
         LH    R15,SPARML
         CH    R15,H125
         BNH   MV125
         LH    R15,H125
         STH   R15,SPARML
MV125    EQU   *
         BCTR  R15,0
         EX    R15,MVCWTO
         LA    R15,5(R15)        ADD 1 FOR EX, 2 MSGLNG,2 MCSFLGS
         STH   R15,WTOLNL
         MVC   WTOLNF,X'0000'
         MVI   WTOLNCT,X'81'     INDICATE 1 LINE
         B     DONEPARM
*
MVCWTO   MVC   WTOLNA(0),STOPARM
MVCWTO#  MVC   4(0,R4),0(R6)
*
OKMULT   EQU   *
         LA    R7,STOPARM
         ST    R7,HSPARMA
         LH    R15,SPARML         DETERMINE LAST POSN IN PARM
         AR    R7,R15             BY ADDING LENGTH TO ST ADDR
         ST    R7,STOPARMX        SAVE IT FOR COMPARISON
         MVC   HSPARML,SPARML     MOVE PARM LNG FOR PARSE RTN
         LA    R15,HSPARMA        GET ADDR OF FW WHICH HOLDS PARM
         ST    R15,HAYSTAKA       SAVE IT FOR PARSE
         LA    R15,HSPARML        GET ADDR OF LENGTH OF PARM
         ST    R15,HAYSTAKL       ALWAYS USE THIS AREA
*
         LA    R7,SLITX           GET ADDR OF '>'
         ST    R7,NEEDLEA         SAVE IT FOR PARSE
         LA    R7,H1              GET ADDR OF LNG
         ST    R7,NEEDLEL         SAVE IT FOR PARSE
         LA    R1,PASSPLA
PARMSRCH EQU   *
         L     R6,HSPARMA         GET POINTER TO < BEGIN
         LA    R6,1(R6)           ADD 1 PAST
         C     R6,STOPARMX        MAKE SURE IT IS IN BOUND
         BNL   XBADPARM            DANGLING <...
*
         ST    R6,HSPARMA
         L     R15,STOPARMX
         SR    R15,R6
         BNP   XBADPARM
         STH   R15,HSPARML
*
         LA    R1,PASSPLA
         CALL  EXPLPARS
         LTR   R15,R15
         BZ    XBADPARM           DANGLING <...
*
         ST    R15,HSPARMA        SAVE ENDING > ADDR
         SR    R15,R6             SUB 1ST FROM LAST  FOR LNG
         BNP   XBADPARM           IF 0 THEN BAD
         CH    R15,H72
         BNH   PARM72
         LH    R15,H72
PARM72   EQU   *
         L     R4,WTOLCUR         GET CUR WTO LINE LNG ADDR FROM SAVA
         BCTR  R15,0              SUB 1 FOR EX
         EX    R15,MVCWTO#        ST WTO LINE DATA
         LA    R15,5(R15)         ADD 1 BACK FOR EX, PLUS 4 FOR LL+FLGS
         STH   R15,0(R4)          ST LNG
         MVC   2(2,R4),WTOLNTD    MOV THE 'D' LINE INDICATOR BY DEFAULT
*
         XR    R5,R5
         IC    R5,WTOLNCT
         LA    R5,1(R5)
         STC   R5,WTOLNCT
         AR    R15,R4
         ST    R15,WTOLCUR
*
         CLI   WTOLNCT,X'0A'
         BE    X10PARM
         CLI   WTOLNCT,X'01'
         BNE   ARNDFRST
*
         MVC   2(2,R4),WTOMCSML   MOVIN MULT LINE MCS FLAG IND
*
         MVC   0(2,R15),WTODES6
         MVC   2(2,R15),WTORTE11
         MVC   4(2,R15),WTOLNTD        'D' OR X2000
         MVC   6(2,R15),X0000
         L     R15,7(R15)
         ST    R15,WTOLNCA
         LA    R15,1(R15)
*
ARNDFRST EQU   *
         LR    R4,R15
         L     R15,HSPARMA
         LA    R15,1(R15)
         C     R15,STOPARMX
         BNL   XMLTPARM
         CLI   0(R15),C'<'     MAKE SURE THAT FIRST CHAR IS '<'
         BNE   XBADPARM
         ST    R15,HSPARMA
         B     PARMSRCH
XBADPARM EQU   *
         OI    XC,X'08'
         B     DONEPARM
XNOPARM  EQU   *
         OI    XC,X'04'
         B     DONEPARM
X10PARM  EQU   *
         OI    XC,X'02'
XMLTPARM EQU   *
         MVC   2(2,R4),WTOLNTD    MOV THE 'D' LINE INDICATOR BY DEFAULT
         L     R4,WTOLNCA
         MVC   0(1,R4),WTOLNCT
         B     DONEPARM
DONEPARM EQU   *
         LM    R4,R8,GETPSV49
         BR    R6
*
***
WTO1     EQU   *
         ST    R9,WTO1RSA
         ST    R4,WTO1RSA+4
         MVI   XC,X'08'
         LA    R4,WTOLNL
         XR    R0,R0
         LA    R1,WTOLA
         WTO   MF=(E,(R1)),TEXT=(R4)
         LTR   R15,R15
         BNZ   WTO1RC8
         MVI   XC,X'00'
WTO1RC8  EQU   *
         L     R1,WTO1RSA
         L     R4,WTO1RSA+4
         BR    R6
***
WTOMULT  EQU   *
         ST    R9,WTO1RSA
         ST    R4,WTO1RSA+4
         MVI   XC,X'08'
         LA    R4,WTOLNL
         XR    R0,R0
         LA    R1,WTOLA
         WTO   MF=(E,(R1)),TEXT=(R4)
         LTR   R15,R15
         BNZ   WTOMRC8
         MVI   XC,X'00'
WTOMRC8  EQU   *
         L     R1,WTO1RSA
         L     R4,WTO1RSA+4
         BR    R6
***
GETJOBN  EQU   *
         STM   R4,R9,SAVR49
         LA    R9,TIOTADR
         EXTRACT (R9),'S',FIELDS=TIOT
         L     R1,TIOTADR
         MVC   JOBNAME,0(R1)
         LM    R4,R9,SAVR49
         BR    R6
*** GET THE SYSDATE SYSTIME IN ORDER TO CREATE A UNIQUE QUALIFIER
GETTIME  EQU   *
         XR    R0,R0
         XR    R1,R1
         TIME
         ST    R0,$TIMEB
         ST    R0,$DBLWD+4
         OI    $DBLWD+7,X'0F'
         UNPK  $TIME,$DBLWD
         XC    $DBLWD,$DBLWD
         ST    R1,$DATEB
         ST    R1,$DBLWD+4
         OI    $DBLWD+7,X'0F'
         UNPK  $DATE,$DBLWD
         XC    MYDEBUG,MYDEBUG
         BR    R6
***
B2C      EQU   *
         CVD   R15,DWORD
         UNPK  HLDSTR,DWORD+4(4)
         OI    HLDSTR+6,X'F0'
         XR    R15,R15
         BR    R6
***
* THIS IS THE ERROR ROUTINE TO FORMAT THE ERROR CODE RETURNED FROM THE
* SVC IF THERE IS AN ERROR ON ALLOCATION.
*
X2CX     EQU   *
FORMERR  EQU   *
         STM   R4,R9,X2CX49
         XR    R6,R6
         LA    R6,8
         ST    R15,HEXFIELD
         LA    R4,HEXFIELD
         LA    R5,EBCDCFLD
*
CONVERT  EQU   *
         SLR   R8,R8
         IC    R8,0(R4)
         SRDL  R8,4
         STC   R8,0(R5)
         LA    R5,1(R5)
         SLR   R8,R8
         SLDL  R8,4
         STC   R8,0(R5)
         LA    R5,1(R5)
         LA    R4,1(R4)
         BCT   R6,CONVERT
*
         TR    EBCDCFLD(8),ERRTRAN
         LM    R4,R9,X2CX49
         BR    R6
DONEEXT  EQU   *
NOEXT    EQU   *
*
         RTNMAC
*
*        PROGRAM CONSTANTS
*
*
*
*
WTOLLBL  WTO   TEXT=(WTOLNL),                                          X
               ROUTCDE=(11),                                           X
               DESC=(6),                                               X
               MF=L
WTOLA    WTO   TEXT=(R4),                                              X
               ROUTCDE=(11),                                           X
               DESC=(6),                                               X
               MF=L
WTOLM    WTO   'THIS IS A TEST OF WTOLM',                              X
               ROUTCDE=(11),                                           X
               DESC=(6),                                               X
               MF=L
WTOAL    WTO   MF=L,TEXT='THIS IS A TEST'
WTOAREA  DC    AL2(WTOAREAX-WTOAREA)
WTOLML   WTO   ('THIS IS A TESTL1 OF WTOLML',D),                       X
               ('THIS IS A TESTL2L19',D),                              X
               ('THIS IS A TESTL3  L21',DE),                           X
               ('THIS IS A TESTL3  L21',E),                            X
               ROUTCDE=(11),                                           X
               DESC=(6),                                               X
               MF=L
         EJECT
WTOML    WTO   ('THIS IS A TESTL1 OF WTOML ',D),                       X
               ('THIS IS A TESTL2L19',D),                              X
               ('THIS IS A TESTL3L19',D),                              X
               ('THIS IS A TESTL4L19',D),                              X
               ('THIS IS A TESTL5L19',D),                              X
               ('THIS IS A TESTL6L19',D),                              X
               ('THIS IS A TESTL7L19',D),                              X
               ('THIS IS A TESTL8L19',D),                              X
               ('THIS IS A TESTL9  L21',DE),                           X
               ('THIS IS A TESTL10-END',E),                            X
               ROUTCDE=(11),                                           X
               DESC=(6)
         EJECT
***
         LTORG
H72      DC    H'72'
F2       DC    F'2'
SLIT     DC    CL1'<'
SLITX    DC    CL1'>'
X2000    DS    0XL2
WTOLNTD  DC    XL2'2000'
X3000    DS    0XL2
X0000    DC    XL2'0000'
WTOLNTDE DC    XL2'3000'
$JOBNAME DC    CL8'$JOBNAME'
$JOBTIME DC    CL8'$JOBTIME'
$JOBDATE DC    CL8'$JOBDATE'
$MODID   DC    CL16'&SYSDATE.-&SYSTIME'
BLANKS   DC    CL8'                '
H1       DC    H'1'
H8       DC    H'8'
H16      DC    H'16'
H124     DC    H'124'
H125     DC    H'125'
H740     DC    H'740'
ZEROES   DC    2F'0'
FMIN1    DC    F'-1'
WTOMCSML DC    XL2'0040'       MCS FLAG MULT LINE IND
WTOMCSR  DC    XL2'8000'       MCS FLAG RTE/DESC CODE IND
WTODES6  DC    B'0000010000000000' DESC 6 FLAG ON
WTORTE11 DC    B'0000000000100000' RTE 11 FLAG ON
WTOMSG   DC    C'THIS IS A TEST OF WTOAREA. IGNORE. THANKS, TCEM'
WTOAREAX EQU   *
         DC    XL2'4000'
         DC    XL2'4020'
*                0....5....1....5....2....5....3....5....4....5....5
BEGNMSG  DC    C'EXPLDYNA PROGM BEGIN AT'
NOPRMSG  DC    C'NO PARM PROVIDED OR ZERO LENGTH'
ENDMSG   DC    C'PROCESSING FINISHED NORMALLY'
***
ERRTRAN  DC    X'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
*
EXPLPARS DC    V(EXPLPARS)
*
MYAREA   DSECT
         DS    F            BWCHAIN
         DS    F            FWCHAIN
SAVR19   DS    10F
WTO1RSA  DS    2F
GETPSV49 DS    6F
X2CX49   DS    6F
SAVR49   DS    6F
SAVR9    DS    F
SAVR6    DS    F
DWORD    DS    D
$DBLWD   DS    D
EBCDCFLD DS    D
HEXFIELD DS    F
TIOTADR  DS    F
PARMIN   DS    F    ADDR OF PARM PASSED BY OS
PARMA    DS    F    ADDR OF OFFSET 2 POINTED BY PARMIN
PARMAL   DS    H    HWL OF PTR POINTED BY PARNIN
$TIMEB   DS    F
$DATEB   DS    F
#JOBNAME DS    0CL8
JOBNAME  DS    CL8
#JOBDATE DS    0CL8
$DATE    DS    CL8
#JOBTIME DS    0CL8
$TIME    DS    CL8
MSGALNG  DS    H
MSGAREA  DS    CL125
MSGAREAX EQU   *-MSGAREA
HLDSTR   DS    CL7
MYDEBUG  DS    CL1
XC       DS    XL1
WTOLNCT  DS    XL1
         DS    0D
WTOLNCA  DS    F
WTOLCUR  DS    F
HSPARMA  DS    F
HSPARML  DS    H
*
*  EXPLPARS REQUIRES R1 POINTING AT THE PASSPLA
*     PASSPLA POINTS TO PASSPL
*       PASSPL HOLDS HW LNG OF X'10'
*       ADDR OF PASSPL+2 (ADDR IN PASSPLA+2)  POINTS TO 4 FW
*         FW1 POINTS TO NEEDLE ARG
*         FW2 POINTS TO HW LNG OF NEEDLE
*         FW3 POINTS TO HAYSTACK ARG
*         FW4 POINTS TO HW LNG OF HAYSTACK
PASSPLA  DS    F
         DS    H
PASSPL   DS    H
NEEDLEA  DS    F
NEEDLEL  DS    F
HAYSTAKA DS    F
HAYSTAKL DS    F
* %%%
         ORG   MYAREA+2048
WTOLNL   DS    H
WTOLNF   DS    XL2
WTOLNA   DS    0CL1
* %%%
         ORG   MYAREA+4096-1024
WTOMAX   EQU   *
STOPARM  DS    1012XL1
STOPARMX DS    F
SPARMA   DS    F
SPARML   DS    H
*
         END
###END EXPLWTOA
$$$BEG ASMTEST7
*ASM     XOPTS(NOPROLOG NOEPILOG)
*        SYSSTATE AMODE31=YES,ARCHLVL=2
       DFHEISTG DSECT
WDATA1 DS CL21
WDATA2 DS PL8
         DFHEIEND
*SMTEST7 DFHEIENT CODEREG=0,STATREG=(11,12),STATIC=START_OF_PROGRAMS_D
ASMTEST7 CSECT
ASMTEST7 AMODE 31
ASMTEST7 RMODE ANY
  DFHEIENT DATAREG=13,EIBREG=10,STATREG=(11,12),CODEREG=0,             *
               STATIC=START_OF_PROGRAMS_DATA
*
         MVC WDATA1,SDATA1
         ZAP WDATA2,PZERO
         EXEC CICS RETURN
IFINCLR  DC X'13'
IFINCLRL EQU *-IFINCLR
*
STATSTG  LOCTR ,
START_OF_PROGRAMS_DATA DS 0H
SDATA1   DC C'IIIIIIIIIIIEEEEEEEEEE'
PZERO    DC PL1'0'
         LTORG
         END
###END ASMTEST7
$$$BEG EXPLTIME
*PROCESS COMPAT(NOCASE,MACROCASE)                          Ver1
         sysstate archlvl=2
EXPLTIME csect
EXPLTIME amode 31
EXPLTIME rmode 31
*
         yregs
         J     BEGIN
PROLOG   LOCTR
         DC    C'EXPLTIME'
         DC    C'AsmDate && Time: &SYSDATE &SYSTIME'
         DC    C'Ver 0.0.1'
CODEBG1  LOCTR
BEGIN    DS    0H
         using data,12
         save  (14,12)       save z/os's regs
         larl  12,data       use this instead of lr and ahi
*        LR    R12,R15
*        AHI   R12,data-BEGIN

         getmain r,lv=worksize
         st    13,4(1)
         lr    13,1
         using (wareas,wareasend),13
*  ...
*         CPUTIMER macro
*     THIS RETURNS NOTHING!!!!!!!!!!!!!!!!!!!
         XC MY_CPUTMIC,MY_CPUTMIC
         XC MY_CPUTTU,MY_CPUTTU
         XC MY_CPUTSV,MY_CPUTSV
         LA 13,SAVE
CPUMIC   CPUTIMER MIC,MY_CPUTMIC
         MVC    MY_CPUTSV,MY_CPUTMIC
         LA 13,SAVE
CPUTU    CPUTIMER MIC,MY_CPUTTU
         MVC    MY_CPUTSV,MY_CPUTTU
*  ...
*         TIME  DEC,TIMEDATE,ZONE=LT,LINKAGE=SYSTEM
         mvc    e_LIST1_stg,LIST1
         mvc    e_stmr1_stg,STIMERM1
         mvc    e_stmr2_stg,STIMERM2
         TIME  DEC,TIMEDATE,LINKAGE=SYSTEM,MF=(E,e_LIST1_stg),         x
               DATETYPE=YYYYMMDD
*        xc    e_stmr1_ID,e_stmr1_ID
         STIMERM SET,ID=e_stmr1_ID,DINTVL=l_DINTVL10,                  *
               WAIT=YES,MF=(E,e_stmr1_stg)
*
         TIME  DEC,TIMEDATE2,LINKAGE=SYSTEM,MF=(E,e_LIST1_stg),        x
               DATETYPE=YYYYMMDD
*        xc    e_stmr1_ID,e_stmr1_ID
*
* at termination:
*
         clrje 15,15,doterm
*        ltr   15,15
*        jz    doterm
err0     ds    0h
         la    15,8
*
doterm   ds    0h
         lr    1,13
         l     0,fsize
         l     13,4(13)
         freemain r,lv=(0),a=(1)
         return (14,12),,rc=0
*
data     ds    0f
fsize    dc    a(worksize)
*
LIST1     TIME  LINKAGE=SYSTEM,MF=L
time_end  equ   *-LIST1
*
STIMERM1 STIMERM SET,MF=L
stmr1_end equ   *-STIMERM1
*
STIMERM2 STIMERM SET,MF=L,RELATED=ABCDEFG
stmr2_end equ   *-STIMERM2
*
l_BINTVL  dc xl4'00000001' hex 0.01 sec
l_DINTVL  dc cl8'00000001' chars hh mm ss th (tenths hundredths)
l_DINTVL10 dc cl8'00001000' is 10 seconds
l_TOD     dc cl8'00000000' is LT TOD 24hr completion time
*l_LT                          same as TOD and preferred identifer
l_MICVL   dc xl8'0000 0000 0000 2000' 64 bits
*For MICVL, the address is an 8-byte storage area containing the time
*interval. The time interval is represented as an unsigned 64-bit
*binary number; bit 51 is the low-order bit of the interval value and
*equivalent to one microsecond.
*
         ltorg
wareas   dsect
save     ds    36f'0'
          ds    0d
MY_CPUTMIC ds    d
MY_CPUTTU ds     d
MY_CPUTSV ds     d
          ds    0d
e_LIST1_stg ds  xl(time_end)
          ds    0d
e_stmr1_stg ds  xl(stmr1_end)
e_stmr1_ID  ds  f
          ds    0d
e_stmr2_stg ds  xl(stmr2_end)
e_stmr2_ID  ds  f
          ds    0d
*07313264   51860000   20160204   00000000
TIMEDATE  DS    CL16         TIME AND DATE RETURNED
TIMEDATE2 DS    CL16         TIME AND DATE RETURNED
wareasend ds   0h
worksize equ   *-save
         end   EXPLTIME
###END EXPLTIME
$$$BEG UCEMTESB
*ASM     XOPTS(NOPROLOG NOEPILOG)
*        SYSSTATE AMODE31=YES,ARCHLVL=2
*
* ON ENTRY, PRM OBEYS SYSTEM LINKAGE STDS
*  R1 POINTS TO PARM LIST W/ TWO ADDR (EIB AND COMM (OR ZERO))
*  R13 POINTS TO ADDR OF SAVE AREA
*  R14 POINTS TO ADDR OF RETURN PT
*  R15 POINTS TO ADDR OF ENTRY  PT
* FOR EACH EXEC CICS CALL MACRO EXPANDS TO
*  DFHECALL MACRO WHICH IS STD SYSTEM CALL
*  R0  UNDEFINED
*  R1  POINTS TO ADDR OF PARM LIST
*  R14 POINTS TO RETURN POINT IN YOUR PGM
*  R15 POINTS TO ADDR OF ENTRY  PT IN EXEC INTF
* DFHEAI MUST BE LINK EDITED WITH YOUR PGM FOR EXEC INTF RESOLUTION
* EXEC CICS RETURN WILL EXIT UOUR PGM OR DFHEIRET IS INSERTED BY
*  THE TRANSLATOR IF NO EXEC RETURN FOUND
* DFHEIRET INSERTED BY TRANSLATOR AT END OF PGM
*  THIS MACRO: RESTORES REGS
*              RETURNS VIA R14
* DFHECALL BUILDS THE PARM LIST IN DYN STG FOR REENTRANCY
* DFHEIENT INSERTED BY TRANSLATOR AFTER FIRST CSECT
*  THIS MACRO: SAVES REGS
*              GETMAIN STG FOR DFHEISTG
*              SETS BASE REG (R3 DEFAULT)
*              SETS DYN STG REG (R13 DEFAULT)
*              SETS EIB REG (R11 DEFAULT)
* DFHEISTG INSERTED BY TRANSLATOR
*              DEFINES STG PARM LIST
*              DEFINES STG FOR REG SAVE AREA
*              INCLUDES YOUR VARS WHEN YOU CODE THE DFHEISTG MACRO
* DFHEIEND INSERTED BY TRANSLATOR TO ID END OF EIDSA
* DFHEIBLK INSERTED BY TRANSLATOR DEFINES EIB DSECT
* MULTIPLE BASE REGS DEFINED BY DFHEIENT (CODEREG DATAREG EIBREG)
* DFHEIPLR IS THE REG VAR ASSIGNED TO FIRST EIBREG OR DEFAULT
*REG 1                      PASSED ADDR OF PARMS
*REG 3                      BASE REGISTER (CMD LVL)
*REG 11                     PTR TO EIB (SET BY DFHEIENT)
*REG 13                     PTR TO DFHEISTG (SET BY DFHEIENT(
         REGSMAC
MYMAPS   DSECT
MYMAPF   DS    F
MYMAPB   DS    F
         DS    0D
MYDSPADR DS    0F
         DS    12C
MYFSTFLD DS    0X
*
MYAREA   DSECT
MYCCONN  DS    CL4      CONNECTION NAME
MYCNET   DS    CL8      CONN NET ID (RET)
MYCAM    DS    F        ACCESS MTHD (RET)
MYCPROT  DS    F        PROTOCOL    (RET)
MYCCS    DS    F        CONN STATUS (RET)
MYCLS    DS    F        LOG NAME ST (RET)
MYCSS    DS    F        SERV STATUS (RET)
MYCPS    DS    F        PEND STATUS (RET)
MYMNAME  DS    CL8      SEED CONN NAME FOR BROWSE
MYMCONN  DS    CL4      MODE CONN NAME
MYMMAX   DS    H        MODE MAX SESS (RET)
MYMAVL   DS    H        MODE AVAIL SESS (RET)
MYMACT   DS    H        MODE ACTIVE SESS (RET)
*
*
* COPYBOOK FOR COMMAREA PARS DSECT  USED IN THIS PGM
PARS     DSECT
         COPY PARSDSCT
*
*
*
SAVE     DFHEISTG DSECT
DWORD    DS    D
HW       DS    H
SAVETRAN DS    CL4
CVTH     DS    CL5
SPAC255  DS  CL255
OPLIT    DS  CL80
OPLIT_L_EQU EQU *-OPLIT
MYTIME   DS    CL8
MYABSTM  DS    PL8
MYFJDT   DS    CL6
MYFTIME  DS    PL4
*
*
* COPYBOOK FOR EIBSTG FOR UCEMPARS
       COPY PARSESCT
*
*
EXEC_CICS_FL DS F        USED TO HOLD FLENGTH VALUES
EXEC_CICS_HL DS H        USED TO HOLD LENGTH VALUES
FRESP    DS  F
FRESP2   DS  F
*
         DFHEIEND
*
********************************************************************
UCEMTESB CSECT
UCEMTESB AMODE 31
UCEMTESB RMODE ANY
   DFHEIENT DATAREG=13,EIBREG=10,STATREG=(11,12),STATIC=STATR,CODEREG=0
*     DFHEIENT DATAREG=13,EIBREG=11,STATREG=3,STATIC=STATR,CODEREG=0
*        EXTRN CEMVALUE
         SPACE 2
*****    GBLC  &SYSDATE
         J     MAIN000
         DC    C'UCEMTESB'
         DC    C'&SYSDATE'
         SPACE 1
MVC2NEEDLE MVC PARS_TST_NEEDLE,PARS_LIT_NEEDLE
MVC2HAYSTK MVC PARS_TST_HAYSTACK,PARS_LIT_HAYSTACK
MVC_NEEDL2OP MVC   PARS_TST_RSLT+50,0(R8)
*
MAIN000  DS    0H
         SPACE 1
         EXEC  CICS HANDLE CONDITION ERROR(ERROR01)
         EXEC  CICS GETMAIN FLENGTH(F4080)                             *
               SET(R10)                                                *
               NOSUSPEND
         MVC   SAVETRAN,EIBTRNID  SAVE THE INITIATING TXN
         ZAP   MYABSTM,PZERO
         EXEC CICS ASKTIME ABSTIME(MYABSTM)
         EXEC CICS FORMATTIME ABSTIME(MYABSTM)                         *
              YYDDD(MYFJDT) TIMESEP TIME(MYFTIME)
*          @@@
         MVC   OPLIT,BEGNLNE
         JAS   R9,WRTLINE
*
         MVC   OPLIT,TIMELNE
         MVC   OPLIT+4(6),MYFJDT
         MVC   OPLIT+13(8),MYFTIME
         JAS   R9,WRTLINE
*
         MVI  SPAC255,C' '
         MVC  SPAC255+1(L'SPAC255-1),SPAC255
         MVC  OPLIT,SPAC255
*
         IILF R15,L'PARS_LIT_NEEDLE
         STH R15,PARS_TST_NEEDLEL
         BCTR R15,0
         EXRL  R15,MVC2NEEDLE
         IILF R15,L'PARS_LIT_HAYSTACK
         STH  R15,PARS_TST_HAYSTACKL
         BCTR R15,0
         EXRL  R15,MVC2HAYSTK
         MVC   PARS_TST_DIRECTION,PARS_LIT_DIRECTION
         MVC   PARS_TST_EQ_NE,PARS_LIT_EQ_NE
         XC    PARS_TST_ADR_RETURN,PARS_TST_ADR_RETURN
         IILF  R0,CA_EQU_LENGTH
         ST    R0,EXEC_CICS_FL
*
         EXEC CICS GETMAIN FLENGTH(EXEC_CICS_FL)                       *
            SET(R4)                                                    *
            NOSUSPEND                                                  *
            RESP(FRESP)                                                *
            RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)
         JNE   PARS_GM_FAILED
*
         ST    R4,PARS_TST_GM_PRM_A
         USING MYCOM_A,R4
         LA    R15,PARS_TST_NEEDLE
         ST    R15,CA_ADR_NEEDLE
         LA    R15,PARS_TST_NEEDLEL
         ST    R15,CA_ADR_NEEDLEL
         LA    R15,PARS_TST_HAYSTACK
         ST    R15,CA_ADR_HAYSTACK
         LA    R15,PARS_TST_HAYSTACKL
         ST    R15,CA_ADR_HAYSTACKL
         LA    R15,PARS_TST_DIRECTION
         ST    R15,CA_ADR_DIRECTION
         LA    R15,PARS_TST_EQ_NE
         ST    R15,CA_ADR_EQ_NE
         LA    R15,PARS_TST_ADR_RETURN
         ST    R15,CA_ADR_RETURN
         MVC   PARS_PGM,PARS_LIT_PGM
         IILF  R0,CA_EQU_LENGTH
         STH   R0,EXEC_CICS_HL
*
         EXEC CICS LINK PROGRAM(PARS_PGM)                              *
             COMMAREA(MYCOM_A) LENGTH(EXEC_CICS_HL)                    *
             RESP(FRESP)                                               *
             RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)
         JNE   LNK_2_PARS_FAIL
         LT    R8,PARS_TST_ADR_RETURN
         JZ    PARS_NF
*
         MVC   PARS_TST_RSLT(L'PARS_LIT_FND),PARS_LIT_FND
         S     R8,CA_ADR_NEEDLE FND ADR IN NEEDLE MINUS START ADR=POS
         JAS   R9,CVTCNT
         MVC   PARS_TST_RSLT+33(5),CVTH
         LH    R6,PARS_TST_HAYSTACKL
         SR    R6,R8          LNG OF FND STR TO END OF HAYS
         IILF  R7,PARS_TST_RSLT_L_EQU-55    LNG OF RMNG OP
         CR    R7,R6   COMP:RMING OP LNG TO RMNG HAYS
         JNH   PARS_USE_RMDR   RMNG OP LIT LT OR EQ TO RMNG HAYS
         LR    R7,R6           RMNG HAYS < RMNG OP: USE RMNG HAYS
PARS_USE_RMDR DS 0H
         L     R8,PARS_TST_ADR_RETURN
         EXRL  R7,MVC_NEEDL2OP
         J     PARS_OP_MSG
*
PARS_NF  DS 0H
         MVC   PARS_TST_RSLT,PARS_LIT_NF_MSG
         J     PARS_OP_MSG
*
LNK_2_PARS_FAIL DS 0H
         MVC   PARS_TST_RSLT(L'PARS_LIT_LINK_ERR),PARS_LIT_LINK_ERR
         MVC   PARS_TST_RSLT(8),PARS_PGM
         J     PARS_OP_MSG
*
PARS_GM_FAILED DS 0H
         MVC   PARS_TST_RSLT,PARS_LIT_GM_FAIL
         J     PARS_OP_MSG
*
PARS_OP_MSG DS 0H
         MVC   PARS_TST_RSLT+4(8),THIS_PGM
         MVC   OPLIT,PARS_TST_RSLT
         JAS   R9,WRTLINE
*
DONEIN   DS    0H
         MVC   OPLIT,ENDMSG
         JAS   R9,WRTLINE
*
RETURN   DS    0H
         EXEC  CICS RETURN
         SPACE
CVTCNT   DS    0H
         CVD   R8,DWORD
         UNPK  CVTH,DWORD+3(5)
         OI    CVTH+4,X'F0'
         BR    R9
*        %%%%%
WRTLINE  DS    0H
DOTD     DS    0H
         EXEC  CICS WRITEQ TD QUEUE('CSSL') FROM(OPLIT) LENGTH(H80)
         BR    R9
ERROR01  DS    0H
         MVC   OPLIT,ERR1LNE
         JAS   R9,WRTLINE
         J     RETURN
ERROR02  DS    0H
         MVC   OPLIT,ERR2LNE
         JAS   R9,WRTLINE
         J     RETURN
         EJECT
*
STATSTG  LOCTR  ,
*   CICS STATIC STORAGE AREA NEEDS LABEL AS SPECIFIED ON DFHEIENT
STATR    DS    0D
F32400   DC    F'32400'
         ORG   *-2
H32400   DS    H
F4080    DC    F'4080'
         ORG   *-2
H4080    DS    H
F80      DC    F'80'
         ORG   *-2
H80      DS    H
*
MAX_CMD_LEN DC H'80'
*
F20      DC    F'20'
         ORG   *-2
H20      DS    H
F16      DC    F'16'
         ORG   *-2
H16      DS    H
F10      DC    F'10'
         ORG   *-2
H10      DS    H
F8       DC    F'8'
         ORG   *-2
H8       DS    H
F4       DC    F'4'
         ORG   *-2
H4       DS    H
F1       DC    F'1'
         ORG   *-2
H1       DS    H
F0       DC    F'0'
         ORG   *-2
H0       DS    H
FMINUS1  DC    F'-1'
         ORG   *-2
HMINUS1  DS    H
HNEG1    DC    H'-1'
*CEMTBLA  DC    A(CEMVALUE)
         SPACE
*
PARS_LIT_NEEDLE DC   CL4'THIS'
PARS_LIT_N_EQU_L  EQU  *-PARS_LIT_NEEDLE
PARS_LIT_NEEDLEL DC  A(PARS_LIT_N_EQU_L)
PARS_LIT_HAYSTACK DC C'THAT A PROGRAM COULD FIND A SINGLE STRING IN THI*
               S VARIABLE IS A MYSTERY TO ME THISA TIME.              '
PARS_LIT_H_EQU_L EQU *-PARS_LIT_HAYSTACK
PARS_LIT_HAYSTACKL DC A(PARS_LIT_H_EQU_L)
PARS_LIT_DIRECTION DC CL1'A'
PARS_LIT_EQ_NE   DC X'0'        EQ IS 0 NE IS 1
PARS_LIT_PGM DC CL8'UCEMPARS'
PARS_LIT_FND  DC C'$$$ 4_______ FOUND STRING AT POS:33___ THE STRING:'
PARS_LIT_NF_MSG DC C'$$$ 4_______ NO MATCH ON CRITERIA'
PARS_LIT_LINK_ERR DC C'!!! 4_______ LINK TO XX_____ FAILED'
PARS_LIT_GM_FAIL DC C'!!! 4_______ GETMAIN FAILURE FOR WORKAREA OF LENG*
               TH:52____'
*
UIS2     DC    CL4'UIS2'
UIS3     DC    CL4'UIS3'
SNASVCMG DC    CL8'SNASVCMG'
UISCM01  DC    CL8'UISCM01'
EISLIT   DC    CL8'ENDOFEIS'
MAPST1   DC    CL8'MAPST1'
MAPST2   DC    CL8'MAPST2'
MAPDY1   DC    CL8'MAPST2'
IM       DC    XL1'00'
PZERO    DC    PL1'0'
SP80     DC    CL80' '
BEGNLNE  DC    CL80'*** BEGIN UCEMTESB ***'
TIMELNE  DC    CL80'***          ++++        '
ENDMSG   DC    CL80'*** END   UCEMTESB ***'
STGMSG   DC    CL80'$$$ STORAGE FOR COND GETMAIN NOT AVAILABLE. BYE.'
ERR1LNE  DC    CL80'$$$ ERROR IN INITIALIZATION OF ROUTINE ERROR 1'
ERR2LNE  DC    CL80'$$$ ERROR IN PROCESSING ERROR 2'
EISSTG   DC    CL80'%%%%%EISSTGST%%%%%EISSTGST%%%%EISSTGST%%%%EISSTGST'
*                   0         0         0         0         0    5'
         SPACE 3
         DC    C'****'
THIS_PGM DC    CL8'UCEMTESB'
         DC    C' - CIGNA * CPCW * '
         DC    C'DATE='
         DC    C'&SYSDATE'
         DC    C' '
         DC    C'TIME='
         DC    C'&SYSTIME'
         DC    C' '
         DC    C'TCEM'
         DC    C'****'
         SPACE 3
         LTORG
         END
###END UCEMTESB
$$$BEG INITSTG
         MACRO
&LABEL   INITSTG &USEREG=,&COPYBK=
.* INITSTG IS MACRO TO GATHER DS STORAGE REQUIREMENTS FOR
.*  DYNAMIC (AUTO) STORAGE USAGE.
.*  SPECIFICALLY:
.*   ALL DS ENCOUNTERED BETWEEN MACRO AND THE INITMAC ARE
.*   INCLUDED IN AN INITIAL GETMAIN OF OS STORAGE
.*  &LABEL IS USED AS THE STORAGE DSECT NAME
.*   OR IF OMITTED, THEN DSECT LABEL IS SIMPLY INITDSCT
.*  BY SPECIFING USEREG=__ KW THEN A USING STATEMENT IS GENERATED
.*   BY THE INITMAC FOR THE &LABEL TO POINT AT THE FIRST FLDS THAT
.*   FOLLOW THE INITMAC 12 BYTE REG CHAIN AREA
.*  CHAIN STORAGE HW RESV, HW LNG, BW PTR, FW PTR
         GBLB  &SAIMAC
         AIF   (&SAIMAC EQ 0).IMAC0
         MNOTE 12,'MACRO INITSTG MUST PRECLUDE MACRO INITMAC.'
         MEXIT
.IMAC0   ANOP
         GBLC  &GUSEREG
         GBLC  &GLABEL
         GBLC  &GCOPY
         LCLC  &LBL
         LCLC  &CB1
         LCLA  &USETMP
&GCOPY   SETC  'NONE'
&GLABEL  SETC  'INITDSCT'
         AIF   (T'&LABEL NE 'O').B1
         MNOTE *,'NO DSECT LABEL SPECIFIED. USING &GLABEL'
&LBL     SETC  '&GLABEL'
         AGO   .CHKUSE
.B1      AIF   (K'&LABEL LE 8).LABOK
         MNOTE 'LABEL EXCEEDS 8 CHARACTERS-LEFT MOST 8 USED'
.LABOK   ANOP
&LBL     SETC  '&LABEL'(1,8)
&GLABEL  SETC  '&LBL'
.CHKUSE  ANOP
         AIF   (T'&USEREG EQ 'O').B8
         AIF   (T'&USEREG NE 'N').USEBAD
&USETMP  SETA  N'&USEREG
         AIF   (N'&USEREG NE 1).USEBAD
         MNOTE '*,USEREG NUMBER:&USETMP'
&USETMP  SETA  K'&USEREG
         MNOTE '*,USEREG KOUNT :&USETMP'
         AIF   (K'&USEREG LE 2).USETRY
.USEBAD  ANOP
         MNOTE 12,'0 OR 1 NUMERIC USE REG EXPECTED. INVALID VALUE WAS P*
               ROVIDED. USING NOT GENERATED.'
         AGO   .B8
.USETRY  ANOP
&USETMP  SETA  &USEREG
         MNOTE '*,USEREG VALUE :&USETMP'
         AIF   (&USETMP LE 1).USEINV
         AIF   (&USETMP LE 12).USEOK
.USEINV  ANOP
         MNOTE 12,'USE REG MUST BE A VALID NUMERIC.NO USING GENERATED'
         AGO   .B8
.USEOK   ANOP
&GUSEREG SETC  '&USEREG'
         MNOTE *,'WILL USE &GLABEL &GUSEREG'
.B8      ANOP
&GLABEL  DSECT
         DS    H            HW RESV
         DS    H            HW LNG
         DS    F            BW STG PTR
         DS    F            FW STG PTR
__PGM_NM DS    CL8
*
         AIF   (T'&COPYBK NE 'O').C1
&GCOPY   SETC  'INITINCL'
         MNOTE *,'USING DEFAULT COPYBOOK &GCOPY'
         AGO   .DOINCL
.C1      ANOP
         MNOTE *,'COPYBOOK PARAMETER NOT OMMITTED: CHECKING VALIDITY'
         AIF   ('&COPYBK' NE '').C2
         MNOTE *,'COPYBOOK SPECIFIED AS NULL, BYPASS COPY'
         AGO   .DONOTINC
.C2      ANOP
         MNOTE *,'COPYBOOK PARAMETER: CHECKING LENGTH 1 TO 8'
         AIF   (K'&COPYBK LT 1).BADCB
         AIF   (K'&COPYBK GT 8).BADCB
         AGO   .OKCBK
.BADCB   ANOP
         MNOTE 12,'INVALID COPYBK VARIABLE. NONE CAN BE COPIED.'
         AGO   .DONOTINC
.OKCBK   ANOP
         MNOTE *,'SETTING COPYBOOK GCOPY VARIABLE'
&GCOPY   SETC  '&COPYBK'
         MNOTE *,'USING COPYBOOK &GCOPY'
.DOINCL  ANOP
         MNOTE *,'IN DOINCL CPYBK &GCOPY'
         AGO   .FINIT
.DONOTINC ANOP
         MNOTE *,'IN DONOTINC:USING MEMBER INITCOPY FOR GCOPY GBLC.'
         MNOTE *,'IN DONOTINC: THIS MEMBER DEFINES NOTHING.'
&GCOPY   SETC  'INITCOPY'
.FINIT   ANOP
         MNOTE *,'*** INITSTG MACRO END.'
         MEND
###END INITSTG
$$$BEG INITCOPY
* BEG INITCOPY
* INITCOPY MEMBER IS A PLACE HOLDER COPYBOOK
* ALLOWING INITSTG MACRO TO PASS GBLC VARIABLE
* TO OPEN CODE, WITH ITS VALUE SET TO
* THIS MEMBER.
* IN THIS PDS, IT IS A EMPTY MEMBER
* END INITCOPY MEMBER
###END INITCOPY
$$$BEG EXPMX2CX
*PROCESS COMPAT(NOCASE,MACROCASE)                          VER1
**
* DEMONSTRATE ROUTINE TO CONVERT HEX DATA TO THE DISPLAYABLE
* EQUIVELENT OF THE HEX VALUE: 1  X'F1' IS SHOW AS X'CFF1' OR F1
**
         YREGS
         SYSSTATE ARCHLVL=2
EXPLM2CX CSECT
EXPLM2CX RMODE 31
EXPLM2CX AMODE 31
*
         J     BEGIN
PROLOG   LOCTR
         DC    C'B2CX SAMPLE CODE'
         DC    C'ASMDATE && TIME: &SYSDATE &SYSTIME'
         DC    C'VER 0.1.0'
CODEBG1  LOCTR
BEGIN    DS    0H
         SAVE  (14,12)       SAVE Z/OS'S REGS
*        R1
         USING DATA,12
         LARL  12,DATA
*
         LARL  R15,HEXTRAN
         LA    R15,HEXTRAN
         LR    R9,R1         SAVE PTR TO PARM
         GETMAIN R,LV=WORKSIZE,LOC=31
         CIJNE R15,0,NOSTG
*
         ST    13,4(1)
         LR    13,1           USE THE GM STG RETURNED IN R1
         USING (WAREAS,WAREASEND),13
         ST    R9,SAVE_PRM_ADR
*   TEST NEW VERSION OF B2CX
         MVI   MYXSTR1,X'00'
*
         MVC   MYXSTR,MYHEX+7
         JAS   R9,B2CX
         JAS   R9,C2BX
*
*  WE WOULD PROCESS A PARM ABOVE
* NOW TO TEST, MANUALLY LOAD A HEX STR
* MANUALLY LOAD THE STRING LENGTHS
         IILF  R15,L'MYHEX
         STH   R15,FROM_HEX_STR_L
         AR    R15,R15
         STH   R15,TO_CHAR_STR_L
*
         LA    R15,FROM_HEX_STR_L
         ST    R15,X_FROM_L_A
         LA    R15,MYHEX
         ST    R15,X_FROM_A
         LA    R15,TO_CHAR_STR_L
         ST    R15,X_TO_L_A
         LA    R15,TO_CHAR_STR
         ST    R15,X_TO_A
         LA    R15,X2CX_PRM_ADR
         JAS   R9,X2CX
         J     DONE_X2CX
*
* THIS IS NEW B2CX CODE
B2CX     DS    0H
* CONVERT BIN TO HEX CHAR
         STM   R4,R9,X2CX49
         UNPK  MYCHAR,MYXSTR(5) UNPACK HEX STREAM
         LA    R9,TABLE     TRANSLATE TO CHAR FORM
         AHI   R9,-240
         TR    MYCHAR,0(R9)     TRANSLATE TO CHAR FORM
         J     B2CX_XIT         MYCHAR HAS 8 CHARS
*
* CONVERT HEX CHAR BACK TO BIN
C2BX     DS    0H
* CONVERT BIN TO HEX CHAR
         STM   R4,R9,X2CX49
         MVC   WORK,MYCHAR SAVE FOR RECONVERT
         LA    R9,TRANHXCH           TRANSLATE TO CHAR FORM
         AHI   R9,-X'C1'
         TR    WORK(8),0(R9)         TRANSLATE TO UNPACKED HEX
         PACK  MYHEX2,WORK PACK BACK TO HEX IN NTHWX2
         J     B2CX_XIT
*
B2CX_XIT  DS  0H
         LM   R4,R9,X2CX49
         BR   R9
*
* THIS IS THE ERROR ROUTINE TO FORMAT THE ERROR CODE RETURNED FROM THE
* SVC IF THERE IS AN ERROR ON ALLOCATION.
*
X2CX     EQU   *
         STM   R4,R9,X2CX49
         LTR   R4,R15
         JNP   NO_X2CX
*
         L     R5,4(R4)          GET PTR TO HW X SRC LNG
         XR    R6,R6
         ICM   R6,B'0011',0(R5)  GET THE LNG
         JNP   NO_X2CX
*
         L     R5,12(R4)          GET PTR TO HW X SRC LNG
         XR    R7,R7
         ICM   R7,B'0011',0(R5)  GET THE LNG
         JNP   NO_X2CX
*
         SLL   R6,1              MULTIPLY BY 2
         CRJNE R6,R7,BAD_X2CX
*
         SRL   R6,1              GET ORIGINAL VALUE BACK
*
         L     R5,8(R4)       GET ADR OF THE TGT CHAR FLD
         L     R4,0(R4)          GET ADR OF SRC HEX FLD
         LA    R9,TABLE     TRANSLATE TO CHAR FORM
         AHI   R9,-240
*
CONVERT  EQU   *
         CIJL  R6,4,CONVERT1
         MVC   MYXSTR(4),0(R4)
         UNPK  MYCHAR,MYXSTR(5) UNPACK HEX STREAM
         TR    MYCHAR,0(R9)     TRANSLATE TO CHAR FORM
         MVC   0(8,R5),MYCHAR
         AHI   R5,8
         AHI   R4,4
         AHI   R6,-3
         J     CONVERT2
CONVERT1 DS    0H
         XR    R8,R8            CLEAR REG
         IC    R8,0(R4)         INSERT CHAR IN 25-32
         SRDL  R8,4             SHIFT OUT 29-32 INTO R9
         STC   R8,0(R5)         STORE SHIFTED 25-28 AS X'0X'
         TR    0(1,R5),HEXTRAN  TRANSLATE ALL 00 THRU 0F
*                                     TO->    F0 - F9,C1 - C6
         LA    R5,1(R5)         ADVANCE PTR TO NEXT POS
         XR    R8,R8            CLEAR REG
         SLDL  R8,4             SHIFT IN THE 29-32
         STC   R8,0(R5)         STORE IT
         TR    0(1,R5),HEXTRAN  TRANSLATE ALL 00 THRU 0F TO
*                                     TO->    F0 - F9,C1 - C6
         LA    R5,1(R5)         ADVANCE ANOTHER
         LA    R4,1(R4)         ADVANCE NEXT
CONVERT2 DS    0H
         JCT   R6,CONVERT       REDUCE COUNTER
*
         XR    R15,R15
         J     OK_X2CX
BAD_X2CX EQU   *
         LA    R15,8
         J     OK_X2CX
NO_X2CX  EQU   *
         LA    R15,4
         J     OK_X2CX
OK_X2CX  EQU   *
         LM    R4,R9,X2CX49
         BR    R9
*
DONE_X2CX EQU  *
         XC    RC,RC
         J     DONEEXT
*
NOSTG    EQU   *
         LA    R15,8
         J     NOFM
***
DONEEXT  EQU   *
         LR    1,13
         IILF  0,WORKSIZE
         L     13,4(13)
         FREEMAIN R,LV=(0),A=(1)
NOFM     EQU   *
         RETURN (14,12),,RC=0
*
*        PROGRAM CONSTANTS
*
*
         EJECT
*
DATA     DS    0D
*
$MODID   DC    CL16'&SYSDATE.-&SYSTIME'
ZEROES   DC    2F'0'
FMIN1    DC    F'-1'
H40      DC    H'40'
H80      DC    H'80'
BLANKS   DC    CL8'                '
HW16     DC    H'16'
*
TABLE   DC C'0123456789ABCDEF'
*
HEXTRAN  DC    X'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
*
* C1C2C3C4C5C6
TRANHXCH DC X'0A0B0C0D0E0F000000000000000000' C1-CF
        DC 32X'00' D0-EF
* F0F1F2F3F4F5F6F7F8F9
        DC X'00010203040506070809000000000000' F0-FF
*
MYHEX   DC X'FFEEDDCCBBAAA9A8A7A6A543210F01'  LEN 15
        DC X'00' DUMMY BYTE
*
         LTORG
*                0....5....1....5....2....5....3....5....4....5....5
***
WAREAS   DSECT
SAVE     DS    36F'0'    FSA4 18 DOUBLEWDS OR 36 FW
*
SAVR19   DS    10F
X2CX49   DS    6F
SAVR49   DS    6F
SAVR9    DS    F
SAVR6    DS    F
SAVE_PRM_ADR   DS F
*
X2CX_PRM_ADR DS 0F
X_FROM_A DS    F
X_FROM_L_A DS    F
X_TO_A   DS    F
X_TO_L_A DS    F
*
VACNTPRM DS    D
DWORD    DS    D
$DBLWD   DS    D
EBCDCFLD DS    D
HEXFIELD DS    F
TIOTADR  DS    F
$TIMEB   DS    F
$DATEB   DS    F
JOBNAME  DS    CL8
$DATE    DS    CL8
$TIME    DS    CL8
MYDEBUG  DS    CL1
MSGAREA1 DS    CL1
RC       DS    CL1
MSGAREA  DS    CL80
HLDSTR   DS    CL7
*
FROM_HEX_STR_L  DS    H
TO_CHAR_STR_L   DS    H
FROM_HEX_STR  DS    XL40
TO_CHAR_STR   DS    XL80
*
MYCHAR  DS XL9 CHAR DATA
*
MYXSTR  DS XL4  CHAR DATA
MYXSTR1 DS XL1
*
WORK    DS XL9 CHAR DATA
*
MYHEX2  DS XL5 BACK TO HEX
*
*
*
WAREASEND DS   0H
WORKSIZE  EQU  *-SAVE
         END
###END EXPMX2CX
$$$BEG EXPLPGM2
         YREGS
         SYSSTATE ARCHLVL=2
EXPLPGM2 CSECT
EXPLPGM2 AMODE 31
EXPLPGM2 RMODE 31
*
         J     BEGIN
PROLOG   LOCTR
         DC    C'EXPLPGM2'
         DC    C'ASMDATE && TIME: &SYSDATE &SYSTIME'
         DC    C'VER 1.2.3'
         DC    C'ALL RIGHTS RESERVED'
CODEBG1  LOCTR
BEGIN    DS    0H
         USING DATA,12
         SAVE  (14,12)       SAVE Z/OS'S REGS
         LARL  12,DATA       USE THIS INSTEAD OF LR AND AHI
*        LR    R12,R15
*        AHI   R12,DATA-BEGIN

         GETMAIN R,LV=WORKSIZE
         ST    13,4(1)
         LR    13,1
         USING (WAREAS,WAREASEND),13
*
         MVC  ONLY,=C'0123'
         MVC  SOMEVAL,=C'4567'
         L    R9,HV
         LA   R5,SOMEVAL
         LA   R4,2(R9,R5)
         MVCIN INV_MSG,BEG_MSGX
         MVCIN INV_MSG,BEG_MSG_END
*  TEST BRCTH BR REL CT HIGH REG
*  CAN NOT USE LA R0,1(R0) BECAUSE R0 FAILS; ALSO CLI 0(R0),C',' FAILS
         IIHF R2,L'COMA_TST_STR
         LARL R2,COMA_TST_STR
TOPOFLOPZ DS 0H
          CLI 0(R2),C','
          JE FND_COMA
          AHI R2,1     CAN NOT USE LA R0,1(R0) BECAUSE R0 DESTROYED
          BRCTH R2,TOPOFLOPZ
          J  NOT_FND_COMA
FND_COMA DS  0H
         LR  R0,R2
NOT_FND_COMA DS 0H
*  TEST BRXH  BR REL INDX HIGH REG
*   R15 - FIRST PARM - HAS THE VALUE THAT WILL CHANGE AND BE COMPARED
*                      TO THE SECOND PARM:ODD REG - THE COMPARE TO VAL
*   R2    SECOND PARM- EVEN ODD PAIR - EVEN REG HAS VAL TO BE ADDED
*                      TO THE FIRST PARM
*                      THEN ODD REG (AS MENTIONED) HAS COMPARE TO
*                      VALUE.
*   TOP.. THIRD PARM - REL ADDR. - JMP TO THIS LABEL WHEN THE VAL
*                      IN THE FIRST PARM IS HIGHER THAN THE VAL IN THE
*                      ODD REG OF SECOND PARM.
         IILF R2,-1
         IILF R3,12
         IILF R15,16
TOPOFLO0 DS   0H
         ST   R15,ONLY
         JXH  R15,R2,TOPOFLO0    SAME
*        BRXH R15,R2,TOPOFLO0      INSTRUCTION
*
*   NOTE - IF SECOND PARM IS AN ODD REG (NOT EVEN ODD PAIR), THEN
*          THE VAL SERVES AS BOTH THE ADDITIVE AND THE COMPARE TO VAL
*        IILF R2,-1
         IILF R3,-1
         IILF R15,4
TOPOFLO1 DS   0H
         ST   R15,ONLY
*        JXH  R15,R3,TOPOFLO1    SAME
         BRXH R15,R3,TOPOFLO1      INSTRUCTION
*  TEST BRXLE BR REL INDX LESS OR EQUAL
*   R15 - FIRST PARM - HAS THE VALUE THAT WILL CHANGE AND BE COMPARED
*                      TO THE SECOND PARM:ODD REG - THE COMPARE TO VAL
*   R2    SECOND PARM- EVEN ODD PAIR - EVEN REG HAS VAL TO BE ADDED
*                      TO THE FIRST PARM
*                      THEN ODD REG (AS MENTIONED) HAS COMPARE TO
*                      VALUE.
*   TOP.. THIRD PARM - REL ADDR. - JMP TO THIS LABEL WHEN THE VAL
*                      IN THE FIRST PARM IS LT/EQ  TO THE VAL IN THE
*                      ODD REG OF SECOND PARM.
         IILF R2,1
         IILF R3,16
         IILF R15,12
TOPOFLO2 DS   0H
         ST   R15,ONLY
         BRXLE R15,R2,TOPOFLO2
DOTERM   DS    0H
         LR    1,13
         L     0,FSIZE
         L     13,4(13)
         FREEMAIN R,LV=(0),A=(1)
         RETURN (14,12),,RC=0
*
DATA     DS    0F
FSIZE    DC    A(WORKSIZE)
*
HV       DC   F'1'
COMA_TST_STR DC C'ABCD,'
BEG_MSG  DC    C'THIS IS A SAMPLE MESSAGE THAT WILL BE USED IN THE GENE*
               RATION OF THE SHA MESSAGE DIGEST. I BELIEVE THAT THE LIT*
               ERAL CAN BE DEFINED UP TO 255 CHARS, BUT THIS IS NOW AT *
               A LENGTH OF 182.'
         ORG   *-1
BEG_MSG_END DS CL1
BEG_MSGX DC    X'15'  ADDED BECAUSE JAVA PGM LOOKS AT TXT FILE
*                      AND THE FILE HAS A X'15' AT THE END
         DC  X'FFFFFFFE'
*
         LTORG
*
WAREAS   DSECT
SAVE     DS    36F'0'
ONLY     DS      F
SOMEVAL  DS      H
INV_MSG  DS      CL(L'BEG_MSG)
*
WAREASEND DS   0H
WORKSIZE EQU   *-SAVE
         END   EXPLPGM2
###END EXPLPGM2
$$$BEG EXPLSTCK
         YREGS
         SYSSTATE ARCHLVL=2
* TO SHOW HOW THE UFHZATDR USES STCK INSTRUCTION TO GEN TERMID
EXPLSTCK CSECT
EXPLSTCK AMODE 31
EXPLSTCK RMODE ANY
*
         J     BEGIN
PROLOG   LOCTR
         DC    C'EXPLSTCK'
         DC    C'ASMDATE && TIME: &SYSDATE &SYSTIME'
         DC    C'VER 0.0.1'
         DC    C'ALL RIGHTS RESERVED'
CODEBG1  LOCTR
BEGIN    DS    0H
         USING DATA,12
         SAVE  (14,12)       SAVE Z/OS'S REGS
         LARL  12,DATA       USE THIS INSTEAD OF LR AND AHI
*        LR    R12,R15
*        AHI   R12,DATA-BEGIN

         GETMAIN R,LV=WORKSIZE
         ST    13,4(1)
         LR    13,1
         USING (WAREAS,WAREASEND),13
*
         STCK  CLOCK               GET CURRENT CLOCK
         STCKE CLOCKE              GET CURRENT CLOCK
         MVC   TODCLOCK,CLOCK
         STM   R0,R1,SAVREGS       SAVE DESTROYED REGS
         STCKCONV STCKVAL=TODCLOCK,CONVVAL=OUTVAL,TIMETYPE=DEC,        X
               DATETYPE=YYYYMMDD,MF=(E,LIST1)
         STCKCONV STCKEVAL=CLOCKE,CONVVAL=OUTVAL,TIMETYPE=DEC,         X
               DATETYPE=YYYYMMDD,MF=(E,LIST1)
         LM    R0,R1,SAVREGS       SAVE DESTROYED REGS
         STM   R4,R6,SAVREGS       SAVE DESTROYED REGS
         UNPK  TRMWRK(9),CLOCK+4(5)  GET VAR FOR TRMID LST 4 CHAR
         MVC   CVBD(8),TRMWRK      GET LAST 4 CHAR OF CLOCK VALUE
         LM    R4,R6,CVBD          GET VALUE AND XOR VALUE
         XR    R4,R6               CLEAR ZONE BITS
         XR    R5,R6               CLEAR ZONE BITS
         SLL   R5,4                MOVE VALUE TO ZONE BITS
         XR    R4,R5               COMBINE VALUES
         ST    R4,CVBD             SAVE RESULT
         LM    R4,R6,SAVREGS       RELOAD DESTROYED REGS
         MVC   TRMWRK(4),CVBD
*
DOTERM   DS    0H
         LR    1,13
         L     0,FSIZE
         L     13,4(13)
         FREEMAIN R,LV=(0),A=(1)
         RETURN (14,12),,RC=0
*
DATA     DS    0F
FSIZE    DC    A(WORKSIZE)
*
HV       DC   F'1'
COMA_TST_STR DC C'ABCD,'
BEG_MSG  DC    C'THIS IS A SAMPLE MESSAGE THAT WILL BE USED IN THE GENE*
               RATION OF THE SHA MESSAGE DIGEST. I BELIEVE THAT THE LIT*
               ERAL CAN BE DEFINED UP TO 255 CHARS, BUT THIS IS NOW AT *
               A LENGTH OF 182.'
         ORG   *-1
BEG_MSG_END DS CL1
BEG_MSGX DC    X'15'  ADDED BECAUSE JAVA PGM LOOKS AT TXT FILE
*                      AND THE FILE HAS A X'15' AT THE END
         DC  X'FFFFFFFE'
*
****************************************************************
*                                                              *
*         CIGNA CONSTANTS AND TABLES                           *
*                                                              *
****************************************************************
TABLE    EQU   *                      EBCDIC INPUT TABLE   (TEO)
         DC    CL16'0123456789ABCDEF'   X'00" - X'0F'
         DC    CL16'GHIJKLMNOPQRSTUV'   X'10" - X'1F'
         DC    CL16'WXYZ$@#./_%&&?!:'   X'20" - X'2F'
         DC    CL16'|"=^,;<>01234567'   X'30" - X'3F'
         DC    CL16'89ABCDEFGHIJKLMN'   X'40" - X'4F'
         DC    CL16'OPQRSTUVWXYZ$@#.'   X'50" - X'5F'
         DC    CL16'/_%&&?!:|"=^,;<>'   X'60" - X'6F'
         DC    CL16'0123456789ABCDEF'   X'70" - X'7F'
         DC    CL16'GHIJKLMNOPQRSTUV'   X'80" - X'8F'
         DC    CL16'WXYZ$@#./_%&&?!:'   X'90" - X'9F'
         DC    CL16'|"=^,;<>01234567'   X'A0" - X'AF'
         DC    CL16'89ABCDEFGHIJKLMN'   X'B0" - X'BF'
         DC    CL16'OPQRSTUVWXYZ$@#.'   X'C0" - X'CF'
         DC    CL16'/_%&&?!:|"=^,;<>'   X'D0" - X'DF'
         DC    CL16'0123456789ABCDEF'   X'E0" - X'EF'
         DC    CL16'GHIJKLMNOPQRSTUV'   X'F0" - X'FF'
*
         LTORG
*
WAREAS   DSECT
SAVE     DS    36F'0'
SAVREGS  DS    3F       CIGNA      SAVE AREA FOR DESTROYED REGS
* KEEP FOLLOWING 3 DEFS IN THIS ORDER
CVBD     DS    D        CIGNA WORK AREA FOR CONV
CLOCK    DS    D        CIGNA      AREA FOR STORE CLOCK
TRMWRK   DS    CL5      CIGNA      VARIABLE TERMID WRK AREA
*
CLOCKE   DS    2D       CIGNA      AREA FOR STORE CLOCK
LIST1    STCKCONV MF=L
TODCLOCK DC X'9FE4781301ABE000'     TOD CLOCK VALUE
OUTVAL   DS CL16                    CONVERTED VALUE
ONLY     DS      F
SOMEVAL  DS      H
INV_MSG  DS      CL(L'BEG_MSG)
*
WAREASEND DS   0H
WORKSIZE EQU   *-SAVE
         END   EXPLSTCK
###END EXPLSTCK
$$$BEG UCEMPINN
*
* V1 - Original
* v1.1 - CHANGES TO FIX ASRA
* v1.2 - changes to add userids to restricted
*      - ALSO ALLOW (G5) REGION ID AS UID
* V1.3 - CEMT AND CEDA CMD NEED A DEFINED CMD AREA-CAN NOT BE NULLS
*      - USE SRST TO FIND FIRST NULL, OR USE DEFAULT 80 OR EIBCALEN
*      - TO DEFINE A VALID CMD AREA
* V1.4 - CEMT AND CEDA CMD - issue writeq cssl to reflect cmd  action
* V1.9 - LINK PROGRAM CMD - PASS COMMAND TO LINK TO PROGRAM WITH CA
* V1.91- correct errors   - PASS COMMAND TO LINK TO PROGRAM WITH CA
* UCEMPINN
*  PING FUNCTION:
*  IF NO COMMAREA, THEN JUST WRITE BASEMSG TO CSSL AND RETURN
*  IF COMMAREA, THEN USE ONE OF THE FOLLOWING TO FORMAT CA
*   CA MUST BE MINIMUM OF 2, UP TO 32400
*     REST OF CA WILL BE FILLED IN AS APPROPRIATE
*   FOR NOW, NEXT 4 CHARACTERS CAN BE LITERAL PING, OR
*       OR CEDA EXPAND ... (NOTE OTHER OPTIONS AVAILABLE)
*       OR CEMT INQUIRE ... (NOTE OTHER OPTIONS AVAILABLE)
*   ANY FUNCTION CAN BE PREFIXED WITH SYSID=____,
*            FOLLOWED BY  PING
*       OR/AND   FOLLOWED BY  CEDA EXPAND ...
*       OR/AND   FOLLOWED BY  CEMT INQUIRE ...
*   IF REMAINING CA IS AT LEAST 29, THEN RETURN START AND STOP TIME
*   EACH HOP WILL RETURN IT'S START AND STOP TIME
*   IF SPACE PERMITS, THEN EACH HOP WILL BE REFLECTED IN THE RETURN CA
*  ORIGINAL COMMAND IS NOT DISTURBED IN THE CA. RESPONSE IS TACKED
*   ONTO THE CA.  FIRST BYTE IN THE RETURNED AREA IS A READABLE RC
*      0 IS NORMAL
*      1 IS NORMAL, BUT PARTIAL DATA WOULD NOT FIT
*      2 IS NORMAL, BUT NON NULL TERMINATED STRING RETURNED
*      4 IS ERROR, SEE WTO
*      8 IS ERROR OR ABEND, NO MESSAGE
* ON ENTRY, PRM OBEYS SYSTEM LINKAGE STDS
*  R1 POINTS TO PARM LIST W/ TWO ADDR (EIB AND COMM (OR ZERO))
*  R13 POINTS TO ADDR OF SAVE AREA
*  R14 POINTS TO ADDR OF RETURN PT
*  R15 POINTS TO ADDR OF ENTRY  PT
* FOR EACH EXEC CICS CALL MACRO EXPANDS TO
*  DFHECALL MACRO WHICH IS STD SYSTEM CALL
*  R0  UNDEFINED
*  R1  POINTS TO ADDR OF PARM LIST
*  R14 POINTS TO RETURN POINT IN YOUR PGM
*  R15 POINTS TO ADDR OF ENTRY  PT IN EXEC INTF
* DFHEAI MUST BE LINK EDITED WITH YOUR PGM FOR EXEC INTF RESOLUTION
* EXEC CICS RETURN WILL EXIT UOUR PGM OR DFHEIRET IS INSERTED BY
*  THE TRANSLATOR IF NO EXEC RETURN FOUND
* DFHEIRET INSERTED BY TRANSLATOR AT END OF PGM
*  THIS MACRO: RESTORES REGS
*              RETURNS VIA R14
* DFHECALL BUILDS THE PARM LIST IN DYN STG FOR REENTRANCY
* DFHEIENT INSERTED BY TRANSLATOR AFTER FIRST CSECT
*  INSTRUCT DFHEIENT CODEREG=(2,3,4),
*               DATAREG=(13,5),
*               EIBREG=6
*
*  THIS MACRO: SAVES REGS
*              GETMAIN STG FOR DFHEISTG
*              SETS BASE REG (R3 DEFAULT)
*              SETS DYN STG REG (R13 DEFAULT)
*              SETS EIB REG (R11 DEFAULT)
* DFHEISTG INSERTED BY TRANSLATOR
*              DEFINES STG PARM LIST
*              DEFINES STG FOR REG SAVE AREA
*              INCLUDES YOUR VARS WHEN YOU CODE THE DFHEISTG MACRO
* DFHEIEND INSERTED BY TRANSLATOR TO ID END OF EIDSA
* DFHEIBLK INSERTED BY TRANSLATOR DEFINES EIB DSECT
* MULTIPLE BASE REGS DEFINED BY DFHEIENT (CODEREG DATAREG EIBREG)
* DFHEIPLR IS THE REG VAR ASSIGNED TO FIRST EIBREG OR DEFAULT
*REG 1                      PASSED ADDR OF PARMS
*REG 2                      BASE REGISTER (CMD LVL)
*REG 3                      2ND BASE REGISTER (CMD LVL)
*REG 11                     PTR TO EIB (SET BY DFHEIENT)
*REG 13                     PTR TO DFHEISTG (SET BY DFHEIENT)
*
*REG 6          SOMETIMES   USED FOR INTERNAL SUBROUTINE
*REG 7          SOMETIMES   USED FOR INTERNAL SUBROUTINE
*REG 8          SOMETIMES   USED FOR INTERNAL SUBROUTINE
*REG 9          MOSTTIMES   USED FOR INTERNAL SUBROUTINE
         SYSSTATE ARCHLVL=1
         REGSMAC
*
CMD_CA   DSECT
CA_START DS    0F
CA_RET_CD  DS  C      X'F0' X'F4' X'F8' ARE ONLY EXPECTED VALUES
CA_RET_STR_ST DS 0C
*
DFHEISTG DSECT
BEGOFEIS DS    CL8
SAVR1    DS    F
SAV_RET_9 DS   F
SAV_SEP_6 DS    F
SAV_4_SRST DS   F
*
PARS_REG_SA DS   16F
*
FRESP    DS    F
FRESP2   DS    F
*
DWORD    DS    D
$DBLWD   DS    D
D_ABSTIME DS   D
EBCDCFLD DS    D
HEXFIELD DS    F
*
THEPARM  DS    4F
THEPARAL EQU   *-THEPARM
*
PARSE_EQ DS H
* SET FIND EQUAL TO H'00'
* SET FIND UNEQUAL TO H'FFFF'
PARSE_DIRECTN DS H
PARMAREA DS    0F
         DS    H
PARMAL   DS    H
PARMA    DS    F
H_MAX_CMD_LEN DS H        USE TO HOLD DERIVED MAX CMD LNG
*
L_OPLIT  DS    H LENGTH OF OPLIT
*
P4       DS    PL4
C8       DS    CL8
TDQ      DS    CL4
SEP      DS    CL1
*
FOUR     DS    CL4,C
*
EIGHT    DS    CL8,C
*
RC       DS    XL1
*
HLDSTR   DS    CL7
TASKNUM  DS    CL8
         ORG   *-5
TASK_NUM DS    CL5
*
TASK_EIBCAL DS    CL5
TRMNETID DS    CL8
TRMUSRNM DS    CL8
TOD_TIME DS    CL8
OPLITM10 DS    CL10
         ORG   *-1
OPLIT1   DS    CL1
OPLIT    DS    CL245
RTE_TO_SYSID DS CL4
*
P_OCA       DS    F   PTR TO ORIG CA
*
P_OCA_CURPOS DS   F   PTR INTO ORIG CA
P_OCA_LSTPOS DS   F   PTR TO LAST POS OF ORIG CA
*
*      GETMAIN A 32400 SCRATCH AREA TO MANIPULATE DATA
P_MOV_2_DATA DS   F    SCRATCH AREA TO SET UP STRING TO RETURN IN CA
P_MOV_2_DATA_CURPOS DS   F SCRATCH AREA CURPOS
MOV_2_DATAL     DS    F     LNG OF THE SCRATCH AREA
P_MOV_2_DATA_LST DS   F     LAST VALID POSITION IN SCRATCH AREA
*
P_DPL_CA    DS    F    PTR TO DPL CA (IF ANY)
*
F_DPL_CAL   DS    F     MAX FLNG FOR CA COMMAREA
            ORG *-2
H_DPL_CAL   DS    H     MAX LNG FOR DPL COMMAREA
H_DPL_RET_CAL   DS    H    DERIVED LNG INCL DELIMITING X'00'
*
P_CMD_A     DS    F    PTR TO CMD WORKING AREA
*
P_CMD_OP_A  DS    F    PTR TO CMD OUTPUT AREA
*
SAV_SEP_ADR DS    F
SAV_CAL      DS   H
SAV_CAL_REMN DS   H
SYSID_SUFXL  DS   H
PROGRAM_SUFXL DS  0H
H_L_PREFIX_DATA DS 0H
*
*CVDA DATAAREAS
PGMAPI   DS   F
TDQ_ENA  DS   F
TDQ_STAT DS   F
TDQ_RECFM DS  F
TDQ_RECLF DS  F
          ORG *-2
TDQ_RECLH DS  H
*
LCL_SYSID   DS   CL4
LCL_APPLID  DS   CL8
LCL_NETNAME DS   CL8
INVKG_PROG DS   CL8
PGM_CUR    DS   CL8
FAC_3270   DS   XL1
ST_CD      DS   CL2
LCL_UID    DS   CL8
LCL_DEF_UID DS  CL8
LCL_UNAME  DS   CL20
*
PGM_CMD    DS   CL8
*
TIMER_ENT_ST_JDT DS CL8
TIMER_ENT_ST_TOD DS CL8
TIMER_ENT_SP_JDT DS CL8
TIMER_ENT_SP_TOD DS CL8
*
TIMER_DPL_ST_JDT DS CL8
TIMER_DPL_ST_TOD DS CL8
TIMER_DPL_SP_JDT DS CL8
TIMER_DPL_SP_TOD DS CL8
*
MYABSTM  DS    PL8
MYABSTM1 DS    PL8
*
TMP_STR_33   DS CL33
L_TMP_STR_33   EQU *-TMP_STR_33
*
ENDOFEIS DS    CL8
*
         DS   0D
*
UR_RESP  DS   0CL(255)
UR_PGMID DS   CL(8)
         DS   CL(1)
UR_VER   DS   CL(4)
         DS   CL(1)
UR_APPLID DS   CL(8)
         DS   CL(1)
UR_TRNID DS   CL(4)
         DS   CL(1)
UR_TSKNO DS   CL(5)
         DS   CL(1)
UR_TRMID DS   CL(4)
         DS   CL(1)
UR_USERID DS   CL(8)
         DS   CL(1)
UR_ASK_DATE DS   CL(8)
         DS   CL(1)
UR_ASK_TIME DS   CL(8)
         DS   CL(1)
UR_CALEN DS  CL(5)
UR_COLON0 DS   CL(1)
UR_INVKPGM DS   CL(8)
UR_COLON1 DS   CL(1)
*  CURRENT POS 81, 255_81=172
UR_RESP_LEN EQU *-UR_RESP
UR_REST_LEN EQU L'UR_RESP-UR_RESP_LEN
UR_REST  DS   CL(UR_REST_LEN)
UR_REST_L DS  H
*
UCEMPINN RMODE ANY
UCEMPINN AMODE 31
UCEMPINN DFHEIENT CODEREG=(2,3)
*        EXTRN CEMVALUE
         ZAP   MYABSTM,PZERO
         ZAP   MYABSTM1,PZERO
         MVC   OPLITM10,=CL10' '
         MVC   OPLIT,OPLIT1
         LA    R15,L'OPLIT
         STH   R15,L_OPLIT
         XC    P_OCA,P_OCA
         XC    P_OCA_CURPOS,P_OCA_CURPOS
         XC    P_OCA_LSTPOS,P_OCA_LSTPOS
         XC    SYSID_SUFXL,SYSID_SUFXL
         XC    TDQ_ENA,TDQ_ENA
         XC    TDQ_STAT,TDQ_STAT
         XC    TDQ_RECLF,TDQ_RECLF
         XC    TDQ_RECFM,TDQ_RECFM
         MVC   TIMER_ENT_SP_JDT,SPACE255
         MVC   TIMER_ENT_SP_TOD,SPACE255
         MVC   TIMER_DPL_ST_JDT,SPACE255
         MVC   TIMER_DPL_ST_TOD,SPACE255
         MVC   TIMER_DPL_SP_JDT,SPACE255
         MVC   TIMER_DPL_SP_TOD,SPACE255
         XC    H_DPL_RET_CAL,H_DPL_RET_CAL
         XC    P_MOV_2_DATA,P_MOV_2_DATA
         XC    P_MOV_2_DATA_CURPOS,P_MOV_2_DATA_CURPOS
         MVC   TDQ,=CL4'CSSL'
*
         MVC   UR_RESP,SPACE255
         MVC   UR_PGMID,PROGNAME
         MVC   PGM_CMD,PROGNAME
         MVC   UR_VER,PROGVER
         MVC   UR_TRNID,EIBTRNID
         UNPK  TASKNUM,EIBTASKN
         OI    TASKNUM+7,X'F0'
         MVC   UR_TSKNO,TASKNUM+3
         MVC   UR_TRNID,EIBTRNID
         MVC   UR_TRMID,EIBTRMID
         LH    R15,EIBCALEN
         CVD   R15,DWORD
         UNPK   TASK_EIBCAL,DWORD+5(3)
         OI    TASK_EIBCAL+4,X'F0'
         MVC   UR_CALEN,TASK_EIBCAL
         MVI   UR_COLON0,C':'
         MVI   UR_COLON1,C':'
         MVC   UR_REST(4),PROGNAME+4
*
         EXEC CICS INQUIRE TDQUEUE(TDQ)                                *
               ENABLESTATUS(TDQ_ENA)                                   *
               OPENSTATUS(TDQ_STAT)                                    *
               RECORDFORMAT(TDQ_RECFM)                                 *
               RECORDLENGTH(TDQ_RECLF)                                 *
               RESP(FRESP)                                             *
               RESP2(FRESP2)
         CLC   TDQ_RECFM,DFHVALUE(VARIABLE)
         JNE   NOT_VARQ
         LH    R15,TDQ_RECLH
         AHI   R15,-4
         STH   R15,TDQ_RECLH
NOT_VARQ DS 0H
         CLC   FRESP,DFHRESP(NORMAL)
         JNE   NO_TDQ
         CLC   TDQ_ENA,DFHVALUE(ENABLED)
         JNE   NO_TDQ
         CLC   TDQ_STAT,DFHVALUE(OPEN)
         JE    OK_TDQ
NO_TDQ   DS 0H
         MVC  TDQ_ENA,DFHVALUE(DISABLED)     SET ONE INDICATOR
OK_TDQ   DS 0H
*
         EXEC CICS ASKTIME ABSTIME(MYABSTM)
         EXEC CICS FORMATTIME ABSTIME(MYABSTM)                         *
              YYYYDDD(TIMER_ENT_ST_JDT) DATESEP('-')                   *
              TIME(TIMER_ENT_ST_TOD) TIMESEP(':')
*
         MVC   MOV_2_DATAL,F32400
         LH    R15,H32400
         LA    R15,1(R15)
         ST    R15,MOV_2_DATAL
         XC    P_MOV_2_DATA_LST,P_MOV_2_DATA_LST   ZERO FINAL LEN
* GET A SCRATCH AREA FOR THIS PROGRAM TO USE IN CREATING A REPLY
*  WITHOUT NEEDING TO KEEP CHECKING OCA LENGTH
         EXEC CICS GETMAIN FLENGTH(MOV_2_DATAL)                        *
               SET(R6)                                                 *
               INITIMG(H0)                                             *
               NOSUSPEND                                               *
               RESP(FRESP)                                             *
               RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)
         JNE   BAD_START
         ST    R6,P_MOV_2_DATA
         LR    R15,R6
         A     R15,MOV_2_DATAL
         BCTR  R15,0
         ST    R15,P_MOV_2_DATA_LST  SAVE LAST POSN IN THE SCRATCH
         MVI   0(R15),X'15' MARK THE ULTIMATE LAST POSN
*
         MVI   0(R6),C'0'
         LA    R6,1(R6)         THIS IS THE RETURN CODE SET TO ZERO
         ST    R6,P_MOV_2_DATA_CURPOS
*
         MVC   BEGOFEIS,=C'BEGOFEIS0<<'
         MVC   ENDOFEIS,=C'ENDOFEIS0<<'
         MVC   HLDSTR,SPACE255
         ST    R1,SAVR1          SAVE R1 FOR REFERENCE
         LA    R15,16
         STH   R15,PARMAL
         LA    R1,THEPARM
         ST    R1,PARMA
         MVC   PARSE_DIRECTN,H1
         XC    PARSE_EQ,PARSE_EQ
         MVI   RC,C'0'
*
         EXEC CICS ASSIGN SYSID(LCL_SYSID)                             *
               APPLID(LCL_APPLID)                                      *
               INVOKINGPROG(INVKG_PROG)                                *
               PROGRAM(PGM_CUR)                                        *
               STARTCODE(ST_CD)                                        *
               USERID(LCL_UID)                                         *
               RESP(FRESP)                                             *
               RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)
         JNE   CANT_DO_IT
*
         MVC   UR_PGMID,PGM_CUR
         MVC   UR_REST(4),PGM_CUR+4
*
         EXEC CICS ASSIGN  USERNAME(LCL_UNAME)                         *
               RESP(FRESP)                                             *
               RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)
         JNE   NOT_OK_AOR
*
OK_TOR_USE EQU *
         CLC   ST_CD,LIT_TERM_TD
         JNE   BYP_ASGN_NET
*
         EXEC CICS ASSIGN NETNAME(LCL_NETNAME)                         *
               DS3270(FAC_3270)                                        *
               RESP(FRESP)                                             *
               RESP2(FRESP2)
         CLC   FRESP,DFHRESP(NORMAL)
         JNE   CANT_DO_IT
*
NOT_OK_AOR  EQU *
BYP_ASGN_NET EQU *
         MVC   RTE_TO_SYSID,SPACE255
         XC    SAV_SEP_ADR,SAV_SEP_ADR
*
         MVI   0(R6),C'<'
         MVC   1(4,R6),LCL_SYSID
         MVC   5(7,R6),=C'(ENTRY:'
         MVC   12(8,R6),TIMER_ENT_ST_JDT
         MVC   21(8,R6),TIMER_ENT_ST_TOD
         MVI   29(R6),C')'
         LA    R6,30(R6)
         ST    R6,P_MOV_2_DATA_CURPOS
*
         MVC   UR_APPLID,LCL_APPLID
         MVC   UR_INVKPGM,INVKG_PROG
         MVC   UR_USERID,LCL_UID
         MVC   UR_ASK_DATE,TIMER_ENT_ST_JDT
         MVC   UR_ASK_TIME,TIMER_ENT_ST_TOD
*
         LH    R15,EIBCALEN
         STH   R15,SAV_CAL_REMN
         STH   R15,SAV_CAL       OCA EIBCALEN - NEVER ALTERED IN
         L     R5,DFHEICAP
         ST    R5,P_OCA
         ST    R5,P_OCA_CURPOS
*
         ARK   R9,R15,R5
         BCTR  R9,0
         ST    R9,P_OCA_LSTPOS
*
*        CHI   R15,X'4'   FOUR IS MIN COMMAND LENGTH FOR
*        JL    NOCA
         CIJL  R15,4,NOCA
*
         LA    R9,L'UR_REST
         STH   R9,UR_REST_L
*        CR    R15,R9
*        JH    USE_ALL_UR
         CRJH  R15,R9,USE_ALL_UR
         STH   R15,UR_REST_L
         LR    R9,R15     USE THE CAL, SMALLER THAN UR_REST
USE_ALL_UR DS 0H
*
         BCTR  R9,0
         EXRL  R9,MVC_UR_REST
*
         ST    R5,SAV_SEP_ADR    PRESET CA ADDR
*                 PREFER  1      SYSID(AAAA)
*                         2      SYSID=AAAA
*                         3      SYSID=(AAAA)
         LH    R15,SAV_CAL
*
*        CHI   R15,7                CHECK FOR A MINIMUM SYSID=X
*        JL    NOT_SYSID            CHECK ONLY FOR LCL COMMAND
         CIJL  R15,7,NOT_SYSID            CHECK ONLY FOR LCL COMMAND
         CLC   0(5,R5),LIT_SYSID_EP  SYSID
         JNE   NOT_SYSID
*
         MVI   SEP,C')'          USE ')' AS SEPARATOR
         LA    R15,2
         STH   R15,SYSID_SUFXL
         CLI   5(R5),C'('            SYSID(
         JE    OK_SYSID6
*
         CLI   5(R5),C'='            SYSID=
         JNE   NOT_SYSID
*
         CLI   6(R5),C'('            SYSID=(
         JE    OK_SYSID7
*                               DEFINITELY HAVE SYSID=_
         MVI   SEP,C','             USE COMMA AS SEPARATOR
         LA    R15,1
         STH   R15,SYSID_SUFXL
*
OK_SYSID6 EQU   *
         LA    R15,6           PRESERVE LNG SYSID= OR SYSID(
         J     CK_CA_LNG
*
MVC_UR_REST MVC UR_REST(0),0(R5)
*
OK_SYSID7 EQU   *
         LA    R15,7           PRESERVE LNG SYSID=(
         J     CK_CA_LNG
*
CK_CA_LNG EQU  *
         LA    R5,0(R15,R5)    POINT BEYOND SYSID.?
         ST    R5,P_OCA_CURPOS
         LH    R1,SAV_CAL_REMN
         SR    R1,R15
         STH   R1,SAV_CAL_REMN
*        CHI   R1,5
*        JL    OK_LSYSID
         CIJL  R1,5,OK_LSYSID
*
         LA    R1,5            ADD 5 TO LNG FOR COMPARE TO SEP
OK_LSYSID EQU  *
         LA    R1,0(R5,R1)     POINT TO LAST SEARCH POSN
* FIND THE FIRST OCCURANCE OF ENDING CHAR
*              R5 HAS ADDR OF FIRST CHAR Following SYSID.?
*              R1 HAS ADDR OF LAST SEARCH POS (SEARCH FOR SEP CHAR)
*   SRST R0 56-63 HAS BYTE TO SEARCH FOR
*        R1 (FIRST REG) HAS THE ENDING ADDR
*        R2 (2ND   REG) HAS THE STARTING ADDR
*   CHK  JC    MASK,JUMP_TO_REL_ADDR
*        CC  0 8    NOT DEFINED
*            1 4    FOUND, R1 UPDATED WITH BYTE FOUND,R2 UNCHGD
*            2 2    NOT FOUND, R1 AND R2 UNCHANGED
*            3 1    SPIN SEARCH, R1 UNCHGD, R2 POINTS TO NEXT SRCH ADR
*              + THIS IS THE VALUE TO USE IN THE JC INSTR
RETRY_SYSID_SRST DS 0H
         LR    R8,R1     RESET LAST POS TO SEARCH OCA
*              WHICH IS POINT AFTER SYSID(|SYSID=|SYSID=(
         LR    R9,R5     RESET TO CURPOS IN OCA
         XR    R0,R0
         IC    R0,SEP    PLACE SEP CHAR INTO BIT 24-31
RET_SRST_SYSID SRST R8,R9
         JC    4,FND_SYSID_SEP
         JC    1,RET_SRST_SYSID  RE-DRIVE
*              NOTE FIRST PASS, SEP IS EITHER ')' OR ','
         CLI   SEP,C','       DID NOT FIND IT, SO WE WILL SEE IF
         JNE   ERR_CA_STR      WE ARE ON FIRST OR SECOND PASS
*                              FIRST PASS, SO RPLACE SEP TO USE SPACE
         MVI   SEP,X'40'         BUT WE WILL TAKE A SPACE AS THE
         LA    R15,1
         STH   R15,PROGRAM_SUFXL
         J     RETRY_SYSID_SRST
*
*
FND_SYSID_SEP  EQU   *
         LR    R15,R8     R8 POINTS AT THE SEP CHAR
         ST    R15,SAV_SEP_ADR SAVE ADDR
         AH    R15,SYSID_SUFXL     ADJUST BY SEP LNG 1 OR 2
         ST    R15,P_OCA_CURPOS   FIRST POS IN CMD
         SR    R8,R5          BEG SYSID MINUS END POSTN GIVES LNG
         LH    R15,SAV_CAL_REMN   GET REMAINING CA LEN
         SR    R15,R8         SUB SYSID LNG TO GET NEW REM CA LNG
         STH   R15,SAV_CAL_REMN SAVE IT
*
GOT_SYSID EQU  *
         LR    R9,R8
         BCTR  R9,0             REDUCE BY 1 FOR EXECUTE
         LA    R15,RTE_TO_SYSID  GET READY FOR EXECUTE
*
*MVC_DST_R15_SRC_R5 MVC 0(0,R15),0(R5)
         EXRL  R9,MVC_DST_R15_SRC_R5   MOVE VIA EXECUTE
*
         CLC   RTE_TO_SYSID,LCL_SYSID
         JE    CHK_CMD
*
RE_DIRECT_ROUTE_QRY EQU *
         EXEC CICS INQUIRE CONNECTION(RTE_TO_SYSID)                    *
               RESP(FRESP)                                             *
               RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)
         JE    DO_DPL
*
         CLC   FRESP,DFHRESP(SYSIDERR)
         JNE   BAD_SYSID_RESP
*
         CLC   LCL_SYSID,LIT_PTERMSVR
         JE    BAD_SYSID_RESP
*
         CLC   LCL_SYSID,LIT_TTERMSVR
         JE    BAD_SYSID_RESP
*
         CLC   RTE_TO_SYSID,LIT_PTERMSVR
         JE    TRY_TTERM
         CLC   RTE_TO_SYSID,LIT_TTERMSVR
         JE    BAD_SYSID_RESP
         MVC   RTE_TO_SYSID,LIT_PTERMSVR
         J     RE_DIRECT_ROUTE_QRY
*
TRY_TTERM EQU  *
         MVC   RTE_TO_SYSID,LIT_TTERMSVR
         J     RE_DIRECT_ROUTE_QRY
*
DO_DPL   EQU   *
         LH    R15,H32400
*        LA    R15,1(R15)        SET ONE LESS THAN SCRATCH AREA
*                                TO ACCOM RC IN POS 0 OF SCRATCH
         ST    R15,F_DPL_CAL
         EXEC CICS GETMAIN FLENGTH(F_DPL_CAL) SET(R8)                  *
               INITIMG(H0)                                             *
               NOSUSPEND                                               *
               RESP(FRESP)                                             *
               RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)
         JNE   BAD_DPL_STG
*
         ST    R8,P_DPL_CA
         LH    R9,SAV_CAL
         L     R6,DFHEICAP
         LH    R7,SAV_CAL
         MVCL  R8,R6          MOVE ENTIRE ORIG CA TO NEW CA FOR DPL
*
         L     R8,P_DPL_CA
         USING CMD_CA,R8
         ZAP   MYABSTM,PZERO
         EXEC CICS ASKTIME ABSTIME(MYABSTM)
         EXEC CICS LINK PROGRAM(PGM_CMD)                               *
               SYSID(RTE_TO_SYSID)                                     *
               COMMAREA(CMD_CA)                                        *
               LENGTH(H_DPL_CAL)                                       *
               DATALENGTH(SAV_CAL)                                     *
               RESP(FRESP)                                             *
               RESP2(FRESP2)
*
         DROP  R8
         CLC   FRESP,DFHRESP(NORMAL)
         JNE   BAD_DPL
*
         ZAP   MYABSTM1,PZERO
         EXEC CICS ASKTIME ABSTIME(MYABSTM1)
*
         EXEC CICS FORMATTIME ABSTIME(MYABSTM)                         *
              YYYYDDD(TIMER_DPL_ST_JDT)  DATESEP('-')                  *
              TIME(TIMER_DPL_ST_TOD)  TIMESEP(':')
         EXEC CICS FORMATTIME ABSTIME(MYABSTM1)                        *
              YYYYDDD(TIMER_DPL_SP_JDT)  DATESEP('-')                  *
              TIME(TIMER_DPL_SP_TOD)  TIMESEP(':')
*
         J     DONE_DPL
*
BAD_DPL_STG EQU   *
BAD_DPL  EQU   *
BAD_CA_RET EQU   *
*
         MVI   RC,C'8'
         L     R6,P_MOV_2_DATA  GET PTR TO SCRATCH
         MVI   0(R6),C'8'       RESET THE RC TO 8
         L     R6,P_MOV_2_DATA_CURPOS GET PTR TO CURPOS SCRATCH
*                               NOW MOVE THE ERROR MESSAGE
         CLC   FRESP,DFHRESP(SYSIDERR)
         JNE   NOT_SYSID_ERR
         LA    R15,28
         C     R15,FRESP2
         JNE   CHK_SYSID_BUSY
         MVC   0(L'CA_RET_SRL_LIT,R6),CA_RET_SRL_LIT
         LA    R15,L'CA_RET_SRL_LIT
         J     MOV_RST_BAD_DPL
CHK_SYSID_BUSY EQU *
         LA    R15,29
         C     R15,FRESP2
         JNE   NOT_SYSID_ERR
         MVC   0(L'CA_RET_SBZ_LIT,R6),CA_RET_SBZ_LIT
         LA    R15,L'CA_RET_SBZ_LIT
         J     MOV_RST_BAD_DPL
BAD_DPL_ALL_SP DS 0H
         MVC   0(L'LIT_BAD_DPL_ALL_SP,R6),LIT_BAD_DPL_ALL_SP
         MVC   40(4,R6),RTE_TO_SYSID
         LA    R15,L'LIT_BAD_DPL_ALL_SP
         J     MOV_RST_BAD_DPL
NOT_SYSID_ERR EQU *
         MVC   0(L'CA_RET_BAD_LIT,R6),CA_RET_BAD_LIT
         LA    R15,L'CA_RET_BAD_LIT
         J     MOV_RST_BAD_DPL
MOV_RST_BAD_DPL EQU *
         LA    R15,1(R15)
         AR    R6,R15
         MVI   0(R6),C'*'
         ST    R6,P_MOV_2_DATA_CURPOS
         J     DONE_DPL_STP_ERR
*
*              NOTE- WE WILL DEAL WITH MOVING THE RESULTANT DPL CA
*                    TO THE SCRATCH AREA GM AT BEGINNING OF PGM.
*                    BOTH AREAS ARE THE SAME LENGTH.
DONE_DPL EQU   *
*              NOTE- SETUP THE RESPONSE PREFIX DATA
*                    THEN APPEND THE DPL CA DATA
*                    FINALLY, RESPONSE SUFFIX DATA
*                    IF THE OCA IS SMALLER THAN THE DPL CA
*                    (USUALLY IS), THEN WE WANT AS MUCH AS WE CAN
*                    WHICH SHOULD HAVE BOTH THE RESPONSE PREFIX
*                    FOLLOWED BY AS MUCH OF THE DPL CA DATA
*                    BUT PRESERVE THE REPONSE SUFFIX DATA
* RESPONSE PREFIX DATA
*              NOTE- WE ALREADY HAVE THE 1 BYTE RC IN POS 0
*                    SO WE ARE STARTING A POS 1
         L     R6,P_MOV_2_DATA_CURPOS       CURPOS IN SCRATCH IS 1
         MVC   0(34,R6),SPACE255
         MVC   0(5,R6),=C'<DPL('
         MVC   5(4,R6),RTE_TO_SYSID
         MVC   9(7,R6),=C'(ENTRY:'
         MVC   16(8,R6),TIMER_DPL_ST_JDT
         MVC   25(8,R6),TIMER_DPL_ST_TOD
         MVI   33(R6),C'{'
         LA    R6,34(R6)
         ST    R6,P_MOV_2_DATA_CURPOS
*%
* DPL CA DATA
*   SRST R0 56-63 HAS BYTE TO SEARCH FOR
*        R1 (FIRST REG) HAS THE ENDING ADDR
*        R2 (2ND   REG) HAS THE STARTING ADDR
*   CHK  JC    MASK,JUMP_TO_REL_ADDR
*        CC  0 8    NOT DEFINED
*            1 4    FOUND, R1 UPDATED WITH BYTE FOUND,R2 UNCHGD
*            2 2    NOT FOUND, R1 AND R2 UNCHANGED
*            3 1    SPIN SEARCH, R1 UNCHGD, R2 POINTS TO NEXT SRCH ADR
*              + MASK IS THE VALUE TO USE IN THE JC INSTR
         L     R9,F_DPL_CAL   DPL CA AND SCRATCH GM ARE SAME SIZE
         AHI   R9,-34         REMOVE THE ABOVE 34 CHARS FROM CALC
*        STH   R9,H_MAX_CMD_LNG    SAVE THIS AS THE DEFAUL LENGTH
         AR    R9,R8          THIS IS MAX SEARCH LENGTH
         XR    R0,R0
         ST    R8,SAV_4_SRST    SAVE BEG ADDR
*
RET_SRST_DPL  SRST R9,R8      SRCH DPL CA FOR FIRST NULL
*
         JC    2,SRST_NOTFND_DPL_SEP
         JC    1,RET_SRST_DPL   RE-DRIVE
*              NOTE- WE DID NOT FIND A NULL CHAR IN THE CA RETURNED
*                    FROM THE DPL. SINCE SRST DOES NOT CHG THE
*                    BEG OR END POS IF STRING NOT FOUND, WE CAN JUST
*                    GO ONTO PARS.
*              NOTE- IF WE DID FIND THE FIRST NULL, WE WILL BE
*                    ONE BEYOND LAST SIGIFCANT CHAR.
*              EITHER FOUND OR NOT FOUND, REDUCE THE LAST POSN BY 1
         L     R8,SAV_4_SRST    RESTORE BEG ADDR
         SRK   R15,R9,R8        R8 IS FIRST NULL MINUS BEGIN ADDR
         STH   R15,H_MAX_CMD_LEN      GIVES A LENGTH
         J     SRST_NOTFND_DPL_SEP1
*
SRST_NOTFND_DPL_SEP DS 0H
         L     R8,SAV_4_SRST    RESTORE BEG ADDR
         BCTR  R9,0      NULL NOT FND, SO REDUCE END PTR
*
SRST_NOTFND_DPL_SEP1 DS 0H
*              NOTE- R9 DPL CA PTR TO FIRST NULL ADDR OR END ADDR
*                    R6 PTR TO DPL CA START ADDR
*                    H_MAX_CMD_LEN HOLDS LENGTH
         MVC   PARSE_DIRECTN,HMINUS1   SEARCH BACKWARDS
         MVC   PARSE_EQ,HMINUS1        FIND UNEQUAL
         LA    R1,THEPARM
         ST    R8,8(R1)                ST ADDR OF THE HAYSTAK
         LA    R15,H_MAX_CMD_LEN        MAX COMMAND LENGTH IS 80 !!
         ST    R15,12(R1)              ST ADDR OF HAYSTAK LENGTH
         LA    R15,SP1
         ST    R15,0(R1)               ST ADDR OF NEEDLE
         LA    R15,H1
         ST    R15,4(R1)               ST ADDR OF NEEDLE LENGTH
* FIND FIRST NON SPACE STARTING FROM END OF DPL CA
         XR    R15,R15
         JAS   R9,PARS
         LTR   R15,R15
         JZ    BAD_DPL_ALL_SP          NO CMD IN CAL_REMN
*
         SRK   R9,R15,R8      KEEPING R8 AS FIRST CHAR IN DPL CA
*                             R9 IS THE LAST NON SP ADDR. GET LENGTH
         LR    R7,R9
         L     R6,P_MOV_2_DATA_CURPOS       CURPOS IN SCRATCH
         MVCL  R6,R8          MOVE DPL CA TO SCRATCH
         ST    R6,P_MOV_2_DATA_CURPOS       CURPOS IN SCRATCH ADV
         L     R9,P_MOV_2_DATA_LST
DONE_DPL_STP_ERR DS 0H
         CRJL  R9,R6,DPL_FIN_0
         SR    R9,R6
         CIJL  R9,L_TMP_STR_33,OK_DPL_STP
         LA    R9,L_TMP_STR_33
OK_DPL_STP DS 0H
         MVC   TMP_STR_33,SPACE255
         LA    R8,TMP_STR_33         MOVE THE SUFFIX DATA
         MVC   0(8,R8),=C'}RETURN:'       TO POS IN OCA MARKED
         MVC   10(8,R8),TIMER_DPL_SP_JDT    BY REG6
         MVI   18(R8),C' '
         MVC   19(8,R8),TIMER_DPL_SP_TOD
         MVI   27(R8),C')'
         MVC   28(4,R8),LCL_SYSID
         MVI   32(R8),C'>'           SET ALL UP FOR MOVE TO COMMAREA
         LR    R7,R9
         MVCL  R6,R8                 MOV ALL OR PART OF RESPONSE
         ST    R6,P_MOV_2_DATA_CURPOS  NOW POINT AT END OF LAST MOVES
         J     DPL_FIN_0             SUFFIX DATA TO SCRATCH AREA
*
*
DPL_FIN_0 EQU *
NO_DATA_TRLR EQU *
         J     FIN_DPL_STUFF
*
*  WE ONLY CHECK THE COMMAND WHEN WE ARE AT THE TARGET SYSID
NOT_SYSID EQU *
CHK_CMD  EQU  *
         CLC   SAV_CAL_REMN,H4   MIN LNG IS 4
         JL    BAD_CMD_LEN_2_TD
         ICM   R6,B'1111',P_OCA_CURPOS  PTR TO SEP CHAR OR 0
         JZ    NOCA             ILLOGICAL BUT TEST ANYWAY
*        L     R5,DFHEICAP      OK, WHAT IS LEFT IN COMMAREA?
*        SR    R6,R5            SUBT SAV_SEP_ADR FROM CA_BEG
*        CH    R6,SAV_CAL       COMP TO SEE IF ANY CA LEFT
*                               R6 SHOULD BE LESS THAN CALEN
*        JL    NOCA             EQ OR GT CALEN
         L     R5,P_OCA_CURPOS
         CLC   LIT_PING,0(R5)
         JNE   CHK_NXT_CMD
         LA    R5,4(R5)
         ST    R5,P_OCA_CURPOS
*        J     GOT_PING
*
FIN_DPL_STUFF EQU *
GOT_PING EQU   *
         JAS   R9,WRIT_CMD_2_TDQ
*
         L     R6,P_MOV_2_DATA_CURPOS
         MVC   0(74,R6),SPACE255         MOVE SPACES INTO PING MSG
         MVC   0(8,R6),LCL_UID
         MVC   9(20,R6),LCL_UNAME
         MVC   30(4,R6),EIBTRNID
         MVC   35(4,R6),EIBTRMID
         MVC   40(7,R6),TASKNUM+1
         MVC   47(8,R6),=C'(RETURN:'
         LA    R6,55(R6)
         ST    R6,P_MOV_2_DATA_CURPOS
*
         ZAP   MYABSTM,PZERO
         EXEC CICS ASKTIME ABSTIME(MYABSTM)
         EXEC CICS FORMATTIME ABSTIME(MYABSTM)                         *
              YYYYDDD(TIMER_ENT_SP_JDT) DATESEP('-')                   *
              TIME(TIMER_ENT_SP_TOD) TIMESEP(':')
*
         MVC   0(8,R6),TIMER_ENT_SP_JDT
         MVC   9(8,R6),TIMER_ENT_SP_TOD
         MVI   17(R6),C')'
         MVI   18(R6),C'>'
         LA    R6,19(R6)
         ST    R6,P_MOV_2_DATA_CURPOS
         J     DO_RETURN
*
CHK_NXT_CMD    EQU *
*        CHK FOR ANY OTHER COMMANDS, ELSE JUST WRITE TDQ
         CLC   LIT_CEMT,0(R5)
         JE    GOT_CEMT
*
         CLC   LIT_CEDA,0(R5)
         JE    GOT_RDO
*
         CLC   LIT_LINK,0(R5)
         JE    GOT_LINK
*
         JNE   CHK_NXT_CMD1
*
GOT_RDO        EQU *
         LA    R5,5(R5)        POINT AROUND THE CEDC LIT
*
         CLC   LIT_RDO_DIS,0(R5)
         JE    GOT_RDO_DIS
*
         CLC   LIT_RDO_ALT,0(R5)
         JE    GOT_RDO_ALT
*
         CLC   LIT_RDO_DEF,0(R5)
         JE    GOT_RDO_ALT
*
         CLC   LIT_RDO_INS,0(R5)
         JE    GOT_RDO_ALT
*
         CLC   LIT_RDO_EXP,0(R5)
         JE    GOT_RDO_EXP
*
         CLC   LIT_RDO_VIEW,0(R5)
         JE    GOT_RDO_VIEW
         J     RESTRK_CMD
*
GOT_RDO_ALT  EQU *
         LA    R15,LIT_ME_X      END OF TBL ADDR
         LA    R9,LIT_ME         TOP OF TBL
CHK_NXT_ID    EQU  *
         CLC   LCL_UID,0(R9)
         JE    GOT_GD_R_ID
         LA    R9,8(R9)           GO TO NEXT ADDR
*        CR    R9,R15
         CRJL  R9,R15,CHK_NXT_ID   LOOP IF NOT AT END
         CLC   LCL_UID,LCL_APPLID
         JE    GOT_GD_R_ID
         EXEC CICS INQUIRE SYSTEM DFLTUSER(LCL_DEF_UID)
         CLC   LCL_UID,LCL_DEF_UID
         JE    GOT_GD_R_ID
         J     RESTRK_CMD
*
GOT_GD_R_ID  EQU *
GOT_RDO_DIS  EQU *
GOT_RDO_EXP  EQU *
GOT_RDO_VIEW EQU *
         AHI   R5,-5          20090427 SET THE 0CA PTR BACK TO CMD
*
         MVC   PGM_CMD,LIT_DFHEDAP
         J     SETUP_CMD
*
GOT_CEMT       EQU *
         CLC   LIT_INQ,5(R5)
         JE    GOT_INQ
*
         CLC   LIT_SET,5(R5)
         JNE   RESTRK_CMD
*
GOT_INQ  EQU   *
         MVC   PGM_CMD,LIT_DFHEMTA
*
SETUP_CMD EQU  *
         JAS   R9,WRIT_CMD_2_TDQ
*
         JAS   R9,SET_UP_CMD
         LTR   R15,R15
         JNZ   FAIL_SET_UP_CMD1
*
         L     R8,P_CMD_A
         USING CMD_CA,R8
         EXEC CICS LINK PROGRAM(PGM_CMD)                               *
               COMMAREA(CMD_CA)                                        *
               LENGTH(H_DPL_CAL)                                       *
               RESP(FRESP)                                             *
               RESP2(FRESP2)
*
*        CLC   FRESP,DFHRESP(NORMAL)
         DROP  R8
         CLC   FRESP,=F'0'
         JNE   FAIL_SET_UP_CMD0
*
         XR    R15,R15
         L     R9,12(R8)     PTR TO BEG GM CMD WK AREA
         ICM   R15,B'0011',4(R9)  INSERT THE OP INTRPT PHASE RC
         STC   R15,RC
         C     R15,F8
         JNL   FAIL_SET_UP_CMD1   IF GT 7, WE HAD PROB
*
         ICM   R15,B'0011',0(R9)  INSERT THE OP INTRPT PHASE LEN
         JZ    FAIL_SET_UP_CMD0   IF ZERO, WE HAD PROB
*
         ARK   R8,R15,R9    POINT TO THE OP BUFF TOT LEN
         XR    R9,R9
         ICM   R9,B'0011',0(R8)   INSERT OP TOT LNG INTO R9
         AHI   R9,-7              SUBTRACT 7 FOR THIS HDR AREA
*                    WHICH HOLDS 3 HW VALUES FROM THE CMD AND X'15' DLM
*                    IN ORDER TO GET ACTUAL LENGTH OF DATA
         JNP   FAIL_SET_UP_CMD0   IF LE 0, WE HAD PROB
*
         LA    R8,7(R8)           BUMP PAST THAT HDR AREA (SEE ABOVE)
*
         CLC   PGM_CMD,LIT_DFHEDAP
         JE    DONE_DFHEDAP
         J     DONE_DFHEMTA
*
DONE_LINK DS   0H
*    WE COULD DO SPECIAL PROPCESSING FOR CEMT HERE
         J      CMD_DONE
*
DONE_DFHEMTA   DS 0H
*    WE COULD DO SPECIAL PROPCESSING FOR CEMT HERE
         J      CMD_DONE
DONE_DFHEDAP   DS 0H
*    WE COULD DO SPECIAL PROPCESSING FOR CEDA HERE
         J      CMD_DONE
CMD_DONE DS 0H
         MVI   RC,X'F0'
         J     ARND_FAIL
*
RESTRK_CMD     EQU *
         JAS   R9,WRIT_CMD_2_TDQ
*
         LA    R8,LIT_RESTRICTED
         XR    R9,R9
         LA    R9,L'LIT_RESTRICTED
         MVI   RC,C'4'
         J     ARND_FAIL
*
FAIL_SET_UP_CMD0 DS 0H
         LA    r15,8
FAIL_SET_UP_CMD1 DS 0H
         STC   R15,RC
         LA    R8,LIT_FAILED_CMD
         XR    R9,R9
         LA    R9,L'LIT_FAILED_CMD
ARND_FAIL EQU  *
         LH    R7,SAV_CAL
         AHI   R7,-3     SAV_CAL OUR RETURN CA, AND LEN NEEDS TO
*                    BE REDUCED: 1 FOR THE ABOVE RC, 1 TO APPEND THE
*                    X'15' FINAL DLM AFTER THE MVCL, AND THEN ANOTHER 1
*                    BECAUSE WE  APPEND A X'00'. USED AS THE DELM IN A
*                    ASSEMBLER MVST (MOVE UNTIL STRING FOUND INSTRCTN).
*                    IN TOTAL, THAT IS 3. WILL STOP THE STG VIO 200905
*
*              NOTE- R8 POINTS AT THE OP FROM A LINK,CEMT,CEDA CMD
         CRJL  R7,R9,ARND_FAIL_USE_CAL
         LR    R7,R9         USE ERR MSG LENGTH
ARND_FAIL_USE_CAL DS 0H
         LR    R9,R7         USE THE OCA CAL IN SAV_CAL
         L     R6,DFHEICAP
         MVC   0(1,R6),RC
         LA    R6,1(R6)
         MVCL  R6,R8        AT END, R6 IS +1 BEYOND SAV_CAL LNG
         AHI   R6,-2        POINT IT BACK 2
         MVI   0(R6),X'15'    EIBLEN -1 AND EIBLEN -0
         MVI   1(R6),X'00'    STO VIO FIXED 200905
*
         J     DO_FIN
*
*
*
GOT_LINK DS 0H
*              NOTE- LINK CMD MUST LOOK LIKE
*                    LINK=ABCDEFG,
*                    LINK=(ABCDEFG),
*                    LINK(ABCDEFG),
*                  FOLLOWED BY A COMMA AND COMMAREA (IF ANY)
*                  OTHERWISE IT IS AN ERROR
*
         JAS   R9,WRIT_CMD_2_TDQ
*
         LH    R15,SAV_CAL_REMN
*
*        CHI   R15,6                CHECK FOR A MINIMUM LINK=X
*        JL    CHK_NXT_CMD1
         CIJL  R15,6,CHK_NXT_CMD1   TOO SMALL
*
         MVI   SEP,C')'          USE ')' AS DEF SEPERATOR
         LA    R15,2              IMPLIES ), AS LENGTH=2
         STH   R15,PROGRAM_SUFXL
         CLI   4(R5),C'('            LINK(
         JE    OK_LINK5
*
         CLI   4(R5),C'='            LINK=
         JNE   BAD_LINK_CMD          NONE FIT, SO ERROR
*
         CLI   5(R5),C'('            LINK=(
         JE    OK_LINK6
*                               DEFINITELY HAVE SYSID=_
         MVI   SEP,C','             USE COMMA AS SEPARATOR
         LA    R15,1
         STH   R15,PROGRAM_SUFXL
*
OK_LINK5  EQU   *
         LA    R15,5           PRESERVE LNG SYSID= OR SYSID(
         J     CK_CA_LINK_LNG
*
OK_LINK6  EQU   *
         LA    R15,6           PRESERVE LNG SYSID=(
*        J     CK_CA_LINK_LNG
*
CK_CA_LINK_LNG EQU  *
*        LR    R7,R15      %?  SAVE THIS LNG, SO WE CAN SUBT LATER
         LA    R5,0(R15,R5)    POINT OCA CURPOS BEYOND LINK?
         ST    R5,P_OCA_CURPOS    SAVE CURPOS IN OCA
         LH    R1,SAV_CAL_REMN    CHK AGAINS REMN OCA LNG
         SR    R1,R15             BY SUBTRACTING LNG
         STH   R1,SAV_CAL_REMN
*        CHI   R1,9
*        JL    OK_L_LINK
         CIJL  R1,9,OK_L_LINK  DETERMIN IF THE REMAINDER IS LT 9
*                              R1 IS EITHER LT 9 (WHICH WE USE)
         LA    R1,9            OR WE SET IT TO 9
OK_L_LINK EQU  *
* EXTRACT THE PROGRAM NAME; LOOK FOR ')' (IF ( FOUND ABOVE)
*                                 OR ','
*  IF NEITHER FOUND, THEN ASSUME THAT NOCA. LOOK FOR THE
*        PGMNAME DELIMITED BY SPACE OR NOT DELIMITED
*        AS IN THE OCA ONLY CONTAINED THE PGMNAME
*   IF THE PGMNAME LENGTH IS ZERO, THEN THAT IS AN ERROR.
* FIND THE FIRST OCCURANCE OF ENDING CHAR
*              R5 HAS ADDR OF FIRST CHAR FOLLOWING LINK.?
*              R1 HAS ADDR OF LAST SEARCH POS (SEARCH FOR SEP CHAR)
*                 WHICH WE LIMIT TO 9 CHARACTERS OR CAL_REMN
*
*   SRST R0 56-63 HAS BYTE TO SEARCH FOR
*        R1 (FIRST REG) HAS THE ENDING ADDR
*        R2 (2ND   REG) HAS THE STARTING ADDR
*   CHK  JC    MASK,JUMP_TO_REL_ADDR
*        CC  0 8    NOT DEFINED
*            1 4    FOUND, R1 UPDATED WITH BYTE FOUND,R2 UNCHGD
*            2 2    NOT FOUND, R1 AND R2 UNCHANGED
*            3 1    SPIN SEARCH, R1 UNCHGD, R2 POINTS TO NEXT SRCH ADR
*              + THIS IS THE VALUE TO USE IN THE JC INSTR
         LA    R1,0(R5,R1)     ADD 9 TO OCA CURPOS
RETRY_LINK_SRST DS 0H
         LR    R8,R1     RESET LAST POS TO SEARCH OCA
*              WHICH IS POINT AFTER LINK(|LINK=|LINK=(
         LR    R9,R5     RESET TO CURPOS IN OCA
         XR    R0,R0
         IC    R0,SEP    PLACE SEP CHAR INTO BIT 24-31
*
RET_SRST_LINK SRST R8,R9
*
         JC    4,FND_LINK_SEP
         JC    1,RET_SRST_LINK  RE-DRIVE
*              NOTE FIRST PASS, SEP IS EITHER ')' OR ','
         CLI   SEP,C','       DID NOT FIND IT, SO WE WILL SEE IF
         JNE   BAD_LINK_CMD    WE ARE ON FIRST OR SECOND PASS
*                              FIRST PASS, SO RPLACE SEP TO USE SPACE
         MVI   SEP,X'40'         BUT WE WILL TAKE A SPACE AS THE
         LA    R15,1
         STH   R15,PROGRAM_SUFXL
         J     RETRY_LINK_SRST
*
FND_LINK_SEP  EQU   *
*              NOTE - R9 STILL PTR TO BEGIN OF SEARCH
         LR    R15,R8     R8 POINTS AT THE SEP CHAR
         ST    R15,SAV_SEP_ADR SAVE ADDR
         AH    R15,PROGRAM_SUFXL   ADJUST BY SEP LNG 1 OR 2
         ST    R15,P_OCA_CURPOS  NOW POINTS 1 BEYOND SEP CHAR(S)
         SR    R8,R5          BEG PROG  MINUS END POSTN GIVES LNG
         LH    R15,SAV_CAL_REMN   GET REMAINING CA LEN
         SR    R15,R8         SUB PROG  LNG TO GET NEW REM CA LNG
         STH   R15,SAV_CAL_REMN SAVE IT
*
*          R5 STILL POINTS TO FIRST POS IN PGMNAME
         LR    R9,R8
         BCTR  R9,0      REDUCE BY 1 FOR EXECUTE
         MVC   PGM_CMD,SPACE255
         LA    R15,PGM_CMD
*
*MVC_DST_R15_SRC_R5 MVC 0(0,R15),0(R5)
         EXRL  R9,MVC_DST_R15_SRC_R5   MOVE VIA EXECUTE
*
         CLC   PGM_CMD,PGM_CUR
         JE    BAD_LINK_CMD
* NOW HAVE POS BEYOND SEP IN SAV_SEP_ADR
* THIS IS START OF ANY COMMAREA...
* GOT A COMMAREA
*        SO REDUCE IT BY 1, AND MVCL TO THE NEW COMA
         LH    R15,H32400
*        LA    R15,1(R15)        REM V1.91
         ST    R15,F_DPL_CAL
         EXEC CICS GETMAIN FLENGTH(F_DPL_CAL) SET(R8)                  *
               INITIMG(H0)                                             *
               NOSUSPEND                                               *
               RESP(FRESP)                                             *
               RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)
         JNE   BAD_DPL_STG
*
         ST    R8,P_DPL_CA
* SO CHECK SAV_CAL_REMN. IF POS, THEN MVCL TO THE GM COMMAERA
* IF NOT POS, THEN LINK WITHOUT CA
         LH    R9,SAV_CAL_REMN
         CIJNH R9,0,LINK_EMPTY_CA  NOTH LEFT IN OCA TO SEND TO PGM
*                  BUT THIS IS OK, WANT TO RETURN A CA RESP IN OCA
         L     R6,P_OCA_CURPOS
         LR    R7,R9          SAV_CAL_REMN
         MVCL  R8,R6          MOVE ENTIRE ORIG CA TO NEW CA FOR DPL
         L     R8,P_DPL_CA
         LH    R9,H_DPL_CAL
*
LINK_EMPTY_CA DS 0H
         USING CMD_CA,R8
         ZAP   MYABSTM,PZERO
         EXEC CICS ASKTIME ABSTIME(MYABSTM)
         CIJNH R9,0,LINK_NO_CA     no ca to pass
         EXEC CICS LINK PROGRAM(PGM_CMD)                               *
               COMMAREA(CMD_CA)                                        *
               LENGTH(H_DPL_CAL)                                       *
               DATALENGTH(SAV_CAL_REMN)                                *
               RESP(FRESP)                                             *
               RESP2(FRESP2)
*
         DROP  R8
         CLC   FRESP,DFHRESP(NORMAL)
         JNE   BAD_LINK_RESP
*
         ZAP   MYABSTM1,PZERO
         EXEC CICS ASKTIME ABSTIME(MYABSTM1)
*
         EXEC CICS FORMATTIME ABSTIME(MYABSTM)                         *
              YYYYDDD(TIMER_DPL_ST_JDT)  DATESEP('-')                  *
              TIME(TIMER_DPL_ST_TOD)  TIMESEP(':')
         EXEC CICS FORMATTIME ABSTIME(MYABSTM1)                        *
              YYYYDDD(TIMER_DPL_SP_JDT)  DATESEP('-')                  *
              TIME(TIMER_DPL_SP_TOD)  TIMESEP(':')
*
         J     DONE_LINK
*
LINK_NO_CA DS  0H
         EXEC CICS LINK PROGRAM(PGM_CMD)                               *
               RESP(FRESP)                                             *
               RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)
         JNE   BAD_LINK_RESP
*
         ZAP   MYABSTM1,PZERO
         EXEC CICS ASKTIME ABSTIME(MYABSTM1)
*
         EXEC CICS FORMATTIME ABSTIME(MYABSTM)                         *
              YYYYDDD(TIMER_DPL_ST_JDT)  DATESEP('-')                  *
              TIME(TIMER_DPL_ST_TOD)  TIMESEP(':')
         EXEC CICS FORMATTIME ABSTIME(MYABSTM1)                        *
              YYYYDDD(TIMER_DPL_SP_JDT)  DATESEP('-')                  *
              TIME(TIMER_DPL_SP_TOD)  TIMESEP(':')
*       JUMP TO THE RETURN OF A PING LIKE MSG
*
         J     FIN_DPL_STUFF
*
CHK_NXT_CMD1   EQU *
*        CHK FOR ANY OTHER COMMANDS, ELSE JUST WRITE TDQ
*
* NOPE. NO MORE COMMANDS
         MVC   OPLIT(L_NO_VALID_CMD_MSG),NO_VALID_CMD_MSG
*        MVC   OPLIT+1(5),TASK_NUM
         MVC   OPLIT+L_NO_VALID_CMD_MSG1(5),TASK_EIBCAL
         MVC   OPLIT+L_NO_VALID_CMD_MSG2(4),0(R5)
         JAS   R9,WRIT_EMSG_2_TD
         JAS   R9,WRIT_CMD_2_TDQ
         MVI   RC,C'8'        SET RC TO INDICATE INCOMPLETE
         J     DO_RETURN
*
BAD_CMD_LEN_2_TD DS  0H
         MVC   OPLIT(L_BAD_CMD_IP_CA_MSG),BAD_CMD_IP_CA_MSG
*        MVC   OPLIT+1(5),TASK_NUM
         MVC   OPLIT+L_BAD_CMD_IP_CA_MSG1(5),TASK_EIBCAL
         MVC   OPLIT+L_BAD_CMD_IP_CA_MSG2(4),0(R5)
         JAS   R9,WRIT_EMSG_2_TD
         JAS   R9,BASEMSG
*
         J     CHK_RET_OR_FIN
*
MVC_REST_CA MVC OPLIT(0),0(R5)
*
NOCA     EQU   *
         CLC   EIBCALEN,H0
         JE    NOCA_ZERO_LEN
*
         MVC   OPLIT(L_BAD_CMD_IP_CA_MSG),BAD_CMD_IP_CA_MSG
*        MVC   OPLIT+1(5),TASK_NUM
         MVC   OPLIT+L_BAD_CMD_IP_CA_MSG1(5),TASK_EIBCAL
         MVC   OPLIT+L_BAD_CMD_IP_CA_MSG2(4),0(R5)
         L     R5,DFHEICAP
         LH    R9,EIBCALEN
         BCTR  R9,0
         EXRL  R9,MVC_LOWCA
         J     NOCA_WRIT_MSG
NOCA_ZERO_LEN  DS 0H
         MVC   OPLIT(L'NOCA_EMP_IP_CA_MSG),NOCA_EMP_IP_CA_MSG
*        MVC   OPLIT+1(5),TASK_NUM
NOCA_WRIT_MSG  DS 0H
         JAS   R9,WRIT_EMSG_2_TD
         JAS   R9,BASEMSG
*
         J     CHK_RET_OR_FIN
*
MVC_LOWCA MVC   OPLIT+L_BAD_CMD_IP_CA_MSG2(0),0(R5)
*
CHK_RET_OR_FIN DS  0H
*
DO_RETURN EQU  *
         LH    R9,SAV_CAL      check to see if any ca was shipped
         CHI   R9,X'00'        nope. so got to fin
         JNP   DO_FIN
*
         L     R7,P_MOV_2_DATA_CURPOS    IS THERE ANY INFO
         L     R6,P_MOV_2_DATA           TO RETURN FROM
         SR    R7,R6                     GM WORKAREA
         JNP   NO_DATA_2_RTN             IS START EQ TO CUR POS
         ST    R7,P_MOV_2_DATA_LST       CUR POS IS GT (POS)
*
*        L     R8,P_OCA_LSTPOS
*        LR    R9,R8
*        S     R9,P_OCA_CURPOS
*        JNP   NO_DATA_2_RTN
*                             R7 HAS LNG OF THIS PROGRAMS DATA
*                             R9 HAS LNG OF THE ORIG CA
*        CR    R7,R9          SEE IF DATA (R7) FITS IN CA (R9).
*        JL    USE_MOV_2_L
         CRJL  R7,R9,USE_MOV_2_L  DATAL IS LESS THAN RENM CA. MOVE ALL
         MVI   RC,C'1'        MOVE 1 TO RC TO DENOTE PARTIAL RESULT
         LR    R7,R9          USE REMN CA LNG FOR MVCL BELOW
USE_MOV_2_L EQU *
*  ??    L     R8,P_OCA_CURPOS     CURRENT CA POS
         L     R8,P_OCA            ORIG CA START POS
         LR    R9,R7               SET REGS LENGTH EQUAL
         MVCL  R8,R6               MOVE IT TO THE ORIG_CA
*
*                             R8 NOW POINTS TO 1 POS BEYOND DATA IN CA
*                             WE SEE IF IT IS STILL WITHIN THE CA
*              NOTE-R8 NOW POINTS 1 BEYOND DATA MVCL ABOVE.
*                   R8 COULD BE OUT OF ORIG CA BY ONE, SO REDUCE IT
         BCTR  R8,0           WE WANT TO APPEND A NULL VALUE TO CA
         C     R8,P_OCA_LSTPOS     SO THAT C AND C++ PGMS CAN SEE IT
*                                  AS A REGULAR NULL TERMINATED STRING
         JL    ADD1_NULL_2_CA    CUR POS STILL WITH IN CA;
*                             SO WE WILL PLACE NULL IN POS BEYOND
*                             THE RETURNED MSG IN THE ORIG CA
*
         MVI   RC,C'1'        SET RC TO INDICATE INCOMPLETE
         JE    NULL_IT        RETURNING CA FILL. OVERWRITE LAST POSN
*              NOTE-SHOULD NEVER GET HERE. THIS INDICATES THAT THE
*                   MVCL ABOVE MOVED DATA BEYOND THE ORIG CA
         MVI   RC,C'2'        SET RC TO INDICATE INC AND NON-NULL_TERM
         J     CANT_RET_NULL_TERM  RET A NON NULL TERM STRING
*
NO_DATA_2_RTN EQU *
         L     R5,P_OCA       CHECK IF CMD IN ORIG CA
         CLC   LIT_PING,0(R5)       IS PING
         JE    DO_FIN         YES. GO FIN
*
*              NOTE-ORIG CA DID NOT HAVE A VALID CMD (OR CAL=0)
         MVC   OPLIT(L'NO_DATA_2_CA_MSG),NO_DATA_2_CA_MSG
*        MVC   OPLIT+1(5),TASK_NUM
         JAS   R9,WRIT_EMSG_2_TD
         J     DO_FIN
*
ADD1_NULL_2_CA EQU *
*                           ADD 1 BACK TO R8, BECAUSE WE CAN FIT
         LA    R8,1(R8)     THE NULL TERM CHARACT WITHIN ORIG CA
NULL_IT  EQU *
         MVI   0(R8),X'00'  PLACE A NULL AT LAST POS IN ORIG CA
CANT_RET_NULL_TERM EQU *
* ??     L     R8,P_OCA_CURPOS
*              ORIG CA LENG > 0, SO WE CAN ISSUE A RETURN CODE
         L     R8,P_OCA
         MVC   0(1,R8),RC     INSERT THE RETURN CODE
*
DO_FIN   EQU   *
         EXEC  CICS RETURN
*
* ERROR MESSAGES
*
CANT_DO_IT EQU *
         MVC   OPLIT,LIT_CANT_DO_IT
         MVC   OPLIT+24(2),ST_CD
         J     DO_WRITE_TD_ERR
*
BAD_LINK_CMD EQU *
         MVC   OPLIT(L'LIT_BAD_LINK_CMD),LIT_BAD_LINK_CMD
         J     DO_WRITE_TD_ERR
*
BAD_LINK_RESP EQU *
         MVC   OPLIT(L'LIT_BAD_LINK_RSP),LIT_BAD_LINK_RSP
         J     DO_WRITE_TD_ERR
*
ERR_CA_STR EQU *
         MVC   OPLIT(L'LIT_BAD_CA_STR),LIT_BAD_CA_STR
         MVC   OPLIT+38(4),RTE_TO_SYSID
         J     DO_WRITE_TD_ERR
*
BAD_SYSID_RESP EQU *
         MVC   OPLIT,LIT_BAD_SYSID
         MVC   OPLIT+19(4),RTE_TO_SYSID
         J     DO_WRITE_TD_ERR
*
BAD_START EQU *
         MVC   OPLIT,LIT_BAD_START
         J     DO_WRITE_TD_ERR
*
DO_WRITE_TD_ERR EQU *
         JAS   R9,WRTLINE
         JAS   R9,BASEMSG
         J     DO_RETURN
*
* BASEMSG WHEN USES MOSTLY EIB INFORMATION
*
BASEMSG  EQU   *
         ST    R9,SAV_RET_9
*
         EXEC CICS INQUIRE TERMINAL(EIBTRMID)                          *
               NETNAME(TRMNETID)                                       *
               USERNAME(TRMUSRNM)                                      *
               RESP(FRESP)                                             *
               RESP2(FRESP2)
*        CLC   FRESP,DFHRESP(NORMAL)
         MVC   OPLIT(8),TRMNETID
         MVC   OPLIT+9(8),TRMUSRNM
         MVC   OPLIT+18(4),EIBTRNID
         MVC   OPLIT+23(4),EIBTRMID
*        ZAP   P4,EIBTASKN
*        UNPK  C8,P4
*        OI    C8+7,X'F0'
*        MVC   OPLIT+28(7),C8+1
         MVC   OPLIT+28(7),TASKNUM+1
         ZAP   P4,EIBTIME
         UNPK  C8,P4
         OI    C8+7,X'F0'
         MVC   OPLIT+36(2),C8+2
         MVI   OPLIT+38,C'.'
         MVC   OPLIT+39(2),C8+4
         MVI   OPLIT+41,C'.'
         MVC   OPLIT+42(2),C8+6
         MVC   OPLIT+45(8),PGM_CUR
         EXEC CICS INQUIRE PROGRAM(PGM_CUR)                            *
               EXECUTIONSET(PGMAPI)                                    *
               RESP(FRESP)                                             *
               RESP2(FRESP2)
         CLC   PGMAPI,DFHVALUE(FULLAPI)
         JE    FULLAPI
         CLC   PGMAPI,DFHVALUE(DPLSUBSET)
         JNE   NOTAPPL
         MVC   OPLIT+54(9),=C'DPLSUBDET'
         J     BASEMSG_DOWRITTD
NOTAPPL  EQU   *
         MVC   OPLIT+54(9),=C'NOTAPPLIC'
         J     BASEMSG_DOWRITTD
FULLAPI  EQU   *
         MVC   OPLIT+54(7),=C'FULLAPI'
         J     BASEMSG_DOWRITTD
*
BASEMSG_DOWRITTD EQU *
         JAS   R9,WRTLINE
         L     R9,SAV_RET_9     R9 SAVED AT TOP OF BASEMSG
         BR    R9
*
*  GENERIC WRITE TDQ WITH ERROR MESSAGE IN OPLIM10
*   WE CALL WRTLINE WITH A JAS USING R9
WRIT_EMSG_2_TD EQU *
         ST    R9,SAV_RET_9
         MVC   OPLIT+1(5),TASK_NUM
         JAS   R9,WRTLINE
         L     R9,SAV_RET_9
         BR    R9
*
* GENERIC WRITE TDQ WITH MESSAGE IN OPLIM10
*
WRTLINE  DS    0H
         CLC   TDQ_ENA,DFHVALUE(ENABLED)
         JNE   WRTLINE_XIT
         MVC   OPLITM10(8),PGM_CUR
         EXEC  CICS WRITEQ TD QUEUE(TDQ) FROM(OPLITM10) LENGTH(H80)
WRTLINE_XIT DS 0H
         MVC   OPLIT,OPLIT1
         BR    R9
*
* ROUTINE TO WRITE CMD LINE TO TDQ WHEN CEMT,CEDA,LINK,...
* TO PROVE WE GOT WHERE WE WERE SUPPOSE TO GET TO.
WRIT_CMD_2_TDQ DS 0H
         CLC   TDQ_ENA,DFHVALUE(ENABLED)
         JNE   WRIT_CMD_2_TDQ_XIT
*
         ST    R9,SAV_RET_9
         LA    R9,L'UR_RESP
         CH    R9,TDQ_RECLH
         JH    WRIT_CMD_2_TDQ_GO
         STH   R9,TDQ_RECLH
WRIT_CMD_2_TDQ_GO DS 0H
         EXEC  CICS WRITEQ TD QUEUE(TDQ)                               *
               FROM(UR_RESP) LENGTH(TDQ_RECLH)                         *
               RESP(FRESP)                                             *
               RESP2(FRESP2)
         L     R9,SAV_RET_9
WRIT_CMD_2_TDQ_XIT DS 0H
         BR    R9
*
* GM AREA (32402) IS USED AS FOLLOWS
*  PARM TO CALL CONSISTS OF 5 FW ADDRESSES
*   OFFSET X'0'
*     1) PTR TO CMD AREA
*   OFFSET X'4'
*     2) PTR TO CMD HW LENGTH
*   OFFSET X'8'
*     3) PTR TO FLAG BYTE
*   OFFSET X'C'
*     4) PTR TO OUTPUT AREA
*   OFFSET X'10'
*     5) PTR TO OUTPUT AREA LENGTH
*   OFFSET X'14' HOLDS DERIVED HW LNG OF CMD
*   OFFSET X'16' HOLDS FLAG BYTE
*   OFFSET X'18' HOLDS HW LNG OF THE OP AREA (32400-26)
*   OUTPUT AREA STARTS HERE AT
*   OFFSET X'1A'
*     EXPECT OUTPUT DATA AS FOLLOWS
*              PROGRAM USES AS REQUIRED
*          A) 3 HW ????
*          B) 1 HW OUTPUT LENGTH
*          C) 1 HW OUTPUT NUMBER OF LINES
*          D) 1 HW OUTPUT CONDITION CODE
*          E) ACTUAL OUTPUT (EACH LINE HAS PREFIX X'15')
*     WE INSURE LAST TWO BYTES ARE INITIALIZED:
*  OFFSET 32400 - X'15' FORCE 'LAST OUTPUT LINE'
*         32401 - X'00'   USED TO DELIMIT SSTR INSTRUCTION
*
* FW|FW|FW|FW|FW|HW|BY|BY|HW|OPDATA......|BY|BY
*
SET_UP_CMD EQU *
         ST    R9,SAV_RET_9
         LH    R15,H32400
         LA    R15,2(R15)
         ST    R15,F_DPL_CAL
         EXEC CICS GETMAIN FLENGTH(F_DPL_CAL) SET(R8)                  *
               INITIMG(H0)                                             *
               NOSUSPEND                                               *
               RESP(FRESP)                                             *
               RESP2(FRESP2)
*
         CLC   FRESP,DFHRESP(NORMAL)
         JNE   BAD_CMD_STG
*
         ST    R8,P_CMD_A       SAVE PTR TO THIS GM AREA
         ST    R5,0(R8)      %? SAVE PTR TO COMMAND
         LH    R15,SAV_CAL_REMN
         CH    R15,MAX_CMD_LEN
         JL    SET_UP_USE_CAL_REMN
         MVC   H_MAX_CMD_LEN,MAX_CMD_LEN  USE DEFAULT
         J     SET_UP_USE_DFT_DML_LEN
SET_UP_USE_CAL_REMN DS 0H
         STH   R15,H_MAX_CMD_LEN   USE CAL_REMN AS SEARCH LENGTH
SET_UP_USE_DFT_DML_LEN DS 0H
*   SRST R0 56-63 HAS BYTE TO SEARCH FOR
*        R1 (FIRST REG) HAS THE ENDING ADDR
*        R2 (2ND   REG) HAS THE STARTING ADDR
*   CHK  JC    MASK,JUMP_TO_REL_ADDR
*        CC  0 8    NOT DEFINED
*            1 4    FOUND, R1 UPDATED WITH BYTE FOUND,R2 UNCHGD
*            2 2    NOT FOUND, R1 AND R2 UNCHANGED
*            3 1    SPIN SEARCH, R1 UNCHGD, R2 POINTS TO NEXT SRCH ADR
*              + THIS IS THE VALUE TO USE IN THE JC INSTR
         LA    R0,0             CLEAR R0  LOOK FOR NULL
         LA    R15,0(R15,R5)    BUMP OCA BEYOND LAST SEARCH CHAR
         ST    R5,SAV_4_SRST
SET_UP_LOOK_FOR_NULL SRST R15,R5
         JC    4,SET_UP_KEEP_NULL_LNG      FOUND
         JC    2,SET_UP_NO_NULLS     NOT FOUND. SPACE FILL?
         JC    1,SET_UP_LOOK_FOR_NULL      SPIN
SET_UP_KEEP_NULL_LNG EQU *
         L     R5,SAV_4_SRST    RESTORE BEGINNING
         SR    R15,R5           GET SEARCH LENGTH
         STH   R15,H_MAX_CMD_LEN   SAVE LNG
SET_UP_NO_NULLS EQU *
* WANT TO FIND THE FIRST CHAR IN PASSED COMMAREA THAT IS NOT A SPACE
*    IN ORDER TO DETERMINE THE ACCURATE COMMAND LENGTH
* USE THE PARS ROUTINE TO FIND, SEARCHIN BACKWARDS
         L     R5,0(R8)           GET START OF CMD BACK INTO R5 FROM
*                                 SAVED PTR (ABOVE) IN THIS GM AREA
*                                 POINTS TO THE OCA CURPOS
         MVC   PARSE_DIRECTN,HMINUS1   SEARCH BACKWARDS
         MVC   PARSE_EQ,HMINUS1        FIND UNEQUAL
         LA    R1,THEPARM
         ST    R5,8(R1)                ST ADDR OF THE HAYSTAK
         LA    R15,H_MAX_CMD_LEN        MAX COMMAND LENGTH IS 80 !!
         ST    R15,12(R1)              ST ADDR OF HAYSTAK LENGTH
         LA    R15,SP1
         ST    R15,0(R1)               ST ADDR OF NEEDLE
         LA    R15,H1
         ST    R15,4(R1)               ST ADDR OF NEEDLE LENGTH
* FIND FIRST NON SPACE STARTING FROM END OF CA
         XR    R15,R15
         JAS   R9,PARS
         LTR   R15,R15
         JZ    BAD_CMD_ALL_SP          NO CMD IN CAL_REMN
*
*  CHECK CMD_CA FOR ACCURATE CEDA CALL TSR3.2 20090427
*
         L     R8,P_CMD_A       LOAD ADDR OF THE GM (ABOVE) CMD CA
*
         LA    R15,1(R15)       ADD 1 AND SUBTRACT CMD END ADDR TO
         SR    R15,R5           DERIVE LNG OF CMD (R15 IS SRCH RSLT)
*                               AND R5 IS THE OCA CURPOS
         CH    R15,H8           GOT CMD LNG. CHK FOR MIN LNG
         JL    BAD_CMD_LEN
         STH   R15,20(R8)      SAVE THE COMMAND LENGTH AT 20 20090427
         LA    R15,20(R8)       STORE PTR TO THEI CMD LNG ADDR
         ST    R15,4(R8)        SAVE PTR TO COMMAND OP AREA BEGIN
*
         MVI   22(R8),X'00'
         LA    R15,22(R8)       DEFAULT COMMAND LENGTH TO REST OF CA
         ST    R15,8(R8)        SAVE PTR TO COMMAND OP LNG
*
         LA    R15,26(R8)       POINT PAST THE CEDAPARM (5 FW ADDR)
         ST    R15,12(R8)        SAVE PTR TO COMMAND OP AREA BEGIN
*
         LH    R15,H32400       OUTPUT AREA LNG MINUS 26
         AHI   R15,-26            20 FOR 5 FW PARMS, 2 FOR HW CMD LNG
         STH   R15,24(R8)         2 FOR FLG/FILL, 2 FOR OP HW LNG
         LA    R15,24(R8)       POINT PAST THE CEDAPARM (5 FW ADDR)
         ST    R15,16(R8)        SAVE PTR TO COMMAND OP AREA BEGIN
*
         A     R8,F32400         POINT TO LAST-1 POS IN GM AREA
         CLC   PGM_CMD,LIT_DFHEDAP
         JNE   GOT_DFHEMTA
         MVI   1(R8),X'00'    FORCE BUFFER END FOR SRST VALUE
         J     ARND_DFHEMTA
GOT_DFHEMTA    EQU *
         MVI   1(R8),X'15'    MOVE X'15' CEMT DELM
ARND_DFHEMTA   EQU *
         MVI   2(R8),X'00'    MOVE X'00' (SRST) DELIMITER
         XR    R15,R15          RETURN 0
         J     RET_SET_UP_CMD
BAD_CMD_LEN    EQU *
BAD_CMD_ALL_SP EQU *
BAD_CMD_STG    EQU *
         L     R15,FMINUS1       SET RET CODE TO -1
RET_SET_UP_CMD EQU *
         L     R9,SAV_RET_9
         BR    R9

**
* GENERALIZED STRING PARSER
*  EXPECTS PARM LIST OF LENGTH X'10' TO BE PASSED IN REG1
*   1ST FW PTR TO STRING TO BE SEARCHED FOR (NEEDLE)
*   2ND FW PTR TO HW LENGTH OF STRING TO BE SEARCHED FOR (NEEDLE)
*   3RD FW PTR TO STRING TO BE SEARCHED     (HAYSTACK)
*   4TH FW PTR TO HW LENGTH OF STRING TO BE SEARCHED
*  RETURN REG 15
*    0 IF NOT FOUND
*    ADDRESS OF FIRST FIND OR NOT FOUND
*  PARSE_DIRECTN SET TO +1 FOR FOWARD SEARCH
*                       -1 FOR BACKWARD SEARCH
*  PARSE_EQ      SET TO  0 FOR STOP WHEN EQUAL FOUND
*                       -1 FOR STOP WHEN NOTEQUAL FOUND
* GENERALIZED STRING PARSER
**
PARS     EQU   *
         STM   R0,R12,PARS_REG_SA
         LTR   R1,R1               REG1 MUST NOT BE NULL
         JZ    NOPARM              addr of 1st of 4 fw ptrs
*
         ICM   R4,B'1111',0(R1)    FIRST PTR TO NEEDLE
         JZ    NOPARM
         ICM   R5,B'1111',4(R1)    BUMP TO NXT ADDR,POINT TO
         LH    R5,0(R5)            HW LNG OF NEEDLE
         LTR   R5,R5
         JZ    NOPARM
         ICM   R6,B'1111',8(R1)    BUMP PAST FIRST TWO ADDR FOR ADDR
         JZ    NOPARM              OF HAYSTACK
         ICM   R7,B'1111',12(R1)   FINALLY BUMP TO LAST ADDR TO GET
         LH    R7,0(R7)            PTR TO HW HAYSTACK ADDR
         LTR   R7,R7
         JZ    NOPARM
*        CR    R5,R7              NEEDLE LNG GT HAY LNG
*        JH    NOPARM
         CRJH  R5,R7,NOPARM
*
         SR    R7,R5          REDUCE THE HAYS LNG BY NEEDLE LNG TO
*                              LIMIT THE COMPARE OF LAST ADDR
         LR    R8,R6          PRESERVE HAYS ADDR
         AR    R8,R7          ADD IN HAYS LNG FOR FINAL POS
         BCTR  R5,0            REDUCE FOR EXECUTE
         LH    R15,PARSE_DIRECTN +1 OR -1
         CHI   R15,0
         JNL   CLCLOOP
         LR    R0,R8          SWAP FOR NEG DIRECTN
         LR    R8,R6           START AT LAST POSN AND END AT FIRST
         LR    R6,R0
CLCLOOP  EQU   *
         CLC   PARSE_EQ,H0
         JNE   DO_UNEQ
*
         EXRL  R5,CLCPARSE     CLC   0(0,R6),0(R4)
         JE    NEEDLEF
         J     CLC_NEXT
*
DO_UNEQ  EQU   *
         EXRL  R5,CLCPARSE     CLC   0(0,R6),0(R4)
         JNE   NEEDLEF
*
CLC_NEXT EQU   *
         AR    R6,R15
         LTR   R15,R15
         JNP   DO_NEG_DIR_TST
*        CR    R6,R8
*        BNH   CLCLOOP
         CRJNH R6,R8,CLCLOOP
         J     NOPARM
*
DO_NEG_DIR_TST EQU *
*        CR    R6,R8
*        JNL   CLCLOOP
         CRJNL R6,R8,CLCLOOP
         J     NOPARM
*
NOPARM   EQU   *
         XR    R15,R15
         J     DONEPGM
*
NEEDLEF  EQU   *
         LR    R15,R6
*
DONEPGM  EQU   *
*              RESET THE PARS DEFAULTS
         XC    PARSE_DIRECTN,PARSE_DIRECTN
         MVI   PARSE_DIRECTN+1,X'01'
         XC    PARSE_EQ,PARSE_EQ
         LM    R0,R12,PARS_REG_SA
         BR    R9
*
***
B2C      EQU   *              CVT BIN TO READABLE TEXT
         CVD   R15,DWORD
         UNPK  HLDSTR,DWORD+4(4)
         OI    HLDSTR+6,X'F0'
         XR    R15,R15
         BR    R9
***
X2CX     EQU   *
         ST    R15,FOUR
         UNPK  EIGHT(9),FOUR(5)
         XC    EBCDCFLD,EBCDCFLD
         MVN   EBCDCFLD(8),EIGHT
         TR    EBCDCFLD,ERRTRAN
         BR    R9
*
*
* SUBROUTINE TO SEARCH CA FOR A SEP CHAR
* EXPECT R6 AS BRANCH REG
*        R8 AS ADR OF THE HAYSTACK
*        R9 IS THE LENGTH OF THE HAYSTACK
*    USE R0, R1, R6, R7
*    RETURN R9 AS POINT THAT SEP FND OF 0 IF NF
LOOK_4_SEP EQU  *
         ST    R6,SAV_SEP_6
         LA    R6,SEP    SEPARATER CHARACTER
         LA    R7,0      SET R7 SO THAT WE USE THE PAD CHAR
         LA    R0,1      R0 IS SET TO LNG OF 1 FOR CUSE LENGTH
         XR    R1,R1
         IC    R1,SEP    PLACE SEP CHAR INTO BIT 24-31
RET_CUSE_SEP_LOOP EQU *
         CUSE  R8,R6     LOOK FOR SEP
         JZ    SEP_FND      CC 0 OR BC 8
         BO    RET_CUSE_SEP_LOOP
         CLI   SEP,C','             IF SYSID=____, WE LOOK FOR A ','
         JNE   SEP_CHAR_NF
         CLI   0(R8),X'40'         BUT WE WILL TAKE A SPACE AS THE
         JE    SEP_FND             DELIMETER
SEP_CHAR_NF  EQU   *
         XR    R9,R9
*
SEP_FND  EQU   *
         L     R6,SAV_SEP_6
         BR    R6
*
*
MVC_DST_R15_SRC_R5 MVC 0(0,R15),0(R5)
CLCPARSE CLC   0(0,R6),0(R4)
*
         LTORG
F32400   DC    F'32400'
         ORG   *-2
H32400   DS    H
F4080    DC    F'4080'
         ORG   *-2
H4080    DS    H
F80      DC    F'80'
         ORG   *-2
H80      DS    H
*
MAX_CMD_LEN DC H'80'
*
F16      DC    F'16'
         ORG   *-2
H16      DS    H
F10      DC    F'10'
         ORG   *-2
H10      DS    H
F8       DC    F'8'
         ORG   *-2
H8       DS    H
F4       DC    F'4'
         ORG   *-2
H4       DS    H
F1       DC    F'1'
         ORG   *-2
H1       DS    H
F0       DC    F'0'
         ORG   *-2
H0       DS    H
FMINUS1  DC    F'-1'
         ORG   *-2
HMINUS1  DS    H
TOD_SEP  DC    CL1':'
SP1      DC    CL1' '
PZERO    DC    PL1'0'
*
LIT_DPL_D DC   CL2'D '
*D     A DISTRIBUTED PROGRAM LINK (DPL) REQUEST THAT DID NOT SPECIFY
*      SYNCONRETURN OPTION. THE TASK CANNOT ISSUE I/O REQUESTS AGAINST
*      PRINCIPAL FACILITY, NOR CAN IT ISSUE ANY SYNCPOINT REQUESTS.
LIT_DPL_DS DC  CL2'DS'
*DS    A DISTRIBUTED PROGRAM LINK (DPL) REQUEST, AS IN CODE D, THAT DID
*      SYNCONRETURN OPTION. THE TASK CAN ISSUE SYNCPOINT
*      REQUESTS.
LIT_TDQ_QD DC  CL2'QD'
*QD    TRANSIENT DATA TRIGGER LEVEL.
LIT_ST_S  DC  CL2'S '
*S     START COMMAND WITHOUT DATA.
LIT_ST_SD  DC  CL2'SD'
*SD    START COMMAND WITH DATA.
LIT_FP_SZ  DC  CL2'SZ'
*SZ    FEPI START COMMAND.
LIT_TERM_TD DC  CL2'TD'
*TD    TERMINAL INPUT OR PERMANENT TRANSID.
LIT_USER_U  DC  CL2'U '
*U     USER-ATTACHED TASK.
*
LIT_DFHEMTA DC CL8'DFHEMTA'
LIT_DFHEDAP DC CL8'DFHEDAP'
LIT_INQ  DC    C'INQ'
LIT_SET  DC    C'SET'
LIT_CEMT DC    C'CEMT'
LIT_CEDA DC    C'CEDA'
LIT_RDO_DIS DC    C'DISPLAY'
LIT_RDO_ALT DC    C'ALTER'
LIT_RDO_EXP DC    C'EXPAND'
LIT_RDO_INS DC    C'INSTALL'
LIT_RDO_DEF DC    C'DEFINE'
LIT_RDO_VIEW DC   C'VIEW'
*
LIT_TTERMSVR DC CL4'TT01'
LIT_PTERMSVR DC CL4'PT01'
SPACE255 DC    CL255' '
SSTR_DELM DC   XL1'FF'
LIT_SYSID_EP DC   CL(7)'SYSID=('
             ORG  LIT_SYSID_EP
LIT_SYSID_E  DS   CL(6)
             ORG  LIT_SYSID_EP+L'LIT_SYSID_EP
LIT_PING     DC   C'PING'
LIT_LINK     DC   C'LINK'
LIT_PROGRAM_EP DC   CL(7)'PROGRAM=('
             ORG  LIT_PROGRAM_EP
LIT_PROGRAM_E  DS   CL(6)
             ORG  LIT_PROGRAM_EP+L'LIT_PROGRAM_EP
RIGHT_PARENT DC   CL1')'
ERRTRAN  DC    X'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
DPL_STP_ERRMSG DC CL33'}RETURN:UNKNOWN)>'
LIT_CANT_DO_IT DC C'#     *ERROR*START CODE>  < INVREQ ASSIGN FUNCTION.X
               ABORTING TRANSACTION.'
*                  #     *ERROR*
LIT_BAD_LINK_CMD DC C'#     *ERROR* LINK COMMAND INVALID'
LIT_BAD_LINK_RSP DC C'#     *ERROR* LINK COMMAND FAILED WITH ERROR RESPX
               ONSE. ABORT TRANSACTION.'
LIT_BAD_CA_STR DC C'#     *ERROR* COMMAREA EMPTY OR HAS INVALID DATA.'
LIT_BAD_DPL   DC C'#     *ERROR* DPL OF UCEMPINN TO SYSID ____ FAILED.'
LIT_BAD_DPL_ALL_SP DC C'#     *ERROR* DPL OF UCEMPINN TO SYSID ____ RETX
               URNED EMPTY COMMAREA.'
LIT_BAD_START DC C'#     *ERROR* GETMAIN OF SCRATCH AREA GETMAIN FAILEDX
               .ABORT TRANSACTION.'
LIT_BAD_SYSID DC C'#     *ERROR* SYSID ____ INVALID. THIS LOCAL REGION X
               NOT CONN TO REMOTE SYSID.'
LIT_FAILED_CMD DC C'{CALL TO EXECUTE COMMAND FAILED. RETURN NO DATA'
LIT_RESTRICTED DC C'{CALL TO EXECUTE COMMAND RESTRICTED.'
CA_RET_BAD_LIT DC C'8{COMMAREA NOT RETURNED OR DPL ERROR}'
CA_RET_SBZ_LIT DC C'8{ALL SESSION LINKS TO SYSID BUSY. TRY LATER?}'
CA_RET_SRL_LIT DC C'8{ALL SESSION LINKS TO SYSID RELEASED.}'
NO_DATA_2_CA_MSG DC C'#     *ERROR* NO DATA GENERATED IN COMMAREA FOR RX
               ETURN TO CALLER!'
NOCA_EMP_IP_CA_MSG  DC C'#     *ERROR* NO INPUT COMMAREA COMMAREA FROM X
               CALLER!>'
*
BAD_CMD_IP_CA_MSG DC C'#     *ERROR* NO VALID DATA INCOMING COMMAREA FRX
               OM CALLER! CAL>'
L_BAD_CMD_IP_CA_MSG1 EQU *-BAD_CMD_IP_CA_MSG
          DC C'     < CA>'
L_BAD_CMD_IP_CA_MSG2 EQU *-BAD_CMD_IP_CA_MSG
          DC  C'    <'
L_BAD_CMD_IP_CA_MSG  EQU *-BAD_CMD_IP_CA_MSG
*
NO_VALID_CMD_MSG DC C'#     *ERROR* NO VALID COMMANDS IN COMMAREA FROM X
               CALLER! CAL>'
L_NO_VALID_CMD_MSG1 EQU *-NO_VALID_CMD_MSG
          DC  C'     < CA>'
L_NO_VALID_CMD_MSG2 EQU *-NO_VALID_CMD_MSG
          DC  C'    <'
L_NO_VALID_CMD_MSG  EQU *-NO_VALID_CMD_MSG
*
TEST_PATTERN_AREA DC   X'4a',C'.<(+',X'4f50',C'!$*);^-/|,%_>?`:#@''="',X
               C'abcdefghijklmnopqr~stuvwxyz{ABCDEFGHI}JKLMNOPQR\STUV',X
               C'WXYZ0123456789'
L_TEST_PATTERN_AREA EQU *-TEST_PATTERN_AREA
*
         DC    0D,C'********'
PROGNAME DC    C'UCEMPINN'
         DC    C' * '
PROGVER  DC    C'V1.9'
         DC    C' * '
         DC    C'DATE='
         DC    C'&SYSDATE'
         DC    C' '
         DC    C'TIME='
         DC    C'&SYSTIME'
         DC    C' '
LIT_ME   DC    CL8'TCEM'
         DC    CL8' '
LIT_ME_X equ   *
         DC    C'********'
         END
###END UCEMPINN
$$$BEG INITINC2
* THE FOLLOWING ARE USUAL FIELDS USED BY STANDARD EXAMPLE CODE
SAVR1_10 DS    10F
SAV_R3R9 DS    7F
X2CX49   DS    6F
SAVR9    DS    F
SAVRD    DS    F
MSGAREA1 DS    CL1
MSGAREA  DS    CL132
SAV_MSGAREA  DS    CL(L'MSGAREA)
* END OF USUAL FIELDS USED BY STANDARD EXAMPLE CODE
###END INITINC2
$$$BEG INITINCL
* THE FOLLOWING ARE USUAL FIELDS USED BY STANDARD EXAMPLE CODE
SAVR1_10 DS    10F
SAV_R3R9 DS    7F
X2CX49   DS    6F
SAVR9    DS    F
SAVRD    DS    F
* THE FOLLOWING ANCHORS MY STKSTG MACRO
STG_STAK_REGS DS 20F    STD REG SA
PTR_STG_STAKB DS F
PTR_STG_STAKA DS F
* THE FOLLOWING ANCHORS MY DCB WORKAREA
PTR_DCB_WORKAREA DS F
*
SAV_MSIN_DCB     DS F
SAV_SYSPR_DCB    DS F
*
H_SYSPRINT_LRECL DS H
H_SINCT  DS    H
*
HLD_REG  DS    F    USED FOR DUMP_REG
SAV_DUMP_REGS_R0RF DS 16F USED TO DUMP ALL REGS
*
DWORD    DS    D
$DBLWD   DS    D
EBCDCFLD DS    D
HEXFIELD DS    F
         DS    F
WRTMSG_SAVR10_1 DS 8F
WRTSTR_SAVR8_10 DS 3F
WRTSTR_LLNG   DS H
*
TIOTADR  DS    F
$TIMEB   DS    F
$DATEB   DS    F
FOUR     DS    CL4,C
HLDSTR   DS    CL7
EIGHT    DS    CL8,C
XC       DS    XL1
JOBNAME  DS    CL8
$DATE    DS    CL8
$TIME    DS    CL8
MSGAREA1 DS    CL1
MSGAREA  DS    CL132
SAV_MSGAREA  DS    CL(L'MSGAREA)
* END OF USUAL FIELDS USED BY STANDARD EXAMPLE CODE
###END INITINCL
$$$BEG EXPLKKRY
*  insert into kix dyn stg
sav_mbl_val ds  f        save number of bits for sha klmd
*
X2CX49   DS    6F
X2CX_PRM_ADR DS 0F
X_FROM_A DS    F
X_FROM_L_A DS  F
X_TO_A   DS    F
X_TO_L_A DS    F
*
FROM_HEX_STR_L  DS    H      hold lng of x src
TO_CHAR_STR_L   DS    H      hold lng od cx dest
*FROM_HEX_STR  DS    XL40
*TO_CHAR_STR   DS    XL80
*
EBCDCFLD DS    D         8 character x string used by x2cx
*
*
MYCHAR  DS XL9 CHAR DATA
*
MYXSTR  DS XL4  CHAR DATA
MYXSTR1 DS XL1
*
WORK    DS XL9 CHAR DATA
*
MYHEX2  DS XL5 BACK TO HEX
*
*
*
*  KRY parms
beg_msg_a  ds  f  HOLD THE ADDR OF THE CN DATA IN STG
beg_msg_l  ds  f  HOLD THE FLENGTH OF THE CN DATA
*
KLMDF1_parm ds 5f'-1'    parm area for sha-1 md 28 bytes or 224bits
KIMDF1_parml equ *-KLMDF1_parm
KLMDF1_mbl  ds 2f'0'     parm area for sha-1 mbr bitlength
*  20 bytes for iv value plus 8 bytes for msg bit lng area
KLMDF1_parml equ *-KLMDF1_parm
*
KLMDF1_x2cxl ds  cl(KIMDF1_parml*2)
*
KLMDF2_parm ds  8f'-1'    parm area for sha256md 40 bytes or 320bits
KIMDF2_parml equ *-KLMDF2_parm
KLMDF2_mbl  ds  2f'0'     parm area for sha256md mbr bit length
*  32 bytes for iv value plus 8 bytes for msg bit lng area
KLMDF2_parml equ *-KLMDF2_parm
*
KLMDF2_x2cxl ds  cl(KIMDF2_parml*2)
*
KLMDF3_parm ds 16f'-1'    parm area for sha512md 80 bytes or 640bits
KIMDF3_parml equ *-KLMDF3_parm
KLMDF3_mbl  ds  4f'0'     parm area for sha512md mbr bit length
*  64 bytes for iv value plus 16 bytes for msg bit lng area
KLMDF3_parml equ *-KLMDF3_parm
*
KLMDF3_x2cxl ds  cl(KIMDF3_parml*2)
*
* kix code
         getmain r,lv=worksize
         st    13,4(1)
         lr    13,1
         using (wareas,wareasend),13
*  ...
do_crying ds 0h
do_msg_dg ds 0h
*  kimd/klmd COMPUTE INTERMEDIATE MESSAGE/LAST DIGEST
*  Reg0 0-56 zeroes 57-63 function code
*  Reg1 - adr of parm block
*  even odd pair r1/r1+1 is not used
*                r2/r2+1
*                   r2 adr of msg
*                   r2+1 lenght of msg (32bit unsigned)
*                (r2 incr by each bye processed)
*                (r2+1 lng is decr as each byte processed0
* For COMPUTE INTERMEDIATE MESSAGE DIGEST, normal completn occurs when
* number of bytes in the second operand as specified in general reg
* R2+1 have been processed. For COMPUTE LAST MESSAGE DIGEST, after all
* bytes in the second operand as specified in general register R2+1 has
* been processed, the padding operation is performed, and then normal
* completion occurs.
*  normal completion, condition code 0 (r2+1 is zero)
*  partial compltion, condition code 3 (r2+1 is non zero)
*  completion, condition code 3 is set and the resulting
*  value in R2 + 1 is nonzero.
*
*
*        xr   0,0     holds function code
*        xr   2,2     even reg, dest
*        xr   3,3     odd reg, not used
*        xr   4,4     even reg, holds src
*        xr   5,5     odd reg, hold length of both area (equal lng)
* here we go with a func 1 call for sha_1
         iilf r0,1     move func x'01' to r0
         la   r1,KLMDF1_parm
         xc   0(KLMDF1_parml,r1),0(r1)  empty parm
         mvc  0(sha_1_icv_l_equ,r1),sha_1_icv_H0  icv for sha1
         l    r4,beg_msg_a     load the msg adr of the cn
         l    r5,beg_msg_l     load the msg lng of th ecn
         iihf r5,0             zero the high reg
         sllg r5,r5,3          shift low reg left 3 (mult by 8)
         st   r5,sav_mbl_val   save this value
         st   r5,KLMDF1_mbl+4   store into parm list
         l    r5,beg_msg_l     load the msg lng (again)
*   CHK  JC    MASK,JUMP_TO_REL_ADDR
*        CC>>0 8    normal completion
*            1 4    not defined
*            2 2    not defined
*            3 1    partial completion; jmp to retry
*              + MASK IS THE VALUE TO USE IN THE JC INSTR
klmd_lop klmd R2,R4
         jc   1,klmd_lop
         cijne r5,0,klmd_lop
*  if we are here, then we are done
         IILF  R15,KIMDF1_parml
         STH   R15,FROM_HEX_STR_L
         AR    R15,R15
         STH   R15,TO_CHAR_STR_L
*
         LA    R15,FROM_HEX_STR_L
         ST    R15,X_FROM_L_A
         LA    R15,KLMDF1_parm
         ST    R15,X_FROM_A
         LA    R15,TO_CHAR_STR_L
         ST    R15,X_TO_L_A
         LA    R15,KLMDF1_x2cxl
         ST    R15,X_TO_A
         LA    R15,X2CX_PRM_ADR
         jas  r9,x2cx
* put container
* here we go with a func 1 call for sha_256
         iilf r0,2     move func x'01' to r0
         la   r1,KLMDF2_parm
         xc   0(KLMDF2_parml,r1),0(r1)
         mvc  0(sha_256_icv_l_equ,r1),sha_256_icv_H0
         l    r4,beg_msg_a
         iilf r5,beg_msg_l
         mvc  KLMDF2_mbl+4,sav_mbl_val
*   CHK  JC    MASK,JUMP_TO_REL_ADDR
*        CC>>0 8    normal completion
*            1 4    not defined
*            2 2    not defined
*            3 1    partial completion; jmp to retry
*              + MASK IS THE VALUE TO USE IN THE JC INSTR
klmd_lop2 klmd 2,4
         jc   1,klmd_lop2
         cijne r5,0,klmd_lop2
*  if we are here, then we are done
         IILF  R15,KIMDF2_parml
         STH   R15,FROM_HEX_STR_L
         AR    R15,R15
         STH   R15,TO_CHAR_STR_L
*
         LA    R15,FROM_HEX_STR_L
         ST    R15,X_FROM_L_A
         LA    R15,KLMDF2_parm
         ST    R15,X_FROM_A
         LA    R15,TO_CHAR_STR_L
         ST    R15,X_TO_L_A
         LA    R15,KLMDF2_x2cxl
         ST    R15,X_TO_A
         LA    R15,X2CX_PRM_ADR
         jas  r9,x2cx
* put container
* here we go with a func 3 call for sha_512
         iilf r0,3     move func x'03' to r0
         la   r1,KLMDF3_parm
         xc   0(KLMDF3_parml,r1),0(r1)
         mvc  0(sha_512_icv_l_equ,r1),sha_512_icv_H0
         larl r4,beg_msg
         iilf r5,beg_msg_l_equ
         mvc  KLMDF3_mbl+12,sav_mbl_val
*   CHK  JC    MASK,JUMP_TO_REL_ADDR
*        CC>>0 8    normal completion
*            1 4    not defined
*            2 2    not defined
*            3 1    partial completion; jmp to retry
*              + MASK IS THE VALUE TO USE IN THE JC INSTR
klmd_lop3 klmd 2,4
         jc   1,klmd_lop3
         cijne r5,0,klmd_lop3
*  if we are here, then we are done
         IILF  R15,KIMDF3_parml
         STH   R15,FROM_HEX_STR_L
         AR    R15,R15
         STH   R15,TO_CHAR_STR_L
*
         LA    R15,FROM_HEX_STR_L
         ST    R15,X_FROM_L_A
         LA    R15,KLMDF3_parm
         ST    R15,X_FROM_A
         LA    R15,TO_CHAR_STR_L
         ST    R15,X_TO_L_A
         LA    R15,KLMDF3_x2cxl
         ST    R15,X_TO_A
         LA    R15,X2CX_PRM_ADR
         jas  r9,x2cx
* put container
*  if we are here, then we are done
         j    doterm
*
*
* at termination:
*
err0     ds    0h
         la    15,8
*
* convert value in r15 to %02x display x string in EBCDCFLD
*
X2CX     EQU   *
         STM   R4,R9,X2CX49
         LTR   R4,R15
         JNP   NO_X2CX
*
         L     R5,4(R4)          GET PTR TO HW X SRC LNG
         XR    R6,R6
         ICM   R6,B'0011',0(R5)  GET THE LNG
         JNP   NO_X2CX
*
         L     R5,12(R4)          GET PTR TO HW X SRC LNG
         XR    R7,R7
         ICM   R7,B'0011',0(R5)  GET THE LNG
         JNP   NO_X2CX
*
         SLL   R6,1              MULTIPLY BY 2
         CRJNE R6,R7,BAD_X2CX
*
         SRL   R6,1              GET ORIGINAL VALUE BACK
*
         L     R5,8(R4)       GET ADR OF THE TGT CHAR FLD
         L     R4,0(R4)          GET ADR OF SRC HEX FLD
         LA    R9,TABLE     TRANSLATE TO CHAR FORM
         AHI   R9,-240
*
CONVERT  EQU   *
         CIJL  R6,4,CONVERT1
         MVC   MYXSTR(4),0(R4)
         UNPK  MYCHAR,MYXSTR(5) UNPACK HEX STREAM
         TR    MYCHAR,0(R9)     TRANSLATE TO CHAR FORM
         MVC   0(8,R5),MYCHAR
         AHI   R5,8
         AHI   R4,4
         AHI   R6,-3
         J     CONVERT2
CONVERT1 DS    0H
         XR    R8,R8            CLEAR REG
         IC    R8,0(R4)         INSERT CHAR IN 25-32
         SRDL  R8,4             SHIFT OUT 29-32 INTO R9
         STC   R8,0(R5)         STORE SHIFTED 25-28 AS X'0X'
         TR    0(1,R5),HEXTRAN  TRANSLATE ALL 00 THRU 0F
*                                     TO->    F0 - F9,C1 - C6
         LA    R5,1(R5)         ADVANCE PTR TO NEXT POS
         XR    R8,R8            CLEAR REG
         SLDL  R8,4             SHIFT IN THE 29-32
         STC   R8,0(R5)         STORE IT
         TR    0(1,R5),HEXTRAN  TRANSLATE ALL 00 THRU 0F TO
*                                     TO->    F0 - F9,C1 - C6
         LA    R5,1(R5)         ADVANCE ANOTHER
         LA    R4,1(R4)         ADVANCE NEXT
CONVERT2 DS    0H
         JCT   R6,CONVERT       REDUCE COUNTER
*
         XR    R15,R15
         J     OK_X2CX
BAD_X2CX EQU   *
         LA    R15,8
         J     OK_X2CX
NO_X2CX  EQU   *
         LA    R15,4
         J     OK_X2CX
OK_X2CX  EQU   *
         LM    R4,R9,X2CX49
         BR    R9
*
*
* x2cx translate table
ERRTRAN  DC    X'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
         org   errtran
HEXTRAN  Ds    X'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
*
TABLE   DC C'0123456789ABCDEF'
*
lit_sha_1_icv  ds 0d
sha_1_icv_H0 dc xl4'67452301'
sha_1_icv_H1 dc xl4'EFCDAB89'
sha_1_icv_H2 dc xl4'98BADCFE'
sha_1_icv_H3 dc xl4'10325476'
sha_1_icv_H4 dc xl4'C3D2E1F0'
sha_1_icv_l_equ equ *-sha_1_icv_H0
*
*
lit_sha_256_icv ds 0d
sha_256_icv_H0 dc xl4'6A09E667'
sha_256_icv_H1 dc xl4'BB67AE85'
sha_256_icv_H2 dc xl4'3C6EF372'
sha_256_icv_H3 dc xl4'A54FF53A'
sha_256_icv_H4 dc xl4'510E527F'
sha_256_icv_H5 dc xl4'9B05688C'
sha_256_icv_H6 dc xl4'1F83D9AB'
sha_256_icv_H7 dc xl4'5BE0CD19'
sha_256_icv_l_equ equ *-sha_256_icv_H0
*
*
lit_sha_512_icv ds 0d
sha_512_icv_H0 dc xl8'6A09E667F3BCC908'
sha_512_icv_H1 dc xl8'BB67AE8584CAA73B'
sha_512_icv_H2 dc xl8'3C6EF372FE94F82B'
sha_512_icv_H3 dc xl8'A54FF53A5F1D36F1'
sha_512_icv_H4 dc xl8'510E527FADE682D1'
sha_512_icv_H5 dc xl8'9B05688C2B3E6C1F'
sha_512_icv_H6 dc xl8'1F83D9ABFB41BD6B'
sha_512_icv_H7 dc xl8'5BE0CD19137E2179'
sha_512_icv_l_equ equ *-sha_512_icv_H0
*
###END EXPLKKRY
$$$BEG EXPLKRY
*PROCESS COMPAT(NOCASE,MACROCASE)                          Ver1
         yregs
         sysstate archlvl=2
explkry  csect
explkry  amode 31
explkry  rmode 31
*
         J     BEGIN
PROLOG   LOCTR
         DC    C'Cryptology Example'
         DC    C'AsmDate && Time: &SYSDATE &SYSTIME'
         DC    C'Ver 0.1.0'
CODEBG1  LOCTR
BEGIN    DS    0H
         save  (14,12)       save z/os's regs
         using data,12
         larl  12,data       use this instead of lr and ahi
*        LR    R12,R15
*        AHI   R12,data-BEGIN

         getmain r,lv=worksize
         st    13,4(1)
         lr    13,1
         using (wareas,wareasend),13
*  ...
do_crying ds 0h
         xr   0,0     holds function code
         xr   2,2     even reg, dest
         xr   3,3     odd reg, not used
         xr   4,4     even reg, holds src
         xr   5,5     odd reg, hold length of both area (equal lng)
         mvi  kmcf0_parm,x'ff'
         mvc  kmcf0_parm+1(kmcf0_parml-1),kmcf0_parm
         la   r1,kmcf0_parm
         kmc  2,4
*        jz   doterm
*
do_msg_dg ds 0h
*  kimd/klmd COMPUTE INTERMEDIATE MESSAGE/LAST DIGEST
*  Reg0 0-56 zeroes 57-63 function code
*  Reg1 - adr of parm block
*  even odd pair r1/r1+1 is not used
*                r2/r2+1
*                   r2 adr of msg
*                   r2+1 lenght of msg (32bit unsigned)
*                (r2 incr by each bye processed)
*                (r2+1 lng is decr as each byte processed0
* For COMPUTE INTERMEDIATE MESSAGE DIGEST, normal completn occurs when
* number of bytes in the second operand as specified in general reg
* R2+1 have been processed. For COMPUTE LAST MESSAGE DIGEST, after all
* bytes in the second operand as specified in general register R2+1 has
* been processed, the padding operation is performed, and then normal
* completion occurs.
*  normal completion, condition code 0 (r2+1 is zero)
*  partial compltion, condition code 3 (r2+1 is non zero)
*  completion, condition code 3 is set and the resulting
*  value in R2 + 1 is nonzero.
*
*
         xr   0,0     holds function code
         xr   2,2     even reg, dest
         xr   3,3     odd reg, not used
         xr   4,4     even reg, holds src
         xr   5,5     odd reg, hold length of both area (equal lng)
         mvi  KLMDF0_parm,x'ff' move hvals just to prove status wd is
         mvc  KLMDF0_parm+1(KLMDF0_parml-1),KLMDF0_parm
*                                            updated by function call
         la   r1,KLMDF0_parm
         klmd 2,4
* here we go with a func 1 call for sha_1
         iilf r0,1     move func x'01' to r0
         la   r1,KLMDF1_parm
         xc   0(KLMDF1_parml,r1),0(r1)
         mvc  0(sha_1_icv_l_equ,r1),sha_1_icv_H0
         larl r4,beg_msg
         iilf r5,beg_msg_l_equ
         iihf r5,0
         sllg r5,r5,3
         st   r5,sav_mbl_val
         st   r5,KLMDF1_mbl+4
         iilf r5,beg_msg_l_equ
*   CHK  JC    MASK,JUMP_TO_REL_ADDR
*        CC>>0 8    normal completion
*            1 4    not defined
*            2 2    not defined
*            3 1    partial completion; jmp to retry
*              + MASK IS THE VALUE TO USE IN THE JC INSTR
klmd_lop klmd 2,4
         jc   1,klmd_lop
         cijne r5,0,klmd_lop
*  if we are here, then we are done
*        la   r15,KLMDF1_parm     r15 points to beg of x values
*        st   r15,x2cx_adr_sha_x
*        iilf r15,KIMDF1_parml    insert total parm lng
*        st   r15,x2cx_sha_x_l
*        la   r15,KLMDF1_x2cxl    load adr of output area
*        st   r15,x2cx_adr_sha_cx
         IILF  R15,KIMDF1_parml
         STH   R15,FROM_HEX_STR_L
         AR    R15,R15
         STH   R15,TO_CHAR_STR_L
*
         LA    R15,FROM_HEX_STR_L
         ST    R15,X_FROM_L_A
         LA    R15,KLMDF1_parm
         ST    R15,X_FROM_A
         LA    R15,TO_CHAR_STR_L
         ST    R15,X_TO_L_A
         LA    R15,KLMDF1_x2cxl
         ST    R15,X_TO_A
         LA    R15,X2CX_PRM_ADR
         jas  r9,x2cx
* here we go with a func 1 call for sha_256
         iilf r0,2     move func x'01' to r0
         la   r1,KLMDF2_parm
         xc   0(KLMDF2_parml,r1),0(r1)
         mvc  0(sha_256_icv_l_equ,r1),sha_256_icv_H0
         larl r4,beg_msg
         iilf r5,beg_msg_l_equ
         mvc  KLMDF2_mbl+4,sav_mbl_val
*   CHK  JC    MASK,JUMP_TO_REL_ADDR
*        CC>>0 8    normal completion
*            1 4    not defined
*            2 2    not defined
*            3 1    partial completion; jmp to retry
*              + MASK IS THE VALUE TO USE IN THE JC INSTR
klmd_lop2 klmd 2,4
         jc   1,klmd_lop2
         cijne r5,0,klmd_lop2
*  if we are here, then we are done
*        la   r15,KLMDF2_parm     r15 points to beg of x values
*        st   r15,x2cx_adr_sha_x
*        iilf r15,KIMDF2_parml    insert total parm lng
*        st   r15,x2cx_sha_x_l
*        la   r15,KLMDF2_x2cxl    load adr of output area
*        st   r15,x2cx_adr_sha_cx
         IILF  R15,KIMDF2_parml
         STH   R15,FROM_HEX_STR_L
         AR    R15,R15
         STH   R15,TO_CHAR_STR_L
*
         LA    R15,FROM_HEX_STR_L
         ST    R15,X_FROM_L_A
         LA    R15,KLMDF2_parm
         ST    R15,X_FROM_A
         LA    R15,TO_CHAR_STR_L
         ST    R15,X_TO_L_A
         LA    R15,KLMDF2_x2cxl
         ST    R15,X_TO_A
         LA    R15,X2CX_PRM_ADR
         jas  r9,x2cx
* here we go with a func 3 call for sha_512
         iilf r0,3     move func x'03' to r0
         la   r1,KLMDF3_parm
         xc   0(KLMDF3_parml,r1),0(r1)
         mvc  0(sha_512_icv_l_equ,r1),sha_512_icv_H0
         larl r4,beg_msg
         iilf r5,beg_msg_l_equ
         mvc  KLMDF3_mbl+12,sav_mbl_val
*   CHK  JC    MASK,JUMP_TO_REL_ADDR
*        CC>>0 8    normal completion
*            1 4    not defined
*            2 2    not defined
*            3 1    partial completion; jmp to retry
*              + MASK IS THE VALUE TO USE IN THE JC INSTR
klmd_lop3 klmd 2,4
         jc   1,klmd_lop3
         cijne r5,0,klmd_lop3
*  if we are here, then we are done
*
*        la   r15,KLMDF3_parm     r15 points to beg of x values
*        st   r15,x2cx_adr_sha_x
*        iilf r15,KIMDF3_parml    insert total parm lng
*        st   r15,x2cx_sha_x_l
*        la   r15,KLMDF3_x2cxl    load adr of output area
*        st   r15,x2cx_adr_sha_cx
         IILF  R15,KIMDF3_parml
         STH   R15,FROM_HEX_STR_L
         AR    R15,R15
         STH   R15,TO_CHAR_STR_L
*
         LA    R15,FROM_HEX_STR_L
         ST    R15,X_FROM_L_A
         LA    R15,KLMDF3_parm
         ST    R15,X_FROM_A
         LA    R15,TO_CHAR_STR_L
         ST    R15,X_TO_L_A
         LA    R15,KLMDF3_x2cxl
         ST    R15,X_TO_A
         LA    R15,X2CX_PRM_ADR
         jas  r9,x2cx
*  if we are here, then we are done
         j    doterm
*
*
* at termination:
*
         clrje 15,15,doterm
*        ltr   15,15
*        jz    doterm
err0     ds    0h
         la    15,8
*
doterm   ds    0h
         lr    1,13
         l     0,fsize
         l     13,4(13)
         freemain r,lv=(0),a=(1)
         return (14,12),,rc=0
*
* convert value in r15 to %02x display x string in EBCDCFLD
x2cx_old ds    0h
         stm   r8,r11,sav_r8_r11_x2cx
         l     r15,x2cx_adr_sha_x
         l     r10,x2cx_sha_x_l
         l     r11,x2cx_adr_sha_cx
         xr    r9,r9
x2cx_top  ds   0h          r9 will have 4 byte increments
         ark   r8,r15,r9    added to the src base adr into r8
         mvc   FOUR,0(r8)   move the '4' bytes in r8 to fld
*        ST    R15,FOUR
         UNPK  EIGHT(9),FOUR(5)
         XC    EBCDCFLD,EBCDCFLD
         MVN   EBCDCFLD(8),EIGHT
         TR    EBCDCFLD,ERRTRAN
         lr    r8,r9      get offset (count)  0,4,8,12...
         sla   r8,1       dbl it for op fld offset 0,8,16,24...
         ar    r8,r11     add to beg of op fld
         mvc   0(8,r8),EBCDCFLD   move char vals to op fld
         ahi   r9,4       add 4 to new ip offset
         crjl  r9,r10,x2cx_top  is it lt total lng of op fld, repeat
*                         not lt so end
         lm    r8,r11,sav_r8_r11_x2cx
         BR    R9
*
X2CX     EQU   *
FORMERR  EQU   *
         STM   R4,R9,X2CX49
         LTR   R4,R15
         JNP   NO_X2CX
*
         L     R5,4(R4)          GET PTR TO HW X SRC LNG
         XR    R6,R6
         ICM   R6,B'0011',0(R5)  GET THE LNG
         JNP   NO_X2CX
*
         L     R5,12(R4)          GET PTR TO HW X SRC LNG
         XR    R7,R7
         ICM   R7,B'0011',0(R5)  GET THE LNG
         JNP   NO_X2CX
*
         SLL   R6,1              MULTIPLY BY 2
         CRJNE R6,R7,BAD_X2CX
*
         SRL   R6,1              GET ORIGINAL VALUE BACK
*
         L     R5,8(R4)       GET ADR OF THE TGT CHAR FLD
         L     R4,0(R4)          GET ADR OF SRC HEX FLD
         LA    R9,TABLE     TRANSLATE TO CHAR FORM
         AHI   R9,-240
*
CONVERT  EQU   *
         CIJL  R6,4,CONVERT1
         MVC   MYXSTR(4),0(R4)
         UNPK  MYCHAR,MYXSTR(5) UNPACK HEX STREAM
         TR    MYCHAR,0(R9)     TRANSLATE TO CHAR FORM
         MVC   0(8,R5),MYCHAR
         AHI   R5,8
         AHI   R4,4
         AHI   R6,-3
         J     CONVERT2
CONVERT1 DS    0H
         XR    R8,R8            CLEAR REG
         IC    R8,0(R4)         INSERT CHAR IN 25-32
         SRDL  R8,4             SHIFT OUT 29-32 INTO R9
         STC   R8,0(R5)         STORE SHIFTED 25-28 AS X'0X'
         TR    0(1,R5),HEXTRAN  TRANSLATE ALL 00 THRU 0F
*                                     TO->    F0 - F9,C1 - C6
         LA    R5,1(R5)         ADVANCE PTR TO NEXT POS
         XR    R8,R8            CLEAR REG
         SLDL  R8,4             SHIFT IN THE 29-32
         STC   R8,0(R5)         STORE IT
         TR    0(1,R5),HEXTRAN  TRANSLATE ALL 00 THRU 0F TO
*                                     TO->    F0 - F9,C1 - C6
         LA    R5,1(R5)         ADVANCE ANOTHER
         LA    R4,1(R4)         ADVANCE NEXT
CONVERT2 DS    0H
         JCT   R6,CONVERT       REDUCE COUNTER
*
         XR    R15,R15
         J     OK_X2CX
BAD_X2CX EQU   *
         LA    R15,8
         J     OK_X2CX
NO_X2CX  EQU   *
         LA    R15,4
         J     OK_X2CX
OK_X2CX  EQU   *
         LM    R4,R9,X2CX49
         BR    R9
*
*
data     ds    0f
fsize    dc    a(worksize)
beg_msg  dc    c'This is a Sample Message that will be used in the gene*
               ration of the sha message digest. i believe that the lit*
               eral can be defined up to 255 chars, but this is now at *
               a length of 182.'
beg_x    dc    x'15'  added because java pgm looks at txt file
*                      and the file has a x'15' at the end
beg_msg_l_equ equ *-beg_msg
*
* x2cx translate table
ERRTRAN  DC    X'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
         org   errtran
HEXTRAN  Ds    X'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
*
TABLE   DC C'0123456789ABCDEF'
*
lit_sha_1_icv  ds 0d
sha_1_icv_H0 dc xl4'67452301'
sha_1_icv_H1 dc xl4'EFCDAB89'
sha_1_icv_H2 dc xl4'98BADCFE'
sha_1_icv_H3 dc xl4'10325476'
sha_1_icv_H4 dc xl4'C3D2E1F0'
sha_1_icv_l_equ equ *-sha_1_icv_H0
*
*
lit_sha_256_icv ds 0d
sha_256_icv_H0 dc xl4'6A09E667'
sha_256_icv_H1 dc xl4'BB67AE85'
sha_256_icv_H2 dc xl4'3C6EF372'
sha_256_icv_H3 dc xl4'A54FF53A'
sha_256_icv_H4 dc xl4'510E527F'
sha_256_icv_H5 dc xl4'9B05688C'
sha_256_icv_H6 dc xl4'1F83D9AB'
sha_256_icv_H7 dc xl4'5BE0CD19'
sha_256_icv_l_equ equ *-sha_256_icv_H0
*
*
lit_sha_512_icv ds 0d
sha_512_icv_H0 dc xl8'6A09E667F3BCC908'
sha_512_icv_H1 dc xl8'BB67AE8584CAA73B'
sha_512_icv_H2 dc xl8'3C6EF372FE94F82B'
sha_512_icv_H3 dc xl8'A54FF53A5F1D36F1'
sha_512_icv_H4 dc xl8'510E527FADE682D1'
sha_512_icv_H5 dc xl8'9B05688C2B3E6C1F'
sha_512_icv_H6 dc xl8'1F83D9ABFB41BD6B'
sha_512_icv_H7 dc xl8'5BE0CD19137E2179'
sha_512_icv_l_equ equ *-sha_512_icv_H0
*
         ltorg
wareas   dsect
save     ds    36f'0'    fsa4 18 doublewds or 36 fw
sav_mbl_val ds  f        save number of bits for sha klmd
*
X2CX49   DS    6F
X2CX_PRM_ADR DS 0F
X_FROM_A DS    F
X_FROM_L_A DS  F
X_TO_A   DS    F
X_TO_L_A DS    F
*
FROM_HEX_STR_L  DS    H      hold lng of x src
TO_CHAR_STR_L   DS    H      hold lng od cx dest
*FROM_HEX_STR  DS    XL40
*TO_CHAR_STR   DS    XL80
*
EBCDCFLD DS    D         8 character x string used by x2cx
FOUR     DS    CL4,C     4 bytes plus 1
EIGHT    DS    CL8,C     8 bytes plus 1
*
*
MYCHAR  DS XL9 CHAR DATA
*
MYXSTR  DS XL4  CHAR DATA
MYXSTR1 DS XL1
*
WORK    DS XL9 CHAR DATA
*
MYHEX2  DS XL5 BACK TO HEX
*
*
* x2cx variables
sav_r8_r11_x2cx ds 4f
x2cx_parm ds   0d
x2cx_adr_sha_x ds f      points to beg of sha x values
x2cx_sha_x_l   ds f      length of the op area
x2cx_adr_sha_cx ds f     adr of the beg of sha cx values
*
kmcf0_parm ds  2d'-1'    parm area for query is 16 bytes or 128bits
kmcf0_parml equ *-kmcf0_parm
*
KLMDF0_parm ds 2d'-1'    parm area for query is 16 bytes or 128bits
KLMDF0_parml equ *-KLMDF0_parm
*
KLMDF1_parm ds 5f'-1'    parm area for sha-1 md 28 bytes or 224bits
KIMDF1_parml equ *-KLMDF1_parm
KLMDF1_mbl  ds 2f'0'     parm area for sha-1 mbr bitlength
*  20 bytes for iv value plus 8 bytes for msg bit lng area
KLMDF1_parml equ *-KLMDF1_parm
*
KLMDF1_x2cxl ds  cl(KIMDF1_parml*2)
*
KLMDF2_parm ds  8f'-1'    parm area for sha256md 40 bytes or 320bits
KIMDF2_parml equ *-KLMDF2_parm
KLMDF2_mbl  ds  2f'0'     parm area for sha256md mbr bit length
*  32 bytes for iv value plus 8 bytes for msg bit lng area
KLMDF2_parml equ *-KLMDF2_parm
*
KLMDF2_x2cxl ds  cl(KIMDF2_parml*2)
*
KLMDF3_parm ds 16f'-1'    parm area for sha512md 80 bytes or 640bits
KIMDF3_parml equ *-KLMDF3_parm
KLMDF3_mbl  ds  4f'0'     parm area for sha512md mbr bit length
*  64 bytes for iv value plus 16 bytes for msg bit lng area
KLMDF3_parml equ *-KLMDF3_parm
*
KLMDF3_x2cxl ds  cl(KIMDF3_parml*2)
*
wareasend ds   0h
worksize equ   *-save
         end   explkry
###END EXPLKRY
$$$BEG UCEMPARS
*ASM     XOPTS(NOPROLOG NOEPILOG)
*        SYSSTATE AMODE31=YES,ARCHLVL=2
         GBLB  &DFHEIMX
&DFHEIMX SETB  0
* SET SW ABOVE TO 1 FOR MIXED MODE ADDR.  THAT IS R12 POINTS TO TCA
* AND R13 WILL POINT TO CSA AND DFHEIPLR NOT ASSUMED
* ON ENTRY, PRM OBEYS SYSTEM LINKAGE STDS
*  R1 POINTS TO PARM LIST W/ TWO ADDR (EIB AND COMM (OR ZERO))
*  R13 POINTS TO ADDR OF SAVE AREA
*  R14 POINTS TO ADDR OF RETURN PT
*  R15 POINTS TO ADDR OF ENTRY  PT
* FOR EACH EXEC CICS CALL MACRO EXPANDS BY INVOKING MACRO DFHECALL
* DFHECALL BUILDS THE PARM LIST IN DYN STG FOR REENTRANCY FOR
*  EACH EXEC CICS CALL. MACRO EXPDS TO SYSTEM STANDARD CALL SEQUENCE
*  R15 CALL TO DFHEIP  R14 RETURN TO PGM R0 (UNUSED) R1 PARMLIST
*   R15 IS ENT POINT TO DFHEIP AND IS ESTABLISHED BY INCLUDE OF
*   DFHEAI STUP IN LINK STEP.
*  DFHECALL MACRO WHICH IS STD SYSTEM CALL
*  R0  UNDEFINED
*  R1  POINTS TO ADDR OF PARM LIST
*  R14 POINTS TO RETURN POINT IN YOUR PGM
*  R15 POINTS TO ADDR OF ENTRY  PT IN EXEC INTF
* DFHEAI MUST BE LINK EDITED WITH YOUR PGM FOR EXEC INTF RESOLUTION
* EXEC CICS RETURN WILL EXIT UOUR PGM OR DFHEIRET IS INSERTED BY
*  THE TRANSLATOR IF NO EXEC RETURN FOUND
* DFHEIRET INSERTED BY TRANSLATOR AT END OF PGM
*  THIS MACRO: RESTORES REGS
*              RETURNS VIA R14
*  OPTIONAL PARM TAKES RCREG=NN WHEN NN IS A REG W/ RETURN CODE FOR R15
* DFHEIENT INSERTED BY TRANSLATOR AFTER FIRST CSECT
*  THIS MACRO: SAVES REGS
*              GETMAIN STG FOR DFHEISTG
*              SETS BASE REG (R3 DEFAULT)
*              SETS DYN STG REG (R13 DEFAULT)
*              SETS EIB REG (R11 DEFAULT)
*  TO OVERRIDE THE TRANSLATOR, CODE TRANSLATOR OPTION NOPROLOG AND
*  CODE YOUR OWN DFHEIENT
*   DFHEIENT CODEREG=(2,3,4),
*            DATAREG=(13,5),
*            EIBREG=6
*              CODEREG - BASE REGISTERS
*              DATAREG - DYNAMIC-STORAGE REGISTERS
*              EIBREG  - REGISTER TO ADDRESS THE EIB.
* RECOMMENDATION: CODE R13 AS THE FIRST DATAREG WHERE DFHEIPLR IS
*            INSERTED TO DEFINE THE FIRST DATA REG AND IT ESTABLISHES
*            ADDRESSABILITY TO THE FIRST DYN STG AREA
*
* DFHEISTG INSERTED BY TRANSLATOR
*              DEFINES STG PARM LIST
*              DEFINES STG FOR REG SAVE AREA
*              INCLUDES YOUR VARS WHEN YOU CODE THE DFHEISTG MACRO
*               MAX AMT IS 64K AND INIT TO X'00'
* DFHEIEND INSERTED BY TRANSLATOR TO ID END OF EIDSA
* DFHEIBLK INSERTED BY TRANSLATOR DEFINES EIB DSECT
* MULTIPLE BASE REGS DEFINED BY DFHEIENT (CODEREG DATAREG EIBREG)
* DFHEIPLR IS THE REG VAR ASSIGNED TO FIRST EIBREG OR DEFAULT
* DFHEIPLR IS ASSUMED BY THE EXPANSION OF A CICS COMMAND TO CONTAIN THE
* VALUE SET UP BY DFHEIENT.  YOU SHOULD
* EITHER DEDICATE THIS REGISTER OR ENSURE THAT IT IS RESTORED BEFORE
* EACH CICS COMMAND.
*
*REG 1                      PASSED ADDR OF PARMS
*REG 3                      STATIC STG REG POINTS TO STATR
*REG 11                     PTR TO EIB (SET BY DFHEIENT)
*REG 13                     PTR TO DFHEISTG (SET BY DFHEIENT(
* BASELESS (RELATIVE ADDRESSING IN USE) SO NO BASE REG
         REGSMAC
*
* COPYBOOK FOR COMMAREA PARS DSECT
*  MYCOM_A IS THE ANCHOR FOR THIS DSECT
       COPY PARSDSCT
*
SAVE     DFHEISTG DSECT
RET_ADR      DS    F
PARSE_EQ     DS    H
         DFHEIEND
*
********************************************************************
UCEMPARS CSECT
UCEMPARS AMODE 31
UCEMPARS RMODE ANY
      DFHEIENT DATAREG=13,EIBREG=11,STATREG=3,STATIC=STATR,CODEREG=0
         J     MAIN000
         DC    C'UCEMPARS'
         DC    C'&SYSDATE'
         SPACE 1
MAIN000  DS    0H
**
* GENERALIZED STRING PARSER V1.3
* V1.3
*  NOW LOOKS AT PARM LENGTH
*   EXPECTS X'18' AS CALEN
*
*  EXPECTS PARM LIST OF LENGTH X'18' TO BE PASSED IN COMMAREA
*   1ST FW PTR TO STRING TO BE SEARCHED FOR (NEEDLE)
*   2ND FW PTR TO HW LENGTH OF STRING TO BE SEARCHED FOR (NEEDLE)
*   3RD FW PTR TO STRING TO BE SEARCHED     (HAYSTACK)
*   4TH FW PTR TO HW LENGTH OF STRING TO BE SEARCHED
*   5TH FW PTR TO 1 CHARACTER A OR D FOR ACENDING OR DECENDING
*   6TH FW PTR TO FW OF RETURN VALUE, DEFAULT RETURN IS  0 (FAILURE)
*   7TH FW PTR TO FW FIELD SET TO 1 FOR EQUAL, OR -1 NE
*
*    -1 IF PARM ERROR
*    0 IF NOT FOUND
*    ADDRESS OF FIRST FIND
* GENERALIZED STRING PARSER
**
         LH    R4,EIBCALEN
*
         CIJNE R4,CA_EQU_LENGTH,NOPARM
*
         EXEC  CICS ADDRESS COMMAREA(R10)
         LTR   R1,R10
         JZ    NOPARM
*
*  R4 HOLDS PARM LENGTH, WILL NEXT HOLD NEEDLE ADDR
*  R5 WILL HOLD ADDR OF NEEDLE HW LENGTH. USED IN EX ON CLC INST
*  R6 HOLDS HAYSTACK ADDR (FIRST OR LAST IF DECENDING)
*  R7 HOLD ADDR OF HAYSTACK LW LENGHT
*  R8 USED TO HOLD FIRST POSITION IN THE HAYSTACK OR LAST IF DECEND
*  R9 ((R6+R7)-R5) GIVES LAST (OR FIRST IS DECENDING) COMPARE ADDR
*  R10 COMMAREA
*  R15 HOLDS 1 OR -1 FOR SEARCHING ACEND AND DECEND
*  R0,R2  ARE WORKREGS
*  ITERATE R6 BY INCREMENT, AND COMPARE NEEDLE AT EACH POS(R6)
*  WHEN FOUND (OR NOT FOUND), RETURN POS(R6)
*  WHEN R6 GT R8 (OR R6 LT R8 IF DECEND), THEN NOT FOUND
*
         USING MYCOM_A,R10
*
         ICM   R4,B'1111',CA_ADR_NEEDLE PTR TO NEEDLE
         JZ    NOPARM
         ICM   R5,B'1111',CA_ADR_NEEDLEL PTR TO LEN NEEDLE
         JZ    NOPARM
         LH    R5,0(R5)            GET LEN INTO REG
         CIJE  R5,0,NOPARM
         ICM   R6,B'1111',CA_ADR_HAYSTACK  PTR TO HAYSTACK
         JZ    NOPARM
         ICM   R7,B'1111',CA_ADR_HAYSTACKL PTR TO HAYSTACK LEN
         JZ    NOPARM
         LH    R7,0(R7)            GET LEN INTO REG
         CIJE  R7,0,NOPARM
         CRJH  R5,R7,NOPARM   NEEDLE LEN MUST BE LE HAY LEN
*
         SR    R7,R5          REDUCE THE HAYS LNG BY NEEDLE LNG TO
*                              LIMIT THE COMPARE OF LAST ADDR
         L     R15,CA_ADR_DIRECTION
         CIJE  R15,0,NOPARM
         CLC   0(1,R15),LIT_DECENDING
         JNE   TEST_ACENDING
         L     R15,MINUS1
         J     GOT_DIRN
TEST_ACENDING EQU  *
*              MAKE ASENDING THE DEFAULT IF DECENDING NOT SPECIFIED
*        CLC   0(1,R15),LIT_ACENDING
         LA    R15,1           SET DIRECTION TO ASCENDING
*        JNE   NOPARM
*
GOT_DIRN EQU   *
*              MAKE PARSE EQ SET TO ZERO THE DEFAULT COMPARE
         MVC   PARSE_EQ,H0
         L     R2,CA_ADR_EQ_NE
         CIJE  R2,0,TEST_EQU
         CLI   0(R2),X'0'
         JE    TEST_EQU
         MVC   PARSE_EQ,H1     TEST NOT EQUAL
TEST_EQU DS    0H
         LR    R8,R6           SAVE BEGIN OF HAYSTACK
         AR    R8,R7           COMPUTE END POINT OF HAYSTACK
*
         BCTR  R5,0            REDUCE NEEDLE LNG FOR EXECUTE
*
         CIJH  R15,0,CLCLOOP   1 IS ASC AND -1 IS DSC
*                        DECENDING
         LR    R0,R8          SWAP FOR NEG DIRECTN
         LR    R8,R6     MAKE START THE LAST POSN AND END IS FIRST
         LR    R6,R0
*                              WHICH WAS EST AS LAST COMP POS
* COMPARE NEEDLE AGAINST HAYSTACK USING EXECUTE DEPENDING ON
*         NEEDLE LENGTH IN REG5
* CLCPARSE CLC   0(0,R6),0(R4) THIS IS SAMPLE OF TARGET EXECUTE
CLCLOOP  EQU   *
         CLC   PARSE_EQ,H0
         JNE   DO_UNEQ
*
         EXRL  R5,CLCPARSE     CLC   0(0,R6),0(R4)
         JE    NEEDLEF
         J     CLC_NEXT
*
DO_UNEQ  EQU   *
         EXRL  R5,CLCPARSE     CLC   0(0,R6),0(R4)
         JNE   NEEDLEF         NOT EQUAL CONDITION FOUND - DONE
*
CLC_NEXT EQU   *
         AR    R6,R15
*
         CIJL  R15,0,DO_NEG_DIR_TST
*
         CRJNH R6,R8,CLCLOOP    ASC: R6 MUST BE <= R8
         J     NOT_FND
*
DO_NEG_DIR_TST DS  0H
         CRJNL R6,R8,CLCLOOP    DSC; R6 MUST BE >= R8
         J     NOT_FND
*
*
NOPARM   DS  0H
         L     R6,FW_PARM_ERROR     MINUS 1
         J     DONEPGM
*
NOT_FND  DS  0H
         XR    R6,R6                ZERO
         J     DONEPGM
*
NEEDLEF  EQU   *
*                                   R6 HAS ADDR OF EE/NE COND
DONEPGM  EQU   *
         L     R15,CA_ADR_RETURN
         ST    R6,0(R15)
*
RETURN   EQU   *
         DFHEIRET
*        EXEC  CICS RETURN
*
CLCPARSE CLC   0(0,R6),0(R4)
*   CICS STATIC STORAGE AREA NEEDS LABEL AS SPECIFIED ON DFHEIENT
STATR    DS    0D
FW_PARM_ERROR DC  F'-1'
              ORG FW_PARM_ERROR
MINUS1        DS  F
*
H0            DC  H'0'
*
H1            DC  H'1'
*
LIT_ACENDING  DC  CL1'A'
LIT_DECENDING DC  CL1'D'
*
EISSTG   DC    CL80'%%%%%EISSTGST%%%%%EISSTGST%%%%EISSTGST%%%%EISSTGST'
*                  0         0         0         0         0    5'
         SPACE 3
         DC    C'****'
         DC    C'UCEMPARS - CIGNA * CPCW *'
         DC    C' '
         DC    C'DATE='
         DC    C'&SYSDATE'
         DC    C' '
         DC    C'TIME='
         DC    C'&SYSTIME'
         DC    C' '
         DC    C'TCEM'
         DC    C'****'
* MOVED TO END FOR RELATIVE ADDRESSING
         LTORG
         END
###END UCEMPARS
$$$BEG PARSESCT
PARS_TST_NEEDLE DS   CL16
PARS_TST_NEEDLEL DS  H
PARS_TST_HAYSTACK DS CL255
PARS_TST_HAYSTACKL DS H
PARS_TST_DIRECTION DS CL1
PARS_TST_EQ_NE   DS X
PARS_TST_ADR_RETURN DS F
*
PARS_TST_GM_PRM_A  DS F
*
PARS_PGM     DS CL8
PARS_TST_RSLT DS CL(OPLIT_L_EQU)
PARS_TST_RSLT_L_EQU EQU *-PARS_TST_RSLT
*
###END PARSESCT
$$$BEG PARSDSCT
MYCOM_A  DSECT
CA_ADR_NEEDLE   DS    F    ADDR OF NEEDLE
CA_ADR_NEEDLEL  DS    F    ADDR OF FW LNG OF NEEDLE
CA_ADR_HAYSTACK DS    F    ADDR OF HAYSTACK
CA_ADR_HAYSTACKL DS   F    ADDR OF FW LNG OF HAYSTACK
CA_ADR_DIRECTION DS   F    ADDR OF FW SET TO A FWD OR D BWD
CA_ADR_RETURN   DS   F     ADDR OF FW TO RECEIVE ADDR OF SEARCH OR 0
CA_ADR_EQ_NE    DS   F     ADDR OF A X  SET TO ZERO(EQ) OR  1  0(NE)
CA_EQU_LENGTH   EQU  *-MYCOM_A
*
###END PARSDSCT
$$$BEG EXPLKIX1
         REGSMAC
TST_WORKAREA DSECT
FLDA     DS    CL1024
LENAREA  EQU   *-FLDA
*
DFHEISTG DSECT
DWORD    DS    D
PTR_TST_WORKAREA DS F
ENDOFEIS DS    CL8          SET TO ENDOFEIS
********************************************************************
EXPLKIX1 AMODE 31
EXPLKIX1 RMODE ANY
EXPLKIX1 CSECT
         B     MAIN000
         SPACE 2
*****    GBLC  &SYSDATE
         DC    C'EXPLKIX1'
         DC    C'&SYSDATE'
         SPACE 1
MAIN000  DS    0H
         EXEC  CICS HANDLE CONDITION ERROR(ERROR01)
         EXEC  CICS GETMAIN FLENGTH(EXPL_A_4080)                       *
               SET(R10)                                                *
               NOSUSPEND
*
*  THE OS GETMAIN DOES NOT SHOW UP IN TRACE, BUT DOES RUN
         STORAGE OBTAIN,LENGTH=LENAREA,LOC=31
         ST    R1,PTR_TST_WORKAREA
         LR    R9,R1
         USING TST_WORKAREA,R9
* HOWEVER, TRYING TO USE THE AREA RESULTS IN AN ASRA
*        MVC   FLDA(MYSTATIC_L),MYSTATIC
*        MVC   FLDA(MYSTATIC_L_TOO),MYSTATIC
*
ERROR01  EQU   *
RETURN   EQU   *
         EXEC  CICS RETURN
         SPACE
EXPL_EQU_4080  EQU 4080,4           CAN NOT USE THIS IN FLENGTH
EXPL_A_4080 DC A(EXPL_EQU_4080)     USE THIS IN FLENGTH
*EXPL_CL_4080 DC (EXPL_EQU_4080)CL1' '
F4080    DC    F'4080'
         LTORG
CN_STRTB_MSG DC C'UCEMPINQ - CNC FOUND. COMMAND OR UNKNOW CONTAINER NAM*
               ES FOLLOW:'
CN_STRTB_MSG_L DC A(*-CN_STRTB_MSG)
MYSTATIC DS    0D
         DC    C'****'
         DC    C'EXPLKIX1 - CIGNA * CPCW *'
         DC    C' '
         DC    C'DATE='
         DC    C'&SYSDATE'
         DC    C' '
         DC    C'TIME='
         DC    C'&SYSTIME'
         DC    C' '
         DC    C'TCEM'
         DC    C'****'
MYSTATIC_L EQU *-MYSTATIC
MYSTATIC_L_TOO EQU *-MYSTATIC,4
         END
###END EXPLKIX1
$$$BEG SAMPCRY
*PROCESS COMPAT(NOCASE,MACROCASE)
         TITLE 'SAMPLE ENCIPHER/DECIPHER S/370 PROGRAM.'
         YREGS
         SYSSTATE ARCHLVL=2
*=====================================================================*
*       SYSTEM/370 ASSEMBLER H EXAMPLE                                *
*                                                                     *
*=====================================================================*
         SPACE
SAMPCRY csect
SAMPCRY AMODE 31
SAMPCRY RMODE 31
*
         DS    0H
         STM   14,12,12(13)     SAVE REGISTERS
         BALR  12,0             USE R12 AS BASE REGISTER
         USING *,12             PROVIDE SAVE AREA FOR SUBROUTINE
         LA    14,SAVE          PERFORM SAVE AREA CHAINING
         ST    13,4(14)           "
         ST    14,8(13)           "
         LR    13,14              "
*
         CALL  CSFKGN,(RETCD,                                          *
               RESCD,                                                  *
               EXDATAL,                                                *
               EXDATA,                                                 *
               KEY_FORM,                                               *
               KEY_LEN,                                                *
               KEYTYP1,                                                *
               KEYTYP2,                                                *
               KEK_ID1,                                                *
               KEK_ID2,                                                *
               DATA_ID,                                                *
               NULL_ID)
         CLC   RETCD,=F'0'      CHECK RETURN CODE
         BNE   BACK             OUTPUT RETURN/REASON CODE AND STOP
         CLC   RESCD,=F'0'      CHECK REASON CODE
         BNE   BACK             OUTPUT RETURN/REASON CODE AND STOP
*
* CALL ENCIPHER WITH THE KEY JUST GENERATED
*  OPERATIONAL FORM
*
         MVC   RULEAC,=F'1'           SET RULE ARRAY COUNT
         MVC   RULEA,=CL8'CUSP    '   BUILD RULE ARRAY
         CALL CSFENC,(RETCD,                                           *
               RESCD,                                                  *
               EXDATAL,                                                *
               EXDATA,                                                 *
               DATA_ID,                                                *
               TEXTL,                                                  *
               TEXT,                                                   *
               ICV,                                                    *
               RULEAC,                                                 *
               RULEA,                                                  *
               PAD_CHAR,                                               *
               OCV,                                                    *
               CIPHER_TEXT)
         CLC   RETCD,=F'0'      CHECK RETURN CODE
         BNE   BACK             OUTPUT RETURN/REASON CODE AND STOP
         CLC   RESCD,=F'0'      CHECK REASON CODE
         BNE   BACK             OUTPUT RETURN/REASON CODE AND STOP
         CALL CSFDEC,(RETCD,                                           *
               RESCD,                                                  *
               EXDATAL,                                                *
               EXDATA,                                                 *
               DATA_ID,                                                *
               TEXTL,                                                  *
               CIPHER_TEXT,                                            *
               ICV,                                                    *
               RULEAC,                                                 *
               RULEA,                                                  *
               OCV,                                                    *
               NEW_TEXT)
         CLC   RETCD,=F'0'      CHECK RETURN CODE
         BNE   BACK             OUTPUT RETURN/REASON CODE AND STOP
         CLC   RESCD,=F'0'      CHECK REASON CODE
         BNE   BACK             OUTPUT RETURN/REASON CODE AND STOP
*
COMPARE  EQU   *                         COMPARE START AND END TEXT
         CLC   TEXT,NEW_TEXT
         BE    GOODENC
         WTO   'DECIPHERED TEXT DOES NOT MATCH STARTING TEXT'
         B      BACK
GOODENC  WTO   'DECIPHERED TEXT MATCHES STARTING TEXT'
*
*
         WTO   'TEST PROGRAM TERMINATING'
         B     RETURN
*
*----------------------------------------------------
* CONVERT RETURN/REASON CODES FROM BINARY TO EBCDIC
*----------------------------------------------------
BACK     DS    0F                OUTPUT RETURN & REASON CODE
         L     5,RETCD           LOAD RETURN CODE
         L     6,RESCD           LOAD REASON CODE
         CVD   5,BCD1            CONVERT TO PACK-DECIMAL
         CVD   6,BCD2
         UNPK  ORETCD,BCD1       CONVERT TO EBCDIC
         UNPK  ORESCD,BCD2
         OI    ORETCD+7,X'F0'    CORRECT LAST DIGIT
         OI    ORESCD+7,X'F0'
*
         MVC   ERROUT+21(4),ORETCD+4
         MVC   ERROUT+41(4),ORESCD+4
ERROUT   WTO   'ERROR CODE =     , REASON CODE =     '
RETURN   EQU   *
         L     13,4(13)          SAVE AREA RESTORATION
         MVC   16(4,13),RETCD    SAVE RETURN CODE
         LM    14,12,12(13)
         BR    14                RETURN TO CALLER
*
         ltorg
BCD1     DS    D                 CONVERT TO BCD TEMP AREA
BCD2     DS    D                 CONVERT TO BCD TEMP AREA
ORETCD   DS    CL8'0'            OUTPUT RETURN CODE
ORESCD   DS    CL8'0'            OUTPUT REASON CODE
*
KEY_FORM DC    CL8'OP      '     KEY FORM
KEY_LEN  DC    CL8'SINGLE  '     KEY LENGTH
KEYTYP1  DC    CL8'DATA    '     KEY TYPE 1
KEYTYP2  DC    CL8'        '     KEY TYPE 2
TEXT     DC    C'ABCDEFGHIJKLMNOPQRSTUV0987654321'
TEXTL    DC    F'32'             TEXT LENGTH
CIPHER_TEXT DC CL32' '
NEW_TEXT DC    CL32' '
DATA_ID  DC    XL64'00'          DATA KEY TOKEN
NULL_ID  DC    XL64'00'          NULL KEY TOKEN - UNFILLED
KEK_ID1  DC    XL64'00'          KEK1 KEY TOKEN
KEK_ID2  DC    XL64'00'          KEK2 KEY TOKEN
RETCD    DS    F'0'              RETURN CODE
RESCD    DS    F'0'              REASON CODE
EXDATAL  DC    F'0'              EXIT DATA LENGTH
EXDATA   DS    0C                EXIT DATA
RULEA    DS    1CL8              RULE ARRAY
RULEAC   DS    F'0'              RULE ARRAY COUNT
ICV      DC    XL8'00'           INITIAL CHAINING VECTOR
OCV      DC    XL18'00'          OUTPUT CHAINING VECTOR
PAD_CHAR DC    F'0'              PAD CHARACTER
SAVE     DS    36F               SAVE REGISTER AREA
         END   SAMPCRY
###END SAMPCRY
$$$BEG ISCICS
***********************************************************************
*                                                                     *
* NAME: ISCICS                                                        *
*                                                                     *
* DESCRIPTION:  DETERMINES ENVIRONMENT OF RUNNING TASK                *
*                                                                     *
* INPUT:  NONE                                                        *
*                                                                     *
* OUTPUT:  RETURN CODE IN R15.  RC = 8 :  BATCH, NO CICS INVOLVED     *
*                               RC = 4 :  BATCH, EXCI CLIENT          *
*                               RC = 0 :  CICS                        *
*                                                                     *
* (C) 2003, BSP GMBH, VOLKER BANDKE                                   *
*                                                                     *
* FOR ASSEMBLY THE CICS MACRO LIBRARY IS REQUIRED IN SYSLIB           *
*                                                                     *
***********************************************************************
ISCICS   AMODE 31
ISCICS   RMODE ANY
ISCICS   CSECT
         YREGS
IS_BATCH EQU  8
IS_EXCI  EQU  4
IS_CICS  EQU  0
         STM   R14,R12,12(R13)             , SAVE CALLER'S REGISTERS
         LR    R3,R15                      , LOAD OWN BASE REG
         USING ISCICS,R3                   , TELL ASSEMBLER
         DFHAFCD TYPE=LOCATE,CB=AFCB       , LOCATE THE AFCB
         LTR   R15,R15                     , TEST IF THERE IS AN AFCB
         BZ    SET_BTCH                    , BRANCH IF NOT
         USING DFHAFCB,R15                 , TELL ASSEMBLER
         LA    R14,AFLSTBEG                , POINT TO BEGINNING OF LIST
         AH    R14,AFLENG                  , ADD LENGTH OF LIST: AFT
         USING AFTSTART,R14                , TELL ASSEMBLER
         TM    AFTFLG1,AFTEXCI             , TEST FOR EXCI
         BO    SET_EXCI                    , BRANCH IF YES
SET_CICS DC    0H                          , INDICATE FULL CICS
         LA    R15,IS_CICS                 , SET FLAG THAT FULL CICS
         B     GOHOME                      , AND EXIT
SET_EXCI DC    0H                          , INDICATE EXCI CLIENT
         LA    R15,IS_EXCI                 , SET APPROPRITE RC
         B     GOHOME                      , AND EXIT
SET_BTCH DC    0H                          , INDICATE BATCH WITH
         LA    R15,IS_BATCH                , NO CICS INVOLVED
GOHOME   DC    0H                          , AND EXIT
         ST    R15,16(R13)                 , SET RC
         LM    R14,R12,12(R13)             , RESTORE REGISTERS
         BR    R14                         , AND RETURN TO CALLER
DFHAFCB  DFHAFCD TYPE=DSECT                , AFCB LAYOUT
         END                               , OF MODULE
###END ISCICS
$$$BEG DADMASC
* This is an unaligned mapset
* DADMASC for Class entries
         TITLE 'DADMASC Mapset MACRO Definition Listing'
DADMASC  DFHMSD TYPE=DSECT,LANG=ASM,TIOAPFX=YES,MODE=INOUT
*
DADMAMC  DFHMDI SIZE=(24,80),CTRL=(FRSET,FREEKB)
         DFHMDF POS=0,LENGTH=6,ATTRB=(ASKIP,BRT),INITIAL='APPLID'
FLD00001 DFHMDF POS=7,LENGTH=8,INITIAL='APPLID  '
FLD00002 DFHMDF POS=32,LENGTH=12,ATTRB=(ASKIP,BRT),                    *
               INITIAL='CA-DADS/PLUS'
FLD00003 DFHMDF POS=45,LENGTH=8,ATTRB=(ASKIP,BRT),INITIAL=' 4.0    '
FLD00004 DFHMDF POS=58,LENGTH=10,INITIAL='MM/DD/YYYY'
FLD00005 DFHMDF POS=69,LENGTH=8,INITIAL='HH:MM:SS'
         DFHMDF POS=105,LENGTH=27,ATTRB=(ASKIP,BRT),                   *
               INITIAL='ASSOCIATED CLASS DEFINITION'
FLD00006 DFHMDF POS=133,LENGTH=10,ATTRB=(ASKIP,BRT),                   *
               INITIAL='DISPLAY   '
FLD00007 DFHMDF POS=237,LENGTH=2,ATTRB=(ASKIP,DRK),INITIAL='AC'
         DFHMDF POS=400,LENGTH=13,ATTRB=(ASKIP,BRT),                   *
               INITIAL='COMMAND  ===>'
FLD00008 DFHMDF POS=415,LENGTH=8,ATTRB=(ASKIP,BRT),INITIAL='        '
         DFHMDF POS=424,LENGTH=1,INITIAL=' '
         DFHMDF POS=563,LENGTH=4,ATTRB=(ASKIP,BRT),INITIAL='TYPE'
         DFHMDF POS=569,LENGTH=4,ATTRB=(ASKIP,BRT),INITIAL='===>'
FLD00009 DFHMDF POS=575,LENGTH=1,ATTRB=(ASKIP,BRT),INITIAL=' '
         DFHMDF POS=577,LENGTH=1,INITIAL=' '
         DFHMDF POS=579,LENGTH=4,ATTRB=(ASKIP,BRT),INITIAL='NAME'
         DFHMDF POS=585,LENGTH=4,ATTRB=(ASKIP,BRT),INITIAL='===>'
FLD00010 DFHMDF POS=591,LENGTH=8,ATTRB=(ASKIP,BRT),INITIAL='--------'
         DFHMDF POS=600,LENGTH=1,INITIAL=' '
FLD00011 DFHMDF POS=1760,LENGTH=79,                                    *
               INITIAL='-----------------------------------------------*
               --------------------------------'
FLD00012 DFHMDF POS=1840,LENGTH=9,ATTRB=(ASKIP,DRK),INITIAL='PF?:     '
FLD00013 DFHMDF POS=1851,LENGTH=9,ATTRB=(ASKIP,DRK),INITIAL='PF?:     '
FLD00014 DFHMDF POS=1862,LENGTH=9,ATTRB=(ASKIP,DRK),INITIAL='PF?:     '
FLD00015 DFHMDF POS=1873,LENGTH=9,ATTRB=(ASKIP,DRK),INITIAL='PF?:     '
FLD00016 DFHMDF POS=1884,LENGTH=9,ATTRB=(ASKIP,DRK),INITIAL='PF?:     '
FLD00017 DFHMDF POS=1895,LENGTH=9,ATTRB=(ASKIP,DRK),INITIAL='PF?:     '
FLD00018 DFHMDF POS=1906,LENGTH=9,ATTRB=(ASKIP,DRK),INITIAL='PF?:     '
         DFHMDF POS=720,LENGTH=18,ATTRB=(ASKIP,BRT),                   *
               INITIAL='ASSOCIATED CLASSES'
FLD00019 DFHMDF POS=880,LENGTH=8,INITIAL='--------'
FLD00020 DFHMDF POS=893,LENGTH=8,INITIAL='--------'
FLD00021 DFHMDF POS=906,LENGTH=8,INITIAL='--------'
FLD00022 DFHMDF POS=919,LENGTH=8,INITIAL='--------'
FLD00023 DFHMDF POS=932,LENGTH=8,INITIAL='--------'
FLD00024 DFHMDF POS=945,LENGTH=8,INITIAL='--------'
FLD00025 DFHMDF POS=960,LENGTH=8,INITIAL='--------'
FLD00026 DFHMDF POS=973,LENGTH=8,INITIAL='--------'
FLD00027 DFHMDF POS=986,LENGTH=8,INITIAL='--------'
FLD00028 DFHMDF POS=999,LENGTH=8,INITIAL='--------'
FLD00029 DFHMDF POS=1012,LENGTH=8,INITIAL='--------'
FLD00030 DFHMDF POS=1025,LENGTH=8,INITIAL='--------'
FLD00031 DFHMDF POS=1040,LENGTH=8,INITIAL='--------'
FLD00032 DFHMDF POS=1053,LENGTH=8,INITIAL='--------'
FLD00033 DFHMDF POS=1066,LENGTH=8,INITIAL='--------'
FLD00034 DFHMDF POS=1079,LENGTH=8,INITIAL='--------'
FLD00035 DFHMDF POS=1092,LENGTH=8,INITIAL='--------'
FLD00036 DFHMDF POS=1105,LENGTH=8,INITIAL='--------'
FLD00037 DFHMDF POS=1120,LENGTH=8,INITIAL='--------'
FLD00038 DFHMDF POS=1133,LENGTH=8,INITIAL='--------'
FLD00039 DFHMDF POS=1146,LENGTH=8,INITIAL='--------'
FLD00040 DFHMDF POS=1159,LENGTH=8,INITIAL='--------'
FLD00041 DFHMDF POS=1172,LENGTH=8,INITIAL='--------'
FLD00042 DFHMDF POS=1185,LENGTH=8,INITIAL='--------'
*
DADMASC  DFHMSD TYPE=FINAL
         END
###END DADMASC
$$$BEG EXPLJSYM
**
*
*MYAREA   INITSTG USEREG=2
MYAREA   DSECT
*        DS    F            BWCHAIN
*        DS    F            FWCHAIN
         COPY PASSPARM
SAVR19   DS    10F
X2CX49   DS    6F
SAVR49   DS    6F
SAVR9    DS    F
SAVR6    DS    F
DWORD    DS    D
$DBLWD   DS    D
EBCDCFLD DS    D
HEXFIELD DS    F
TIOTADR  DS    F
$TIMEB   DS    F
$DATEB   DS    F
JOBNAME  DS    CL8
$DATE    DS    CL8
$TIME    DS    CL8
MSGAREA1 DS    CL1
MSGAREA  DS    CL132
HLDSTR   DS    CL7
XC       DS    XL1
MYDEBUG  DS    CL1
*
SJSYM_RC     DS   F
SJSYM_RSN    DS   F
SJDIAG       DS   4F
SYM_ENTS     DS   H
             DS   0D
SYMS         DS   Y(SYMS_END)
S1           DS   CL16
S2           DS   CL16
S3           DS   CL16
S4           DS   CL16
SYMS_END     EQU  *-SYMBOLS
             ORG  SYMS
SYMBOLS      DS   0CL(SYMS_END)
             ORG  ,
SYMS_L       EQU  (SYMS_END/16)
SYMBOLAREA   DS   64F
*
SJ_EXEC      DS   XL(SJMAC_L)
*****        EQU  ((((*+4096)/4096)*4096)+4096)
             ORG  *+4096
*
EXPLJSYM CSECT
EXPLJSYM RMODE ANY
EXPLJSYM AMODE 31
         INITMAC 3,EQU=R,ID=EXPLJSYM
*
         MVI   MSGAREA1,C' '
         MVC   MSGAREA,MSGAREA1
         OPEN  (SYSPRINT,(OUTPUT))
         MVC   MSGAREA(5),$DATE+3
         MVC   MSGAREA+6(6),$TIME+1
         JAS   R9,GETJOBN
         MVC   MSGAREA+13(8),JOBNAME
         MVC   MSGAREA+22(L'BEGNMSG),BEGNMSG
         JAS   R9,WRTMSG
*
         LA    R9,SYMS_L
         STH   R9,SYM_ENTS
         MVC   MSGAREA,SYMBMSG
         MVC   MSGAREA+7(L'GET_BY_NAME),GET_BY_NAME
         JAS   R9,WRTMSG
         MVC   S1,S1_LIT
         MVC   S2,S2_LIT
         MVC   S3,S3_LIT
*
A  IEFSJSYM REQUEST=GETBYNAME,SYMLISTARRAY=SYMBOLS,NUMENTRIES=SYM_ENTS,X
               SYMBAREA=SYMBOLAREA,SYMBAREALEN=(L'SYMBOLAREA),         X
               DIAGDATA=SJDIAG
         MVC   MSGAREA+7(L'MSGAREA-7),SYMBOLAREA
         JAS   R9,WRTMSG
*OR
         MVC   MSGAREA,SYMBMSG
         MVC   MSGAREA+7(L'GET_ALL),GET_ALL
         JAS   R9,WRTMSG
B   IEFSJSYM REQUEST=GETALL,SYMBAREA=SYMBOLAREA,                       X
               SYMBAREALEN=(L'SYMBOLAREA),                             X
               RETCODE=SJSYM_RC,RSNCODE=SJSYM_RSN,DIAGDATA=SJDIAG
***
         MVC   MSGAREA+7(L'MSGAREA-7),SYMBOLAREA
         JAS   R9,WRTMSG
***
         JAS   R9,GETTIME
         MVC   MSGAREA(L'ENDMSG),ENDMSG
         MVC   MSGAREA+25(5),$DATE+3
         MVC   MSGAREA+31(6),$TIME+1
         JAS   R6,GETJOBN
         MVC   MSGAREA+40(8),JOBNAME
         JAS   R9,WRTMSG
*
NOSTG    EQU   *
         XR    R15,R15
         LA    R15,8
         J     NOFM
EXITRC8  EQU   *
         XR    R15,R15
         LA    R15,8
***
DOCLOSE  EQU   *
         MVC   MSGAREA(L'ENDMSG),ENDMSG
         JAS   R9,WRTMSG
         CLOSE SYSPRINT
         IC    R15,XC
***
NOFM     EQU   *
BYL15    EQU   *
         RTNMAC  RC=(15)
*
***
WRTMSG   EQU   *
         PUT   SYSPRINT,MSGAREA
         MVC   MSGAREA,MSGAREA1
         BR    R9
***
GETJOBN  EQU   *
         LA    R9,TIOTADR
         EXTRACT (R9),'S',FIELDS=TIOT
         L     R1,TIOTADR
         MVC   JOBNAME,0(R1)
         BR    R9
*** GET THE SYSDATE SYSTIME IN ORDER TO CREATE A UNIQUE QUALIFIER
GETTIME  EQU   *
         XR    R0,R0
         XR    R1,R1
         TIME
         ST    R0,$TIMEB
         ST    R0,$DBLWD+4
         OI    $DBLWD+7,X'0F'
         UNPK  $TIME,$DBLWD
         XC    $DBLWD,$DBLWD
         ST    R1,$DATEB
         ST    R1,$DBLWD+4
         OI    $DBLWD+7,X'0F'
         UNPK  $DATE,$DBLWD
         XC    MYDEBUG,MYDEBUG
         BR    R9
***
B2C      EQU   *
         CVD   R15,DWORD
         UNPK  HLDSTR,DWORD+4(4)
         OI    HLDSTR+6,X'F0'
         XR    R15,R15
         BR    R9
***
* THIS IS THE ERROR ROUTINE TO FORMAT THE ERROR CODE RETURNED FROM THE
* SVC IF THERE IS AN ERROR ON ALLOCATION.
*
X2CX     EQU   *
FORMERR  EQU   *
         STM   R4,R9,X2CX49
         XR    R6,R6
         LA    R6,8
         ST    R15,HEXFIELD
         LA    R4,HEXFIELD
         LA    R5,EBCDCFLD
*
CONVERT  EQU   *
         SLR   R8,R8
         IC    R8,0(R4)
         SRDL  R8,4
         STC   R8,0(R5)
         LA    R5,1(R5)
         SLR   R8,R8
         SLDL  R8,4
         STC   R8,0(R5)
         LA    R5,1(R5)
         LA    R4,1(R4)
         BCT   R6,CONVERT
*
         TR    EBCDCFLD(8),ERRTRAN
         LM    R4,R9,X2CX49
         BR    R9
DONEEXT  EQU   *
NOEXT    EQU   *
*
         RTNMAC
*
*        PROGRAM CONSTANTS
*
*
*
*
         EJECT
$MODID   DC    CL16'&SYSDATE.-&SYSTIME'
ZEROES   DC    2F'0'
FMIN1    DC    F'-1'
HW3      DC    H'3'
HW16     DC    H'16'
F8       DC    F'8'
F44      DC    F'44'
BLANKS   DC    CL8'        '
*                0....5....1....5....2....5....3....5....4....5....5
BEGNMSG  DC    C'EXPLJSYM PROGM BEGIN AT'
SYMBMSG  DC    CL80'SYMBOL:'
GET_BY_NAME DC C'GET_BY_NAME:'
GET_ALL     DC C'GET_ALL:'
ENDMSG   DC    C'EXPLJSYM PROCESSING FINISHED NORMALLY'
ERRTRAN  DC    X'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
S1_LIT       DS   CL16'MYSNAME'
S2_LIT       DS   CL16'MYSPLEX'
S3_LIT       DS   CL16'MYCPU1'
***
SJMAC    IEFSJSYM MF=(L,IEFSJMACAREA)
SJMAC_L  EQU   *-SJMAC
*
*
JFCB     DS    44F
JFCBPTR  DC    XL1'87'
         DC    AL3(JFCB)
***
SYSPRINT DCB   DDNAME=SYSPRINT,MACRF=(PM),DSORG=PS
***
*SYSUT1   DCB   MACRF=R,BLKSIZE=96,LRECL=96,KEYLEN=44,RECFM=F,
*              DSORG=PS,EXLST=JFCBPTR,DDNAME=SYSUT1,EODAD=DONERD
SYSUT1   DCB   MACRF=PM,LRECL=80,RECFM=FB,                             X
               DSORG=PS,EXLST=JFCBPTR,DDNAME=SYSUT1
***
         LTORG
         END
###END EXPLJSYM
$$$BEG DFHREST
REST     TITLE 'CUSTOMER INFORMATION CONTROL SYSTEM   TRANSACTION RESTA*
               RT EXIT PROGRAM'
***********************************************************************
*                                                                     *
* 20140326 - copied from  TTED.TSK.F.R510.SYS.SDFHSAMP(DFHREST)       *
*          - added code for BA GOHN AICA waiting for INTRDR           *
*                                                                     *
***********************************************************************
*                                                                     *
* MODULE NAME = DFHREST                                               *
*                                                                     *
* DESCRIPTIVE NAME = CICS/ESA TRANSACTION RESTART PROGRAM             *
*                                                                     *
*                                                                     *
*                                                                     *
*        Licensed Materials - Property of IBM                         *
*                                                                     *
*        "Restricted Materials of IBM"                                *
*                                                                     *
*        5655-Y04                                                     *
*                                                                     *
*        (C) Copyright IBM Corp. 1993, 2000"                          *
*                                                                     *
*                                                                     *
*                                                                     *
*                                                                     *
* STATUS = 6.8.0                                                      *
*                                                                     *
* FUNCTION =                                                          *
*        This module signals to Transaction Manager whether or not    *
*        the task that calls it after an abend may be restarted.      *
*        For further information, see the CICS/ESA Recovery and       *
*        Restart Guide, and the CICS/ESA Customization Guide.         *
*        This program is invoked via an APLU LINK_URM call from the   *
*        Transaction Manager task reply gate.                         *
*                                                                     *
*        THIS IS A PRODUCT SENSITIVE SAMPLE.                          *
*        REFER TO PRODUCT DOCUMENTATION.                              *
*                                                                     *
* CHANGE ACTIVITY :                                                   *
*                                                                     *
*        $MOD(DFHREST),COMP(TRANMGR),PROD(CICS TS ):                  *
*                                                                     *
*     PN= REASON REL YYMMDD HDXIII : REMARKS                          *
*    $L0= 647    410 930202 HD4XGN  : Create DFHREST                  *
*    $L1= 651    410 940113 HD2GJST : Remove Local DLI deadlock test  *
*    $L2= 651    510 940615 HD0FJTC : Restart after VSAM CI deadlock  *
*    $L3= 654    510 950201 HD0PIHR : Restart After AFCW              *
*    $P1= M82373 410 930415 HD2YAIH : COBOL version of DFHXMRSC       *
*    $P2= M16418 610 001020 HD7OPJW : Binder error messages           *
*                                                                     *
***********************************************************************
* * * * *         T R A N S A C T I O N    R E S T A R T      * * * * *
* * * * *                   P R O G R A M                     * * * * *
***********************************************************************
         COPY DFHXMRSD             Data passed from transaction mgr
***********************************************************************
* * *          R E G I S T E R   D E F I N I T I O N              * * *
***********************************************************************
PARMBAR  EQU   7                   Base register for commarea
R8       EQU   8                   R8 REGISTER
R9       EQU   9                   R9 REGISTER
R10      EQU   10                  R10 REGISTER
***********************************************************************
* * *          D Y N A M I C  S T O R A G E                       * * *
***********************************************************************
DFHEISTG DSECT  ,
FRESP    DS    F
FRESP2   DS    F
*
WK_DW    DS    D
WK_PL3   DS    PL3
WK_LIM_3 DS    CL3
*
DATA1    DS    CL1                 SPACE TO FILL DATA
DATA     DS    0CL128              NB. KEEP IN STEP WITH MESSAGE1 BELOW
         DS    CL12
TRANID   DS    CL4                 Transaction id insert for msg
         DS    CL9
TASKID   DS    CL8                 Taskid insert for msg
         DS    CL16
ABNDID   DS    CL4      @50-53     TASKID INSERT FOR MSG
MSGAREA  DS    CL74     @54-127
         DFHEJECT ,
***********************************************************************
* * * * *                 T A S K   R E T R Y                 * * * * *
* * * * *                    P R O G R A M                    * * * * *
***********************************************************************
DFHREST  CSECT                     Transaction restart program CSECT
DFHREST  AMODE 31                                                  @P2A
DFHREST  RMODE ANY                                                 @P2A
         L     PARMBAR,DFHEICAP    Address commarea
         USING XMRS_COMMAREA,PARMBAR Tell the assembler
***********************************************************************
*                                                                     *
***********************************************************************
         JAS   R9,INIT_MSG
***********************************************************************
*                                                                     *
*  If the transaction has issued a read or write to the terminal or   *
*  has executed a syncpoint, then don't attempt to restart.           *
*                                                                     *
***********************************************************************
         CLI   XMRS_READ,XMRS_READ_YES                             @P1C
         JE    RESTNO_ZCIOR
         CLI   XMRS_WRITE,XMRS_WRITE_YES                           @P1C
         JE    RESTNO_ZCIOW
         CLI   XMRS_SYNCPOINT,XMRS_SYNCPOINT_YES                   @P1C
         JE    RESTNO_SYNC
***********************************************************************
*                                                                     *
*  If the transaction has been restarted a particular number of       *
*  times, then don't attempt to restart.                              *
*                                                                     *
***********************************************************************
         SR    R8,R8
         LH    R8,XMRS_RESTART_COUNT
         LH    R10,LIMIT
         J     TRY_REST
***********************************************************************
INIT_MSG DS   0H
         XC    FRESP,FRESP
         XC    FRESP2,FRESP2
         MVI   DATA1,C' '
         MVC   DATA,DATA1
         MVC   DATA(L_MESSAGE1),MESSAGE1
         MVC   TRANID,EIBTRNID     GIVE ACTUAL TRANSACTION ID.
         MVC   ABNDID,XMRS_CURRENT_ABEND_CODE
         UNPK  TASKID+1(7),EIBTASKN  MAKE TASK NUMBER PRINTABLE
         MVZ   TASKID+7(1),TASKID+6
         BR    R9
***********************************************************************
*  NOTE - AICA IS IN SCOPE FOR CERTAIN TRANS                          *
*  Only consider restarting the transaction if the current abend      *
*  code shows that the failure was due to a deadlock.  There is then  *
*  a reasonable chance of the restarted transaction succeeding.       *
*                                                                     *
*  Documented deadlock abend codes are:                               *
*                                                                     *
*    ADCD  DBCTL deadlock                                             *
*    AFCF  Deadlock detected CICS (non-RLS) File Control              *
*    AFCW  Deadlock detected by RLS                                   *
*    AICA  FOR TRANS ON AICA_LIST                                     *
*                                                                     *
***********************************************************************
TRY_REST DS 0H
         CLC   XMRS_CURRENT_ABEND_CODE,AB_ADCD
         JE    RESTYES
         CLC   XMRS_CURRENT_ABEND_CODE,AB_AFCF
         JE    RESTYES
         CLC   XMRS_CURRENT_ABEND_CODE,AB_AFCW
         JE    RESTYES
         CLC   XMRS_CURRENT_ABEND_CODE,AB_AICA
         JE    RESTYES_AICA
         J     RESTNO_UNKN_ABCD
***********************************************************************
*                                                                     *
*  Tell Transaction Manager to restart the transaction and issue a    *
*  message to CSMT.                                                   *
*                                                                     *
***********************************************************************
RESTYES_AICA  DS    0H
         LA    R9,AICA_LIST
         LA    R10,AICA_LIST_END
RESTYES_TOPOFLOP DS 0H
         CLC   EIBTRNID,2(R9)    ACTUAL TRANSACTION ID.
         JE    RESTYES_AICA_TRANID
         LA    R9,6(R9)
         CR    R9,R10
         JL    RESTYES_TOPOFLOP
         J     RESTNO_UNKN_TRNID
*
***********************************************************************
*                                                                     *
*  Tell Transaction Manager to restart the transaction and issue a    *
*  message to CSMT.                                                   *
*                                                                     *
***********************************************************************
RESTYES_AICA_TRANID DS 0H
         LH    R10,0(R9) SET R10 TO AICA REST LIMIT
*
RESTYES  DS    0H
*                        R8 HAS CUR REST COUNT FROM CA
         CR    R8,R10    R10 HAS RESTART LIMIT
         JNL   RESTART_LIM_EXCEEDED
*
         MVC   MSGAREA(L'MSG_RESTARTED),MSG_RESTARTED
         CVD   R8,WK_DW        MAKE TASK NUMBER PRINTABLE
         UNPK  WK_LIM_3,WK_DW+6(2)
         OI    WK_LIM_3+2,X'F0'
         MVC   MSGAREA+25(3),WK_LIM_3
*
*   MAKE IT RESTARTABLE
         MVI   XMRS_RESTART,XMRS_RESTART_YES                       @P1C
         J     RESTMSG_1
*
RESTART_LIM_EXCEEDED DS 0H
*
         MVC   MSGAREA(L'MSG_FAIL_REST_LIM),MSG_FAIL_REST_LIM
         CVD   R8,WK_DW        MAKE TASK NUMBER PRINTABLE
         UNPK  WK_LIM_3,WK_DW+6(2)
         OI    WK_LIM_3+2,X'F0'
         MVC   MSGAREA+25(3),WK_LIM_3
         J     RESTMSG
*
***********************************************************************
* TASK HAS ISSUED ZCIO RECEIVE
***********************************************************************
RESTNO_ZCIOR DS 0H
         MVC   MSGAREA(L'MSG_FAIL_ZCIOR),MSG_FAIL_ZCIOR
         J     RESTMSG
***********************************************************************
* TASK HAS ISSUED ZCIO SEND
***********************************************************************
RESTNO_ZCIOW DS 0H
         MVC   MSGAREA(L'MSG_FAIL_ZCIOW),MSG_FAIL_ZCIOW
         J     RESTMSG
***********************************************************************
* TASK HAS ISSUED SYNC
***********************************************************************
RESTNO_SYNC  DS 0H
         MVC   MSGAREA(L'MSG_FAIL_SYNC),MSG_FAIL_SYNC
         J     RESTMSG
***********************************************************************
* TASK HAS EXCEEDED RESTART LIMIT
***********************************************************************
RESTNO_REST_LIM DS 0H
         MVC   MSGAREA(L'MSG_FAIL_REST_LIM),MSG_FAIL_REST_LIM
         J     RESTMSG
***********************************************************************
* TASK TRANSID IS NOT IN TABLE
***********************************************************************
RESTNO_UNKN_TRNID DS 0H
         MVC   MSGAREA(L'MSG_FAIL_TRNID),MSG_FAIL_TRNID
         J     RESTMSG
***********************************************************************
* TASK ABCODE  IS NOT IN TABLE
***********************************************************************
RESTNO_UNKN_ABCD DS    0H
         MVC   MSGAREA(L'MSG_FAIL_ABCD),MSG_FAIL_ABCD
         J     RESTMSG
***********************************************************************
* WRITE CSSL MSG
***********************************************************************
RESTMSG  DS    0H
         MVI   XMRS_RESTART,XMRS_RESTART_NO                        @P1C
***********************************************************************
RESTMSG_1  DS    0H
         EXEC CICS WRITEQ TD QUEUE('CSMT')                             *
              FROM(DATA) LENGTH(H128)                                  *
              RESP(FRESP) RESP2(FRESP2)
*
         CLI   WTO_Y_N,C'Y'
         JNE   RESTEND
*
         EXEC CICS WRITE OPERATOR TEXT(DATA)
*
         J     RESTEND
***********************************************************************
RESTEND  DS    0H
         EXEC CICS RETURN
*
         LTORG *
***********************************************************************
* * *                C O N S T A N T S   A R E A                  * * *
***********************************************************************
         DC    0D
LIMIT    DC    H'20'               LIMIT FOR NUMBER OF RESTARTS
H128     DC    H'128'              LIMIT FOR NUMBER OF RESTARTS
ABCODE_LIST DC 0D
AB_ADCD   DC  CL4'ADCD'
AB_AFCF   DC  CL4'AFCF'
AB_AFCW   DC  CL4'AFCW'
AB_AICA   DC  CL4'AICA'
AB_END    DC  XL4'FFFFFFFF'
ABCODE_LIST_END EQU *-ABCODE_LIST
*
AICA_LIST DC 0D
BA_GOHN  DC    H'2',CL4'GOHN'
TS_UJJJ  DC    H'2',CL4'UJJJ'
TS_NULL  DC    H'0',XL4'00000000'       EMPTY FOR ZAP IF NEEDED
TS_END   DC    H'0',XL4'FFFFFFFF'
AICA_LIST_END DS  0H
***********************************************************************
**   Fields between here and MSGEND must remain consecutive
**   and match those fields defined in dynamic storage
**   collectively called 'DATA'.
MESSAGE1 DC    C'TRANSACTION:'
         DC    CL4' '
         DC    C',TASK NO:'
         DC    CL8' 0000000'
         DC    C': RECOVERY FROM:'
         DC    CL4' '
MSG_STATUS DC    C': TRANSID IS CANDIDATE FOR RESTART'
L_MESSAGE1 EQU   *-MESSAGE1
MSGEND   EQU   *
MSG_FAIL_ABCD DC    C': FAILED: ABENDCD IS NOT IN TABLE '
MSG_FAIL_TRNID DC    C': FAILED: TRANID IS NOT IN TABLE  '
MSG_FAIL_ZCIOR DC    C': FAILED DUE TO TERMINAL RECVCT >0'
MSG_FAIL_ZCIOW DC    C': FAILED DUE TO TERMINAL SENDCT >0'
MSG_FAIL_SYNC DC    C': FAILED DUE TO TASK ISSUED SYNCPT'
MSG_RESTARTED DC     C': TRANS RESTARTED COUNT :___:TIMES'
MSG_FAIL_REST_LIM DC C': RESTART LIMIT EXCEEDED:___:     '
HEXLIST  DC    X'0123456789ABCDEF'
WTO_Y_N  DC    CL1'N'              DO NOT WTO LIMIT
         END
###END DFHREST
$$$BEG KIXHANG
* FOR EACH EXEC CICS CALL MACRO EXPANDS TO
*  DFHECALL MACRO WHICH IS STD SYSTEM CALL
*  R0  UNDEFINED
*  R1  POINTS TO ADDR OF PARM LIST
*  R14 POINTS TO RETURN POINT IN YOUR PGM
*  R15 POINTS TO ADDR OF ENTRY  PT IN EXEC INTF
* DFHEAI MUST BE LINK EDITED WITH YOUR PGM FOR EXEC INTF RESOLUTION
* EXEC CICS RETURN WILL EXIT YOUR PGM OR DFHEIRET IS INSERTED BY
*  THE TRANSLATOR IF NO EXEC RETURN FOUND
* DFHEIRET INSERTED BY TRANSLATOR AT END OF PGM
*  THIS MACRO: RESTORES REGS
*              RETURNS VIA R14
* DFHECALL BUILDS THE PARM LIST IN DYN STG FOR REENTRANCY
* DFHEIENT INSERTED BY TRANSLATOR AFTER FIRST CSECT
*  THIS MACRO: SAVES REGS
*              GETMAIN STG FOR DFHEISTG
*              SETS BASE REG (R3 DEFAULT)
*              SETS DYN STG REG (R13 DEFAULT)
*              SETS EIB REG (R11 DEFAULT)
* DFHEISTG INSERTED BY TRANSLATOR
*              DEFINES STG PARM LIST
*              DEFINES STG FOR REG SAVE AREA
*              INCLUDES YOUR VARS WHEN YOU CODE THE DFHEISTG MACRO
* DFHEIEND INSERTED BY TRANSLATOR TO ID END OF EIDSA
* DFHEIBLK INSERTED BY TRANSLATOR DEFINES EIB DSECT
* MULTIPLE BASE REGS DEFINED BY DFHEIENT (CODEREG DATAREG EIBREG)
* DFHEIPLR IS THE REG VAR ASSIGNED TO FIRST EIBREG OR DEFAULT
*REG 1                      PASSED ADDR OF PARMS
*REG 3                      BASE REGISTER (CMD LVL)
*REG 11                     PTR TO EIB (SET BY DFHEIENT)
*REG 13                     PTR TO DFHEISTG (SET BY DFHEIENT(
* DFHEIENT ALLOWS FOR PARAMETERS:
*    CODEREGS=(1,...,N) OR R3 BY DEFAULT
*    EIBREG=(N) OR R11/RB BY DEFAULT
*    DATAREG=(N) OR R13/RD BY DEFAULT
*
         REGSMAC
MYDSECT  DSECT
MYMF1    DS    F
*
* DFHEISTG GENERATES A DSECT WHICH ANCHORS THE EXEC INTF. THE MACRO
*  WILL GENERATE A PREFIX AREA TO YOUR OWN DATA, FOLLOWING THE DSECT
*  STATEMENT. IN THIS PREFIX AREA, THE DFHEIPLR (R13), THE DFHEIBP
*  FW POINTER AND DFHEICAP (COMMAREA) POINTERS ARE INITIALIZED BY
*  CICS.
*
DFHEISTG DSECT
SAV_R13  DS    F
SAVEAREX DS    18F
SAVEAREA DS    18D
CRUMPLE  DS    CL16
DWORD    DS    D
FWORD    DS    F
HWORD    DS    H
HWD      DS    0H
*
CVTH     DS    CL8
*
MYMSG1   DS    CL1
MYMSG    DS    CL80
MYTIME   DS    CL8
MYABSTM  DS    PL8
MYFJDT   DS    CL8
MYFTIME  DS    CL8
SAVETRAN DS    CL4
* DEFAULT WAIT TIME IS WAITTIME DC     CL8'00001500'
*                                      CL8'HHMMSSTH'
WAITVAL  DS    CL8
BUFFER   DS    CL(BUFLEN)
ENDOFEIS DS    CL8          SET TO ENDOFEIS
********************************************************************
*
* THE FIRST CSECT IS GOING TO BE USED BY THE TRANSLATOR TO INSERT
*  THE  DFHEIENT MACRO. YOU COULD HAVE ALSO CODED YOUR OWN  DFHEIENT
*  IN ORDER TO SPECIFY CODE AND DATA REGISTERS. THE MACRO GENERATES
*  THE ACTUAL EIBLK DSECT AND THEN INITIALIZES THE EXPECTED DYN STG
*  AND VARIOUS POINTERS IN THE AREA GENERATED BY DFHEISTG.
KIXHANG DFHEIENT
         J     MAIN000
         SPACE 2
*****    GBLC  &SYSDATE
         DC    C'KIXHANG'
         DC    C'&SYSDATE'
         SPACE 1
MAIN000  DS    0H
         MVC   CRUMPLE,L_CRUMPLE
         MVC   ENDOFEIS,L_ENDOFEIS
         MVI   MYMSG1,X'40'
BUFLEN   EQU   133 DEFINE THE BUFFER LENGTH
         MVI BUFFER,C' ' CLEAR A BUFFER TO BLANKS
         MVC BUFFER+1(BUFLEN-1),BUFFER RIPPLE THE FIRST BLANK
         MVC   WAITVAL,WAITTIME
*
*   DEF: R11 IS EIB
*        R13 IS DYN STG
         L     R5,DFHEICAP        POINTED TO FROM EIS
         LTR   R5,R5
         JZ    USEDFLT
         LH    R15,EIBCALEN
         CHI   R15,8
         JNE   USEDFLT
*
         MVC   WAITVAL,0(R5)
*
USEDFLT  DS    0H
         EXEC  CICS HANDLE CONDITION ERROR(ERROR01)
         EXEC  CICS GETMAIN FLENGTH(F4080)                             *
               SET(R10)                                                *
               NOSUSPEND
         USING MYDSECT,R10
         MVC   SAVETRAN,EIBTRNID  SAVE THE INITIATING TXN
         ZAP   MYABSTM,PZERO
         EXEC CICS ASKTIME ABSTIME(MYABSTM)
         EXEC CICS FORMATTIME ABSTIME(MYABSTM)                         *
              DATESEP YYYYDDD(MYFJDT)                                  *
              TIMESEP TIME(MYFTIME)
*          @@@
         MVC   MYMSG,BEGNLNE
*        JAS   R9,WRTLINE
*
*        MVC   MYMSG,TIMELNE
         MVC   MYMSG+22(8),MYFJDT
         MVC   MYMSG+36(8),MYFTIME
         MVC   MYMSG+58(8),WAITVAL
         JAS   R9,WRTLINE
*
         LR    R9,R13
         ST    R13,SAV_R13
         ST    R13,SAVEAREA+4
         LR    R15,R13
         LA    R13,SAVEAREA
         ST    R13,8(R15)
         STIMER WAIT,DINTVL=WAITVAL
*        L      R13,SAV_R13
         LR    R13,R9
         L     R13,SAVEAREA+4
***
DONEIN   EQU   *
         ZAP   MYABSTM,PZERO
         EXEC CICS ASKTIME ABSTIME(MYABSTM)
         EXEC CICS FORMATTIME ABSTIME(MYABSTM)                         *
              DATESEP YYYYDDD(MYFJDT)                                  *
              TIMESEP TIME(MYFTIME)
         MVC   MYMSG,ENDMSG
         MVC   MYMSG+22(8),MYFJDT
         MVC   MYMSG+36(8),MYFTIME
         JAS   R9,WRTLINE
*
RETURN   EQU   *
         EXEC  CICS RETURN
         SPACE
CVTCNT   EQU   *
         CVD   R8,DWORD
         UNPK  CVTH,DWORD+3(5)
         OI    CVTH+4,X'F0'
         XR    R8,R8
         BR    R9
*        %%%%%
WRTLINE  EQU   *
DOTD     EQU   *
         EXEC  CICS WRITEQ TD QUEUE('CSSL') FROM(MYMSG) LENGTH(H80)
         MVC   MYMSG,MYMSG1
         BR    R9
ERROR01  DS    0H
         MVC   MYMSG,ERR1LNE
         BAS   R9,WRTLINE
         J     RETURN
ERROR02  DS    0H
         MVC   MYMSG,ERR2LNE
         JAS   R9,WRTLINE
         J     RETURN
         EJECT
WAITTIME DC     CL8'00001500'
*   DINTVL HH MM SS T H (8BYTE:GMT, DW:MICVL,
*   BINTVL FW BIN INTVL AS .01 SEC THROUGH 7FFFFFFF
*   TUINTVL FW BIN INTVL AS 26.04 MS
F4080    DC    F'4080'
HNEG1    DC    H'-1'
H0       DC    H'0'
H20      DC    H'20'
H80      DC    H'80'
H4080    DC    H'4096'
*CEMTBLA  DC    A(CEMVALUE)
         SPACE
PZERO    DC    PL1'0'
SP80     DC    CL80' '
*
L_ENDOFEIS DC  CL8'ENDOFEIS'
L_CRUMPLE DC  CL16'XXXXXXXXXXXXXXXX'
BEGNLNE  DC    CL80'*** BEGIN KIXHANG ***          ++++         : WAITI*
               NG FOR:         (HHMMSSDH)'
*TIMELNE  DC    CL80'***          ++++        '
*              CL80'0....5....0....5....0....5....0....5....0....5'
ENDMSG   DC    CL80'*** END   KIXHANG ***          ++++         '
STGMSG   DC    CL80'$$$ STORAGE FOR COND GETMAIN NOT AVAILABLE. BYE.'
ERR1LNE  DC    CL80'$$$ ERROR IN INITIALIZATION OF ROUTINE ERROR 1'
ERR2LNE  DC    CL80'$$$ ERROR IN PROCESSING ERROR 2'
*                   0         0         0         0         0    5'
         SPACE 3
         LTORG
         DC    C'****'
         DC    C'KIXHANG - CIGNA * CPCW *'
         DC    C' '
         DC    C'DATE='
         DC    C'&SYSDATE'
         DC    C' '
         DC    C'TIME='
         DC    C'&SYSTIME'
         DC    C' '
         DC    C'TCEM'
         DC    C'****'
*        EXTRN CEMVALUE
         END
###END KIXHANG
$$$BEG MYSTIM
*
MYSTIM   CSECT
         STM   R14,R12,12(R13)
         BALR  R11,0
         USING *,R11
         ST    R13,SAVEAREA+4
         LR    R15,R13
         LA    R13,SAVEAREA
         ST    R13,8(R15)
         XR     R2,R2
         L      R2,0(R1)
         LTR    R2,R2
         BZ     NOPARM
         XR     R3,R3
         LH     R3,0(R2)
         CH     R3,=H'8'
         BNE    NOPARM
         LA     R5,2(R2)
         MVC    WAITTIME,2(R2)
NOPARM   EQU    *
***
         STIMER WAIT,DINTVL=WAITTIME
* OTHER OPTIONS:
*   WAIT
*   REAL{,EXIT RTN}
*   TASK{,EXIT RTN}
*   REGISTER  CONTENTS
*       0-12      DO NOT CONTAIN ANY INFORMATION FOR USE BY THE ROUTINE
*       13        ADDRESS OF A SYSTEM-PROVIDED, 72-BYTE SAVE AREA.
*       14        RETURN ADDRESS (TO THE SYSTEM).
*       15        ADDRESS OF THE EXIT ROUTINE.
*   DINTVL HH MM SS T H (8BYTE:GMT, DW:MICVL,
*   BINTVL FW BIN INTVL AS .01 SEC THROUGH 7FFFFFFF
*   TUINTVL FW BIN INTVL AS 26.04 MS
*   MICVL
*   ,GMT=   8BYTE TOD COMPLETION TIME
*   ,TOD=          SAME
*   ,LT=           SAME
*   SEE ALSO STIMERM CPUTIMER TTIMER
***
ENDIT    EQU    *
         ST    R13,SAVEAREA+4
         LR    R15,R13
         LA    R13,SAVEAREA
         ST    R13,8(R15)
SAVEAREA DS    18F
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
***
WAITTIME DC     CL8'00000500'
         LTORG
         END
###END MYSTIM
$$$BEG KIXSMTP
           TITLE 'S E N D M A I L  TCPSMTP MAIL INTERFACE'
***********************************************************************
*                                                                     *
*     S E N D M A I L  THIS PROGRAM IS USED TO SEND EMAIL FROM CICS   *
*     USING THE CICS SPOOL INTERFACE.                                 *
*                                                                     *
*     COMMAREA FORMAT:                                                *
*         40 BYTES RECIPIENT EMAIL ADDRESS                            *
*         40 BYTES SENDER EMAIL ADDRESS                               *
*         80 BYTES TO:                                                *
*         80 BYTES FROM:                                              *
*         80 BYTES SUBJECT:                                           *
*         80 BYTES MESSAGE TEXT     <<< 400 AT END                    *
*            ....                                                     *
*         80 BYTES END OF MESSAGE LINES                               *
*                                                                     *
*    NOTE THAT THE COMMAREA MUST BE A MULTIPLE OF 80 CHARACTERS       *
*    AND BE A MINIMUM OF 5*80 OR 400 BYTES LONG AND A MAXIMUM OF      *
*    32K (CICS COMMAREA LIMIT).                                       *
*                                                                     *
*    RETURN CODES:                                                    *
*         FF  ERROR                                                   *
*                                                                     *
*    EXAMPLE:                                                         *
*                                                                     *
*     CA       DS   0D                                                *
*     CARCPT   DC   CL40'CHARLIE.MACK@CIGNA.COM'                      *
*     CAFROM   DC   CL40'TCEM@ASYSTCP'
*              ORG  CA                                                *
*     CARESP   DC   XL1'00'                                           *
*              ORG                                                    *
*     CAMSG1   DC   CL80'TO:  CHARLIE MACK'                           *
*     CAMSG2   DC   CL80'FROM: "TCEM (ON CGTO)"
*     CAMSG3   DC   CL80'SUBJECT: MAIL FROM CICS'                     *
*     CAMSG4   DC   CL80'THIS IS A TEST EMAIL FROM CGE7'              *
*     CAMSG5   DC   CL80'THIS IS MY WAY COOL'                         *
*                                                                     *
*              EXEC CICS LINK PROGRAM('KIXSMTP')                      *
*                        COMMAREA(CA) LENGTH(CALEN)                   *
*              CLI  CARESP,X'FF'    Q-ERROR RETURN CODE               *
*              BE   SENDFAIL        BIF YES, ELSE CONTINUE            *
*                                                                     *
***********************************************************************
         EJECT                                                        *
***********************************************************************
*                                                                     *
*    REGISTER USAGE:                                                  *
*     R0                                                              *
*     R1                                                              *
*     R2                                                              *
*     R3   COMMAREA POINTER                                           *
*     R4   COMMAREA STOPPER                                           *
*     R5   JAS                                                        *
*     R6                                                              *
*     R7                                                              *
*     R8                                                              *
*     R9                                                              *
*     R10                                                             *
*     R11  EIB BASE REGISTER                                          *
*     R12  CODE BASE REGISTER                                         *
*     R13  DATA BASE REGISTER                                         *
*     R14                                                             *
*     R15                                                             *
*                                                                     *
***********************************************************************
         SPACE 2
         EJECT
***********************************************************************
*                                                                     *
*        P R O G R A M     V A R I A B L E S                          *
*                                                                     *
***********************************************************************
DFHEISTG DSECT
         SPACE 1
RESP     DS    F
HLDMSGLEN DS   H
TOKEN    DS    CL8
WORKLINE DS    CL80
         SPACE 1
***********************************************************************
*                                                                     *
*        C O M M A R E A     D S E C T                                *
*                                                                     *
***********************************************************************
         SPACE 1
COMMAREA DSECT
CARCPT   DS    CL40
CAFROM   DS    CL40
         ORG   COMMAREA
CAMSG    DS    CL80
CANEXT   EQU   *
         ORG   COMMAREA
CARESP   DS    XL1
         ORG
         SPACE 3
***********************************************************************
         EJECT
KIXSMTP DFHEIENT CODEREG=(12),DATAREG=(13),EIBREG=(11)
KIXSMTP AMODE 31
KIXSMTP RMODE ANY
         DFHREGS
         EJECT
         SPACE 2
START    DS    0H                 ** INITIALIZATION **
         L     R3,DFHEICAP        GET ADDRESS OF COMMAREA
         LTR   R3,R3              Q-IS COMMAREA AVAILABLE
         JNZ   USE_CA             BIF NO
*
         LA    R3,DFTMSG
         MVC   HLDMSGLEN,DFTMSGLEN
         J     USE_DFT
USE_CA   DS    0H
         CLC   EIBCALEN,=H'400'   Q-IS COMMAREA OF PROPER LENGTH
         JL    RETURN8            YES
         MVC   HLDMSGLEN,EIBCALEN
USE_DFT  DS    0H
         USING COMMAREA,R3        SET ADDRESSABILITY
         LR    R4,R3              ADDRESS THE
         AH    R4,HLDMSGLEN           END OF THE COMMAREA
* BUILD EMAIL MESSAGES
         EXEC CICS SPOOLOPEN OUTPUT TOKEN(TOKEN) USERID(TCPSMTP)       *
               NODE(NODE) CLASS(CLASSB) NOCC PUNCH RESP(RESP)
         CLC   RESP,DFHRESP(NORMAL)
         JNE   RETURN8
         MVC   WORKLINE,HELLO
         JAS   R5,WRITE
         MVC   WORKLINE,MAILFROM
         MVC   WORKLINE+12(L'CAFROM),CAFROM
         JAS   R5,WRITE
         MVC   WORKLINE,RCPTTO
         MVC   WORKLINE+10(L'CARCPT),CARCPT
         JAS   R5,WRITE
         MVC   WORKLINE,DATA
         JAS   R5,WRITE
         LA    R3,CANEXT
SENDLOOP DS    0H
         MVC   WORKLINE,CAMSG
         JAS   R5,WRITE
         LA    R3,CANEXT
         CR    R3,R4
         JL    SENDLOOP
         EXEC CICS SPOOLCLOSE TOKEN(TOKEN) KEEP RESP(RESP)
         CLC   RESP,DFHRESP(NORMAL)
         JE    RETURN
RETURN8  DS    0H                 ** INVALID COMMAREA LENGTH **
         MVI   CARESP,X'FF'       SET RC=ERROR
RETURN12 DS    0H
RETURN   DS    0H
         EXEC CICS RETURN
WRITE    DS    0H
         EXEC CICS SPOOLWRITE TOKEN(TOKEN) FROM(WORKLINE) RESP(RESP)
         CLC   RESP,DFHRESP(NORMAL)
         BNE   RETURN8
         BR    R5
         SPACE 2
***********************************************************************
         EJECT
***********************************************************************
*                                                                     *
*        P R O G R A M     C O N S T A N T S                          *
* HELO WNDMVS1
* MAIL FROM:<XXXX@ASYSTCP1>                                           *
* RCPT TO:<CHARLIE.MACK@CIGNA.COM>                                    *
* DATA                                                                *
* DATE: TUE 01 JUL 2003 13:00:00 EST                                  *
* GREETINGS TOO!                                                      *
* QUIT                                                                *
*                                                                     *
***********************************************************************
         SPACE 1
TCPSMTP  DC    CL8'TY1SMTP'             ACTUAL SYSOUT PARAMETER
NODE     DC    CL8'WNDMVS1'             JES NODE
CLASSB   DC    CL1'B'                   SYSOUT CLASS
HELLO    DC    CL80'HELO MVSHOST'
MAILFROM DC  CL80'MAIL FROM:<1234567890123456789012345678901234567890>'
* ONE TO MANY RCPTTO LINES CAN BE WRITTEN
RCPTTO   DC  CL80'RCPT TO:<1234567890123456789012345678901234567890>'
*
DATA     DC    CL80'DATA'
*
DFTRCPT   DC  CL40'<CHARLIE.MACK@CIGNA.COM>'
DFTSNDR   DC  CL40'<TCEM@YSYSTCP1.SYS.CIGNA.COM>'
DFTMSG    DC  0D
DFTFROM   DC  CL80'FROM: TCEM@YSYSTCP1.SYS.CIGNA.COM'
DFTTO     DC  CL80'TO: CHARLIE.MACK@CIGNA.COM'
DFTSUBJECT DC CL80'SUBJECT: MAIL FROM CICS'
DFTMSG1   DC  CL80'THIS IS A TEST EMAIL FROM CGE7'
DFTMSGLEN DC   Y(*-DFTMSG)
***********************************************************************
         SPACE 1
         END
###END KIXSMTP
$$$BEG PGMAM24
          TITLE 'PGMAM24'
DFHEISTG DSECT
RIDB     DS    CL4
REC      DS    CL4
*
PGMAM24  AMODE 24
PGMAM24  RMODE 24
PGMAM24  CSECT
         BAL  2,ROUTINE
         EXEC CICS RETURN
ROUTINE  EXEC CICS HANDLE CONDITION ERROR(AFTREAD)
         EXEC CICS READ INTO(REC) FILE('BIGG') RIDFLD(RIDB)
AFTREAD  BCR  15,2
         END
###END PGMAM24
$$$BEG UCANULST
         REGSMAC
*
* DFHEISTG GENERATES A DSECT WHICH ANCHORS THE EXEC INTF. THE MACRO
*  WILL GENERATE A PREFIX AREA TO YOUR OWN DATA, FOLLOWING THE DSECT
*  STATEMENT. IN THIS PREFIX AREA, THE DFHEIPLR (R13), THE DFHEIBP
*  FW POINTER AND DFHEICAP (COMMAREA) POINTERS ARE INITIALIZED BY
*  CICS.
*
DFHEISTG DSECT
DWORD    DS    D
FRESP    DS    F
FRESP2   DS    F
ACTIVLST DS    F         ADDR OF ACTIVE TASK LIST
ACTIVTASKN DS  F         ADDR OF ACTIVE TASK LIST
ACTIVCNT DS    F         # OF TASKS ACTIVE THIS REGION
*
MYMSG1   DS    CL1
MYMSG    DS    CL132
MYTIME   DS    CL8
MYABSTM  DS    PL8
ACT_ULST_TASKN DS PL4
MYFDT    DS    CL10
MYFTIME  DS    CL8
INQREQID DS    CL16
INQTRNID DS    CL4
SAVE_PGMID DS  CL8
SAVETRAN DS    CL4
TASKNUM  DS    CL8
ENDOFEIS DS    CL8          SET TO ENDOFEIS
********************************************************************
*
* THE FIRST CSECT IS GOING TO BE USED BY THE TRANSLATOR TO INSERT
*  THE  DFHEIENT MACRO. YOU COULD HAVE ALSO CODED YOUR OWN  DFHEIENT
*  IN ORDER TO SPECIFY CODE AND DATA REGISTERS. THE MACRO GENERATES
*  THE ACTUAL EIBLK DSECT AND THEN INITIALIZES THE EXPECTED DYN STG
*  AND VARIOUS POINTERS IN THE AREA GENERATED BY DFHEISTG.
UCANULST DFHEIENT CODEREG=3
         MVC   ENDOFEIS,L_ENDOFEIS
         MVI   MYMSG1,X'40'
         MVC   MYMSG,MYMSG1            RIPPLE THE FIRST BLANK
*
         EXEC CICS ASSIGN PROGRAM(SAVE_PGMID)
         MVC   MYMSG(8),SAVE_PGMID
         MVC   SAVETRAN,EIBTRNID  SAVE THE INITIATING TXN
         MVC   MYMSG+9(4),SAVETRAN
         UNPK  TASKNUM,EIBTASKN
         OI    TASKNUM+7,X'F0'
         MVC   MYMSG+14(5),TASKNUM+3
         BAS   R9,GETDT_TM
         MVC   MYMSG+40(70),STRTMSG
         MVC   MYMSG+48(L'STDMSG),STDMSG
         BAS   R9,WRTLINE
*
         EXEC CICS INQUIRE TASK LIST LISTSIZE(ACTIVCNT)                X
         SET(R9) SETTRANSID(R7)
         ST    R7,ACTIVLST     SAVE ADDR OF ACTIV TRAN LIST
         ST    R9,ACTIVTASKN   SAVE ADDR OF ACTIV TRANNUM LIST
*
         L     R4,ACTIVCNT
         LA    R5,0
FIND_ULST_LOOP EQU *
         CLC   0(4,R7),ULST_TRNID
         BE    FND_ULST_ACT
         LA    R5,4(R5)
         LA    R7,4(R7)
         BCT   R4,FIND_ULST_LOOP
         B     ULST_NOT_ACTIVE
FND_ULST_ACT  EQU   *
         LA    R9,0(R5,R9)
         ZAP   ACT_ULST_TASKN,0(4,R9)
         BZ    DO_CAN_REQID
         EXEC CICS SET TASK(ACT_ULST_TASKN) FORCEPURGE                 *
              RESP(FRESP) RESP2(FRESP2)
         CLC   FRESP,DFHRESP(NORMAL)
         BE    ULST_FP
         MVC   MYMSG+40(8),ULST_FP_FAIL
         B     FP_MSG
*
ULST_FP  EQU   *
         MVC   MYMSG+40(8),ULST_FP_GOOD
         B     FP_MSG
*
FP_MSG   EQU   *
         BAS   R9,GETDT_TM
         BAS   R9,WRTLINE
         B     DO_CAN_REQID
*
ULST_NOT_ACTIVE EQU *
         MVC   MYMSG+40(8),ULST_NOT_RUN
         BAS   R9,GETDT_TM
         BAS   R9,WRTLINE
         B     DO_CAN_REQID
*
DO_CAN_REQID EQU *
         LA    R4,100            LOOP COUNTER FOR REQID
*
         EXEC CICS INQUIRE REQID START                                 *
              RESP(FRESP) RESP2(FRESP2)
         CLC   FRESP,DFHRESP(NORMAL)
         BE    LOOP_REQID
*
         BAS   R9,GETDT_TM
         MVC   MYMSG+40(8),ERRMSG
         BAS   R9,WRTLINE
         B DONEIN
*
LOOP_REQID EQU *
         EXEC CICS INQUIRE REQID(INQREQID) NEXT TRANSID(INQTRNID)      *
              RESP(FRESP) RESP2(FRESP2)
         CLC   FRESP,DFHRESP(END)
         BE    NOTFND
*
         CLC   FRESP,DFHRESP(NORMAL)
         BNE   REQIDERR0
*
         CLC   INQTRNID,ULST_TRNID
         BE    FND_ULST
*
         BCT   R4,LOOP_REQID
         MVC   MYMSG+40(8),TOOMANY
         B     REQIDERR1
*
FND_ULST EQU *
         EXEC CICS INQUIRE REQID END
         EXEC CICS CANCEL TRANSID(ULST_TRNID) REQID(INQREQID)          *
              RESP(FRESP) RESP2(FRESP2)
         CLC   FRESP,DFHRESP(NORMAL)
         BE    DONEIN
*
         CLC   FRESP,DFHRESP(NOTFND)
         BE    NOTFND
*
REQIDERR0 EQU   *
         MVC   MYMSG+40(8),ERRMSG
REQIDERR1 EQU   *
         BAS   R9,GETDT_TM
         BAS   R9,WRTLINE
         B DONEIN
*
NOTFND   EQU   *
         EXEC CICS INQUIRE REQID END
         BAS   R9,GETDT_TM
         MVC   MYMSG+40(8),NOTFNDMSG
         BAS   R9,WRTLINE
         B DONEIN
*
DONEIN   EQU   *
         BAS   R9,GETDT_TM
         MVC   MYMSG+40(8),ENDMSG
         BAS   R9,WRTLINE
*
RETURN   EQU   *
         EXEC  CICS RETURN
         SPACE
GETDT_TM DS    0H
         ZAP   MYABSTM,PZERO
         EXEC CICS ASKTIME ABSTIME(MYABSTM)
         EXEC CICS FORMATTIME ABSTIME(MYABSTM) DATESEP                 *
              YYYYMMDD(MYFDT) TIMESEP TIME(MYFTIME)
*          @@@
         MVC   MYMSG+20(10),MYFDT
         MVC   MYMSG+31(8),MYFTIME
         BR    R9
*        %%%%%
WRTLINE  EQU   *
DOTD     EQU   *
         EXEC  CICS WRITEQ TD QUEUE('CSSL') FROM(MYMSG) LENGTH(H132)
         BR    R9
         EJECT
         LTORG
H132     DC    H'132'
PZERO    DC    PL1'0'
*
L_ENDOFEIS DC  CL8'ENDOFEIS'
ULST_TRNID DC  CL4'ULST'
ULSTREQD DC    CL8'ULSTREQD'
STDMSG   DC    C' :CANCEL ULST TRANSID REQID(ULSTREQD)'
STRTMSG  DC    CL70'* START '
ENDMSG   DC    CL8'* END   '
ERRMSG   DC    CL8'$ ERROR '
TOOMANY  DC    CL8'@TOOMANY'
ULST_NOT_RUN DC  CL8'*NOT ACT'
ULST_FP_FAIL DC  CL8'$FP FAIL'
ULST_FP_GOOD DC  CL8'*FP GOOD'
NOTFNDMSG DC    CL8'!NOTFND '
         SPACE 3
         DC    C'****'
         DC    C'UCANULST - CIGNA * CPCW *'
         DC    C' '
         DC    C'DATE='
         DC    C'&SYSDATE'
         DC    C' '
         DC    C'TIME='
         DC    C'&SYSTIME'
         DC    C' '
         DC    C'TCEM'
         DC    C'****'
*        EXTRN CEMVALUE
         END
###END UCANULST
$$$BEG EXPLBREL
TEST     CSECT
R12      EQU   12
         USING STATICAREA,R12
*        COPY  IEABRC
* THE IEABRC MACRO DEFINES MACROS TO INTERCEPT
* AND CHANGE VARIOUS BASE-DISPLACEMENT BRANCH
* INSTRUCTIONS TO THEIR RELATIVE BRANCH
* EQUIVALENTS. MANY MACROS CONTAIN BASE-
* DISPLACEMENT BRANCHES THAT COULD FUNCTIONALLY
* BE RELATIVE BRANCHES. IN ORDER TO WRITE AN
* ASSEMBLER ROUTINE THAT BOTH USES THESE MACROS
* AND USES RELATIVE BRANCHING, YOU CAN USE IEABRC
* TO ENABLE THOSE MACROS TO USE RELATIVE BRANCHES.
* CHANGING BASE-DISPLACEMENT BRANCH INSTRUCTIONS
* TO THEIR RELATIVE BRANCH EQUIVALENTS CAN
* ELIMINATE CODE ADDRESSABILITY ISSUES.
* NOTE:
* USING IEABRC DOES NOT GUARANTEE THAT ALL
* MACROS CAN BE INVOKED WITHOUT CODE
* ADDRESSABILITY. SOME MACROS STILL REQUIRE
* ADDRESSABILITY TO THE LOCATION WHERE THE
* MACRO IS INVOKED.
*
* THE IEABRCX MACRO DEFINES MACROS TO INTERCEPT
* AND CHANGE VARIOUS BASE-DISPLACEMENT BRANCH
* INSTRUCTIONS TO THEIR RELATIVE BRANCH
* EQUIVALENTS. MANY MACROS CONTAIN BASE-
* DISPLACEMENT BRANCHES THAT COULD FUNCTIONALLY
* BE RELATIVE BRANCHES. IN ORDER TO WRITE AN
* ASSEMBLER ROUTINE THAT BOTH USES THESE MACROS
* AND USES RELATIVE BRANCHING, YOU CAN USE
* IEABRCX TO ENABLE THOSE MACROS TO USE RELATIVE
* BRANCHES. CHANGING BASE-DISPLACEMENT BRANCH
* INSTRUCTIONS TO THEIR RELATIVE BRANCH
* EQUIVALENTS CAN ELIMINATE CODE ADDRESSABILITY
* ISSUES.
* NOTES:
*     USING IEABRCX DOES NOT GUARANTEE THAT ALL
*     MACROS CAN BE INVOKED WITHOUT CODE
*     ADDRESSABILITY. SOME MACROS STILL REQUIRE
*     ADDRESSABILITY TO THE LOCATION WHERE THE
*     MACRO IS INVOKED.
*     IBM RECOMMENDS USING IEABRCX INSTEAD OF
*     IEABRC BECAUSE IEABRCX PROVIDES ADDITIONAL
*     FUNCTIONALITY. USING IEABRCX DEFINE IS
*     EQUIVALENT TO USING COPY IEABRC.
*
         IEABRCX DEFINE
         ENQ   (QNAME,RNAME,E,RNAMELEN,SYSTEM)
*
         IEABRCX PUSH       SAVE THE CURRENT STATE
         IEABRCX DISABLE    DISABLE CONVERSION
* -- BASE/DISPLACEMENT BRANCHES NOT CONVERTED
         IEABRCX POP        RESTORE THE PREVIOUS STATE
         ENQ   (QNAME,RNAME2,E,RNAME2LEN,SYSTEM)
STATICAREA DC  D'0'
QNAME    DC    CL8'THEQNAME'
RNAME    DC    CL8'THERNAME'
RNAMELEN EQU   L'RNAME
RNAME2   DC    CL9'THERNAME2'
RNAME2LEN EQU  L'RNAME2
         END   TEST
###END EXPLBREL
$$$BEG RXVSAM1
  TITLE 'RXVSAM1 - REXX Function To Perform VSAM Requests'
* exclude 312
         PUSH PRINT
         PRINT OFF
         MACRO
&LABEL   GENMSGS &GEN=DSECT
         AIF   ('&GEN' EQ 'DSECT').OK
         AIF   ('&GEN' EQ 'CSECT').OK
         MNOTE 8,'GENMSGS MACRO STATEMENT HAD AN INVALID VALUE'
         AGO   .ENDMAC
.OK      ANOP
&LABEL   &GEN
         AIF   ('&GEN' EQ 'CSECT').SKP0000
M$ALLOK  DS      0CL38
.SKP0000 ANOP
         DC      CL4'0000'
         DC      CL4'I'
         DC      CL30'Request successfully processed'
         AIF   ('&GEN' EQ 'CSECT').SKP0001
M$BADARG DS      0CL31
.SKP0001 ANOP
         DC      CL4'0001'
         DC      CL4'E'
         DC      CL23'Invalid argument passed'
         AIF   ('&GEN' EQ 'CSECT').SKP0002
M$BADOPN DS      0CL19
.SKP0002 ANOP
         DC      CL4'0002'
         DC      CL4'E'
         DC      CL11'Open failed'
         AIF   ('&GEN' EQ 'CSECT').SKP0003
M$BADCLO DS      0CL20
.SKP0003 ANOP
         DC      CL4'0003'
         DC      CL4'E'
         DC      CL12'Close failed'
         AIF   ('&GEN' EQ 'CSECT').SKP0004
M$EOF    DS      0CL19
.SKP0004 ANOP
         DC      CL4'0004'
         DC      CL4'W'
         DC      CL11'End of File'
         AIF   ('&GEN' EQ 'CSECT').SKP0005
M$PREVOP DS      0CL28
.SKP0005 ANOP
         DC      CL4'0005'
         DC      CL4'E'
         DC      CL20'File is already open'
         AIF   ('&GEN' EQ 'CSECT').SKP0006
M$NOBLK  DS      0CL46
.SKP0006 ANOP
         DC      CL4'0006'
         DC      CL4'E'
         DC      CL39'UNABLE TO ACCESS RXVSAM1 BLOCK VARIABLE'
         AIF   ('&GEN' EQ 'CSECT').SKP0007
M$NORECV DS      0CL67
.SKP0007 ANOP
         DC      CL4'0007'
         DC      CL4'E'
         DC      CL46'REXX record variable could not be accessed or '
         DC      CL13'was undefined'
         AIF   ('&GEN' EQ 'CSECT').SKP0008
M$DUPL   DS      0CL24
.SKP0008 ANOP
         DC      CL4'0008'
         DC      CL4'E'
         DC      CL16'Duplicate record'
         AIF   ('&GEN' EQ 'CSECT').SKP0010
M$VMSG   DS      0CL38
.SKP0010 ANOP
         DC      CL4'0010'
         DC      CL4'E'
         DC      CL30'Unable to save VSAM error data'
         AIF   ('&GEN' EQ 'CSECT').SKP0011
M$RMSG   DS      0CL41
.SKP0011 ANOP
         DC      CL4'0011'
         DC      CL4'E'
         DC      CL33'Unable to set return message text'
         AIF   ('&GEN' EQ 'CSECT').SKP0012
M$CLOSAC DS      0CL77
.SKP0012 ANOP
         DC      CL4'0012'
         DC      CL4'E'
         DC      CL46'ACB was not available to perform CLOSE request'
         DC      CL23' - file may not be open'
         AIF   ('&GEN' EQ 'CSECT').SKP0014
M$NOACB  DS      0CL71
.SKP0014 ANOP
         DC      CL4'0014'
         DC      CL4'E'
         DC      CL41'ACB was not available to perform request '
         DC      CL22'- file may not be open'
         AIF   ('&GEN' EQ 'CSECT').SKP0015
M$BADSCB DS      0CL56
.SKP0015 ANOP
         DC      CL4'0015'
         DC      CL4'E'
         DC      CL48'Unable to obtain max record length for this file'
         AIF   ('&GEN' EQ 'CSECT').SKP0016
M$NOTFND DS      0CL24
.SKP0016 ANOP
         DC      CL4'0016'
         DC      CL4'W'
         DC      CL16'Record not found'
         AIF   ('&GEN' EQ 'CSECT').SKP016A
M$BWDNF  DS      0CL87
.SKP016A ANOP
         DC      CL4'0016'
         DC      CL4'W'
         DC      CL47'Record not found - a FULL KEY must be specified'
         DC      CL32' when issuing a STARTBWD request'
         AIF   ('&GEN' EQ 'CSECT').SKP016B
M$SHWCAT DS      0CL50
.SKP016B ANOP
         DC      CL4'0016'
         DC      CL4'W'
         DC      CL47'SHOWCAT - PRIMARY KEY LENGTH DEFINED:'
         DC      CL5'00000'
         AIF   ('&GEN' EQ 'CSECT').SKP0017
M$NORLEN DS      0CL41
.SKP0017 ANOP
         DC      CL4'0017'
         DC      CL4'E'
         DC      CL33'Cannot determine length of record'
         AIF   ('&GEN' EQ 'CSECT').SKP0018
M$BADUPD DS      0CL41
.SKP0018 ANOP
         DC      CL4'0018'
         DC      CL4'E'
         DC      CL33'Unable to modify RPL for "UPDate"'
         AIF   ('&GEN' EQ 'CSECT').SKP0019
M$BADFUN DS      0CL23
.SKP0019 ANOP
         DC      CL4'0019'
         DC      CL4'E'
         DC      CL15'Function failed'
         AIF   ('&GEN' EQ 'CSECT').SKP0020
M$NOREC  DS      0CL40
.SKP0020 ANOP
         DC      CL4'0020'
         DC      CL4'E'
         DC      CL32'Unable to update RECORD variable'
         AIF   ('&GEN' EQ 'CSECT').SKP0021
M$NOIN   DS      0CL34
.SKP0021 ANOP
         DC      CL4'0021'
         DC      CL4'E'
         DC      CL26'File is not open for INPUT'
         AIF   ('&GEN' EQ 'CSECT').SKP0022
M$NOOUT  DS      0CL35
.SKP0022 ANOP
         DC      CL4'0022'
         DC      CL4'E'
         DC      CL26'File is not open for OUTPUT'
         AIF   ('&GEN' EQ 'CSECT').SKP0023
M$BADDSW DS      0CL42
.SKP0023 ANOP
         DC      CL4'0023'
         DC      CL4'E'
         DC      CL34'Unable to switch to DIR processing'
         AIF   ('&GEN' EQ 'CSECT').SKP0024
M$NOGEN  DS      0CL41
.SKP0024 ANOP
         DC      CL4'0024'
         DC      CL4'E'
         DC      CL33'READGENERIC only allowed for KSDS'
         AIF   ('&GEN' EQ 'CSECT').SKP0025
M$NONNUM DS      0CL45
.SKP0025 ANOP
         DC      CL4'0025'
         DC      CL4'E'
         DC      CL37'Non-numeric key specified for an RRDS'
         AIF   ('&GEN' EQ 'CSECT').SKP0026
M$NOESDS DS      0CL48
.SKP0026 ANOP
         DC      CL4'0026'
         DC      CL4'E'
         DC      CL40'This function is not allowed for an ESDS'
         AIF   ('&GEN' EQ 'CSECT').SKP0027
M$NORRN  DS      0CL33
.SKP0027 ANOP
         DC      CL4'0027'
         DC      CL4'E'
         DC      CL26'UNABLE TO SET RXVSAM1_RRN#'
         AIF   ('&GEN' EQ 'CSECT').SKP0028
M$KEYZER DS      0CL63
.SKP0028 ANOP
         DC      CL4'0028'
         DC      CL4'E'
         DC      CL48'A zero length (omitted) key is only allowed for '
         DC      CL7'an ESDS'
         AIF   ('&GEN' EQ 'CSECT').SKP0088
M$NOPOS  DS      0CL55
.SKP0088 ANOP
         DC      CL4'0088'
         DC      CL4'E'
         DC      CL47'READPREV attempted without a previous STARTBWD '
         AIF   ('&GEN' EQ 'CSECT').SKP0092
M$NOGET  DS      0CL59
.SKP0092 ANOP
         DC      CL4'0092'
         DC      CL4'E'
         DC      CL47'REWRITE or DELETE attempted without a previous '
         DC      CL4'READ'
         AIF   ('&GEN' EQ 'CSECT').SKP0108
M$BADRL  DS      0CL99
.SKP0108 ANOP
         DC      CL4'0108'
         DC      CL4'E'
         DC      CL48'Record length = 0, > max, < key length (KSDS) or'
         DC      CL43' not equal to slot size (fixed length RRDS)'
.ENDMAC  ANOP
         MEND
         POP PRINT
         MACRO
&LABEL   SETMSG &MSG=
         AIF   ('&MSG' NE '').OK
         MNOTE 8,'NO MESSAGE SPECIFIED'
         AGO   .ENDMAC
.OK      ANOP
         L     14,RXVSMSG@        GET EPA FOR RXVSAM1 MSG CSECT
         USING MSGDSECT,14
         LA    15,&MSG
         ST    15,MSG@            SAVE -> MESSAGE TEXT
         LA    15,L'&MSG
         STH   15,MSGLEN          SAVE MESSAGE LENGTH
         DROP  14
.ENDMAC  ANOP
         MEND
         SPACE
         MACRO
&LABEL   NTERROR &REQ=,&SYM=,&GOTO=
         AIF   ('&REQ' NE '').CHKSYM
         MNOTE 8,'NO REQUEST TYPE SPECIFIED'
         AGO   .ENDMAC
.CHKSYM  ANOP
         AIF   ('&SYM' NE '').OK
         MNOTE 8,'NO SYMBOL (LABEL) SPECIFIED'
         AGO   .ENDMAC
.OK      ANOP
         MVC   NTMSG(NTMSGLEN),NTMSGINI    INIT MESSAGE AREA
         ST    R15,NAMTOKRC                SAVE RETURN CODE
         CVD   R15,DBLWRK
         OI    BYTEWRK2,X'F0'
         MVC   NTMSGR15,HALFWRK2
         MVC   NTREQ,=CL8'&REQ'            SAVE REQUEST TYPE
         MVC   NTLABEL,=CL8'&SYM'          AND RXVSAM1 LABEL
         AIF   ('&GOTO' EQ '').ENDMAC
         B     &GOTO
.ENDMAC  ANOP
         MEND
         EJECT
         MACRO
&LABEL   ADDTRACE &ENTRY=
         OC    TRACE@B,TRACE@B             DO WE HAVE A TRACE AREA?
         BNZ   YY&SYSNDX                   YES, ADD ENTRY TO IT
         STORAGE OBTAIN,LENGTH=4096000     NO GET A 4 MEG AREA
         ST    R1,TRACE@B                  SAVE BEGINNING ADDR
         LR    R0,R1                       CLEAR AREA
         L     R1,=F'4096000'
         SR    R15,R15
         MVCL  R0,R14
         L     R1,TRACE@B                  GET -> TO AREA
         MVC   0(8,R1),=CL8'TR@CET@B'      STICK EYECATCHER IN IT
         LA    R15,8(R1)
         ST    R15,TRACE@C                 POSITION FOR NEXT ENTRY
         LR    R15,R1
         A     R15,=F'4096000'
         ST    R15,TRACE@M                 ENDING ADDRESS OF AREA
YY&SYSNDX  L   R1,TRACE@C
         LA    R15,L'&ENTRY                MAKE SURE THIS ENTRY
         AR    R15,R1                      WON'T GO OFF THE END
         C     R15,TRACE@M
         BNL   ZZ&SYSNDX
         MVC   0(L'&ENTRY,R1),&ENTRY
         ST    R15,TRACE@C
ZZ&SYSNDX  DS  0H
         MEND
         EJECT
*---------------------------------------------------------------------
*  This function will provide access to a VSAM file from a REXX exec.
* It is designed to be called as an external function in the MVS/ESA
* environment.  The function call should take the form:
*    RXVSAM1(<request>,<ddname>,{<key>|<filetype>,<recordarea>})
* The first 2 arguments are required, 3 and 4 are optional.  Argument
* definitions/values:
*  1. request: OPENINPUT OPENOUTPUT OPENIO
*              CLOSE
*              READ READGENERIC READNEXT READPREV READLAST
*              WRITE REWRITE DELETE
*              STARTFWD STARTBWD
*              R1EQKSDS
*              R1GEKSDS
*
*  2. ddname: must be 1 - 8 uppercase or national characters
*  3. key: the key or rrn (for requests other than OPEN)
*     filetype: either KSDS, ESDS or RRDS (one of the three must be
*               specified in uppercase for OPEN requests)
*     This argument may be null in some cases (READNEXT, READPREV,
*     READLAST, WRITE, DELETE).  A null key for WRITE requests
*     is designed for use in writing to an RRDS for the first time
*     (initialization), and should always be used when writing to
*     an ESDS.  To make the argument 3 null, code an extra comma
*     before argument 4, for example:
*         result = RXVSAM1('READNEXT','MYFILE',,'MY_RECORD_AREA')
*     If the key is an RRN, it must be given in decimal.  Direct
*     READs are possible for an ESDS, using RBAs as the key.
*  4. recordarea: the REXX VARIABLE name that contains record data
*     this argument is always ignored for OPEN or CLOSE requests.
*     If this argument is omitted, the variable name RXVSAM1_RECORD is
*     used (for READ requests) or assumed (for WRITE|REWRITE requets).
*
*  2.1 -- add DELETE macros for routines that have been LOADed
*  (IRXEXCOM and various name / token routines).
*
*  2.2 -- locate IEANTxx services by bumping through storage rather
*  than doing a LOAD. Remove associated DELETEs. Add RXVSAMSG CSECT
*  at end of this assembly; revise GENMSGS macro. Get IRXEXCOM address
*  by bumping thru ENVBLOCK (environemnt block) to IRXEXTE (external
*  address table), rather than doing a LOAD. Remove associated DELETE.
*  Add required ENVBLOCK & IRXEXTE macros (dsects). Allow rewrite for
*  an ESDS. (Special thanks to Rob Van Riel for these changes)
*
*----------------------------------------------------------------------
         EJECT
RXVSAM1  CSECT
RXVSAM1  AMODE 31
RXVSAM1  RMODE ANY
         SPACE
R0       EQU   0                  REGISTER EQUATES
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6                  -> SHVBLOCK (also used as a work reg)
R7       EQU   7                  -> FILE WORK AREA
R8       EQU   8                  -> ARGUMENT LIST
R9       EQU   9                  -> LOCAL WORK AREA
R10      EQU   10                 BASE REGISTER 3
R11      EQU   11                 BASE REGISTER 2
R12      EQU   12                 BASE REGISTER 1
R13      EQU   13
R14      EQU   14
R15      EQU   15
         EJECT
MSGDSECT GENMSGS GEN=DSECT
         SPACE 2
         IEANTASM
         PRINT NOGEN
         EJECT
RXVSAM1  CSECT                    RESUME CSECT
         SPACE
         USING RXVSAM1,R12,R11,R10
         BAKR  R14,0              SAVE CALLER'S REGS & RETURN LOC
         LR    R12,R15            SET 1ST BASE REG
         LR    R4,R1              PARK PARM POINTER (R1) IN R4
         LR    R5,R0              PARK ENV BLOCK PTR (R0) IN R5    @ANZ
         LA    R2,LOCAL_WORKAREA_LENGTH  SIZE OF OUR LOCAL WORK AREA
         STORAGE OBTAIN,LENGTH=(R2)    GET LOCAL WORK AREA
         SPACE
         LR    R9,R1              SET BASE REGISTER FOR LOCAL WORK AREA
         USING LOCAL_WORKAREA,R9  SET ADDRESSABILITY
         LR    R2,R9
         LA    R3,LOCAL_WORKAREA_LENGTH
         SR    R15,R15            PAD OF X'00' & ZERO LENGTH
         MVCL  R2,R14             INIT WORKAREA TO BINARY ZERO
         LA    R15,SAVEAREA       SET -> TO OUR SAVE AREA
         ST    R13,4(R15)         CHAIN BACKWARD ->
         ST    R15,8(R13)         CHAIN FORWARD ->
         LR    R13,R15
         LA    R11,4095(R12)      SET 2ND BASE REG
         LA    R11,1(R11)
         LA    R10,4095(R11)      SET 3RD BASE REG
         LA    R10,1(R10)
         B     MAIN100            BRANCH AROUND EYECATCHER
         SPACE
EYECATCH DS    0D
         DC    CL8'RXVSAM1'
         DC    CL8'&SYSDATE'
         DC    CL8'&SYSTIME'
         DC    CL16'RELEASE 2.2'
MOVEDDNM MVC   DDNAME(0),0(R3)    EXECUTED INSTRUCTION
         EJECT
MAIN100  DS    0H
         IAZXJSAB READ,JOBID=MYJOBID,JOBNAME=MYJOBNM
         SPACE
         LR    R1,R4              RESTORE PARM (R1) FROM SAVED REG
         USING EFPL,R1            SET ADDRESSABILITY
         ST    R1,EFPL@           KEEP POINTER AROUND JUST IN CASE
         LA    R6,OURSHVBL        INIT -> TO OUR SHARED VAR BLK
         USING SHVBLOCK,R6        SET ADDRESSABILITY
         L     R8,EFPLARG         GET -> TO ARGUMENT LIST
         USING ARGTABLE_ENTRY,R8  SET ADDRESSABILITY
         DROP  R1                 DROP EFPL ADDRESSABILITY
         SPACE
         MVC   VSAMEMSG(VMSGLEN),VMSGINIT  INIT VSAM ERROR MSG AREA
         MVC   NTMSG(NTMSGLEN),NTMSGINI    INIT NAME/TOKEN MSG AREA
         SPACE
         SETMSG MSG=M$ALLOK       INITIALIZE RETURN MESSAGE
         MVC   VSAMER15,=CL2'00'  INITIALIZE VSAM REG 15 RC
         SPACE
*R5 already -> environment block -- loaded from R0 at entry to RXVSAM1
         SPACE
         USING ENVBLOCK,R5        SET ADDRESSABILITY TO ENVBLOCK   @ANZ
         ST    R5,ENVB@           SAVE ENVIRONMENT BLOCK POINTER   @ANZ
         L     R5,ENVBLOCK_IRXEXTE EXTERNAL ENTRY VECTOR ADDRESS   @ANZ
         USING IRXEXTE,R5         SET ADDRESSABILITY TO EXTE       @ANZ
         L     R0,IRXEXCOM        IRXEXCOM ROUTINE ADDRESS         @ANZ
         ST    R0,IRXEXCO@        SAVE ROUTINE ADDRESS FOR LATER USE
         DROP  R5                 DROP ENVBLOCK ADDRESSABILITY     @ANZ
         SPACE
         L     R5,ARGTABLE_ARGSTRING_PTR  GET ADDR OF REQUEST ARG
         C     R5,=X'FFFFFFFF'    IF ADDRESS IS ALL X'FF'
         BE    MAIN400            NO ARG PASSED,ERROR
         SPACE
         ST    R5,ARG_1_@         SAVE ARG1 PTR AND LNG
         MVC   ARG_1_L,ARGTABLE_ARGSTRING_LENGTH
*
         LA    R8,ARGTABLE_NEXT   BUMP TO NEXT ARGUMENT (DDNAME)
         LM    R3,R4,ARGTABLE_ARGSTRING_PTR  GET ADDR & LENGTH OF ARG
         C     R3,=X'FFFFFFFF'    IF ADDRESS IS ALL X'FF'
         BE    MAIN400            NO ARG PASSED,ERROR
         SPACE
         CHI   R4,8               IF DDNAME LONGER THAN 8 CHARACTERS
         BH    MAIN400            IT'S AN ERROR
         XC    RONE_PHASE_PTR,RONE_PHASE_PTR
         XC    RONE_PHASE,RONE_PHASE
         XC    RONE_TYPE,RONE_TYPE
         MVC   RONE_KTYP,=C'KEQ'   DEFAULT TO RPL OPTCD KEQ
         LA    R8,ARGTABLE_NEXT   BUMP TO "NEXT" ARGUMENT
         SPACE
         MVC   DDNAME,SPACES      INIT BLANK PADDED DDNAME
         BCTR  R4,0               DECR IN PREPARATION FOR EXECUTED MVC
         EX    R4,MOVEDDNM        SET OUR COPY OF THE DDNAME
         SPACE
         MVC   IEANTNA1,MYJOBID   CREATE "NAME" FOR NAME / TOKEN
         MVI   IEANTNA1,C'X'      SERVICES: JOBID (1ST CHAR ALWAYS "X")
         MVC   IEANTNA2,DDNAME    PLUS DDNAME
         XC    IEANTTOK,IEANTTOK  CLEAR OUT "TOKEN"
         MVC   IEANTLVL,=AL4(IEANT_TASK_LEVEL)  TASK LVL FOR ALL REQ
         EJECT
MAIN200  DS    0H
*
* THE FOLLOWING USING IS GLOBAL (FOR THE REST OF THE CSECT).  IT IS THE
* INDIVIDUAL ROUTINE'S RESPONSIBILITY TO ENSURE R7 CONTAINS A VALID
* ADDRESS WHEN A FILE WORK AREA IS "ACTIVE"
*
         USING FWABLOCK,R7
*
* PERFORM CORRECT ROUTINE BASED ON FUNCTION REQUEST - SET R14 AS A
* "RETURN" ADDRESS
*
         LA    R14,MAIN500        SERVES AS A "RETURN" POINT
         CLC   =CL4'OPEN',0(R5)
         BE    OPEN000
         CLC   =CL4'CLOS',0(R5)
         BE    CLOS000
         CLC   =CL4'R1EQ',0(R5)   FIRST PARM FIRST 4 CHAR
         BE    RONE000_R1EQ        CAN SPECIFY READ ONE REC
         CLC   =CL4'R1GE',0(R5)    BY CODING THE REQUEST AS
         BE    RONE000_R1GE        R1EQ OR R1GE
         CLC   =CL4'READ',0(R5)
         BE    READ000
         CLC   =CL4'WRIT',0(R5)
         BE    WRIT000
         CLC   =CL4'REWR',0(R5)
         BE    REWR000
         CLC   =CL4'DELE',0(R5)
         BE    DELE000
         CLC   =CL4'STAR',0(R5)
         BE    STAR000
         SPACE
MAIN400  DS    0H
         SETMSG MSG=M$BADARG      SET BAD RESULT CODE
         B     MAIN900            EXIT
         EJECT
MAIN500  DS    0H
         SPACE
*+*+*+
*  NEED TO CHECK FOR AN INVALID NAME / TOKEN REQUEST & PUT ERROR
*  MESSAGE IN A REXX VARIABLE IF NECESSARY
*+*+
         LA    R2,VMSGVAR         ELSE, SET MESSAGE: GET -> TO MESSAGE
         LA    R3,L'VMSGVAR       VARIABLE NAME & LENGTH OF VAR NAME
         STM   R2,R3,SHVNAMA      STORE IN SHV PARM LIST (2 FULLWORDS)
         CLC   VSAMER15,=CL2'00'  IS VSAM REG 15 RC ZERO?
         BE    MAIN520            YES, RESET VARIABLE TO ITS DEFAULT
         SPACE
         MVC   SHVVALL,=A(VSAMELEN)   ELSE, SET IT TO OUR "REAL"
         LA    R0,VSAMEMSG        VARIABLE
         ST    R0,SHVVALA
         B     MAIN530
         SPACE
MAIN520  DS    0H
         SPACE
         MVC   SHVVALL,SHVNAML    NAME LENGTH & VAR LENGTH ARE EQUAL
         MVC   SHVVALA,SHVNAMA    NAME AND VALUE ARE THE SAME TOO
         SPACE
MAIN530  DS    0H
         SPACE
         MVI   SHVCODE,SHVSTORE   REQUEST: STORE A VARIABLE
         L     R15,IRXEXCO@       GET EPA TO IRXEXCOM ROUTINE
         CALL  (15),(IRXEXLIT,0,0,OURSHVBL),VL,MF=(E,EXCOPLST)
         SPACE
         TM    SHVRET,SHVBADN+SHVBADV+SHVBADF  CHECK ERROR BITS
         BZ    MAIN900            IF ALL OK, CONTINUE
         SPACE
         SETMSG MSG=M$VMSG        ELSE, SET MESSAGE THEN FALL THRU
         SPACE
MAIN900  DS    0H
         LA    R0,L'RMSGVAR       LENGTH OF RET MSG VARIABLE NAME
         ST    R0,SHVNAML         SET LENGTH IN SHARED VARIABLE BLOCK
         LA    R0,RMSGVAR         -> TO VARIABLE NAME
         ST    R0,SHVNAMA
         LH    R0,MSGLEN          LENGTH OF VARIABLE
         ST    R0,SHVVALL
         L     R0,MSG@            GET -> TO MESSAGE
         ST    R0,SHVVALA
         MVI   SHVCODE,SHVSTORE   REQUEST: STORE A VARIABLE
         L     R15,IRXEXCO@       ADDR OF IRXEXCOM ROUTINE
         CALL  (15),(IRXEXLIT,0,0,OURSHVBL),VL,MF=(E,EXCOPLST)
         SPACE
         TM    SHVRET,SHVBADN+SHVBADV+SHVBADF  CHECK ERROR BITS
         BZ    MAIN950            IF ALL OK, CONTINUE
         SPACE
         SETMSG MSG=M$RMSG        REVISE RETURN MESSAGE
         EJECT
MAIN950  DS    0H
         L     R1,EFPL@           GET POINTER TO ORIGINAL PARM LIST
         USING EFPL,R1            SET ADDRESSABILITY
         L     R2,EFPLEVAL        GET -> TO EVALUATION BLOCK
         L     R2,0(,R2)          GET ACTUAL ADDRESS OF BLOCK
         USING EVALBLOCK,R2       SET ADDRESSABILITY
         L     R14,MSG@           1ST 4 BYTES OF MSG ARE THE RESULT
         MVC   EVALBLOCK_EVLEN,=F'4'          PASS RESULT BACK IN THE
         MVC   EVALBLOCK_EVDATA(4),0(R14)     EVALUATION BLOCK
         DROP  R2,R1
         SPACE
GOBACK   DS    0H
         LA    R2,LOCAL_WORKAREA_LENGTH  SIZE OF OUR LOCAL WORK AREA
         STORAGE RELEASE,LENGTH=(R2),ADDR=(R9)    RELEASE WORK AREA
         SPACE
         SLR   R15,R15            MAKE SURE RETURN CODE IS ZERO
         PR                       RETURN TO CALLER
         DROP  R6                 DROP SHVBLOCK ADDRESSABILITY
         EJECT
OPEN000  DS    0H
*
* UPON ENTRY, R8 -> ARGUMENT LIST 3 SLOT (FILE TYPE), R5 STILL -> TO
* TYPE OF REQUEST
*
         ST    R14,RETURNTO       SAVE RETURN POINT
         L     R4,ARGTABLE_ARGSTRING_PTR
         C     R4,=X'FFFFFFFF'    IS ADDRESS ALL X'FF' ?
         BNE   OPEN010            NO, CONTINUE
         SPACE
         SETMSG MSG=M$BADARG      SET BAD RESULT CODE
         B     OPEN999
         SPACE
OPEN010  DS    0H    -- SEE IF THERE'S A NAME / TOKEN FOR THIS FILE --
         BAS   R14,RTRVTOK0
         SPACE
         CH    R15,=AL2(IEANT_NOT_FOUND)   IF NO TOKEN EXISTS
         BE    OPEN020                     IT'S OK TO CONTINUE
         SPACE
         LTR   R15,R15                     IF A TOKEN EXISTS
         BZ    OPEN015                     FILE IS ALREADY OPEN
         SPACE
         NTERROR REQ=RETRIEVE,SYM=OPEN010,GOTO=OPEN999
         SPACE
OPEN015  DS    0H
         SETMSG MSG=M$PREVOP
         B     OPEN999          THE FILE IS ALREADY OPEN - EXIT
         SPACE
OPEN020  DS    0H
         LA    R2,FWALEN        LENGTH OF FILE WORK AREA
         STORAGE OBTAIN,LENGTH=(R2)    GET A NEW FILE WORK AREA
         SPACE
         LR    R7,R1            -> TO FWA (ADDRESSABILITY ALREADY SET)
         LR    R2,R7
         LA    R3,FWALEN
         SR    R15,R15
         MVCL  R2,R14           INIT AREA TO X'00'
*
* NOTE: R3 REMAINS AS A POINTER TO THE ACB THROUGHOUT THE REST OF THE
*       OPEN LOGIC
*
         LA    R3,ACBAREA         -> TO OUR ACB
         EJECT
         CLC   L_KSDS,RONE_TYPE        KSDS? SET IN RONE000
         BE    OPEN021            NO, TRY NEXT POSSIBLITY
         CLC   L_KSDS,0(R4)       KSDS?
         BNE   OPEN030            NO, TRY NEXT POSSIBLITY
         SPACE
OPEN021  EQU   *
         OI    F@OPENFL,F@OSEQ+F@ODIR+F@OKSDS     SET OUR FLAGS
         GENCB BLK=ACB,DDNAME=(*,DDNAME),MACRF=(KEY,SEQ,DIR),          X
               LENGTH=ACBAREAL,WAREA=(R3),RMODE31=ALL,                 X
               MF=(G,GENCB_PARMLIST)
         SPACE
         LTR   R15,R15            GENCB SUCCESSFUL?
         BZ    OPEN100            YES - CONTINUE
         B     OPEN900            NO - DO ERROR HANDLING
         SPACE
OPEN030  DS    0H
         CLC   L_ESDS,RONE_TYPE   ESDS? SET IN RONE000
         BE    OPEN031            NO, TRY NEXT POSSIBLITY
         CLC   L_ESDS,0(R4)       ESDS?
         BNE   OPEN040            NO, TRY NEXT POSSIBLITY
         SPACE
OPEN031  EQU   *
         OI    F@OPENFL,F@OSEQ+F@OESDS          SET FLAGS
         GENCB BLK=ACB,DDNAME=(*,DDNAME),MACRF=(ADR,SEQ),              X
               LENGTH=ACBAREAL,WAREA=(R3),RMODE31=ALL,                 X
               MF=(G,GENCB_PARMLIST)
         SPACE
         LTR   R15,R15            GENCB SUCCESSFUL?
         BZ    OPEN100            YES - CONTINUE
         B     OPEN900            NO - DO ERROR HANDLING
         SPACE
OPEN040  DS    0H
         CLC   L_RRDS,RONE_TYPE   RRDS? SET IN RONE000
         BE    OPEN041
         CLC   L_RRDS,0(R4)       RRDS?
         BNE   OPEN050            NO, DO ERROR PROCESSING
         SPACE
OPEN041  EQU   *
         OI    F@OPENFL,F@OSEQ+F@ODIR+F@ORRDS         SET FLAGS
         GENCB BLK=ACB,DDNAME=(*,DDNAME),MACRF=(KEY,SEQ,DIR),          X
               LENGTH=ACBAREAL,WAREA=(R3),RMODE31=ALL,                 X
               MF=(G,GENCB_PARMLIST)
         SPACE
         LTR   R15,R15            GENCB SUCCESSFUL?
         BZ    OPEN100            YES - CONTINUE
         B     OPEN900            NO - DO ERROR HANDLING
         SPACE
OPEN050  DS    0H
         SETMSG MSG=M$BADARG      SET BAD RESULT CODE
         B     OPEN999
         EJECT
OPEN100  DS    0H
         CLC   =CL4'R1EQ',0(R5)   R5 STILL SET TO FIRST ARG
         BE    OPEN101            DEAULT FOR OPENINPUT
         CLC   =CL4'R1GE',0(R5)   R5 STILL SET TO FIRST ARG
         BE    OPEN101            DEAULT FOR OPENINPUT
         CLC   =CL9'OPENINPUT',0(R5)    OPEN INPUT?
         BNE   OPEN110            NO, TRY NEXT POSSIBILITY
OPEN101  EQU   *
         SPACE
         OI    F@OPENFL,F@OIN           SET FLAG
         MODCB ACB=(R3),MACRF=(IN),RMODE31=ALL,MF=(G,MODCB_PARMLIST)
         SPACE
         LTR   R15,R15            MODCB SUCCESSFUL?
         BZ    OPEN200            YES - READY TO ISSUE OPEN
         B     OPEN900            NO - DO ERROR HANDLING
         SPACE
OPEN110  DS    0H
         CLC   =CL6'OPENIO',0(R5) INPUT & OUTPUT?
         BNE   OPEN120            NO, TRY NEXT POSSIBILITY
         SPACE
         OI    F@OPENFL,F@OIN+F@OOUT    SET FLAGS
         MODCB ACB=(R3),MACRF=(IN,OUT),RMODE31=ALL,                    X
               MF=(G,MODCB_PARMLIST)
         SPACE
         LTR   R15,R15            MODCB SUCCESSFUL?
         BZ    OPEN200            YES - READY TO ISSUE OPEN
         B     OPEN900            NO - DO ERROR HANDLING
         EJECT
OPEN120  DS    0H
         CLC   =CL10'OPENOUTPUT',0(R5)   ONLY OUTPUT?
         BNE   OPEN130            NO, BAD ARGUMENT
         SPACE
         OI    F@OPENFL,F@OOUT           SET FLAG
         MODCB ACB=(R3),MACRF=(OUT),RMODE31=ALL,MF=(G,MODCB_PARMLIST)
         SPACE
         LTR   R15,R15            MODCB SUCCESSFUL?
         BZ    OPEN200            YES - READY TO ISSUE OPEN
         B     OPEN900            NO - DO ERROR HANDLING
         SPACE
OPEN130  DS    0H
         SETMSG MSG=M$BADARG     SET BAD RESULT CODE
         B     OPEN999
         EJECT
OPEN200  DS    0H
         XC    OPEN_PARMLIST,OPEN_PARMLIST   INIT AREA
         OI    OPEN_PARMLIST,X'80'           HI-ORDER ON = 31 BIT FORM
         ST    R3,OPEN_PARMLIST+4            STORE ACB -> IN 2ND WORD
         OPEN  MODE=31,MF=(E,OPEN_PARMLIST)  OPEN DATASET
         SPACE
         LTR   R15,R15            WAS OPEN SUCCESSFUL?
         BNZ   OPEN210            NO - DO ERROR PROCESSING
         SPACE
         B     OPEN300            READY TO GENERATE RPL
         SPACE
OPEN210  DS    0H
         MVC   VSAMELAB,=CL8'OPEN210'   SET UP ERROR MESSAGE FIELDS
         CVD   R15,DBLWRK
         UNPK  VSAMER15,HALFWRK2
         OI    VSAMER15+1,X'F0'
         LA    R2,FULLWRK2
         SHOWCB ACB=(R3),AREA=(R2),LENGTH=4,FIELDS=ERROR,              X
               MF=(G,SHOWCB_PARMLIST)
         SPACE
         LTR   R15,R15            DID SHOWCB WORK?
         BZ    OPEN230            YES - GO PICK UP ERROR MESSAGE
         SPACE
OPEN220  DS    0H
         MVC   VSAMELAB,=CL8'OPEN220'   SET UP ERROR MESSAGE FIELDS
         CVD   R15,DBLWRK         SET RETURN CODE FROM SHOWCB
         UNPK  VSAMER15,HALFWRK2
         OI    VSAMER15+1,X'F0'
         CVD   R0,DBLWRK          SET REASON CODE
         UNPK  VSAMEREA,HALFWRK2
         OI    VSAMEREA+3,X'F0'
         B     OPEN990            AND EXIT ROUTINE
         SPACE
OPEN230  DS    0H
         LH    R0,HALFWRK2
         CVD   R0,DBLWRK
         UNPK  VSAMEREA,HALFWRK2  SET REASON CODE IN MESSAGE
         OI    VSAMEREA+3,X'F0'
         B     OPEN990            AND EXIT ROUTINE
         EJECT
OPEN300  DS    0H      -- GET MAX RECORD LENGTH & GENERATE RPL --
         LA    R2,F@LRECL
         SHOWCB ACB=(R3),AREA=(R2),LENGTH=8,                           X
               FIELDS=(LRECL,KEYLEN),MF=(G,SHOWCB_PARMLIST)
*               FIELDS=LRECL,MF=(G,SHOWCB_PARMLIST)
         SPACE
         LTR   R15,R15            DID SHOWCB WORK?
         BZ    OPEN310            YES, CONTINUE
         SPACE
         MVC   VSAMELAB,=CL8'OPEN300'
         MVC   VSAMEREA,=CL4'0000'
         CVD   R15,DBLWRK
         UNPK  VSAMER15,HALFWRK2
         OI    VSAMER15+1,X'F0'
         CH    R15,=H'4'          IF R15 ISN'T 4, REASON CODE ISN'T
         BNE   OPEN999            IN R0
         SPACE
         CVD   R0,DBLWRK          SET REASON CODE
         UNPK  VSAMEREA,HALFWRK2
         OI    VSAMEREA+3,X'F0'
         SETMSG MSG=M$BADSCB      SET BAD RESULT CODE
         SPACE
         B     OPEN999
         SPACE
OPEN310  DS    0H
         L     R2,F@LRECL         GET MAX LRECL FROM SHOWCB
         N     R2,=X'FFFFFFFC'
         LA    R2,8(R2)           ROUND UP TO NEXT DOUBLEWORD
         ST    R2,F@BUFLEN        SAVE LENGTH FOR LATER USE
         STORAGE OBTAIN,LENGTH=(R2)
         SPACE
         ST    R1,F@RECBUF        SAVE ADDRESS OF STORAGE
         SPACE
OPEN320  DS    0H            -- READY TO GENERATE RPL --
         LA    R2,RPLAREA         -> TO WHERE RPL WILL BE BUILT
         CLC   L_KSDS,RONE_TYPE
         BE    OPEN400
         CLC   L_RRDS,RONE_TYPE
         BE    OPEN410
         CLC   L_ESDS,RONE_TYPE
         BE    OPEN420
*
         CLC   L_KSDS,0(R4)       KSDS?
         BE    OPEN400
         CLC   L_RRDS,0(R4)       RRDS?
         BE    OPEN410
         CLC   L_ESDS,0(R4)       ESDS?
         BE    OPEN420
         EJECT
OPEN400  DS    0H                        -- KSDS --
         L     R4,F@RECBUF        -> RECORD BUFFER
         L     R5,F@BUFLEN        SIZE OF BUFFER
         LA    R6,F@RPLARG        -> KEY (ARGUMENT)
         CLC   RONE_KTYP,=C'KGE'
         JE    OPEN402
OPEN401  DS    0H
         OI    F@RPLFL,F@RKEY+F@RARD+F@RSEQ+F@RFWD+F@RKEQ+F@RFKS
         GENCB BLK=RPL,ACB=(R3),AREA=(R4),AREALEN=(R5),WAREA=(R2),     X
               LENGTH=RPLAREAL,OPTCD=(KEY,ARD,SEQ,FWD,KEQ,FKS),        X
               ARG=(R6),MF=(G,GENCB_PARMLIST)
         SPACE
         LTR   R15,R15            ALL OK?
         BZ    OPEN500            YES, CONTINUE
         B     OPEN910            NO, DO ERROR HANDLING
         SPACE
OPEN402  DS    0H
         OI    F@RPLFL,F@RKEY+F@RARD+F@RSEQ+F@RFWD+F@RFKS
         GENCB BLK=RPL,ACB=(R3),AREA=(R4),AREALEN=(R5),WAREA=(R2),     X
               LENGTH=RPLAREAL,OPTCD=(KEY,ARD,SEQ,FWD,KGE,FKS),        X
               ARG=(R6),MF=(G,GENCB_PARMLIST)
         SPACE
         LTR   R15,R15            ALL OK?
         BZ    OPEN500            YES, CONTINUE
         B     OPEN910            NO, DO ERROR HANDLING
         SPACE
OPEN410  DS    0H                        -- RRDS --
         L     R4,F@RECBUF        -> RECORD BUFFER
         L     R5,F@BUFLEN        SIZE OF BUFFER
         LA    R6,F@RPLARG        -> KEY (ARGUMENT)
         CLC   RONE_KTYP,=C'KGE'
         JE    OPEN412
OPEN411  DS    0H
         OI    F@RPLFL,F@RKEY+F@RARD+F@RSEQ+F@RFWD+F@RKEQ+F@RFKS
         GENCB BLK=RPL,ACB=(R3),AREA=(R4),AREALEN=(R5),WAREA=(R2),     X
               LENGTH=RPLAREAL,OPTCD=(KEY,ARD,SEQ,FWD,KEQ,FKS),        X
               ARG=(R6),MF=(G,GENCB_PARMLIST)
         SPACE
         LTR   R15,R15            ALL OK?
         BZ    OPEN500            YES, CONTINUE
         B     OPEN910            NO, DO ERROR HANDLING
         SPACE
OPEN412  DS    0H
         OI    F@RPLFL,F@RKEY+F@RARD+F@RSEQ+F@RFWD+F@RFKS
         GENCB BLK=RPL,ACB=(R3),AREA=(R4),AREALEN=(R5),WAREA=(R2),     X
               LENGTH=RPLAREAL,OPTCD=(KEY,ARD,SEQ,FWD,KGE,FKS),        X
               ARG=(R6),MF=(G,GENCB_PARMLIST)
         SPACE
         LTR   R15,R15            ALL OK?
         BZ    OPEN500            YES, CONTINUE
         B     OPEN910            NO, DO ERROR HANDLING
         SPACE
OPEN420  DS    0H                        -- ESDS --
         L     R4,F@RECBUF        -> RECORD BUFFER
         L     R5,F@BUFLEN        SIZE OF BUFFER
         LA    R6,F@RPLARG        -> KEY (ARGUMENT)
         CLC   RONE_KTYP,=C'KGE'
         JE    OPEN422
OPEN421  DS    0H
         OI    F@RPLFL,F@RARD+F@RSEQ+F@RFWD+F@RKEQ+F@RFKS
         GENCB BLK=RPL,ACB=(R3),AREA=(R4),AREALEN=(R5),WAREA=(R2),     X
               LENGTH=RPLAREAL,OPTCD=(ADR,ARD,SEQ,FWD,KEQ,FKS),        X
               ARG=(R6),MF=(G,GENCB_PARMLIST)
         SPACE
         LTR   R15,R15            ALL OK?
         BZ    OPEN500            YES, CONTINUE
         B     OPEN910            NO, DO ERROR HANDLING
OPEN422  DS    0H
         OI    F@RPLFL,F@RARD+F@RSEQ+F@RFWD+F@RFKS
         GENCB BLK=RPL,ACB=(R3),AREA=(R4),AREALEN=(R5),WAREA=(R2),     X
               LENGTH=RPLAREAL,OPTCD=(ADR,ARD,SEQ,FWD,KGE,FKS),        X
               ARG=(R6),MF=(G,GENCB_PARMLIST)
         SPACE
         LTR   R15,R15            ALL OK?
         BZ    OPEN500            YES, CONTINUE
         B     OPEN910            NO, DO ERROR HANDLING
         EJECT
OPEN500  DS    0H
         XC    IEANTTOK,IEANTTOK  CLEAR OUT TOKEN AREA
         ST    R7,IEANTTOK        SAVE -> TO FILE WORK AREA
         MVC   IEANTPOP,=AL4(IEANT_NOPERSIST)
*
* CREATE A NAME / TOKEN SO WE CAN FIND THE FILE WORK AREA NEXT TIME
* RXVSAM1 IS CALLED. REL 2.2: BUMP THRU CONTROL BLOCKS TO FIND IEANTCR.
*
         L     R15,X'10'
         L     R15,X'220'(R15,0)
         L     R15,X'14'(R15,0)
         L     R15,X'04'(R15,0)
         CALL  (15),(IEANTLVL,IEANTNAM,IEANTTOK,IEANTPOP,IEANTRC),     X
               MF=(E,IEANTLST)
         SPACE
         LTR   R15,R15
         BZ    OPEN999            IF CREATE SUCCEEDED, ALL DONE
         SPACE
         NTERROR REQ=CREATE,SYM=OPEN500,GOTO=OPEN999
         SPACE 3
OPEN900  DS    0H      -- GENERAL ERROR GENERATING THE ACB --
         MVC   VSAMELAB,=CL8'OPEN900'
         B     OPEN920
         SPACE
OPEN910  DS    0H      -- GENERAL ERROR GENERATING THE RPL --
         MVC   VSAMELAB,=CL8'OPEN910'  SET LABEL & FALL THRU
         SPACE
OPEN920  DS    0H
         MVC   VSAMEREA,=CL2'00'
         CVD   R15,DBLWRK
         UNPK  VSAMER15,HALFWRK2
         OI    VSAMER15+1,X'F0'
         BAS   R14,GETREG0        CHECK FOR REASON CODE IN R0
         SPACE
OPEN990  DS    0H
         MVI   RONE_PHASE,C'X'
         SETMSG MSG=M$BADOPN      SET BAD RESULT CODE & FALL-THRU
         SPACE
OPEN999  DS    0H
         L     R14,RETURNTO       GET RETURN POINT RONE000
         BR    R14                EXIT & RETURN TO MAINLINE
         EJECT
CLOS000  DS    0H
         ST    R14,RETURNTO       SAVE RETURN POINT
         BAS   R14,RTRVTOK0       GO SEE IF THERE'S A NAME / TOKEN
         SPACE
         LTR   R15,R15            IF TOKEN EXISTS
         BZ    CLOS100            FILE IS OPEN
         SPACE
         CH    R15,=AL2(IEANT_NOT_FOUND) FOR ANYTHING OTHER THAN "NOT
         BNE   CLOS050            FOUND" GENERATE A NAME / TOKEN ERROR
         SPACE
         SETMSG MSG=M$CLOSAC      ASSUME FILE ISN'T OPEN
         B     CLOS999
         SPACE
CLOS050  DS    0H
         NTERROR REQ=RETRIEVE,SYM=CLOS000,GOTO=CLOS999
         SPACE
CLOS100  DS    0H
         L     R7,IEANTTOK        PICK UP ADDRESS OF FWA
         OC    ACBAREA,ACBAREA    ACB AREA SHOULD BE NON-ZERO
         BNZ   CLOS150            IF IT IS, CONTINUE
         SPACE
         SETMSG MSG=M$CLOSAC      IF ACB IS ZERO, ASSUME FILE ISN'T
         B     CLOS999            OPEN - GENERATE MESSAGE & EXIT
         SPACE
CLOS150  DS    0H
         XC    CLOSE_PARMLIST,CLOSE_PARMLIST INIT AREA
         OI    CLOSE_PARMLIST,X'80'          HI-ORDER ON = 31 BIT FORM
         LA    R3,ACBAREA                    STORE POINTER TO ACB
         ST    R3,CLOSE_PARMLIST+4           IN 2ND WORD OF LIST
         CLOSE MODE=31,MF=(E,CLOSE_PARMLIST)
         SPACE
         LTR   R15,R15            SUCCESSFUL?
         BZ    CLOS500            YES - GO DELETE ACB VARIABLE
         SPACE
         MVC   VSAMELAB,=CL8'CLOS000'   SET UP ERROR MESSAGE FIELDS
         CVD   R15,DBLWRK
         UNPK  VSAMER15,HALFWRK2
         OI    VSAMER15+1,X'F0'
         LA    R2,FULLWRK2
         SHOWCB ACB=(R3),AREA=(R2),LENGTH=4,FIELDS=ERROR,              X
               MF=(G,SHOWCB_PARMLIST)
         SPACE
         LTR   R15,R15            DID SHOWCB WORK?
         BZ    CLOS300            YES - GO PICK UP ERROR MESSAGE
         EJECT
CLOS200  DS    0H
         MVC   VSAMELAB,=CL8'CLOS200'   SET UP ERROR MESSAGE FIELDS
         CVD   R15,DBLWRK         SET RETURN CODE FROM SHOWCB
         UNPK  VSAMER15,HALFWRK2
         OI    VSAMER15+1,X'F0'
         CVD   R0,DBLWRK          SET REASON CODE
         UNPK  VSAMEREA,HALFWRK2
         OI    VSAMEREA+3,X'F0'
         B     CLOS990            AND EXIT ROUTINE
         SPACE
CLOS300  DS    0H
         UNPK  VSAMEREA,HALFWRK2  SET REASON CODE IN MESSAGE
         OI    VSAMEREA+3,X'F0'
         B     CLOS990
         SPACE
CLOS500  DS    0H      -- CLEANUP STUFF --
         OC    F@RECBUF,F@RECBUF    DO WE HAVE A RECORD BUFFER?
         BZ    CLOS510              NO, JUST DO FWA CLEANUP
         SPACE
         L     R2,F@BUFLEN          LENGTH OF RECORD BUFFER
         L     R3,F@RECBUF          ADDRESS OF RECORD BUFFER
         STORAGE RELEASE,LENGTH=(R2),ADDR=(R3)    RELEASE REC BUFFER
         SPACE
CLOS510  DS    0H
         LA    R2,FWALEN            LENGTH OF FILE WORK AREA
         STORAGE RELEASE,LENGTH=(R2),ADDR=(R7)    RELEASE FWA
         SPACE
         L     R15,X'10'            BUMP THRU STORAGE TO FIND
         L     R15,X'220'(R15,0)    IEANTDL STUB / POINTER
         L     R15,X'14'(R15,0)
         L     R15,X'0C'(R15,0)
         CALL  (15),(IEANTLVL,IEANTNAM,IEANTRC),MF=(E,IEANTLST)
         SPACE
         LTR   R15,R15              IF NAME / TOKEN DELETE WAS OK
         BZ    CLOS999              ALL DONE
         SPACE
         NTERROR REQ=DELETE,SYM=CLOS510,GOTO=CLOS999
         SPACE
CLOS990  DS    0H
         SETMSG MSG=M$BADCLO      SET MESSAGE & FALL-THRU
         MVI   RONE_PHASE,C'X'
         SPACE
CLOS999  DS    0H
         L     R14,RETURNTO       GET RETURN POINT
         BR    R14                EXIT & RETURN TO MAINLINE
         EJECT
RONE000_R1EQ  DS    0H
        MVC   RONE_KTYP,=C'KEQ'
        J     RONE000
*
RONE000_R1GE  DS    0H
        MVC   RONE_KTYP,=C'KGE'
        J     RONE000
*
RONE000  DS    0H
*
* UPON ENTRY, R8 -> 3RD ARGUMENT (KEY) AND R5 STILL -> TYPE OF REQUEST
*
*        ST    R14,RETURNTO       SAVE RETURN POINT
*                                 GOT TO BE RONEKSDS RONEESDS RONERRDS
         CLC   ARG_1_L,F8         INSURE LNG OF ARG IS 8
         BNE   RONE999
         L     R15,ARG_1_@
         MVC   RONE_TYPE,4(R15)   MOVE THE VSAM TYPE FOR GENACB
*                                   AS IN KSDA ESDS RRDS
         MVC   RONE_PHASE,=C'OPEN'
         LA    R14,RONE010
         ST    R14,RONE_PHASE_PTR
         B     OPEN000
RONE010  EQU *
         CLI   RONE_PHASE,C'X'    OPEN PHASE HAD AN ERROR
         BE    RONE999                 GET OUT NOW
*
         MVC   RONE_PHASE,=C'READ'
         LA    R14,RONE020
         ST    R14,RONE_PHASE_PTR
         B     READ000
RONE020  EQU *
*        CLI   RONE_PHASE,C'X'     READ PHASE HAD AN ERROR
*        BE    RONE999                  GET OUT NOW
         MVC   RONE_PHASE,=C'CLOS' ALWAYS CLOSE
         LA    R14,RONE030
         ST    R14,RONE_PHASE_PTR
         B     CLOS000
RONE030  EQU *
         CLI   RONE_PHASE,C'X'
         BE    RONE999
RONE900  EQU *
RONE999  EQU *
         LA     R14,MAIN500
         BR     R14
         EJECT
*
READ000  DS    0H
*
* UPON ENTRY, R8 -> 3RD ARGUMENT (KEY) AND R5 STILL -> TYPE OF REQUEST
*
         ST    R14,RETURNTO       SAVE RETURN POINT
         BAS   R14,RTRVTOK0       GO SEE IF THERE'S A NAME / TOKEN
         SPACE
         LTR   R15,R15            IF TOKEN EXISTS
         BZ    READ010            READY TO GO
         SPACE
         SETMSG MSG=M$NOACB
         NTERROR REQ=RETRIEVE,SYM=READ000,GOTO=READ999
         SPACE
READ010  DS    0H
         L     R7,IEANTTOK        PICK UP ADDRESS OF FWA
         TM    F@OPENFL,F@OIN     FILE OPEN FOR INPUT?
         BO    READ020            YES
         SPACE
         SETMSG MSG=M$NOIN        NO, SET MESSAGE
         B     READ999            AND EXIT
         SPACE
READ020  DS    0H
*
* FROM THIS POINT THRU THE REST OF THE READ LOGIC, R4 -> RPLAREA
*
         LA    R4,RPLAREA
*
*  FOR ANY READ TYPE, IF THE FILE IS OPEN FOR OUTPUT, ALLOW FOR THE
*  POSSIBILITY OF UPDATE (ENSURE RPL IS SET UP TO ALLOW UPDATE)
*
         TM    F@OPENFL,F@OOUT    IS FILE OPEN FOR OUTPUT?
         BZ    READ040            NO, LET RPL STAND AS IS
         SPACE
         TM    F@RPLFL,F@RUPD     ALREADY SET UP FOR UPDATE?
         BNZ   READ040            YES, NO CHANGE TO RPL NEEDED
         SPACE
         MODCB RPL=(R4),OPTCD=(UPD),MF=(G,MODCB_PARMLIST)
         SPACE
         LTR   R15,R15            DID MODCB WORK?
         BZ    READ030            YES, CONTINUE
         SPACE
         MVC   VSAMELAB,=CL8'READ020'
         MVC   VSAMEREA,=CL2'00'
         CVD   R15,DBLWRK
         UNPK  VSAMER15,HALFWRK2
         OI    VSAMER15+1,X'F0'
         BAS   R14,GETREG0        CHECK FOR REASON CODE IN REGISTER 0
         SETMSG MSG=M$BADUPD
         B     READ999            EXIT ROUTINE
         SPACE
READ030  DS    0H
         OI    F@RPLFL,F@RUPD     RESET FLAG TO INDICATE UPDATE
         EJECT
READ040  DS    0H        -- BRANCH TABLE FOR READ REQUEST TYPE --
         CLC   RONE_KTYP,=C'KGE'     IF THIS IS KEY GE, THEN
         BE    READ100                IT IS A GENERIC READ
*
         CLC   L_KSDS,RONE_TYPE
         BE    READ500
*
         CLC   L_RRDS,RONE_TYPE
         BE    READ500
*
         CLC   =CL11'READGENERIC',0(R5)
         BE    READ100
         CLC   =CL8'READNEXT',0(R5)
         BE    READ200
         CLC   =CL8'READPREV',0(R5)
         BE    READ300
         CLC   =CL8'READLAST',0(R5)
         BE    READ400
         B     READ500
         EJECT
READ100  DS    0H         -- GENERIC READ --
         TM    F@OPENFL,F@OKSDS   IS FILE A KSDS?
         BO    READ102            YES, GENERIC READ IS ALLOWED
         SETMSG MSG=M$NOGEN       OTHERWISE, SET ERROR MESSAGE
         B     READ999            AND EXIT ROUTINE
         SPACE
READ102  DS    0H
         LM    R2,R3,ARGTABLE_ARGSTRING_PTR
         C     R2,=X'FFFFFFFF'    WAS KEY SUPPLIED?
         BE    READ104            NO, DO ERROR STUFF
         LTR   R3,R3              WAS ARG LENGTH ZERO?
         BZ    READ104            YES, DO ERROR STUFF
         B     READ106            KEY IS OK, CONTINUE PROCESSING
         SPACE
READ104  DS    0H
         SETMSG MSG=M$BADARG      INVALID ARGUMENT
         B     READ999            EXIT ROUTINE
         SPACE
READ106  DS    0H
         TM    F@RPLFL,F@RDIR     IS RPL SET UP FOR DIRECT READ?
         BO    READ108            YES, GO SET UP GENERIC KEY
         BAS   R14,TODIR          CHANGE TO DIRECT READ
         LTR   R15,R15            IF R15 IS ZERO
         BZ    READ108            RESET WAS SUCCESSFUL
         B     READ999            ELSE, EXIT IMMEDIATELY
         SPACE
READ108  DS    0H
         XC    F@RPLARG,F@RPLARG  CLEAR OUR ARGUMENT/KEY AREA
         ST    R3,F@ARGLEN        SAVE LENGTH OF ARGUMENT
         BCTR  R3,0               DECREMENT FOR EXECUTED MVC
         EX    R3,ARGMVC          COPY KEY TO OUR AREA
         TM    F@RPLFL,F@RFKS+F@RKEQ   RPL SET UP FOR FULL KEY?
         BZ    READ600            NO, ALREADY SET FOR GENERIC, DO GET
         SPACE
         L     R2,F@ARGLEN        ACTUAL LENGTH OF GENERIC KEY
         MODCB RPL=(R4),OPTCD=(KGE,GEN),KEYLEN=(R2),                   X
               MF=(G,MODCB_PARMLIST)
         SPACE
         LTR   R15,R15            MODCB SUCCESSFUL?
         BZ    READ110            YES, CONTINUE
         SPACE
         MVC   VSAMELAB,=CL8'READ102'      SET LABEL IN ERROR MSG
         B     READ990            DO GENERAL MODCB FAILURE LOGIC
         SPACE
READ110  DS    0H
         NI    F@RPLFL,X'FF'-(F@RFKS+F@RKEQ)    RESET OUR FLAG BITS
         B     READ600            GO GET RECORD
         EJECT
READ200  DS    0H         -- READ NEXT RECORD --
*
*  A "KEY" (3RD ARGUMENT) MUST BE SUPPLIED, ALTHOUGH IT MAY BE NULL
*
         LM    R2,R3,ARGTABLE_ARGSTRING_PTR
         C     R2,=X'FFFFFFFF'    WAS KEY SUPPLIED?
         BNE   READ202            YES, CONTINUE
         SPACE
         SETMSG MSG=M$BADARG      INVALID ARGUMENT
         B     READ999            EXIT ROUTINE
         SPACE
READ202  DS    0H
         TM    F@RPLFL,F@RSEQ+F@RFWD  SET FOR SEQ / FWD ?
         BO    READ600            YES, READY TO GET RECORD
         SPACE
         MODCB RPL=(R4),OPTCD=(SEQ,FWD),                               X
               MF=(G,MODCB_PARMLIST)
         SPACE
         LTR   R15,R15            IF MODCB WORKED (RPL IS RESET)
         BZ    READ204            RESET OUR FLAG AND GO GET RECORD
         SPACE
         MVC   VSAMELAB,=CL8'READ204'   ELSE, SET ERROR MSG
         B     READ990            DO GENERAL MODCB FAILURE LOGIC
         SPACE
READ204  DS    0H
         OI    F@RPLFL,F@RSEQ+F@RFWD     RESET FLAG
         NI    F@RPLFL,X'FF'-F@RDIR
         B     READ600            GO GET RECORD
         EJECT
READ300  DS    0H         -- READ PREVIOUS RECORD --
*
*  A "KEY" (3RD ARGUMENT) MUST BE SUPPLIED, ALTHOUGH IT MAY BE NULL
*
         LM    R2,R3,ARGTABLE_ARGSTRING_PTR
         C     R2,=X'FFFFFFFF'    WAS KEY SUPPLIED?
         BNE   READ302            YES, CONTINUE
         SPACE
         SETMSG MSG=M$BADARG      INVALID ARGUMENT
         B     READ999            EXIT ROUTINE
         SPACE
READ302  DS    0H
         CLI   F@POINT,F@POINTY   HAS FILE POSITIONING BEEN DONE?
         BE    READ304            YES, CONTINUE
         SPACE
         SETMSG MSG=M$NOPOS       SET MESSAGE - NO PREVIOUS "STARTBWD"
         B     READ999
         SPACE
READ304  DS    0H
         TM    F@RPLFL,F@RSEQ     SET FOR SEQUENTIAL ACCESS?
         BZ    READ306            NO, NEED TO ISSUE THE MODCB
         TM    F@RPLFL,F@RFWD     SET UP FOR FORWARD PROCESSING?
         BZ    READ600            NO, CAN PROCEED DIRECTLY TO GET REC
         SPACE
READ306  DS    0H
         MODCB RPL=(R4),OPTCD=(SEQ,BWD),                               X
               MF=(G,MODCB_PARMLIST)
         SPACE
         LTR   R15,R15            IF MODCB WORKED
         BZ    READ308            RESET OUR FLAG AND GO GET RECORD
         SPACE
         MVC   VSAMELAB,=CL8'READ306'   ELSE, SET ERROR MSG
         B     READ990            DO GENERAL MODCB FAILURE LOGIC
         SPACE
READ308  DS    0H
         NI    F@RPLFL,X'FF'-(F@RFWD+F@RDIR)  NOW BACKWARD & NOT DIR
         OI    F@RPLFL,F@RSEQ           IS NOW SEQUENTIAL PROCESSING
         B     READ600            GO GET RECORD
         EJECT
READ400  DS    0H           -- READ LAST RECORD --
*
*  NOTE: THE NORMAL "GET" PROCESSING (AT LABEL READ600) IS NOT DONE
*        FOR THIS REQUEST SINCE THE RPL NEEDS TO BE SWITCHED BACK TO
*        ARD (USER'S ARGUMENT GOVERNS REQUEST) AFTER THE GET IS DONE.
*  A "KEY" (3RD ARGUMENT) MUST BE SUPPLIED, ALTHOUGH IT MAY BE NULL
*
         LM    R2,R3,ARGTABLE_ARGSTRING_PTR
         C     R2,=X'FFFFFFFF'    WAS KEY SUPPLIED?
         BNE   READ402            YES, CONTINUE
         SPACE
         SETMSG MSG=M$BADARG      INVALID ARGUMENT
         B     READ999            EXIT ROUTINE
         SPACE
READ402  DS    0H
         TM    F@RPLFL,F@RDIR     SET UP FOR DIRECT PROCESSING?
         BO    READ404            YES, CONTINUE
         SPACE
         BAS   R14,TODIR          NO, CHANGE TO DIRECT PROCESSING
         LTR   R15,R15            IF R15 IS ZERO, CHANGE WAS SUCCESSFUL
         BZ    READ404
         B     READ999            ELSE, JUST GIVE UP
         SPACE
READ404  DS    0H
         MODCB RPL=(R4),OPTCD=(BWD,LRD),                               X
               MF=(G,MODCB_PARMLIST)
         LTR   R15,R15            MODCB SUCCESSFUL?
         BZ    READ406            YES, CONTINUE
         SPACE
         MVC   VSAMELAB,=CL8'READ404'      NO, SET ERROR MESSAGE LABEL
         B     READ990            DO GENERAL MODCB FAILURE LOGIC
         SPACE
READ406  DS    0H
         NI    F@RPLFL,X'FF'-F@RFWD   RESET OUR FLAG
         GET   RPL=(R4)
         SPACE
         LTR   R15,R15            SUCCESSFUL GET?
         BZ    READ408
         SPACE
         MVC   VSAMELAB,=CL8'READ406'
         B     READ990            DO GENERAL MODCB FAILURE LOGIC
         SPACE
READ408  DS    0H
         MODCB RPL=(R4),OPTCD=(ARD),                                   X
               MF=(G,MODCB_PARMLIST)
         LTR   R15,R15            MODCB SUCCESSFUL?
         BZ    READ800            YES, GO SET RECORD AS A REXX VARIABLE
         SPACE
         MVC   VSAMELAB,=CL8'READ408'      NO, SET ERROR MESSAGE LABEL
         B     READ990            DO GENERAL MODCB FAILURE LOGIC
         EJECT
READ500  DS    0H           -- DIRECT READ --
         LM    R2,R3,ARGTABLE_ARGSTRING_PTR
         C     R2,=X'FFFFFFFF'    WAS KEY SUPPLIED?
         BE    READ502            NO, DO ERROR STUFF
         LTR   R3,R3              WAS KEY LENGTH ZERO?
         BZ    READ502            YES, DO ERROR STUFF
         B     READ504            KEY ARGUMENT OK, CONTINUE
         SPACE
READ502  DS    0H
         SETMSG MSG=M$BADARG      INVALID ARGUMENT
         B     READ999            EXIT ROUTINE
         SPACE
READ504  DS    0H
         TM    F@RPLFL,F@RDIR     SET UP FOR DIRECT PROCESSING?
         BO    READ506            YES, CONTINUE
         SPACE
         BAS   R14,TODIR          NO, GO CHANGE TO DIRECT PROCESSING
         LTR   R15,R15            IF R15 IS ZERO, CHANGE WAS SUCCESSFUL
         BZ    READ506
         B     READ999            OTHERWISE, QUIT
         SPACE
READ506  DS    0H
         XC    F@RPLARG,F@RPLARG  CLEAR KEY AREA
         ST    R3,F@ARGLEN        SAVE KEY (ARGUMENT) LENGTH
         BCTR  R3,0               DECR LENGTH FOR EXECUTE
         EX    R3,ARGMVC          COPY KEY
         TM    F@RPLFL,F@RFKS+F@RKEY   SET UP FOR FULL/EQUAL KEY?
         BO    READ510            YES, CHECK FOR DATASET TYPE
         SPACE
         MODCB RPL=(R4),OPTCD=(KEQ,FKS),                               X
               MF=(G,MODCB_PARMLIST)
         LTR   R15,R15            MODCB SUCCESSFUL?
         BZ    READ508            YES, RESET OUR FLAG & GET RECORD
         SPACE
         MVC   VSAMELAB,=CL8'READ506'   NO, SET ERROR MESSAGE LABEL
         B     READ990            DO GENERAL MODCB FAILURE LOGIC
         SPACE
READ508  DS    0H
         OI    F@RPLFL,F@RFKS+F@RKEQ   RESET OUR FLAG BITS
         SPACE
READ510  DS    0H
         TM    F@OPENFL,F@OKSDS   IF FILE IS A KSDS
         BO    READ600            READY TO GET RECORD
         SPACE
         BAS   R14,CONVKEY        ELSE, CONVERT "KEY"
         LTR   R15,R15            IF CONVERSION FAILED, EXIT ROUTINE
         BNZ   READ999            ELSE, FALL-THRU TO READ600
         EJECT
READ600  DS    0H   -- PERFORM GET MACRO & CHECK RESULT --
         GET   RPL=(R4)
         SPACE
         LTR   R15,R15            SUCCESSFUL GET?
         BZ    READ800            YES, SET RECORD AS A REXX VARIABLE
         SPACE
         MVC   VSAMELAB,=CL8'READ600'
         BAS   R14,GETFDBK        GO GET FEEDBACK WORD
         SPACE
         CLC   VSAMEREA,FDBKNF    NOT FOUND?
         BNE   READ602            NO, TRY NEXT POSSIBILITY
         SETMSG MSG=M$NOTFND      YES, SET MESSAGE
         B     READ999            AND CONSIDER READ "SUCCESSFUL"
         SPACE
READ602  DS    0H
         CLC   VSAMEREA,FDBKEOF   END OF FILE
         BNE   READ604            NO, MUST BE SOME HOSEUP
         SETMSG MSG=M$EOF         YES, SET MESSAGE
         B     READ999            AND CONSIDER READ "SUCCESSFUL"
         SPACE
READ604  DS    0H
         SETMSG MSG=M$BADFUN      READ FAILED
         B     READ999            EXIT ROUTINE
         EJECT
READ800  DS    0H      -- RECORD OBTAINED, SET REXX VARIABLE --
         LA    R2,FULLWRK1
         SHOWCB RPL=(R4),AREA=(R2),LENGTH=4,FIELDS=(RECLEN),           X
               MF=(G,SHOWCB_PARMLIST)
         LTR   R15,R15            SHOWCB WORKED?
         BZ    READ802            YES, CONTINUE
         SPACE
         MVC   VSAMELAB,=CL8'READ800'
         CVD   R15,DBLWRK         SET R.C. FROM SHOWCB
         UNPK  VSAMER15,HALFWRK2
         OI    VSAMER15+1,X'F0'
         CVD   R0,DBLWRK          SET REASON CODE FROM SHOWCB
         UNPK  VSAMEREA,HALFWRK2
         OI    VSAMEREA+3,X'F0'
         SETMSG MSG=M$NORLEN
         B     READ999
         SPACE
READ802  DS    0H
         LA    R8,ARGTABLE_NEXT   GET LAST ARGUMENT
         LM    R2,R3,ARGTABLE_ARGSTRING_PTR
         C     R2,=X'FFFFFFFF'    WAS RECORD VARIABLE NAME SUPPLIED?
         BNE   READ804            YES, GO SET VARIABLE
         SPACE
         LA    R2,RECVARDF        NO, USE OUR DEFAULT
         LA    R3,L'RECVARDF
         SPACE
READ804  DS    0H
         LA    R6,OURSHVBL        GET -> TO SHARED VARIABLE BLOCK
         USING SHVBLOCK,R6        SET ADDRESSABILITY
         STM   R2,R3,SHVNAMA      STORE -> & LENGTH OF VARIABLE NAME
         MVC   SHVVALL,FULLWRK1   LENGTH OF RECORD AREA
         MVC   SHVVALA,F@RECBUF   ADDRESS OF RECORD AREA
         MVI   SHVCODE,SHVSTORE   NEED TO STORE THIS VARIABLE
         L     R15,IRXEXCO@       ADDRESS OF REXX VARIABLE ROUTINE
         CALL  (15),(IRXEXLIT,0,0,OURSHVBL),VL,MF=(E,EXCOPLST)
         SPACE
         TM    SHVRET,SHVBADN+SHVBADV+SHVBADF    CHECK ERROR BITS
         BZ    READ999            IF VAR STORED SUCCESSFULLY, ALL DONE
         SPACE
         SETMSG MSG=M$NOREC       SET ERROR MESSAGE
         B     READ999            EXIT ROUTINE
         SPACE
READ990  DS    0H     -- GENERAL ERROR LOGIC FOR MODCB FAILURE --
         BAS   R14,GETREG0        GET REASON CODE
         SETMSG MSG=M$BADFUN      SET MESSAGE & FALL-THRU TO EXIT
         MVI   RONE_PHASE,C'X'
         SPACE
READ999  DS    0H
         L     R14,RETURNTO       GET RETURN POINT RONE000
         BR    R14                EXIT & RETURN TO MAINLINE
         DROP  R6                 DROP SHVBLOCK ADDRESSABILITY
         EJECT
STAR000  DS    0H
*
* UPON ENTRY, R8 -> 3RD ARGUMENT (KEY) AND R5 STILL -> TYPE OF REQUEST
*
         ST    R14,RETURNTO       SAVE RETURN POINT
         BAS   R14,RTRVTOK0       GO SEE IF THERE'S A NAME / TOKEN
         SPACE
         LTR   R15,R15            IF TOKEN EXISTS
         BZ    STAR010            READY TO GO
         SPACE
         SETMSG MSG=M$NOACB
         NTERROR REQ=RETRIEVE,SYM=STAR000,GOTO=STAR999
         SPACE
STAR010  DS    0H
         L     R7,IEANTTOK        PICK UP ADDRESS OF FWA
         TM    F@OPENFL,F@OESDS   ESDS FILE?
         BZ    STAR020            NO, THEN IT'S OK TO DO A START
         SPACE
         SETMSG MSG=M$NOESDS      YES, THEN START ISN'T ALLOWED
         B      STAR999           EXIT ROUTINE
         SPACE
STAR020  DS    0H
         LM    R2,R3,ARGTABLE_ARGSTRING_PTR     WAS KEY SUPPLIED?
         C     R2,=X'FFFFFFFF'
         BE    STAR030            NO, DO ERROR STUFF
         LTR   R3,R3              WAS IT'S LENGTH ZERO?
         BZ    STAR030            YES, DO ERROR STUFF
         B     STAR040            KEY WAS OK, CONTINUE
         SPACE
STAR030  DS    0H
         SETMSG MSG=M$BADARG      NO, SET ERROR MESSAGE
         B     STAR999            AND EXIT ROUTINE
         SPACE
STAR040  DS    0H
         XC    F@RPLARG,F@RPLARG  CLEAR OUT ARGUMENT AREA
         ST    R3,F@ARGLEN        SAVE KEY LENGTH
         BCTR  R3,0               DECREMENT FOR EXECUTE
         EX    R3,ARGMVC          COPY KEY
         TM    F@OPENFL,F@OKSDS   IF FILE IS A KSDS
         BO    STAR050            GO CHECK REQUEST
         SPACE
         BAS   R14,CONVKEY        ELSE, CONVERT "KEY"
         LTR   R15,R15            IF CONVERSION FAILED, EXIT ROUTINE
         BNZ   STAR999            ELSE, FALL-THRU TO STAR050
         EJECT
STAR050  DS    0H
*
* FROM THIS POINT THRU THE REST OF THE START LOGIC, R4 -> RPLAREA
*
         LA    R4,RPLAREA
         CLC   =CL8'STARTFWD',0(R5)
         BE    STAR100
         CLC   =CL8'STARTBWD',0(R5)
         BE    STAR200
         SPACE
         SETMSG MSG=M$BADARG
         B     STAR999
         SPACE
STAR100  DS    0H           -- POSITION FOR FORWARD READING --
         TM    F@RPLFL,F@RSEQ+F@RFWD    SET FOR SEQUENTIAL/FWD?
         BNO   STAR102            NO, NEED TO ISSUE MODCB
         TM    F@RPLFL,F@RKEQ+F@RFKS    SET FOR KEY = / FULL KEY?
         BNZ   STAR102            YES, NEED TO ISSUE MODCB
         B     STAR600            READY TO ISSUE POINT MACRO
         SPACE
STAR102  DS    0H
         L     R2,F@ARGLEN        ARGUMENT (KEY LENGTH)
         MODCB RPL=(R4),OPTCD=(SEQ,FWD,KGE,GEN),KEYLEN=(R2),           X
               MF=(G,MODCB_PARMLIST)
         LTR   R15,R15            MODCB SUCCESSFUL?
         BZ    STAR104            YES, RESET OUR FLAGS & DO POINT
         SPACE
         MVC   VSAMELAB,=CL8'STAR102'    NO, SET ERROR MESSAGE LABEL
         BAS   R14,GETREG0        OBTAIN REASON CODE
         SETMSG MSG=M$BADFUN      FUNCTION FAILED
         B     STAR999
         SPACE
STAR104  DS    0H
         OI    F@RPLFL,F@RSEQ+F@RFWD     SET OUR FLAGS
         NI    F@RPLFL,X'FF'-(F@RDIR+F@RKEQ+F@RFKS)
         B     STAR600            READY TO ISSUE POINT MACRO
         EJECT
STAR200  DS    0H      -- POSITION FOR BACKWARD READING --
         TM    F@RPLFL,F@RSEQ+F@RKEQ+F@RFKS  SEQ / KEY = / FULL KEY?
         BNO   STAR202            NO, NEED TO ISSUE MODCB
         TM    F@RPLFL,F@RFWD     FORWARD?
         BO    STAR202            YES, NEED TO ISSUE MODCB
         B     STAR600            READY TO ISSUE POINT MACRO
         SPACE
STAR202  DS    0H
         MODCB RPL=(R4),OPTCD=(SEQ,BWD,KEQ,FKS),                       X
               MF=(G,MODCB_PARMLIST)
         LTR   R15,R15            MODCB SUCCESSFUL?
         BZ    STAR204            YES, RESET OUR FLAGS & DO POINT
         SPACE
         MVC   VSAMELAB,=CL8'STAR102'    NO, SET ERROR MESSAGE LABEL
         BAS   R14,GETREG0        OBTAIN REASON CODE
         SETMSG MSG=M$BADFUN      FUNCTION FAILED
         B     STAR999
         SPACE
STAR204  DS    0H
         OI    F@RPLFL,F@RSEQ+F@RKEQ+F@RFKS     SET OUR FLAGS
         NI    F@RPLFL,X'FF'-(F@RDIR+F@RFWD)
         B     STAR600            READY TO ISSUE POINT MACRO
         EJECT
STAR600  DS    0H     -- ISSUE POINT FOR FILE POSITIONING --
         POINT RPL=(R4)
         SPACE
         LTR   R15,R15            POINT SUCCESSFUL?
         BZ    STAR900            YES, ALL DONE
         SPACE
         MVI   F@POINT,F@POINTN   NO FILE POSITIONING
         BAS   R14,GETFDBK        GO GET FEEDBACK WORD
         SPACE
         CLC   VSAMEREA,FDBKEOF   WAS IT AN "END OF FILE"?
         BNE   STAR602            NO, TRY NEXT POSSIBILITY
         SPACE
         SETMSG MSG=M$EOF         YES, SET MESSAGE
         B      STAR999           CONSIDER START "SUCCESSFUL"
         SPACE
STAR602  DS    0H
         CLC   VSAMEREA,FDBKNF    WAS IT A "NOT FOUND"?
         BNE   STAR604            NO, MUST BE SOME GENUINE HOSEUP
         SPACE
         SETMSG MSG=M$BWDNF       YES, SET MESSAGE
         B      STAR999           CONSIDER START "SUCCESSFUL"
         SPACE
STAR604  DS    0H
         MVC   VSAMELAB,=CL8'STAR604'   POINT GOT AN UNEXPECTED ERROR
         SETMSG MSG=M$BADFUN      SET MESSAGE
         B     STAR999            EXIT
         SPACE
STAR900  DS    0H
         MVI   F@POINT,F@POINTY   FILE POSITIONING HAS BEEN DONE
         SPACE 2
STAR999  DS    0H
         L     R14,RETURNTO       GET RETURN POINT
         BR    R14                EXIT & RETURN TO MAINLINE
         EJECT
WRIT000  DS    0H
*
* UPON ENTRY, R8 -> 3RD ARGUMENT (KEY) AND R5 STILL -> TYPE OF REQUEST
*
         ST    R14,RETURNTO       SAVE RETURN POINT
         BAS   R14,RTRVTOK0       GO SEE IF THERE'S A NAME / TOKEN
         SPACE
         LTR   R15,R15            IF TOKEN EXISTS
         BZ    WRIT010            READY TO GO
         SPACE
         SETMSG MSG=M$NOACB
         NTERROR REQ=RETRIEVE,SYM=WRIT000,GOTO=WRIT999
         SPACE
WRIT010  DS    0H
         L     R7,IEANTTOK        PICK UP ADDRESS OF FWA
         TM    F@OPENFL,F@OOUT    FILE OPEN FOR OUTPUT?
         BO    WRIT020            YES
         SPACE
         SETMSG MSG=M$NOOUT       NO, SET MESSAGE
         B     WRIT999            AND EXIT
         SPACE
WRIT020  DS    0H
*
* FROM THIS POINT THRU THE REST OF THE START LOGIC, R4 -> RPLAREA
*
         LA    R4,RPLAREA
         TM    F@RPLFL,F@RUPD     SET FOR UPDATE?
         BZ    WRIT100            NO, READY TO DO RECORD STUFF
         SPACE
         MODCB RPL=(R4),OPTCD=(NUP),                                   X
               MF=(G,MODCB_PARMLIST)
         LTR   R15,R15            SUCCESSFUL?
         BZ    WRIT030            YES, RESET OUR FLAGS, ETC.
         SPACE
         MVC   VSAMELAB,=CL8'WRIT020'
         B     WRIT990            DO GENERAL MODCB FAILURE LOGIC
         SPACE
WRIT030  DS    0H
         NI    F@RPLFL,X'FF'-F@RUPD     RESET FLAG & FALL-THRU
         EJECT
WRIT100  DS    0H
         LM    R2,R3,ARGTABLE_ARGSTRING_PTR   GET KEY ARGUMENT
         C     R2,=X'FFFFFFFF'    IS THERE A REAL ARGUMENT?
         BNE   WRIT110            YES, CONTINUE
         SPACE
         SETMSG MSG=M$BADARG      NO, SET ERROR MESSAGE
         B     WRIT999            EXIT ROUTINE
         SPACE
WRIT110  DS    0H
         LTR   R3,R3              IF ARG IS NONNULL,
         BNZ   WRIT130            COPY "KEY" INTO OUR AREA
         SPACE
         MODCB RPL=(R4),OPTCD=(SEQ),                                   X
               MF=(G,MODCB_PARMLIST)
         LTR   R15,R15            SUCCESSFUL?
         BZ    WRIT120            YES, RESET OUR FLAGS, ETC.
         SPACE
         MVC   VSAMELAB,=CL8'WRIT110'
         B     WRIT990            DO GENERAL MODCB FAILURE LOGIC
         SPACE
WRIT120  DS    0H
         OI    F@RPLFL,F@RSEQ     NOW SET FOR SEQUENTIAL ACCESS
         NI    F@RPLFL,X'FF'-F@RDIR   NO LONGER SET FOR DIRECT
         B     WRIT140            SKIP OVER KEY COPY
         SPACE
WRIT130  DS    0H
         XC    F@RPLARG,F@RPLARG  ELSE CLEAR OUT OUR COPY OF THE "KEY"
         ST    R3,F@ARGLEN        SAVE KEY LENGTH FOR LATER
         BCTR  R3,0               DECREMENT LENGTH FOR EXECUTE
         EX    R3,ARGMVC          COPY ARGUMENT TO OUR "KEY" AREA
         TM    F@RPLFL,F@RDIR     SET FOR DIRECT ACCESS?
         BO    WRIT140            YES, CONTINUE
         SPACE
         BAS   R14,TODIR          NO, SWITCH TO DIRECT
         LTR   R15,R15            IF THAT FAILED
         BNZ   WRIT999            JUST GIVE UP
         SPACE
WRIT140  DS    0H
         LA    R8,ARGTABLE_NEXT   BUMP TO NEXT ARGUMENT
         LM    R2,R3,ARGTABLE_ARGSTRING_PTR    GET ADDR & LENGTH
         C     R2,=X'FFFFFFFF'    NULL ARGUMENT?
         BNE   WRIT150            NO, PICK UP REC AREA VARIABLE NAME
         SPACE
         LA    R2,RECVARDF        YES, SET OUR OWN DEFAULTS FOR REC
         LA    R3,L'RECVARDF      VARIABLE NAME & NAME LENGTH
         EJECT
WRIT150  DS    0H
         LA    R6,OURSHVBL        GET -> TO SHARED VARIABLE BLOCK
         USING SHVBLOCK,R6        SET ADDRESSABILITY
         STM   R2,R3,SHVNAMA      SET -> & LENGTH OF VARIABLE NAME
         MVC   SHVBUFL,F@BUFLEN   SET LENGTH AREA TO HOLD VARIABLE
         MVC   SHVVALA,F@RECBUF   SET -> TO OUR VARIABLE VALUE AREA
         MVI   SHVCODE,SHVFETCH   WANT TO GET THIS VARIABLE
         L     R15,IRXEXCO@       ADDRESS OF IRXEXCOM ROUTINE
         CALL  (15),(IRXEXLIT,0,0,OURSHVBL),VL,MF=(E,EXCOPLST)
         SPACE
         TM    SHVRET,SHVBADN+SHVBADV+SHVBADF+SHVNEWV
         BZ    WRIT160            DID WE GET THE VARIABLE OK?
         SPACE
         SETMSG MSG=M$NORECV      NO, SET ERROR MESSAGE & EXIT
         B     WRIT999
         SPACE
WRIT160  DS    0H  - OBTAINED RECORD AREA, ENSURE IT WASN'T TRUNCATED -
         TM    SHVRET,SHVTRUNC    WAS VARIABLE TRUNCATED?
         BZ    WRIT170            NO, READY TO PUT RECORD
         SPACE
         SETMSG MSG=M$BADRL       YES, SET ERROR MESSAGE
         B     WRIT999            AND EXIT ROUTINE
         SPACE
WRIT170  DS    0H       -- OBTAINED RECORD AREA, DO VSAM PUT --
         L     R2,SHVVALL         SIZE OF RECORD AREA (LENGTH)
         MODCB RPL=(R4),RECLEN=(R2),                                   X
               MF=(G,MODCB_PARMLIST)
         LTR   R15,R15            MODCB WORKED?
         BZ    WRIT180            YES, CONTINUE
         SPACE
         MVC   VSAMELAB,=CL8'WRIT170'   NO, SET LABEL IN ERROR MSG
         B     WRIT990            DO GENERAL MODCB FAILURE LOGIC
         SPACE
WRIT180  DS    0H
         TM    F@OPENFL,F@ORRDS   IS FILE AN RRDS?
         BZ    WRIT190            NO, READY TO PUT RECORD
         TM    F@RPLFL,F@RSEQ     SEQUENTIAL ACCESS?
         BO    WRIT190            YES, NO KEY TO CONVERT
         SPACE
         BAS   R14,CONVKEY        ELSE, CONVERT KEY
         LTR   R15,R15            IF CONVERSION FAILED, EXIT ROUTINE
         BNZ   WRIT999            ELSE, FALL-THRU & PUT RECORD
         EJECT
WRIT190  DS    0H
         PUT   RPL=(R4)           WRITE THE RECORD
         LTR   R15,R15            SUCCESSFUL?
         BZ    WRIT999            ALL DONE
         SPACE
         BAS   R14,GETFDBK        GET FEEDBACK WORD
         CLC   VSAMEREA,FDBKDUPL  WAS IT A DUPLICATE
         BNE   WRIT200            NO, TRY NEXT POSSIBILITY
         SETMSG MSG=M$DUPL        YES, SET MESSAGE
         B     REWR999            EXIT ROUTINE
         SPACE
WRIT200  DS    0H
         CLC   VSAMEREA,FDBKBADL  WAS IT A BAD RECORD LENGTH?
         BNE   WRIT210            NO, TRY NEXT POSSIBILITY
         SETMSG MSG=M$BADRL       YES, SET MESSAGE
         B     REWR999            EXIT ROUTINE
         SPACE
WRIT210  DS    0H
         MVC   VSAMELAB,=CL8'WRIT210'   SET LABEL IN ERROR MSG
         SETMSG MSG=M$BADFUN      BAD FUNCTION
         B     WRIT999            EXIT ROUTINE
         SPACE
WRIT990  DS    0H        -- GENERAL LOGIC FOR MODCB FAILURE --
         BAS   R14,GETREG0        OBTAIN FEEDBACK
         SETMSG MSG=M$BADFUN      SET MESSAGE & FALL-THRU TO EXIT
         SPACE
WRIT999  DS    0H
         L     R14,RETURNTO       GET RETURN POINT
         BR    R14                EXIT & RETURN TO MAINLINE
         DROP  R6                 DROP SHVBLOCK ADDRESSABILITY
         EJECT
REWR000  DS    0H
*
* UPON ENTRY, R8 -> 3RD ARGUMENT (KEY)
*
         ST    R14,RETURNTO       SAVE RETURN POINT
         BAS   R14,RTRVTOK0       GO SEE IF THERE'S A NAME / TOKEN
         SPACE
         LTR   R15,R15            IF TOKEN EXISTS
         BZ    REWR010            READY TO GO
         SPACE
         SETMSG MSG=M$NOACB
         NTERROR REQ=RETRIEVE,SYM=REWR000,GOTO=REWR999
         SPACE
REWR010  DS    0H
         L     R7,IEANTTOK        PICK UP ADDRESS OF FWA
         TM    F@OPENFL,F@OOUT    FILE OPEN FOR OUTPUT?
         BO    REWR020            YES
         SPACE
         SETMSG MSG=M$NOOUT       NO, SET MESSAGE
         B     REWR999            AND EXIT
         SPACE
REWR020  DS    0H
*
* FROM THIS POINT THRU THE REST OF THE REWRITE LOGIC, R4 -> RPLAREA
* AND R6 -> SHARED VARIABLE BLOCK
*
         LA    R4,RPLAREA
         LA    R6,OURSHVBL        GET -> TO SHARED VARIABLE BLOCK
         USING SHVBLOCK,R6        SET ADDRESSABILITY
         LM    R2,R3,ARGTABLE_ARGSTRING_PTR   GET KEY ARGUMENT
         C     R2,=X'FFFFFFFF'    IS THERE A REAL ARGUMENT?
         BE    REWR030            NO, DO ERROR STUFF
         LTR   R3,R3              IS KEY ARGUMENT LENGTH ZERO?
         BZ    REWR040            YES, ENSURE IT'S AN ESDS
         B     REWR050            KEY IS OK, CONTINUE
         SPACE
REWR030  DS    0H
         SETMSG MSG=M$BADARG      NO, SET ERROR MESSAGE
         B     REWR999            EXIT ROUTINE
         EJECT
REWR040  DS    0H        -- ZERO LENGTH ONLY ALLOWED FOR AN ESDS --
         TM    F@OPENFL,F@OESDS   IS FILE AN ESDS?
         BO    REWR060            YES - IT'S OK - SKIP KEY STUFF
         SPACE
         SETMSG MSG=M$KEYZER      SET ZERO KEY LENGTH MESSAGE
         B     REWR999            EXIT ROUTINE
         SPACE
REWR050  DS    0H
         XC    F@RPLARG,F@RPLARG  CLEAR OUT OUR COPY OF THE "KEY"
         ST    R3,F@ARGLEN        SAVE KEY LENGTH FOR LATER
         BCTR  R3,0               DECREMENT LENGTH FOR EXECUTE
         EX    R3,ARGMVC          COPY ARGUMENT TO OUR "KEY" AREA
         SPACE
REWR060  DS    0H        -- CHECK FOR RECORD VARIABLE NAME --
         LA    R8,ARGTABLE_NEXT   BUMP TO NEXT ARGUMENT
         LM    R2,R3,ARGTABLE_ARGSTRING_PTR    GET ADDR & LENGTH
         C     R2,=X'FFFFFFFF'    NULL ARGUMENT?
         BNE   REWR070            NO, PICK UP REC AREA VARIABLE NAME
         SPACE
         LA    R2,RECVARDF        YES, SET OUR OWN DEFAULTS FOR REC
         LA    R3,L'RECVARDF      VARIABLE NAME & NAME LENGTH
         SPACE
REWR070  DS    0H
         STM   R2,R3,SHVNAMA      SET -> & LENGTH OF VARIABLE NAME
         MVC   SHVBUFL,F@BUFLEN   SET LENGTH AREA TO HOLD VARIABLE
         MVC   SHVVALA,F@RECBUF   SET -> TO OUR VARIABLE VALUE AREA
         MVI   SHVCODE,SHVFETCH   WANT TO GET THIS VARIABLE
         L     R15,IRXEXCO@       ADDRESS OF IRXEXCOM ROUTINE
         CALL  (15),(IRXEXLIT,0,0,OURSHVBL),VL,MF=(E,EXCOPLST)
         SPACE
         TM    SHVRET,SHVBADN+SHVBADV+SHVBADF+SHVNEWV
         BZ    REWR080            DID WE GET THE VARIABLE OK?
         SPACE
         SETMSG MSG=M$NORECV      NO, SET ERROR MESSAGE & EXIT
         B     REWR999
         SPACE
REWR080  DS    0H  - OBTAINED RECORD AREA, ENSURE IT WASN'T TRUNCATED -
         TM    SHVRET,SHVTRUNC    WAS VARIABLE TRUNCATED?
         BZ    REWR100            NO, READY TO PUT RECORD
         SPACE
         SETMSG MSG=M$BADRL       YES, SET ERROR MESSAGE
         B     REWR999            AND EXIT ROUTINE
         EJECT
REWR100  DS    0H       -- OBTAINED RECORD AREA, DO VSAM PUT --
         L     R2,SHVVALL         SIZE OF RECORD AREA (LENGTH)
         MODCB RPL=(R4),RECLEN=(R2),                                   X
               MF=(G,MODCB_PARMLIST)
         LTR   R15,R15            MODCB WORKED?
         BZ    REWR110            YES, CONTINUE
         SPACE
         MVC   VSAMELAB,=CL8'REWR100'   NO, SET LABEL IN ERROR MSG
         BAS   R14,GETREG0        GET FEEDBACK FROM REGISTER 0
         SETMSG MSG=M$BADFUN      INDICATE FAILURE
         B     REWR999            EXIT ROUTINE
         SPACE
REWR110  DS    0H
         PUT   RPL=(R4)           WRITE THE RECORD
         LTR   R15,R15            SUCCESSFUL?
         BZ    REWR999            CONTINUE
         SPACE
         BAS   R14,GETFDBK        GET FEEDBACK WORD
         CLC   VSAMEREA,FDBKDUPL  WAS IT A DUPLICATE
         BNE   REWR120            NO, TRY NEXT POSSIBILITY
         SETMSG MSG=M$DUPL        YES, SET MESSAGE
         B     REWR999            EXIT ROUTINE
         SPACE
REWR120  DS    0H
         CLC   VSAMEREA,FDBKBADL  WAS IT A BAD RECORD LENGTH?
         BNE   REWR130            NO, TRY NEXT POSSIBILITY
         SETMSG MSG=M$BADRL       YES, SET MESSAGE
         B     REWR999            EXIT ROUTINE
         SPACE
REWR130  DS    0H
         MVC   VSAMELAB,=CL8'REWR130'   SET LABEL IN ERROR MSG
         SETMSG MSG=M$BADFUN      BAD FUNCTION
         B     REWR999            EXIT ROUTINE
         SPACE 2
REWR999  DS    0H
         L     R14,RETURNTO       GET RETURN POINT
         BR    R14                EXIT & RETURN TO MAINLINE
         DROP  R6                 DROP SHVBLOCK ADDRESSABILITY
         EJECT
DELE000  DS    0H
*
* UPON ENTRY, R8 -> 3RD ARGUMENT (KEY)
*
         ST    R14,RETURNTO       SAVE RETURN POINT
         BAS   R14,RTRVTOK0       GO SEE IF THERE'S A NAME / TOKEN
         SPACE
         LTR   R15,R15            IF TOKEN EXISTS
         BZ    DELE010            READY TO GO
         SPACE
         SETMSG MSG=M$NOACB
         NTERROR REQ=RETRIEVE,SYM=DELE000,GOTO=DELE999
         SPACE
DELE010  DS    0H
         L     R7,IEANTTOK        PICK UP ADDRESS OF FWA
         TM    F@OPENFL,F@OOUT    FILE OPEN FOR OUTPUT?
         BO    DELE020            YES
         SPACE
         SETMSG MSG=M$NOOUT       NO, SET MESSAGE
         B     DELE999            AND EXIT
         SPACE
DELE020  DS    0H
         TM    F@OPENFL,F@OESDS   IS FILE AN ESDS?
         BZ    DELE030            NO, OK TO CONTINUE
         SPACE
         SETMSG MSG=M$NOESDS      YES, IT IS - THIS FUNCTION NOT
         B     REWR999            ALLOWED FOR AN ESDS, SET MSG & EXIT
         SPACE
DELE030  DS    0H
         LM    R2,R3,ARGTABLE_ARGSTRING_PTR   GET KEY ARGUMENT
         C     R2,=X'FFFFFFFF'    IF KEY ARGUMENT EXISTS, DO ERASE
         BNE   DELE100            (RECORD AREA ARGUMENT IS IGNORED)
         SPACE
         SETMSG MSG=M$BADARG      NO, SET ERROR MESSAGE
         B     REWR999            EXIT ROUTINE
         EJECT
DELE100  DS    0H
         LA    R4,RPLAREA
         ERASE RPL=(R4)           ERASE THE RECORD
         LTR   R15,R15            IF ERASE WAS SUCCESSFUL
         BZ    DELE999            EXIT ROUTINE
         SPACE
         MVC   VSAMELAB,=CL8'DELE100'   ERASE FAILED, SET LABEL
         BAS   R14,GETFDBK        GET FEEDBACK WORD
         CLC   VSAMEREA,FDBKNOGE  ERROR WAS "NO PREVIOUS GET"?
         BNE   DELE110            NO, INDICATE GENERAL FUNCTION FAILURE
         SPACE
         SETMSG MSG=M$NOGET       SET NO PREVIOUS GET MESSAGE
         B     DELE999            EXIT ROUTINE
         SPACE
DELE110  DS    0H
         SETMSG MSG=M$BADFUN      FUNCTION FAILED
         SPACE 2
DELE999  DS    0H
         L     R14,RETURNTO       GET RETURN POINT
         BR    R14                EXIT & RETURN TO MAINLINE
         EJECT
*
* ARGMVC - EXecuted MVC to copy argument (key / RRN / RBA) to the
*          area where the RPL expects to find it.  R2 must point to
*          the argument source.
*
         SPACE
ARGMVC   MVC   F@RPLARG(0),0(R2)  EXECUTED INSTRUCTION
         SPACE 3
*
* ARGTRT - EXecuted TRT to check for numeric bytes in an RRN key.
*
         SPACE
ARGTRT   TRT   F@RPLARG(0),NUMTAB      EXECUTED INSTRUCTION
         SPACE 3
*
* ARGPACK - EXecuted PACK for converting RRN key to packed decimal.
*
         SPACE
ARGPACK  PACK  DBLWRK,F@RPLARG(0)      EXECUTED INSTRUCTION
         EJECT
TODIR    DS    0H         -- CHANGE RPL TO DIRECT READ --
*
* ANY NON-ZERO VALUE IN R15 UPON EXIT INDICATES TO THE CALLER THAT
* THIS ROUTINE DETECTED A PROBLEM, AND FURTHER PROCESSING IS PROBABLY
* NOT A GOOD IDEA
*
* !! THIS ROUTINE ASSUMES THE CALLER HAS SET R4 AS A -> TO THE RPL !!
*
         ST    R14,LVL1R14        SAVE RETURN POINT
         SR    R15,R15            CLEAR R15
         TM    F@OPENFL,F@OOUT    FILE OPEN FOR OUTPUT?
         BO    TODIR100           YES, MODIFY ONLY PROCESSING TYPE
         SPACE
         MODCB RPL=(R4),OPTCD=(DIR,NSP),                               X
               MF=(G,MODCB_PARMLIST)
         LTR   R15,R15            SUCCESSFUL?
         BZ    TODIR200           YES, RESET OUR FLAGS
         SPACE
         MVC   VSAMELAB,=CL8'TODIR'
         B     TODIR900           DO REST OF ERROR PROCESSING
         SPACE
TODIR100 DS    0H
         MODCB RPL=(R4),OPTCD=(DIR),                                   X
               MF=(G,MODCB_PARMLIST)
         LTR   R15,R15            SUCCESSFUL?
         BZ    TODIR200           YES, GO RESET OUR FLAG
         SPACE
         MVC   VSAMELAB,=CL8'TODIR200'
         B     TODIR900           DO REST OF ERROR PROCESSING
         SPACE
TODIR200 DS    0H
         OI    F@RPLFL,F@RDIR     RESET OUR FLAG - DIRECT PROCESSING
         NI    F@RPLFL,X'FF'-F@RSEQ       TURN OFF SEQUENTIAL FLAG
         B     TODIR999           ALL DONE, EXIT ROUTINE
         SPACE
TODIR900 DS    0H         -- ERROR MODIFYING A CONTROL BLOCK --
         CVD   R15,DBLWRK
         UNPK  VSAMER15,HALFWRK2
         OI    VSAMER15+1,X'F0'
         BAS   R14,GETREG0        GET REASON CODE FROM REGISTER 0
         SETMSG MSG=M$BADDSW      SET BAD RESULT CODE & FALL-THRU
         SPACE
TODIR999 DS    0H
         L     R14,LVL1R14        GET RETURN POINT
         BSM   0,R14              EXIT & RETURN TO CALLER
         EJECT
RTRVTOK0 DS    0H
*
*  RETRIEVES THE NAME / TOKEN PAIR.  CALLER MUST CHECK FOR ERRORS -
*  R15 IS LEFT INTACT. REL 2.2: BUMP THRU STORAGE TO FIND IEANTRT
*
         ST    R14,LVL1R14        SAVE RETURN POINT
         L     R15,X'10'
         L     R15,X'220'(R15,0)
         L     R15,X'14'(R15,0)
         L     R15,X'08'(R15,0)
         CALL  (15),(IEANTLVL,IEANTNAM,IEANTTOK,IEANTRC),              X
               MF=(E,IEANTLST)
         SPACE
         L     R14,LVL1R14        GET RETURN POINT
         BSM   0,R14              EXIT & RETURN TO CALLER
         EJECT
CONVKEY  DS    0H    -- CONVERT AN RRN KEY TO BINARY --
*
*  A NON-ZERO VALUE IN R15 INDICATES THAT THE ARGUMENT (KEY) WAS
*  NOT NUMERIC.  THIS ROUTINE SETS THE ERROR MESSAGE.
*
         ST    R14,LVL1R14        SAVE RETURN POINT
         SR    R15,R15            SET ROUTINE RETURN CODE TO ZERO
         L     R14,F@ARGLEN       GET KEY LENGTH
         BCTR  R14,0              DECREMENT FOR EXECUTE
         EX    R14,ARGTRT         TEST TO ENSURE IT'S NUMERIC
         BZ    CONVK100           IF IT WAS, CONTINUE
         SPACE
         SETMSG MSG=M$NONNUM      ELSE, SET MSG (WHICH PUTS A NON-ZERO
         B     CONVK999           VALUE IN R15 ALSO), AND EXIT ROUTINE
         SPACE
CONVK100 DS    0H
         EX    R14,ARGPACK        PACK KEY
         CVB   R14,DBLWRK         CONVERT TO BINARY
         ST    R14,F@RPLARG       REPLACE ARGUMENT, THEN EXIT
         SPACE
CONVK999 DS    0H
         L     R14,LVL1R14        GET RETURN POINT
         BSM   0,R14              RETURN TO CALLER
         EJECT
GETFDBK  DS    0H          -- GET FDBK / SET REASON CODE --
*
* This routine will issue a SHOWCB to obtain the feedback fullword
* so the reason code can be added to the error message.  This routine
* assumes that R15 still contains the VSAM return code (probably 8).
* The caller of this routine is responsible for setting the value of
* VSAMELAB before the call and issuing the SETMSG macro upon return
* from the routine.
*
* !! THIS ROUTINE ASSUMES THE CALLER HAS SET R4 AS A -> TO THE RPL !!
*
         ST    R14,LVL1R14        SAVE RETURN POINT
         CVD   R15,DBLWRK
         UNPK  VSAMER15,HALFWRK2
         OI    VSAMER15+1,X'F0'
         LA    R2,FULLWRK2
         SHOWCB RPL=(R4),AREA=(R2),LENGTH=4,FIELDS=(FDBK),             X
               MF=(G,SHOWCB_PARMLIST)
         SPACE
         LTR   R15,R15            DID SHOWCB WORK?
         BZ    GETFDBK1           YES - GO PICK UP ERROR MESSAGE
         SPACE
         MVC   VSAMELAB,=CL8'GETFDBK'   SET UP ERROR MESSAGE FIELDS
         CVD   R15,DBLWRK         SET RETURN CODE FROM SHOWCB
         UNPK  VSAMER15,HALFWRK2
         OI    VSAMER15+1,X'F0'
         CVD   R0,DBLWRK          SET REASON CODE
         UNPK  VSAMEREA,HALFWRK2
         OI    VSAMEREA+3,X'F0'
         B     GETFDBK9           EXIT SUBROUTINE
         SPACE
GETFDBK1 DS    0H
*
*  TO CONSIDER:  SAVE FDBK WORD IN A DISPLAYABLE FORMAT SOMEWHERE
*
         SR    R14,R14
         IC    R14,BYTEWRK2       LAST BYTE OF FEEDBACK WORD
         CVD   R14,DBLWRK         IS THE REASON CODE
         UNPK  VSAMEREA,HALFWRK2
         OI    VSAMEREA+3,X'F0'
         SPACE
GETFDBK9 DS    0H
         L     R14,LVL1R14        GET RETURN POINT
         BSM   0,R14              EXIT & RETURN TO CALLER
         EJECT
GETREG0  DS    0H
*
* Put reason code into VSAMEMSG - this routine assumes the return code
* from a VSAM SHOWCB, MODCB, etc., has been left intact in R15.  No
* registers are altered by this routine, can be called from anywhere
*
         CH    R15,=H'4'          REASON CODE IS ONLY IN R0 WHEN THE
         BNE   GETREG0X           VSAM R.C. IS 4
         SPACE
         CVD   R0,DBLWRK          PUT REASON CODE IN VSAM ERROR MESSAGE
         UNPK  VSAMEREA,HALFWRK2
         OI    VSAMEREA+3,X'F0'
         SPACE
GETREG0X DS    0H
         BSM   0,R14              RETURN TO CALLER
         SPACE
         TITLE 'RXVSAM1 - L T O R G'
         LTORG
         TITLE 'RXVSAM1 - Constants'
         DS    0D
NUMTAB   DC    256X'FF'           TRT TABLE FOR NUMERIC CLASS TEST
         ORG   NUMTAB+C'0'
         DC    10X'00'
         ORG
*
* COMMON FDBK REASON CODES IN CHARACTER (DECIMAL) FORMAT
*
FDBKEOF  DC    CL4'0004'               END OF FILE
FDBKDUPL DC    CL4'0008'               DUPLICATE RECORD
FDBKSEQE DC    CL4'0012'               SEQUENCE ERROR
FDBKNF   DC    CL4'0016'               RECORD NOT FOUND
FDBKNOGE DC    CL4'0092'               PUT OR ERASE, NO PREVIOUS GET
FDBKBADL DC    CL4'0108'               BAD RECORD LENGTH
*
* MISCELLANEOUS CONSTANTS
*
F8       DC    F'8'
         ORG *-2
H8       DS    H
L_KSDS   DC    CL4'KSDS'
L_ESDS   DC    CL4'ESDS'
L_RRDS   DC    CL4'RRDS'
USCORE   DC    8C'_'              UNDERSCORES CONSTANT
SPACES   DC    CL8' '             SPACES CONSTANT
IRXEXLIT DC    CL8'IRXEXCOM'      PROGRAM NAME CONSTANT
RXVSMSG@ DC    V(RXVSAMSG)        -> TO RXVSAMSG CSECT
VMSGVAR  DC    CL19'RXVSAM_VSAMERRORMSG'     VSAM ERR MSG VAR NAME
RMSGVAR  DC    CL16'RXVSAM_RETURNMSG'  RETURN MESSAGE VARIABLE NAME
RECVARDF DC    CL13'RXVSAM_RECORD'     DEFAULT RECORD VARIABLE NAME
         SPACE
VMSGINIT DS    0X
         DC    CL43'VSAM error, return code in register 15 was '
         DC    CL2'00'
         DC    CL18', reason code was '
         DC    CL4'0000'
         DC    CL24' (LABEL IN RXVSAM1 WAS: '
         DC    CL8' '
         DC    CL1')'
VMSGLEN  EQU   *-VMSGINIT
         SPACE
NTMSGINI DS    0X              NAME / TOKEN SERVICES ERROR MESSAGE
         DC    CL44'NAME / TOKEN service error, register 15 was '
         DC    CL2'00'
         DC    CL14', request was '
         DC    CL8' '
         DC    CL24' (LABEL IN RXVSAM1 WAS: '
         DC    CL8' '
         DC    CL1')'
         SPACE
         TITLE 'RXVSAM1 - Local Work Area'
*
* This area is initialized to X'00'
*
LOCAL_WORKAREA DSECT
DBLWRK   DS    0D
FULLWRK1 DS    F
FULLWRK2 DS    0F
HALFWRK1 DS    H
HALFWRK2 DS    0H
BYTEWRK1 DS    X
BYTEWRK2 DS    X
         SPACE
         DS    0D                 ALIGN ON A DOUBLEWORD
IEANTNAM DS    0CL16              NAME FOR NAME / TOKEN PAIR
IEANTNA1 DS    CL8                 - 1ST PART (BASED ON JOB ID)
IEANTNA2 DS    CL8                 - 2ND PART (BASED ON FILE DD)
IEANTTOK DS    XL16               TOKEN FOR NAME / TOKEN PAIR
*        The 1st fullword of the token is a -> to this file's FWA
IEANTLVL DS    A                  LEVEL FOR IEANT SERVICE
IEANTPOP DS    A                  PERSIST OPTION FOR IEANT SERVICE
IEANTRC  DS    F                  RETURN CODE FROM IEANT SERVICE
IEANTLST DS    5F                 ADDR LIST FOR ABOVE 5 PARMS (CALL)
         SPACE
SAVEAREA DS    18F
         SPACE
EXCOPLST DS    4F                 PARM LIST AREA FOR IREXCOM CALL
GENCB_PARMLIST DS  20F            PARM LIST FOR GENCB MACRO
MODCB_PARMLIST DS  20F            PARM LIST FOR MODCB MACRO
SHOWCB_PARMLIST DS 20F            PARM LIST FOR SHOWCB MACRO
OPEN_PARMLIST  DS  2F             PARM LIST FOR OPEN MACRO
CLOSE_PARMLIST DS  2F             PARM LIST FOR CLOSE MACRO
         SPACE
MSG@     DC    F'0'               -> TO ERROR MSG TEXT
EFPL@    DC    F'0'               -> TO EFPL (SAVED AT FUNCTION ENTRY)
ENVB@    DC    F'0'               -> TO ENVB (SAVED AT ENTRY)      @ANZ
IRXEXCO@ DC    F'0'               -> IRXEXCOM ENTRY ADDRESS
RECBUF@  DC    F'0'               -> TO RECORD BUFFER AREA
RETURNTO DC    F'0'               R14 SAVE FOR OPEN/READ/WRIT/CLOS ETC
LVL1R14  DC    F'0'               R14 SAVE - LEVEL 1 SUBROUTINES
NAMTOKRC DC    F'0'               R15 (R.C.) FROM NAME / TOKEN SERVICES
TRACE@B  DC    F'0'               -> TO TRACE AREA
TRACE@C  DC    F'0'               -> TO "NEXT" SLOT IN TRACE AREA
TRACE@M  DC    F'0'               -> TO END OF TRACE AREA
MSGLEN   DC    H'0'               LENGTH OF RETURN MESSAGE (MSG@)
RECBUFL  DC    H'0'               LENGTH OF RECORD BUFFER (RECBUF@)
ARG_1_@  DC    F'0'               SAVE ARG 1 PTR ADDR
ARG_1_L  DC    F'0'               SAVE ARG 1 LNG
RONE_PHASE_PTR  DC  F'0'           RONE PHASE CONTROL RETURN ADR
RONE_PHASE DS  CL4' '             RONE PHASE CONTROL
RONE_TYPE  DS  CL4' '             RONE TYPE OF VSAM FILE
RONE_KTYP  DS  CL3' '             RONE KEY TYPE RPL OPTCD KEQ KGE
MYJOBID  DS    CL8                JOB ID (1ST CHAR OVERLAID WITH "X")
MYJOBNM  DS    CL8                JOB nm (1ST CHAR OVERLAID WITH "X")
DDNAME   DS    CL8                SPACE PADDED DDNAME
         SPACE
VSAMEMSG DS    0X                 VSAM ERROR MESSAGE
         DS    CL43
VSAMER15 DS    CL2
         DS    CL18
VSAMEREA DS    CL4
         DS    CL23
VSAMELAB DS    CL8
         DS    CL1
VSAMELEN EQU   *-VSAMEMSG
         SPACE
NTMSG    DS    0X              NAME / TOKEN SERVICES ERROR MESSAGE
         DS    CL44
NTMSGR15 DS    CL2
         DS    CL14
NTREQ    DS    CL8
         DS    CL23
NTLABEL  DS    CL8
         DS    CL1
NTMSGLEN EQU   *-NTMSG
         SPACE
         DS    0F
OURSHVBL DC  XL(SHVBLEN)'00'           OUR SHARED VARIABLE BLK STORAGE
         SPACE
LOCAL_WORKAREA_LENGTH EQU *-LOCAL_WORKAREA   TOTAL LENGTH OF AREA
         TITLE 'RXVSAM1 - File Work Area  '
FWABLOCK DSECT
*
* FWABLOCK - THERE WILL BE ONE OF THESE FOR EACH OPEN VSAM DATASET.
* The OPEN routine obtains the storage, and the CLOSE routine releases
* it.  NAME / TOKEN services are used to manage (keep track) of this
* block between invocations of RXVSAM1.
*
FWA      DS    0F   --- BEGINNING OF FILE WORK AREA ---
ACBAREA  DS    XL76               OUR COPY OF CURRENT ACB
ACBAREAL EQU   *-ACBAREA          LENGTH OF AREA
         SPACE
RPLAREA  DS    XL76               OUR COPY OF CURRENT RPL
RPLAREAL EQU   *-RPLAREA          LENGTH OF AREA
         SPACE
FWAFLAGS DS    0F                 FLAGS
F@RECBUF DC    F'0'                - OUR RECORD BUFFER ADDRESS
F@BUFLEN DC    F'0'                - LENGTH OF OUR RECORD BUFFER
F@LRECL  DC    F'0'                - MAX RECORD LENGTH FOR THIS FILE
F@ARGLEN DC    F'0'                - LENGTH OF KEY (ARGUMENT)
F@OPENFL DC    X'0'                - ACB FLAGS
F@OIN    EQU   X'80'                 - OPEN FOR INPUT   | Both flags on
F@OOUT   EQU   X'40'                 - OPEN FOR OUTPUT  | if open I-O
F@OSEQ   EQU   X'20'                 - FILE SET FOR SEQUENTIAL ACCESS
F@ODIR   EQU   X'10'                 - FILE SET FOR DIRECT ACCESS
F@O###   EQU   X'08'                 - (UNUSED BIT SETTING)
F@OKSDS  EQU   X'04'                 - FILE IS A KSDS
F@ORRDS  EQU   X'02'                 - FILE IS AN RRDS
F@OESDS  EQU   X'01'                 - FILE IS AN ESDS
F@RPLFL  DC    X'0'                - RPL FLAGS
F@RKEY   EQU   X'80'                 - USE KEY (RRN) ARGS (OFF = ADR)
F@RARD   EQU   X'40'                 - USE USER'S ARGS (OFF = LRD)
F@RSEQ   EQU   X'20'                 - SEQUENTIAL ACCESS
F@RDIR   EQU   X'10'                 - DIRECT ACCESS (MAY ALSO SET NSP)
F@RUPD   EQU   X'08'                 - UPD (OFF = NUP {UNLESS F@RDIR})
F@RFWD   EQU   X'04'                 - FORWARD (OFF = BWD) PROCESSING
F@RKEQ   EQU   X'02'                 - EQUAL KEY (OFF = KGE)
F@RFKS   EQU   X'01'                 - FULL KEY SUPPLIED (OFF = GEN)
F@POINT  DS    X                  FILE POSITIONING IS SET
F@POINTN EQU   X'00'                - NO
F@POINTY EQU   X'FF'                - YES
         DS    X
F@RPLARG DC    XL255'00'          ARGUMENT (KEY) AREA FOR RPL
         SPACE
         DS    XL1
FWALEN   EQU   *-FWA              LENGTH OF FILE WORK AREA BLOCK
FWAEND   DS    0X                 END OF BLOCK MARKER
*
* End of FILE WORK AREA block
*
         TITLE 'RXVSAM1 - IRXEFPL Dsect'
         PRINT GEN
         IRXEFPL
         TITLE 'RXVSAM1 - IRXEVALB Dsect'
         IRXEVALB
         TITLE 'RXVSAM1 - IRXARGTB Dsect'
         IRXARGTB
         TITLE 'RXVSAM1 - IRXSHVB Dsect'
         IRXSHVB
         TITLE 'RXVSAM1 - IRXENVB Dsect'                           @ANZ
         IRXENVB                                                   @ANZ
         TITLE 'RXVSAM1 - IRXEXTE Dsect'                           @ANZ
         IRXEXTE                                                   @ANZ
         TITLE 'RXVSAM1 - IGGSHWPL DSECT'                          @ANZ
         IGGSHWPL                                                  @ANZ
         TITLE 'RXVSAM1 - MISC SYSTEM DESCTS'
STCB     DSECT
         DS    XL188
STCBJSAB DS    A
         DS    XL4
         SPACE 2
         IAZJSAB DSECT=YES
         EJECT
         IHAASCB
         EJECT
         IHAASSB
         EJECT
         IHAPSA
         EJECT
         IKJTCB
         SPACE 2
 TITLE 'RXVSAM1SG - Error Messages for RXVSAM1'
         PRINT GEN
RXVSAMSG AMODE 31
RXVSAMSG RMODE ANY
RXVSAMSG GENMSGS GEN=CSECT
         END
###END RXVSAM1
$$$BEG EXSYSP1
         REGSMAC
URGNCNTL CSECT
URGNCNTL AMODE 31
URGNCNTL RMODE ANY
         STM   14,12,12(13)
         LR    12,15
         USING URGNCNTL,12
* GET SAVE AREA AND ADD TO CHAIN
         GETMAIN R,LV=72,LOC=(31)
         ST    13,4(1)
         LR    13,1
* GET STORAGE BELOW THE LINE AND COPY DCBS, ETC.
         GETMAIN R,LV=SIZE_TOT,LOC=(24)
         LR    11,1
         USING WORKAREA,11
         XC    H_SYSPRINT_LRECL,H_SYSPRINT_LRECL
         XC    H_SYSIN_LRECL,H_SYSIN_LRECL
         LA    R15,SIZE_MSG
         STH   R15,H_MAX_SYSPRINT_LRECL
         XC    H_MOV_SYSPRINT_LRECL,H_MOV_SYSPRINT_LRECL
         MVI   SYSPRINT_MSG1,X'40'
         MVC   SYSPRINT_MSG,SYSPRINT_MSG1
         MVC   IN(SIZE_INDCB),INDCB
         MVC   OUT(SIZE_OUTDCB),OUTDCB
         MVC   OPENWK(SIZE_OPN),OPENS
         MVC   CLOSWK(SIZE_CLO),CLOSES
* GET STORAGE FOR RECORDS
         GETMAIN R,LV=SIZE_WORKAREA,LOC=(31)
         LR    3,1
* OPEN; NOTE MF PARAMETER
         OPEN (IN,,OUT,(OUTPUT)),MF=(E,OPENWK)
         LA    14,IN
         USING IHADCB,14
         MVC   H_SYSIN_LRECL,DCBLRECL
         DROP  14
         LA    14,OUT
         USING IHADCB,14
         MVC   H_SYSPRINT_LRECL,DCBLRECL
         DROP  14
         CLC   H_SYSPRINT_LRECL,H_MAX_SYSPRINT_LRECL
         BL    RET16
         MVC   H_MAX_SYSPRINT_LRECL,H_SYSPRINT_LRECL
         MVC   H_MOV_SYSPRINT_LRECL,H_SYSPRINT_LRECL
         CLC   H_SYSIN_LRECL,H_MAX_SYSPRINT_LRECL
         BH    ADJ_MOV_LNG
         MVC   H_MOV_SYSPRINT_LRECL,H_SYSIN_LRECL
ADJ_MOV_LNG EQU *
         LH    R15,H_MOV_SYSPRINT_LRECL
         BCTR  R15,0   ADJUST MOVE LENGTH FOR EXECUTE
         STH   R15,H_MOV_SYSPRINT_LRECL
* MAIN LOGIC
LOOP     DS    0H
         GET   IN,(3)
         PUT   OUT,(3)
         B     LOOP
MOV_MSG  MVC   SYSPRINT_MSG,BEGMSG
RET16    DS    0H
         MVI   RC,X'16'
DONE     DS    0H
         CLOSE (IN,,OUT),MF=(E,CLOSWK)
         LR    1,3
         FREEMAIN R,LV=100,A=(1)
         LR    1,11
         FREEMAIN R,LV=SIZE_TOT,A=(1)
         LR    1,13
         L     13,4(1)
         FREEMAIN R,LV=72,A=(1)
         LM    14,12,12(13)
         SR    15,15
         BR    14
*
RC       DC    XL1'00'
BEGMSG   DC    CL255'*URGNCNTL TEST MSG'
         LTORG
* WORK AREAS AND CONTROL BLOCKS
INDCB    DCB DDNAME=SYSIN,DSORG=PS,MACRF=GM,                           X
               DCBE=IN_DCBE
SIZE_INDCB EQU *-INDCB
OUTDCB   DCB DDNAME=SYSPRINT,DSORG=PS,MACRF=PL,                        X
               RECFM=FB,DCBE=OUT_DCBE
SIZE_OUTDCB EQU *-OUTDCB
OPENS    OPEN (,,),MF=L
SIZE_OPN EQU *-OPENS
CLOSES   CLOSE (,,),MF=L
         DS    H
SIZE_CLO EQU *-CLOSES
SIZE_TOT EQU *-INDCB
IN_DCBE  DCBE RMODE31=BUFF,EODAD=DONE
OUT_DCBE DCBE RMODE31=BUFF
*
WORKAREA DSECT
IN       DS  XL(SIZE_INDCB)
OUT      DS  XL(SIZE_OUTDCB)
OPENWK   DS  XL(SIZE_OPN)
CLOSWK   DS  XL(SIZE_CLO)
*
H_SYSIN_LRECL DS H
H_SYSPRINT_LRECL DS H
H_MAX_SYSPRINT_LRECL DS H
H_MOV_SYSPRINT_LRECL DS H
*
SYSPRINT_MSG1 DS CL1
SYSPRINT_MSG  DS CL256
SIZE_MSG  EQU *-SYSPRINT_MSG
*
SIZE_WORKAREA EQU *-WORKAREA
*
URGNCNTL CSECT
TESTDCBD DCBD DSORG=PS,DEVD=DA
*
         END URGNCNTL
###END EXSYSP1
$$$BEG EXPBASSM
ENTRY LINKAGE FROM CALLER VIA BASSM:
BAKR 14,0 SAVE CALLER'S REGISTERS
LARL 13,SAVEAREA GET DUMMY SAVE AREA ADDRESS
LARL 12,DATA SET BASE REGISTER FOR DATA
USING DATA,12 TELL THE ASSEMBLER
* THE FOLLOWING CODE IS NEEDED IF THE CALLER MIGHT HAVE BEEN IN AMODE 64
LA 2,1 GET CALLER'S
ESTA 2,2 PSW
TMLL 2,1 CALLER WAS IN AMODE 64?
JNZ ENTERED YES: JUMP
LLGTR 1,1 ENSURE R1 HAS A GOOD ADDRESS
ENTERED DS 0H
EXIT LINKAGE BACK TO CALLER:
LGHI 15,0 SET RETURN CODE
PR , RETURN TO CALLER
DATA LTORG START OF DATA AREA
SAVEAREA DC 0D'0',F'0',C'F1SA'
###END EXPBASSM
$$$BEG EXPLINST
**
**  NOTE ASMMSP HLASM TOOLKIT MACRO IS NOT AVAILABLE
**  WORD     CONTENTS
**
**  0        USED BY LANGUAGE PRODUCTS
**  1        ADDRESS OF PREVIOUS SAVE AREA (STORED BY CALLING PROGRAM)
**  2        ADDRESS OF NEXT SAVE AREA (STORED BY TARGET PROGRAM)
**  3        GPR 14 (RETURN ADDRESS)
**  4        GPR 15 (ENTRY ADDRESS)
**  5 - 17   GPRS 0 - 12
**
** IF THE CALLING PROGRAM IS IN PRIMARY MODE, THE PARAMETER LIST
** MUST BE IN THE PRIMARY ADDRESS SPACE.  ALL ADDRESSES PASSED
** BY THE PROGRAMS MUST BE CONTAINED IN THE PRIMARY ADDRESS
** SPACE AND MUST NOT BE ALET-QUALIFIED. THE PROGRAM THAT
** PASSES PARAMETER DATA CAN USE GPRS 0 AND 1, OR BOTH.  TO
** PASS THE ADDRESS OF A PARAMETER LIST, THE PROGRAM SHOULD USE
** GPR 1.
**
** FOR A GOOD EXAMPLE OF HOW YOUR PRIMARY MODE PROGRAMS CAN
** PASS PARAMETERS, CONSIDER THE WAY THE SYSTEM USES A
** REGISTER TO PASS INFORMATION IN THE PARM FIELD OF AN EXEC
** STATEMENT TO YOUR PROGRAM.  WHEN YOUR PROGRAM RECEIVES
** CONTROL FROM THE SYSTEM, REGISTER 1 CONTAINS THE ADDRESS OF A
** FULLWORD ON A FULLWORD BOUNDARY IN YOUR PROGRAM'S ADDRESS
** SPACE (SEE FIGURE 2-2).  THE HIGH-ORDER BIT (BIT 0) OF THIS WORD
** IS SET TO 1.  THE SYSTEM USES THIS CONVENTION TO INDICATE THE
** LAST WORD IN A VARIABLE-LENGTH PARAMETER LIST. BITS 1-31 OF THE
** FULLWORD CONTAIN THE ADDRESS OF A TWO-BYTE LENGTH FIELD ON A
** HALFWORD BOUNDARY.  THE LENGTH FIELD CONTAINS A BINARY COUNT OF
** THE NUMBER OF BYTES IN THE PARM FIELD, WHICH IMMEDIATELY
** FOLLOWS THE LENGTH FIELD.  IF THE PARM FIELD WAS OMITTED IN THE
** EXEC STATEMENT, THE COUNT IS SET TO ZERO.  TO PREVENT POSSIBLE
** ERRORS, ALWAYS USE THE COUNT AS A LENGTH ATTRIBUTE IN ACQUIRING
** THE INFORMATION IN THE PARM FIELD.
**
**
**  RMODE 24 OR ANY FOR RESIDENCY. MUST BE 24 IF YOU HAVE A QSAM DCB
**  OR YOU MUST LOAD THE QSAM DCB CONTROL BLOCK INTO DYN STORAGE BELOW
**  AND USE A BSM TO SWITCH IN AND OUT OF 24 BIT MODE FOR THE IO.
**  AMODE 24 OR 31 FOR ADDRESSABILITY.
**  RESIDENCY AFFECTS WHERE IN STORAGE THE LOADER WILL PLACE YOUR PGM,
**  RMODE CAN BE 24,31,ANY WHERE ANY WILL IMPLY 31 FIRST AND THEN 24.
**  ADDRESSABILITY SET THE PSW AMODE INDICATOR AND IMPLYS THAT ADDRESSE
**  THAT YOU PROGRAM DEALS WITH ARE 24BIT OR 31 BIT.  REMEMBER, SOME
**  INSTRUCTIONS OPERATE IN EITHER AND LOAD OR STORE 24 BIT VALUES.
**
EXPL_SAV IHASAVER
**
TESTDCBD DCBD DSORG=PS,DEVD=DA
*
*
* DYNAMIC STORAGE THAT MUST RESIDE BELOW 16MB LINE DUE TO DCB & EXIT
* LIST RESTRICTIONS.  GET SEPARATE STORAGE FOR THIS.
DCB_WORKAREA DSECT
SYSPR_DCB DS   XL(SYSPREND) DCB LNG QS  ACTUAL QSAM DCB
* EACH ENTRY IN DCB EXIT LIST IS FOUR BYTES.
SY_EXL      DS    X         LAST ENTRY IN EXIT LIST AND FOR DCB OPENX
SY_EXLOPEN  DS    AL3       ADDRESS OF 24-BIT DCB OPEN EXIT ROUTINE
SYPENLIST DS    XL(LSPROPPL) LEN OPEN PARAMETER LIST
*
*
CLOLIST  DS    XL(LSPRCLPL) LEN CLOS PARAMETER LIST
* THE FOLLOWING IS EXECUTABLE CODE TO BRANCH ABOVE THE 16MB LINE.
         DS    0H
OPEN24   DS    XL(LENOPEN24)   DCB OPEN EXIT BELOW 16MB LINE
ADOPEN31 DS    A         ADDRESS OF DCB OPEN EXIT ABOVE THE LINE
LENAREA  EQU   *-DCB_WORKAREA
*
*** CHECK THIS OUT    NOT AVAILABLE PARMLIB(IEAPRD__)
*        COPY ASMMSP
*** CHECK THIS OUT
*
**
** REGISTER USAGE
**  R0  WORK FOR MANY INST
**  R1 PASS PARM ADDR AND WORK AND TRT
**  R2 WORK AND USED BY TRT
**  R3 BASE1
**  R4 R5 WORK AND USED FOR EVEN ODD
**  R6 R7 WORK AND USED FOR EVEN ODD
**  R8 WORK
**  R9 WORK AND USED FOR SR LINKAGE
**  R10 DCBPTR AND WORK
**  R11 USED FOR AUTO STORAGE
**  R12 BASE2
**  R13 SAVEAREA
**  R14 WORK
**  R15 PASS DATA IN REG TO SR AND WORK
**
MY_AREA  DSECT
         DS    F            AREA LENGTH
         DS    F            BWCHAIN
         DS    F            FWCHAIN
*
*MYSTK_S  STAKMAC  RTYPE=BUILD,USERLEN=4096
*
MYDYN_S  INITSTG USEREG=11
*
         COPY PASSPAR1
SAVE_CKSM DS    F
SAVE_MVST_R1 DS    F
SAVE_MVST_R2 DS    F
SAVE_CS      DS    F
CLST_IND DS    XL1
MYDEBUG  DS    CL1
TRY_TRT  DS    CL8
         ORG   MYDYN_S+4096-256
STOPARM  DS    256XL1
*
EXPLINST CSECT
EXPLINST RMODE ANY
EXPLINST AMODE 31
LBLPGM   INITMAC 3,12,EQU=R,ID=EXPLINST
AFTER_USING EQU *
         ST    R1,PARMAP
         XR    R1,R1
         ST    R13,SAVRD
*
MY_LOCTR LOCTR
MY_L_A   DC    C'LOCTR_A'
MY_L_B   DC    C'LOCTR_B'
ACON_PARM_LST DC A(PARM_LST)
EXPLINST LOCTR
         STORAGE OBTAIN,LENGTH=LENAREA,LOC=BELOW  GET DCB & ETC.
         ST    R1,PTR_DCB_WORKAREA
         LR    R10,R1
         USING DCB_WORKAREA,R10
*
         MVC   SYSPR_DCB,MODSPRDCB CREATE DCB BELOW THE LINE
         MVC   SYPENLIST,MODSPRPEN  BUILD OPEN PARAMETER LIST
*   OPEN USES NORMAL RSA CONVENTIONS
         OPEN  (SYSPR_DCB),MF=(E,SYPENLIST) LIST IS BELOW THE LINE
*        OPEN  (SYSPRINT,(OUTPUT))
         LA    R14,SYSPR_DCB
         USING IHADCB,R14
         MVC   H_SYSPRINT_LRECL,DCBLRECL
         DROP  R14
         DROP  R10
*
         BAS   R9,INITRTN
*        MHELP 64
         WRITMAC STRLIT='TEST THIS OUT FOR A MULTIPLE LINE ENTRY THAT WX
               ILL PRINT OUT TO MULTIPLE LINES AND I WOULD HOPE THAT ANX
               Y OUTPUT WOULD BE FORMATTED TO MULTIPLE LINES'
         BAS   R9,GETTIME
*
         MVC   MSGAREA(L'BEGNMSG),BEGNMSG
         MVC   MSGAREA+25(5),$DATE+3
         MVC   MSGAREA+31(6),$TIME+1
         BAS   R9,GETJOBN
         BAS   R9,WRTMSG
*
         L     R1,PARMAP
         LTR   R1,R1
         BZ    NOPARM
         L     R1,0(R1)
         ST    R1,PARMAP
         LH    R15,0(R1)
         LTR   R15,R15
         BZ    NOPARM
         STH   R15,PARMAL
         BCTR  R15,0
         LA    R1,2(R1)
         ST    R1,PARMA
         EX    R15,MVCPARM
         MVC   MSGAREA(L'PRMSG),PRMSG
         XR    R15,R15
         LH    R15,PARMAL
         BAS   R9,X2CX
         MVC   MSGAREA+14(3),EBCDCFLD+5
         BAS   R9,WRTMSG
         B     WRIT_PRMMSG
*
NOPARM   EQU   *
         WRITMAC STRLIT='NO PARM PROVIDED OR ZERO LENGTH'
WRIT_PRMMSG EQU *
         MVI   XC,X'08'
***
*** INSERT CODE HERE
         L     R15,ACON_PARM_LST
         USING PARM_LST,R15
         LA    R0,PRM_2
         MVC   MSGAREA(L'PRM_2),PRM_2
         DROP  R15
*
         XR    R15,R15
*     IF ICM,R15,B'0011',0(R1),NZ THEN
*        LTR  R15,R15
*     ELSE ,
*        LTR  R15,R15
*     ENDIF
*        LA    R15,3
*     SELECT  C,R15,EQ
*       WHEN (=F'1')
*        LA    R15,4
*       WHEN (=F'2',=F'3')
*        BCTR R15,0
*        BCTR R15,0
*       OTHRWISE
*        LA    R15,1
*       ENDSEL
*
*       DO WHILE=(C,R15,NE,=F'10'),UNTIL=(CLI,0(R15),EQ,C'0')
*        LA   R15,1(R15)
*       ENDDO
*
*  TRT AUTOMATICALLY USES R1 AND R2 SO SAVE IT IF YOU MUST
*  TAKES 1 BYTE AT A TIME FROM ADDR1 AND TAKES THE BYTE HEX VALUE
*   OF THE BYTE AS AN OFFSET (FROM 0) INTO THE TABLE POINTED TO BY
*   ADDR2. IF BYTE VALUE IN ADDR2 IS 00 THEN INCREMENT TO NEXT ADDR1.
*   DO THIS UNTIL LNG IS DONE, THEN RETURN CC0 TO IND NOTHING TRANSLATD
*  IF THE VAL IN BYTE OF ADDR2 IS NOT 00 THEN:
*   R1 IS SET TO THE RESPECTIVE ADDR FOR THE BYTE FROM ADDR1
*   R2 24-31 IS SET TO THE VALUE OF THE POINTED TO BYTE OF R2
*   IF MORE BYTES NEED TO BE CHECKED, SET CC1
*   IF NO MORE BYTES NEED TO BE CHECKED, SET CC2
         LA    R6,TRY_TRT
         XR    R1,R1
         XR    R2,R2
         LA    R15,TRT_TST
TST_TRT_EX TRT   0(8,6),0(R15)
DO_TRT_AGN EQU *
         BZ    DON_TRT_0
         BC    2,DON_TRT
         LR    R5,R1
         SR    R5,R6
         BCTR  R5,0
         LR    R6,R1
         LA    R6,1(R6)
         EX    R5,TST_TRT_EX
         B     DO_TRT_AGN
DON_TRT    EQU *
DON_TRT_0  EQU *
         LA    R8,AFTER_USING
         XR    R9,R9
         L     R9,L_EXPLPGM
         XR    R15,15
         XR    R1,R1
CC_THREE EQU  *
         LA    R1,1(R1)
*
         CKSM  R15,R8
         BC    8,CC_ZERO
         BC    1,CC_THREE
         BC    12,CC_ZERO
CC_ZERO  EQU  *
         ST    R15,SAVE_CKSM
         BAS   R9,X2CX
         MVC   MSGAREA+40(8),EBCDCFLD
         LR    R15,R1
         BAS   R9,X2CX
         MVC   MSGAREA+50(8),EBCDCFLD
         BAS   R9,WRTMSG
*
         L     R15,SAVE_CKSM
         BAS   R9,X2CX
         MVC   MSGAREA+40(8),EBCDCFLD
         BAS   R9,WRTMSG
*
         L     R15,SAVE_CKSM
         AHI   R15,X'1'
         BAS   R9,X2CX
         MVC   MSGAREA+40(8),EBCDCFLD
         BAS   R9,WRTMSG
         MVCIN MSGAREA(L'ENDMSG),ENDMSG+(L'ENDMSG-1)
         BAS   R9,WRTMSG
*
         LA    R4,MSGAREA+17
         LA    R15,STRB
*
         BAS   R9,X2CX
         MVC   MSGAREA+6(8),EBCDCFLD
         MVC   SAV_MSGAREA,MSGAREA
         MVC   MSGAREA(6),=C'1ASR15'
         BAS   R9,WRTMSG
*
         LR    R15,R4
         BAS   R9,X2CX
         MVC   MSGAREA+6(8),EBCDCFLD
         MVC   MSGAREA(6),=C'1ASR4 '
*
         LA    R15,STRB
         LA    R0,X'E0'
         XR    R1,R1
LOOP1A   EQU   *                   MVST USES 24-31 R0 AS DELIMITER CHAR
         C     R1,=F'5'            USES FIRST REG AS THE TARGET BUFF
         BH    BAD_LOOP1A          USES SECOND REG AS SOURCE BUFF
         LA    R1,1(R1)            MOVE UNTIL DELIMITER (NOTHING
         MVST  R4,R15              MOVED IF S0C1-0C4) FND AND MOVED
         BC    4,LOOP1A_FND_CHAR   CC4(1) INDICATES FOUND DELIMITER
         BC    10,BAD_LOOP1A       CC1(4) INDICATES CPU INTERUPTED,REGS
*                                  ARE UPDATED FOR REDRIVE OF INSTRUCTN
         ST    R4,SAVE_MVST_R1     SAVE INTERIM REGS JUST FOR HH
         ST    R15,SAVE_MVST_R2
         B     LOOP1A
BAD_LOOP1A EQU *
         MVC   MSGAREA(6),=C'LOOP1A'
         MVC   MSGAREA+17(L'BAD_LOOP1A_MSG),BAD_LOOP1A_MSG
         B     WRIT_LOOP1A_MSG
LOOP1A_FND_CHAR EQU *
         BAS   R9,X2CX
         MVC   MSGAREA+6(8),EBCDCFLD
         MVC   SAV_MSGAREA,MSGAREA
         MVC   MSGAREA(6),=C'1A R15'
         BAS   R9,WRTMSG
*
         LR    R15,R4
         BAS   R9,X2CX
         MVC   MSGAREA+6(8),EBCDCFLD
         MVC   MSGAREA(6),=C'1A R4 '
*
WRIT_LOOP1A_MSG EQU *
         BAS   R9,WRTMSG
*
         MVC   MSGAREA,SAV_MSGAREA
         LA    R15,STRC
         XR    R0,R0
         LA    R0,X'E0'
         XR    R1,R1
LOOP1B   EQU   *
         C     R1,=F'5'
         BH    BAD_LOOP1B
         LA    R1,1(R1)
         MVST  R4,R15
         BC    4,LOOP1B_FND_CHAR
         BC    10,BAD_LOOP1B       CC1(4) INDICATES CPU INTERUPTED,REGS
*                                  ARE UPDATED FOR REDRIVE OF INSTRUCTN
         ST    R4,SAVE_MVST_R1     SAVE INTERIM REGS JUST FOR HH
         ST    R15,SAVE_MVST_R2
         B     LOOP1B
BAD_LOOP1B EQU *
         MVC   MSGAREA(6),=C'LOOP1B'
         MVC   MSGAREA+7(L'BAD_LOOP1B_MSG),BAD_LOOP1B_MSG
         B     WRIT_LOOP1B_MSG
LOOP1B_FND_CHAR EQU *
         BAS   R9,X2CX
         MVC   MSGAREA+6(8),EBCDCFLD
         MVC   SAV_MSGAREA,MSGAREA
         MVC   MSGAREA(6),=C'1B R15'
         BAS   R9,WRTMSG
*
         LR    R15,R4
         BAS   R9,X2CX
         MVC   MSGAREA+6(8),EBCDCFLD
         MVC   MSGAREA(6),=C'1B R4 '
*
WRIT_LOOP1B_MSG EQU *
         BAS   R9,WRTMSG
*                         SRST SEARCH STRING USES R0 AND TWO OTHER REG
*                         BIT 24-31 OF R0 IS USED FOR DELIMTER CHAR
*                         FIRST REG SETS THE ENDING SEARCH ADDR
*                         SECOND REG SETS THE BEGIN SEARCH ADDR
         XR    R0,R0      WHEN R0 IS ALSO USED AS 'END SEARCH ADDR'
*                         IT CAN BE USED BY SETTING 0-23 TO ZEROES
*                         DELIMETER IN 24-31, AND KNOWING THAT THE
         LA    R0,X'E0'   THE STRING IS KNOWN TO HAVE THE DELIMETER
         LA    R5,STRB    BYTE;WE WOULD ALLOW ADDR WRAP TO ALLOW THE
*                         SEARCH TO FIND THE KNOWN CHAR
         XR   R1,R1
LOOP2A   EQU  *
         C     R1,=F'5'
         BH    BAD_LOOP2A
         LA    R1,1(R1)
         SRST R0,R5
         BC   2,LOOP2A_NF     WE ARRIVED AT END ADDR, NO CHG IN REGS
         BC   4,LOOP2A_FOUND  FIRST REG HAS ADDR OF FOUND CHAR, R2 NC
         BC   8,BAD_LOOP2A    THE CC IS NOT VALID
*        BC   1,LOOP2A        SECOND REG CHANGED FOR NEXT SEARCH ADDR
         ST    R0,SAVE_MVST_R1     SAVE INTERIM REGS JUST FOR HH
         ST    R5,SAVE_MVST_R2
         B    LOOP2A
BAD_LOOP2A EQU *
         MVC   MSGAREA(6),=C'LOOP2B'
         MVC   MSGAREA+7(L'BAD_LOOP2A_MSG),BAD_LOOP2A_MSG
         B     WRIT_LOOP2A_MSG
LOOP2A_NF  EQU *
         MVC   MSGAREA(6),=C'LOOP2B'
         MVC   MSGAREA+7(L'NF_LOOP2A_MSG),NF_LOOP2A_MSG
         B     WRIT_LOOP2A_MSG
MVCL2A   MVC   MSGAREA+15(0),STRB
*
LOOP2A_FOUND    EQU *
         LR    R15,R0
         BAS   R9,X2CX
         MVC   MSGAREA+6(8),EBCDCFLD
         MVC   MSGAREA(6),=C'2A R0'
         BAS   R9,WRTMSG
*
         LR    R15,R5
         BAS   R9,X2CX
         MVC   MSGAREA+6(8),EBCDCFLD
         MVC   MSGAREA(6),=C'2A R5 '
         BAS   R9,WRTMSG
*
         LA    R15,STRB
         SR    R0,R15
         BAS   R9,X2CX
         MVC   MSGAREA+6(8),EBCDCFLD
         MVC   MSGAREA(6),=C'2A LNG'
*
         BCTR  R0,0
         EX    R0,MVCL2B
*
WRIT_LOOP2A_MSG EQU *
         BAS   R9,WRTMSG
*
         MVC   MSGAREA(L'LOOP2B_START),LOOP2B_START
         BAS   R9,WRTMSG
         MVC   MSGAREA,SAV_MSGAREA
         BAS   R9,WRTMSG
         LA    R4,SAV_MSGAREA+(L'SAV_MSGAREA)
         LA    R5,SAV_MSGAREA
         LR    R15,R4
         BAS   R9,X2CX
         MVC   MSGAREA+6(8),EBCDCFLD
         MVC   MSGAREA(6),=C'2BSR4'
         BAS   R9,WRTMSG
*
         LR    R15,R5
         BAS   R9,X2CX
         MVC   MSGAREA+6(8),EBCDCFLD
         MVC   MSGAREA(6),=C'2BSR5 '
         BAS   R9,WRTMSG
*
         LA   R0,X'E0'
         XR   R1,R1
LOOP2B   EQU  *
         LA   R1,1(R1)
         C    R1,=F'5'
         BH   BAD_LOOP2B
         SRST R4,R5
         BC   4,LOOP2B_FOUND
         BC   2,LOOP2B_NF
         BC   8,BAD_LOOP2B    THE CC IS NOT VALID
*        BC   1,LOOP2B        SECOND REG CHANGED FOR NEXT SEARCH ADDR
         ST    R0,SAVE_MVST_R1     SAVE INTERIM REGS JUST FOR HH
         ST    R5,SAVE_MVST_R2
         B    LOOP2B
BAD_LOOP2B EQU *
         LR    R15,R1
         BAS   R9,X2CX
         MVC   MSGAREA+6(8),EBCDCFLD
         MVC   MSGAREA(6),=C'2B R1'
         MVC   MSGAREA+154(L'BAD_LOOP2B_MSG),BAD_LOOP2B_MSG
         B     WRIT_LOOP2B_MSG
LOOP2B_NF  EQU *
         LR    R15,R1
         BAS   R9,X2CX
         MVC   MSGAREA+6(8),EBCDCFLD
         MVC   MSGAREA(6),=C'2B R1'
         MVC   MSGAREA(L'NF_LOOP2B_MSG),NF_LOOP2B_MSG
         B     WRIT_LOOP2B_MSG
MVCL2B   MVC   MSGAREA+15(0),SAV_MSGAREA
LOOP2B_FOUND    EQU *
         LR    R15,R4
         BAS   R9,X2CX
         MVC   MSGAREA+6(8),EBCDCFLD
         MVC   MSGAREA(6),=C'2B R4'
         BAS   R9,WRTMSG
*
         LR    R15,R5
         BAS   R9,X2CX
         MVC   MSGAREA+6(8),EBCDCFLD
         MVC   MSGAREA(6),=C'2B R5 '
         BAS   R9,WRTMSG
*
         LA    R15,SAV_MSGAREA
         SR    R4,R15
         LR    R15,R4
         BAS   R9,X2CX
         MVC   MSGAREA+6(8),EBCDCFLD
         MVC   MSGAREA(6),=C'2B LNG'
*
         BCTR  R4,0
         EX    R4,MVCL2B
*
WRIT_LOOP2B_MSG EQU *
         BAS   R9,WRTMSG
*
         LR   R0,R0
         XR   R15,R15
         AHI  R15,X'7FF0'
         BAS   R9,X2CX
         MVC   MSGAREA+6(8),EBCDCFLD
         MVC   MSGAREA(6),=C'AHI 15'
         BAS   R9,WRTMSG
*
         BASR R15,0         SIMILAR TO BALR.  R2 IS 0 SO NO BRANCH
         BSM  R15,0         USED TO SET NEW ADDR MODE. SEE JMP24 MAC
*AN INCREMENT IS ADDED TO THE FIRST OPERAND, THE SUM IS COMPARED WITH A
*COMPARE  VALUE.  THE RESULT OF THE COMP DETERMINES WHETHER BRANCHING
*OCCURS.  SUBSEQUENTLY, THE SUM IS PLACED AT  THE  FIRST-OPERAND  LOCN.
*THE  SECOND-OPERAND  ADDRESS  IS  USED AS A BRANCH ADDRESS.  R3 FIELD
*DESIGNATES REGISTERS CONTAINING THE INCREMENT AND THE COMPARE VALUE.
*FOR BRANCH ON INDEX HIGH, WHEN THE SUM IS HIGH, THE INSTRUCTION ADDR
* IN THE CURRENT PSW IS REPLACED BY THE BRANCH ADDRESS.  WHEN THE
* SUM IS LOW OR EQUAL, NORMAL INSTRUCTION SEQUENCING PROCEEDS WITH THE
* UPDATED INSTRUCTION ADDRESS.
*FOR BRANCH ON INDEX LOW OR EQUAL, WHEN  THE  SUM  IS  LOW  OR  EQUAL,
* THE INSTRUCTION  ADDRESS IN THE CURRENT PSW IS REPLACED BY THE
* BRANCH ADDRESS. WHEN THE SUM IS HIGH, NORMAL  INSTRUCTION  SEQUENCING
* PROCEEDS  WITH  THE UPDATED INSTRUCTION ADDRESS.
*WHEN THE R3 FIELD IS EVEN, IT DESIGNATES A PAIR OF REGISTERS;
* THE CONTENTS OF  THE  EVEN  AND ODD REGISTERS OF THE PAIR ARE USED
* AS THE INCREMENT AND THE COMPARE VALUE, RESPECTIVELY.
* WHEN THE R3 FIELD IS ODD, IT  DESIGNATES A  SINGLE  REGISTER,  THE
*CONTENTS OF WHICH ARE USED AS BOTH THE INCREMENT AND THE COMPARE VALUE
         XR   R1,R1    R1 WILL HOLD THE SUM
         LA   R4,1     EVEN - INCREMENT
         LA   R5,5     ODD  - COMPARE VALUE
         WRITMAC STRLIT='TESTING THE BXLE INSTRUCTION. 5 TIMES??'
B_WHEN_LT_OR_EQ EQU *
         LR   R15,R1   I WANT TO PRINT THESE EVERY LOOP THROUGH
         BAS   R9,X2CX
         MVC   MSGAREA+8(8),EBCDCFLD
         LR   R15,R4
         BAS   R9,X2CX
         MVC   MSGAREA+28(8),EBCDCFLD
         MVC   MSGAREA(7),=C'BXLE R1'
         MVC   MSGAREA+25(2),=C'R4'
         BAS   R9,WRTMSG
         BXLE R1,R4,B_WHEN_LT_OR_EQ    R1 BY R2 AND COMPARE W/ VALUE
*                                      IN R2+1. B LE TO ADDR IN
         WRITMAC STRLIT='FINISHED TESTING THE BXLE INSTRUCTION.'
         LR   R15,R1
         BAS   R9,X2CX
         MVC   MSGAREA+8(8),EBCDCFLD
         LR   R15,R4
         BAS   R9,X2CX
         MVC   MSGAREA+28(8),EBCDCFLD
         MVC   MSGAREA(7),=C'BXLE R1'
         MVC   MSGAREA+25(2),=C'R4'
         BAS   R9,WRTMSG
*        BXH  R1,R2,B_HI    R2+1 WHEN R2 IS EVEN OR (SAME) R2 IF ODD
* THE  FIRST AND SECOND OPERANDS ARE COMPARED.  IF EQUAL, THE THIRD
* OPERAND IS STORED AT THE SECOND-OPERAND LOCATION.   IF UNEQUAL
* THE SECOND OPERAND IS LOADED AT THE FIRST-OPERAND LOCATION. RESULT
* THE COMPARISON IS INDICATED IN THE CONDITION CODE.
         WRITMAC STRLIT='BEGIN COMPARE AND SWAP'
*
*
         LA   R4,255          FIRST REG IS OPERAND 1
         LA   R5,254          SECOND REG IS OPERAND 3
         MVC  SAVE_CS,F254    3RD FIELD IS OPERAND 2
         CS   R4,R5,SAVE_CS   OPERANDS 1 AND 2 COMPARED
         BZ   R4_R5_EQ        CC 1 OR MASK 8, COMPARE EQ SO OPERAND 3
*                             IS STORED AT THE SECOND
         BNZ  R4_R5_NE        CC 2 OR MASK 4, COMPARE NE SO OPERAND 2
*                             IS LOADED INTO THE FIRST
R4_R5_NE EQU   *
         WRITMAC STRLIT='      COMPARE AND SWAP FOUND NOT EQUAL'
         B     CNS_REGS
R4_R5_EQ EQU   *
         WRITMAC STRLIT='      COMPARE AND SWAP FOUND EQUAL'
CNS_REGS EQU   *
         MVC   MSGAREA(6),=C'CNS R1'
         LR   R15,R4
         BAS   R9,X2CX
         MVC   MSGAREA+6(8),EBCDCFLD
         MVC   MSGAREA+20(6),=C'CNS R2'
         LR   R15,R5
         BAS   R9,X2CX
         MVC   MSGAREA+26(8),EBCDCFLD
*
         L     R15,SAVE_CS
         BAS   R9,X2CX
         MVC   MSGAREA+36(8),EBCDCFLD
         BAS   R9,WRTMSG
*
         L    R5,F16
         CS   R4,R5,SAVE_CS THIS TIME R1 EQ F254 SO R2 STORED F16
         BZ   R4_R5_EQ2
         BNZ  R4_R5_NE2
R4_R5_NE2 EQU   *
         WRITMAC STRLIT='      2ND COMPARE AND SWAP FOUND NOT EQUAL'
         B     CNS_REGS2
R4_R5_EQ2 EQU   *
         WRITMAC STRLIT='      2ND COMPARE AND SWAP FOUND EQUAL'
CNS_REGS2 EQU   *
         MVC   MSGAREA(6),=C'CNS R1 '
         LR   R15,R4
         BAS   R9,X2CX
         MVC   MSGAREA+6(8),EBCDCFLD
         MVC   MSGAREA+20(6),=C'CNS R2'
*
         LR   R15,R5
         BAS   R9,X2CX
         MVC   MSGAREA+26(8),EBCDCFLD
*
         L     R15,SAVE_CS
         BAS   R9,X2CX
         MVC   MSGAREA+36(8),EBCDCFLD
         BAS   R9,WRTMSG
*
*        CDS  R1,R2,F254    REGS ARE EVEN-ODD PAIR
         CHI  R4,X'010'     COMPAR HW IMMEDIATE
         BE   CHI_EQ
         WRITMAC STRLIT='COMPARE HALFWORD IMED IS FALSE'
         B    CHI_FIN
CHI_EQ   EQU  *
         WRITMAC STRLIT='COMPARE HALFWORD IMED IS TRUE'
CHI_FIN  EQU  *
         ICM  R1,B'1111',=X'F1F2F3F4'
         BC   8,ICM_ZEROES
         WRITMAC STRLIT='ICM WAS NOT ZEROES'
         B    ICM_DONE
ICM_ZEROES EQU *
         WRITMAC STRLIT='ICM WAS ZEROES'
ICM_DONE   EQU *
         CLM  R1,B'1010',=X'F1F2'   COM LOGICAL UNDER MASK NE
         BC   6,CLM_NOT_EQ
         BNE  CLM_NOT_EQ
         WRITMAC STRLIT='COMPARE LOGICAL CHAR UNDER MASK-EQUAL???'
         B    CLCM_NEXT
CLM_NOT_EQ EQU  *
         WRITMAC STRLIT='COMPARE LOGICAL CHAR UNDER MASK-NOT EQUAL!!!'
CLCM_NEXT EQU   *
         CLM  R1,B'1010',=X'F1F3'   EQ
         BC   6,CLM_NOT_EQ1
         BNE  CLM_NOT_EQ1
         WRITMAC STRLIT='COMPARE LOGICAL CHAR UNDER MASK-EQUAL!!!'
         B    CLCM_NEXT1
CLM_NOT_EQ1 EQU  *
         WRITMAC STRLIT='COMPARE LOGICAL CHAR UNDER MASK-NOT EQUAL???'
CLCM_NEXT1 EQU   *
*
*        MVI  STR_HAYSTK+255,X'00'  COM LOGICAL STRINGS
*        MVI  STR_NEEDLE+1,X'00'
*        XR   R0,R0
*        LA   R1,STR_HAYSTK
         WRITMAC STRLIT='CLST TEST ONE, LOOKING FOR BACK SLASH'
         B     ARND_INIT_2ND_PASS
INIT_2ND_PASS  EQU  *
         WRITMAC STRLIT='CLST TEST ONE, LOOKING FOR NULL VALUE'
         MVI  CLST_IND,X'00'
ARND_INIT_2ND_PASS  EQU  *
         LA   R4,CLST_1
         LA   R5,CLST_2
         XR   R0,R0
         IC   R0,CLST_IND    LOOKING FOR SOME ENDING DELIMETER'\'
         LR    R15,R4
         BAS   R9,X2CX
         MVC   MSGAREA+6(8),EBCDCFLD
*
         LR    R15,R5
         BAS   R9,X2CX
         MVC   MSGAREA+16(8),EBCDCFLD
         BAS   R9,WRTMSG
         XR    R1,R1
*
CLST_LOOP_INTR EQU *
         LA   R1,1(R1)
         CLST R4,R5
         BZ   F_CLST_N_CC0   CC 0 OR BC 8
         BL   E_CLST_N_CC1   CC 1 OR BC 4
         BH   E_CLST_H_CC2   CC 2 OR BC 2
         BO   CLST_LOOP_INTR CC 3 OR BC 1
* CONDITION CODES
* 0 IS THE 8 BIT IN MASK  BC 8 OR BZ OR BE
* 1 IS THE 4 BIT IN MASK  BC 4 OR BL(OW) BM(INUS) BM(IXED)
* 2        2              BC 2 OR BH(IGH) BP(LUS)
* 3        1              BC 1 OR BO(VERFLOW) BO(NES)
*                         BC 7 BNE  BC 13 BNH  BC 11 BNL
*                         BC 7 BNZ  BC 14 BNO  BC 11 BNM(IXED)
*                         BC 7 BNZ  BC 14 BNO(VERFLOW)
*                         BC 13 BNP(LUS) BC 11 BNM(INUS)
*
F_CLST_N_CC0 EQU *
         WRITMAC STRLIT='CLST ENDED WITH STING VALUES EQUAL.'
         B    CLST_LOOP2
E_CLST_N_CC1 EQU *
         WRITMAC STRLIT='CLST ENDED WITH STING 1 VALUE LOWER.'
         B    CLST_LOOP2
E_CLST_H_CC2 EQU *
         WRITMAC STRLIT='CLST ENDED WITH STING 1 VALUE HIGHER.'
         B    CLST_LOOP2
CLST_LOOP2  EQU *
         LR    R15,R4
         BAS   R9,X2CX
         MVC   MSGAREA+6(8),EBCDCFLD
*
         LR    R15,R5
         BAS   R9,X2CX
         MVC   MSGAREA+16(8),EBCDCFLD
         LR    R15,R1
         BAS   R9,X2CX
         MVC   MSGAREA+26(13),=C'COUNT CYCLES '
         MVC   MSGAREA+40(8),EBCDCFLD
         BAS   R9,WRTMSG
*
         CLI  CLST_IND,X'E0'
         BE   INIT_2ND_PASS
*
         WRITMAC STRLIT='NOW TESTING CUSE COMP UNTIL STRING EQUAL'
*     COMPARE UNTIL STRING EQUAL REQUIRES
*      THIS INSTRUCTION COMPARES SUBSTRINGS BASED ON LENGTH OF R0
*      24-31(1-255). IT STARTS COMPARING EACH STRING AT OFF 0 AND
*      PROCEEDS L TO R COMPARING BYTE BY BYTE FOR LENGTH IN R0.
*      AS EACH BYTE IS COMPARED, IF UNEQUAL THEN DECREMENT LENGTHS
*      AND INCREMENT THE PTRS. CONTINUE TO SEARCH FOR MATCH STRING.
*      WHEN ALL CHAR MATCH FOR SPECIFIED R0 LENGTH, RET CC0.
*      IF NOT, CONTINUE TO CYCLE DOWN THE STRINGS, COMPARING SUB
*      STRINGS AT SAME OFFSET FROM 0. WHEN SHORTEST IS EXHAUSETED,
*      LEN IN REG IS 0, THEN USE PAD BYTE TO CONTINUE TESTING UNTIL
*      END OF LONGEST.  WHEN NO EXACT MATCH (INCL PADDED STINGS) IS
*      FOUND AND ARRIVE AT END OF LONGEST, IF LAST BYTE COMPARE WAS
*      A MATCH, RETURN CC1, ELSE RETURN CC2. LEN IN REG OF LONGEST WILL
*      HAVE NUMBER OF FINAL MATCHED SUBSTRINGS BEFORE CC1.
*     REQUIRES
*     TWO PAIRS OF EVEN-ODD REG
*     BITS 24-31 OF R0 TO DESIGNATE THE SEARCH FOR SUBSTRING LENGTH
*     OPERAND 1 IS AN EVEN REG WITH ADDR OF THE SEARCH FOR STRING
*       IMPLIED OPERAND 1 ODD REG WITH LNG OF THE SEARCH FOR STRING
*     OPERAND 2 IS AN EVEN REG WITH ADDR OF THE SEARCHABLE STRING
*       IMPLIED OPERAND 2 ODD REG WITH LNG OF THE SEARCHABLE STRING
*     IMPLIED R0 BITS 24-31 ARE USED TO DETERMINE THE ACTUAL SEARCH
*       FOR STRING LENGTH
         LA   R4,CLST_2
         LA   R5,L'CLST_2
         LA   R6,STR_UNEQ
         LA   R7,L'STR_UNEQ
         LA   R0,X'06'        LOOK FOR 'ZZST FOR' FIRST MATCH
*
         LR    R15,R4
         BAS   R9,X2CX
         MVC   MSGAREA+6(8),EBCDCFLD
*
         LR    R15,R5
         BAS   R9,X2CX
         MVC   MSGAREA+16(8),EBCDCFLD
         BAS   R9,WRTMSG
         LR    R15,R6
         BAS   R9,X2CX
         MVC   MSGAREA+6(8),EBCDCFLD
*
         LR    R15,R7
         BAS   R9,X2CX
         MVC   MSGAREA+16(8),EBCDCFLD
         LR    R15,R0
         BAS   R9,X2CX
         MVC   MSGAREA+26(8),=C'REG0 IS '
         MVC   MSGAREA+36(8),EBCDCFLD
         BAS   R9,WRTMSG
         XR    R2,R2
*
CUSE_STR_LOOP_INTR EQU *
         LA   R2,1(R2)
         C    R2,F16
         BH   CUSE_ERROR
         CUSE R4,R6
         BZ   F_CUSE_CC0   CC 0 OR BC 8
         BL   E_CUSE_NF_END_EQ_CC1   CC 1 OR BC 4
         BH   E_CUSE_NF_END_NE_CC2   CC 2 OR BC 2
         BO   CUSE_STR_LOOP_INTR CC 3 OR BC 1
*
F_CUSE_CC0 EQU *
         WRITMAC STRLIT='CUSE FOUND EQUAL SUBSTRINGS AT...'
         B    WRIT_CUSE_REGS
E_CUSE_NF_END_EQ_CC1 EQU *
         WRITMAC STRLIT='CUSE FOUND EQUAL AT END OF LONGER STRING...'
         B    WRIT_CUSE_REGS
E_CUSE_NF_END_NE_CC2 EQU *
         WRITMAC STRLIT='CUSE FOUND UNEQUAL AT END OF LONGER STRING...'
         B    WRIT_CUSE_REGS
CUSE_ERROR  EQU *
         WRITMAC STRLIT='SIXTEEN ITERATIONS...SO WHAT GIVES????'
         B    WRIT_CUSE_REGS
*
WRIT_CUSE_REGS EQU *
         LR    R15,R4
         BAS   R9,X2CX
         MVC   MSGAREA+6(8),EBCDCFLD
*
         LR    R15,R5
         BAS   R9,X2CX
         MVC   MSGAREA+16(8),EBCDCFLD
         BAS   R9,WRTMSG
*
         LTR   R1,R5
         BNP   NO_CUSE_SUBSTRING_ONE
         LR    R15,R4
         BCTR  R1,0
         EX    R1,MVC2MSG
         BAS   R9,WRTMSG
NO_CUSE_SUBSTRING_ONE EQU *
         LR    R15,R6
         BAS   R9,X2CX
         MVC   MSGAREA+6(8),EBCDCFLD
*
         LR    R15,R7
         BAS   R9,X2CX
         MVC   MSGAREA+16(8),EBCDCFLD
         LR    R15,R2
         BAS   R9,X2CX
         MVC   MSGAREA+26(13),=C'COUNT CYCLES '
         MVC   MSGAREA+40(8),EBCDCFLD
         BAS   R9,WRTMSG
*
         LTR   R9,R7
         BNP   NO_CUSE_SUBSTRING_TWO
         LR    R15,R6
         BCTR  R9,0
         EX    R9,MVC2MSG
         BAS   R9,WRTMSG
NO_CUSE_SUBSTRING_TWO EQU *
*
***
         L     R15,ACON_PARM_LST
         USING PARM_LST,R15
         LA    R0,PRM_2
         MVC   MSGAREA(L'PRM_2),PRM_2
         DROP  R15
***
         B     DOCLOSE
*
*
NOSTG    EQU   *
EXITRC8  EQU   *
         XR    R15,R15
         LA    R15,8
         B     BYL15
*
*
OPEN31   EQU   *         ENTRY POINT OF DCB OPEN EXIT ABOVE THE LINE
         BSM   0,R14     SWITCH TO 24-BIT MODE AND RETURN TO OPEN
*
DOCLOSE  EQU   *
         MVC   MSGAREA(L'ENDMSG),ENDMSG
         BAS   R9,WRTMSG
         L     R10,PTR_DCB_WORKAREA
         USING DCB_WORKAREA,R10
         CLOSE (SYSPR_DCB),MF=(E,CLOLIST)
         IC    R15,XC
BYL15    EQU   *
         RTNMAC  RC=(15)
NORTNCD  EQU   *
         RTNMAC
*
INITRTN  EQU   *
* PLACE ANY INITIALIZATION PROCESSING HERE
         MVC   WRTSTR_LLNG,H_SYSPRINT_LRECL
         MVI   CLST_IND,X'E0'
         MVI   MSGAREA1,X'40'
         MVC   MSGAREA,MSGAREA1
         MVC   SAV_MSGAREA,MSGAREA
         MVI   XC,X'00'
         MVC   TRY_TRT,=X'0001020300000100'
         XC    PTR_STG_STAKB,PTR_STG_STAKB
         XC    PTR_STG_STAKA,PTR_STG_STAKA
         BR    R9
*
***
MVCPARM  MVC   MSGAREA+18(0),0(R1)
MVC2MSG  MVC   MSGAREA(0),0(R10)
WRTSTR   EQU  *
*   REG15 SET TO BEGIN ADDRESS OF A NULL TERMINATED STRING
*   REQUIRES A FW AUTOSTORAGE SAVE AREA FOR R9  WRTSTR_SAVR9
*   REQUIRES A FW AUTOSTORAGE HW VALUE FOR O/P LINE LENGTH 1-255
*                                               WRTSTR_LLNG
*
         STM  R8,R10,WRTSTR_SAVR8_10
         LR   R9,R15
         XR   R0,R0
SRST_AGN SRST R0,R9
         BC   4,WRTSTR_FND
         BC   1,SRST_AGN      SECOND REG CHANGED FOR NEXT SEARCH ADDR
***
BAD_WRTSTR EQU *
         XR    R15,R15
         BCTR  R15,0
         B     WRTSTR_RET
WRTSTR_FND EQU *
         SR    R0,R15         R0 NOW HAVE NULL POS. DERIVE LNG
         BNP   BAD_WRTSTR
         LR    R10,R15        SAVE START
         LR    R8,R0          SAVE DERIVED LENGTH
WRTSTR_TOL EQU *
         CH    R8,WRTSTR_LLNG
         BNH   WRTSTR_DO_EX
         LH    R9,WRTSTR_LLNG
         BCTR  R9,0
         EX    R9,MVC2MSG
         BAS   R9,WRTMSG
         AH    R10,WRTSTR_LLNG
         SH    R8,WRTSTR_LLNG
         B     WRTSTR_TOL
*
WRTSTR_DO_EX   EQU  *
         LTR   R9,R8
         BNP   WRTSTR_FIN
         BCTR  R9,0
         EX    R9,MVC2MSG
         BAS   R9,WRTMSG
WRTSTR_FIN EQU *
         XR    R15,R15
WRTSTR_RET EQU *
         LM    R8,R10,WRTSTR_SAVR8_10
         BR    R9
*
WRTMSG   EQU   *
         STM   R10,R1,WRTMSG_SAVR10_1
         L     R10,PTR_DCB_WORKAREA
         USING DCB_WORKAREA,R10
         LA    R1,SYSPR_DCB
         PUT   (1),MSGAREA
         DROP  R10
         MVC   MSGAREA,MSGAREA1
         LM    R10,R1,WRTMSG_SAVR10_1
         BR    R9
***
GETJOBN  EQU   *
         ST    R9,SAVR9
         LA    R9,TIOTADR
         EXTRACT (R9),'S',FIELDS=TIOT
         L     R1,TIOTADR
         MVC   JOBNAME,0(R1)
         L     R9,SAVR9
         BR    R9
*** GET THE SYSDATE SYSTIME IN ORDER TO CREATE A UNIQUE QUALIFIER
GETTIME  EQU   *
         XR    R0,R0
         XR    R1,R1
         TIME
         ST    R0,$TIMEB
         ST    R0,$DBLWD+4
         OI    $DBLWD+7,X'0F'
         UNPK  $TIME,$DBLWD
         XC    $DBLWD,$DBLWD
         ST    R1,$DATEB
         ST    R1,$DBLWD+4
         OI    $DBLWD+7,X'0F'
         UNPK  $DATE,$DBLWD
         XC    MYDEBUG,MYDEBUG
         BR    R9
***
B2C      EQU   *
         CVD   R15,DWORD
         UNPK  HLDSTR,DWORD+4(4)
         OI    HLDSTR+6,X'F0'
         XR    R15,R15
         BR    R9
***
* THIS IS THE ERROR ROUTINE TO FORMAT THE ERROR CODE RETURNED FROM THE
* SVC IF THERE IS AN ERROR ON ALLOCATION.
*
X2CX     EQU   *
FORMERR  EQU   *
         STM   R4,R9,X2CX49
         XR    R6,R6
         LA    R6,8
         ST    R15,HEXFIELD
         LA    R4,HEXFIELD
         LA    R5,EBCDCFLD
*
CONVERT  EQU   *
         SLR   R8,R8
         IC    R8,0(R4)
         SRDL  R8,4
         STC   R8,0(R5)
         LA    R5,1(R5)
         SLR   R8,R8
         SLDL  R8,4
         STC   R8,0(R5)
         LA    R5,1(R5)
         LA    R4,1(R4)
         BCT   R6,CONVERT
*
         TR    EBCDCFLD(8),ERRTRAN
         LM    R4,R9,X2CX49
         BR    R9
         LTORG
DONEEXT  EQU   *
NOEXT    EQU   *
*
         RTNMAC
*
*        PROGRAM CONSTANTS
*
*
*
*
         EJECT
$MODID   DC    CL16'&SYSDATE.-&SYSTIME'
* NEW CONSTANTS
BIN_CONST DC   FL8'95'
BIN_CONST_FD DC   FD'95'
ADR_CONST_8  DC   AD(95)
*UNICODE_CONST DC  CU1(A)
ZEROES   DC    2F'0'
FMIN1    DC    F'-1'
F254     DC    F'254'
BLANKS   DC    CL8'                '
F16      DC    F'16'
         ORG   F16
         DS    H
HW16     DS    H
F80      DC    F'80'
         ORG   F80
         DS    H
HW80     DS    H
Z123     DC    Z'123'
*                0....5....1....5....2....5....3....5....4....5....5
MY_LOCTR LOCTR
MY_L_C   DC    C'LOCTR_C'
MY_L_D   DC    C'LOCTR_D'
BEGNMSG  DC    C'EXPLDYNA PROGM BEGIN AT'
NOPRMSG  DC    C'NO PARM PROVIDED OR ZERO LENGTH'
PRMSG    DC    C'PARM PROVIDED>'
*CNSMSG   DC    C'BEGIN COMPARE AND SWAP'
*CNSMSG_EQ  DC    C'      COMPARE AND SWAP FOUND EQUAL'
*CNSMSG_NE  DC    C'      COMPARE AND SWAP FOUND NOT EQUAL'
LOOP2B_START   DC    C'LOOP2B START: SAV_MSGAREA'
BAD_LOOP1A_MSG DC    C'MVST ERROR FOR LOOP 1A'
BAD_LOOP1B_MSG DC    C'MVST ERROR FOR LOOP 1B'
BAD_LOOP2A_MSG DC    C'SRST ERROR FOR LOOP 2A'
NF_LOOP2A_MSG  DC    C'SRST NF FOR LOOP 2A'
BAD_LOOP2B_MSG DC    C'SRST ERROR FOR LOOP 2B'
NF_LOOP2B_MSG  DC    C'SRST NF FOR LOOP 2B'
CLST_1   DC    C'TEST FOR CLST COMP LOGICAL STRING\ NOT EQUAL HERE'
         DC    XL1'00'   USED FOR CLST DELIMITER
CLST_2   DC    C'TEST FOR CLST COMP LOGICAL STRING\ UN-EQUIL UN-EQUAL'
         DC    XL1'00'   USED FOR CLST DELIMITER
ENDMSG   DC    C'PROCESSING FINISHED NORMALLY'
L_ENDMSG EQU   *-ENDMSG
ERRTRAN  DC    X'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
TRT_TST  DC    X'00000300F4'
***
INV_ENDMSG DS  CL(L'ENDMSG)
STR_HAYSTK DC  CL256' '
           DC  CL256' '
STRA       DC  CL256' '
STRB       DC  CL80'THIS IS ANOTHER \ STRINGB'
E_STRB     DC  XL1'00'
STRC       DC  CL80'EXAMPLE\'
STRTRM     DC  CL1'\'
STR_NEEDLE DC  CL10'1'
NULL_STR   DC  XL1'00'
STR_UNEQ   DC  C'ZZST FOR'
***
L_EXPLPGM DC   A(*-AFTER_USING)
***
L_EXPLINST DC A(*-EXPLINST)
MODSPRPEN OPEN (,OUTPUT),MF=L,MODE=31 MODEL OPEN PARAMETER LIST
LSPROPPL EQU   *-MODSPRPEN
*
MODSPRCLO CLOSE (),MF=L,MODE=31    MODEL OPEN PARAMETER LIST
LSPRCLPL EQU   *-MODSPRCLO
*
* THE FOLLOWING IS THE MODEL FOR THE DCB OPEN EXIT ROUTINE ENTRY POINT
* WE COPY THIS CODE TO THE WORK AREA, WHICH IS BELOW THE LINE.  THE
* BSM SETS THE CURRENT ADDRESSING MODE (24) IN BIT 0 OF R14 WITHOUT
* CHANGING ANYTHING ELSE IN R14.  IT ALSO SWITCHES TO 31-BIT DUE TO
* BIT 0 IN R15 AND BRANCHES TO THE ADDRESS IN R15.
MODOPEN24 L    R15,ADOPEN31-OPEN24(,R15) ENTRY PT TO DCB OPEN EXIT RTN
         BSM   R14,R15        SAVE AMODE, SWITCH TO 31-BIT AND BRANCH
LENOPEN24 EQU  *-MODOPEN24
*
SYSPR_BEGINMSG DC   C'THIS IS A TEST FOR QSAM ABOVE TO SYSPRINT'
*
* DCB MODEL FOR SYSPRINT, WHICH IS ABOVE THE LINE.
MODSPRDCB DCB  DSORG=PS,DDNAME=SYSPRINT,MACRF=(PM)
SYSPREND EQU   *-MODSPRDCB
*
*SYSUT1   DCB   MACRF=R,BLKSIZE=96,LRECL=96,KEYLEN=44,RECFM=F,
*              DSORG=PS,EXLST=JFCBPTR,DDNAME=SYSUT1,EODAD=DONERD
*YSUT1   DCB   MACRF=PM,LRECL=80,RECFM=FB,                            X
*              DSORG=PS,EXLST=JFCBPTR,DDNAME=SYSUT1
***
         LTORG
*
PARM_LST EQU   *
PRM_1    DC    C'TEST1'
PRM_2    DC    C'TEST2'
         END
###END EXPLINST
$$$BEG INITMAC
         MACRO
&LABEL   INITMAC &EQU=,&ID=,&SA=
.* INITMAC IS MACRO TO INITIALIZE ASM PGM
.*  SPECIFICALLY:
.*   ACCEPTS 1 TO 15 BASE REGS AS POS PARMS
.*     REG 0 INVALID
.*     REG13 OK IF IT IS THE FIRST SPECIFIED
.*   IF REG13 IS USED, THEN YOU CAN USE SA= KW TO POINT PGM USER SA
.*   USE OF REG13 CAUSES NONREENT.
.*   ELSE REG13 IS USED AS THE DEFAULT SAVEAREA
.*   R0 TO R15 EQU GENERATED.  OVERRIDE R WITH 1 TO 6 CHAR PREFIX
.*    BY SPECIFING EQU=______ KW.
         GBLB  &SAIMAC
         GBLB  &SKTMAC
         GBLC  &GLABEL
         GBLC  &GUSEREG
         LCLC  &LCSEC
&LCSEC   SETC  '&SYSECT'
         AIF   (T'&GLABEL EQ 'O').NOSTG
         MNOTE *,'DYNAMIC STORAGE '
&GLABEL  DSECT
         AIF   (&SKTMAC NE 1).NOSTAK
*
         COPY STAKANCH
.NOSTAK   ANOP
INITSTG_END EQU *-&GLABEL
&LCSEC   CSECT
IMACSTG  EQU   INITSTG_END
         AGO   .DETGML
.NOSTG   ANOP
         MNOTE *,'GLOBAL GLABEL WAS NOT PROVIDED. NO LOCAL STORAGE.'
IMACSTG  EQU   0
.DETGML  ANOP
         LCLA  &POS,&TOTOPD,&REG13SW
         LCLC  &SVAR,&LBL,&PRFX
         LCLC  &REGS,&REG1,&REG2
&SAIMAC  SETB  0
         AIF   (T'&LABEL NE 'O').B1
         MNOTE *,'NO LABEL SPECIFIED'
         AGO   .CHKEQU
.B1      AIF   (K'&LABEL LE 8).LABOK
         MNOTE 'LABEL EXCEEDS 8 CHARACTERS-LEFT MOST 8 USED'
.LABOK   ANOP
&LBL     SETC  '&LABEL'(1,8)
.CHKEQU  AIF   (T'&EQU EQ 'O').B8
         AIF   (K'&EQU LE 6).EQUOK
         MNOTE 'REG PREFIX GREATER THAN 6-USING LEFT MOST 6'
.EQUOK   ANOP
&PRFX    SETC  '&EQU'(1,6)
.B8      ANOP
&SVAR    SETC  'SVAR'.'&SYSNDX'
&TOTOPD  SETA  N'&SYSLIST
         AIF   (&TOTOPD EQ 0).NOREG
         AIF   (&TOTOPD LE 15).PROCEED
         MNOTE 0,'MORE THAN 15 BASE REGS SPECIFIED-SURPLUS IGNORED'
&TOTOPD  SETA  15
.PROCEED ANOP
         AIF   (T'&EQU EQ 'O').EQUTBLO
         AGO   .EQUTBL
.B2      ANOP
.*       AIF   (T'&ID NE 'O').SETID
         AGO   .SETID
.B3      ANOP
.ULOOP   ANOP
&POS     SETA  &POS+1
         AIF   (&POS GT &TOTOPD).USING
         AIF   ('&SYSLIST(&POS)' EQ '13').REG13
         AIF   ('&SYSLIST(&POS)' EQ '0').INVREG
.B4      ANOP
&REGS    SETC  '&REGS'.','.'&PRFX'.'&SYSLIST(&POS)'
         AGO   .ULOOP
.USING   ANOP
         AIF   (&REG13SW EQ 1).USING13
&LBL     STM   &PRFX.14,&PRFX.12,12(&PRFX.13)
         BALR  &PRFX.&SYSLIST(1),0
         USING *&REGS
.B5      ANOP
&POS     SETA  1
         AIF   (&TOTOPD EQ 1).REST
.NXLOAD  ANOP
&POS     SETA  &POS+1
         AIF   (&POS GT &TOTOPD).REST
&REG1    SETC  '&SYSLIST(&POS-1)'
&REG2    SETC  '&SYSLIST(&POS)'
         LA    &PRFX.&REG2,2048
         LA    &PRFX.&REG2,2048(&PRFX.&REG1,&PRFX.&REG2)
         AGO   .NXLOAD
.REG13   AIF   (&POS GT 1).INVREG
&REG13SW SETA  1
         AGO   .B4
.USING13 ANOP
         AIF   (T'&SA EQ 'O').B6
&SVAR    SETC  '&SA'(1,8)
.B6      ANOP
&LBL     STM   &PRFX.14,&PRFX.12,12(&PRFX.13)
         LR    &PRFX.2,&PRFX.13
         BALR  &PRFX.12,0
         BAL   &PRFX.13,76(0,&PRFX.12)
&SVAR    DC    18F'0'
         USING &SVAR&REGS
         AGO   .B5
.REST    AIF   (&REG13SW EQ 1).CKGUSE
         GETMAIN R,LV=84,SP=1
         LTR   &PRFX.15,&PRFX.15
         BZ    *+10
         LM    14,12,12(13)
         BSM   0,14
*
         ST    &PRFX.13,4(0,&PRFX.1)    ST BW SYS RSA TO OUR AREA
         ST    &PRFX.1,8(0,&PRFX.13)    ST FW OUR RSA TO SYS AREA
         LR    &PRFX.13,&PRFX.1         PRESERVE OUR SAVEAREA ADDR
.CKGUSE  AIF   (T'&GLABEL EQ 'O').NOSTG1
         MNOTE *,'DYNAMIC STORAGE GETMAIN'
.* IMACGML IS ALWAYS AT LEAST 12 BYTE PFX    4 BYTE FW CHAIN PTR
.*         WHERE FIRST 12 BYTES ARE 2 BYTE RESERVED
.*                                  2 BYTE AREA LNG
.*                                  4 BYTE BW CHAIN PTR
.*                                  4 BYTE FW CHAIN PTR
.*         FOLLOWED BY USER DEFINED LABEL FOR USING
.*         FOLLOWED BY USER STORAGE DEFINITIONS
IMACGML  EQU   IMACSTG,4,C'A'
IMACGM   GETMAIN R,LV=IMACGML,SP=1
         LTR   &PRFX.15,&PRFX.15
         BZ    *+16
         LR    &PRFX.1,&PRFX.13          RESET OUR RSA PTR
         L     &PRFX.13,4(&PRFX.1)       RESET PTR TO SYS SAVE AREA
         LM    14,12,12(13)
         BSM   0,14
*
         XC    0(12,&PRFX.1),0(&PRFX.1) CLEAR PFX AREA
         AIF   (&REG13SW EQ 1).CKGUSE2
         ST    &PRFX.13,4(0,&PRFX.1)    STORE OUR RSA PTR TO  AUTOSTG
         ST    &PRFX.1,8(0,&PRFX.13)    STORE NEW AUTOSTG INTO OUR RSA
.CKGUSE2 ICM   &PRFX.15,B'0111',IMACGM+5        USE R15 TO HOLD LNG
         STH   &PRFX.15,2(0,&PRFX.1)    STORE LNG AT END OF RSA
         AIF   (T'&GUSEREG EQ 'O').NOGUSE
         LR    &GUSEREG,&PRFX.1
         USING &GLABEL,&GUSEREG
         L     &PRFX.15,4(&GUSEREG)
         MVC   __PGM_NM,4(&PRFX.15)
         AGO   .GUSESET
.NOGUSE  ANOP
         MNOTE 4,'AUTO STORAGE ALLOCATED - NO REGISTER USE IDENTIFIED'
.GUSESET ANOP
         AIF   (&REG13SW EQ 1).CKGUSE3
         LR    &PRFX.1,&PRFX.13          SET TO OUR RSA PTR
.NOSTG1  L     &PRFX.13,4(&PRFX.1)       RESET PTR TO SYS SAVE AREA
.CKGUSE3 ANOP
         L     &PRFX.1,24(0,&PRFX.13)   ACCESS PARM REG FROM OLD RSA
         L     &PRFX.13,8(0,&PRFX.13)   REPOINT TO OUR NEW RSA
&SAIMAC  SETB  1
         AGO   .DOMXIT
.B7      ST    &PRFX.2,4(0,&PRFX.13)
         ST    &PRFX.13,8(0,&PRFX.2)
.DOMXIT  ANOP
         MEXIT
.EQUTBLO ANOP
&PRFX    SETC  'R'
.EQUTBL  ANOP
&PRFX.0  EQU   0
&PRFX.1  EQU   1
&PRFX.2  EQU   2
&PRFX.3  EQU   3
&PRFX.4  EQU   4
&PRFX.5  EQU   5
&PRFX.6  EQU   6
&PRFX.7  EQU   7
&PRFX.8  EQU   8
&PRFX.9  EQU   9
&PRFX.10 EQU   10
&PRFX.11 EQU   11
&PRFX.12 EQU   12
&PRFX.13 EQU   13
&PRFX.14 EQU   14
&PRFX.15 EQU   15
         AIF   (&REG13SW EQ 1).B5
         AGO   .B2
.SETID   B     12(0,&PRFX.15)
         AIF   (T'&ID NE 'O').CSECTNM
         AIF   ('&ID'(1,1) EQ '*').CSECTNM
$_PGM_NM DC    CL8'&ID'
         AGO   .B3
.CSECTNM ANOP
$_PGM_NM DC    CL8'&SYSECT'
         AGO   .B3
.NOREG   MNOTE 12,'NO REGISTERS SPECIFIED-MACRO NOT GENERATED'
         MEXIT
.INVREG  MNOTE 12,'INVALID REGISTER SPECIFIED-MACRO GEN TERMINATED'
         MEND
###END INITMAC
$$$BEG INITMAC1
         MACRO
&LABEL   INITMAC &EQU=,&ID=,&SA=
.* INITMAC IS MACRO TO INITIALIZE ASM PGM
.*  SPECIFICALLY:
.*   ACCEPTS 1 TO 15 BASE REGS AS POS PARMS
.*     REG 0 INVALID
.*     REG13 OK IF IT IS THE FIRST SPECIFIED
.*   IF REG13 IS USED, THEN YOU CAN USE SA= KW TO POINT PGM USER SA
.*   USE OF REG13 CAUSES NONREENT.
.*   ELSE REG13 IS USED AS THE DEFAULT SAVEAREA
.*   R0 TO R15 EQU GENERATED.  OVERRIDE R WITH 1 TO 6 CHAR PREFIX
.*    BY SPECIFING EQU=______ KW.
         GBLB  &SAIMAC
         GBLB  &SKTMAC
         GBLC  &GLABEL
         GBLC  &GUSEREG
         GBLC  &GDSAREG
         LCLC  &LCSEC
&GLABEL  SETC  '$_INITMAC'
&LCSEC   SETC  '&SYSECT'
&GDSAREG SETC  '13'
         AIF   (T'&GLABEL EQ 'O').NOSTG
         MNOTE *,'DYNAMIC STORAGE WOULD START HERE'
&GLABEL  DSECT
*        AIF   (&SKTMAC NE 1).NOSTAK
*
*        COPY STAKANCH
.NOSTAK   ANOP
INITSTG_END EQU *-&GLABEL
&LCSEC   CSECT
IMACSTG  EQU   INITSTG_END
         AGO   .DETGML
.NOSTG   ANOP
         MNOTE *,'GLOBAL GLABEL WAS NOT PROVIDED. NO LOCAL STORAGE.'
IMACSTG  EQU   0
.DETGML  ANOP
         LCLA  &POS,&TOTOPD,&REG13SW
         LCLC  &SVAR,&LBL,&PRFX
         LCLC  &REGS,&REG1,&REG2
&SAIMAC  SETB  0
         AIF   (T'&LABEL NE 'O').B1
         MNOTE *,'NO LABEL SPECIFIED'
         AGO   .CHKEQU
.B1      AIF   (K'&LABEL LE 8).LABOK
         MNOTE 'LABEL EXCEEDS 8 CHARACTERS-LEFT MOST 8 USED'
.LABOK   ANOP
&LBL     SETC  '&LABEL'(1,8)
.CHKEQU  AIF   (T'&EQU EQ 'O').B8
         AIF   (K'&EQU LE 6).EQUOK
         MNOTE 'REG PREFIX GREATER THAN 6-USING LEFT MOST 6'
.EQUOK   ANOP
&PRFX    SETC  '&EQU'(1,6)
.B8      ANOP
&SVAR    SETC  'SVAR'.'&SYSNDX'
&TOTOPD  SETA  N'&SYSLIST
         AIF   (&TOTOPD EQ 0).NOREG
         AIF   (&TOTOPD LE 15).PROCEED
         MNOTE 0,'MORE THAN 15 BASE REGS SPECIFIED-SURPLUS IGNORED'
&TOTOPD  SETA  15
.PROCEED ANOP
         AIF   (T'&EQU EQ 'O').EQUTBLO
         AGO   .EQUTBL
.B2      ANOP
.*       AIF   (T'&ID NE 'O').SETID
         AGO   .SETID
.B3      ANOP
.ULOOP   ANOP
&POS     SETA  &POS+1
         AIF   (&POS GT &TOTOPD).USING
         AIF   ('&SYSLIST(&POS)' EQ '13').REG13
         AIF   ('&SYSLIST(&POS)' EQ '0').INVREG
.B4      ANOP
&REGS    SETC  '&REGS'.','.'&PRFX'.'&SYSLIST(&POS)'
         AGO   .ULOOP
.USING   ANOP
         AIF   (&REG13SW EQ 1).USING13
         STM   &PRFX.14,&PRFX.12,12(&PRFX.13)
*        BASR  &PRFX.&SYSLIST(1),&PRFX.14
         BASR  &PRFX.&SYSLIST(1),0
         USING *&REGS
.B5      ANOP
&POS     SETA  1
         AIF   (&TOTOPD EQ 1).REST
.NXLOAD  ANOP
&POS     SETA  &POS+1
         AIF   (&POS GT &TOTOPD).REST
&REG1    SETC  '&SYSLIST(&POS-1)'
&REG2    SETC  '&SYSLIST(&POS)'
         LA    &PRFX.&REG2,2048
         LA    &PRFX.&REG2,2048(&PRFX.&REG1,&PRFX.&REG2)
         AGO   .NXLOAD
.REG13   AIF   (&POS GT 1).INVREG
&REG13SW SETA  1
         AGO   .B4
.USING13 ANOP
         AIF   (T'&SA EQ 'O').B6
&SVAR    SETC  '&SA'(1,8)
.B6      ANOP
         STM   &PRFX.14,&PRFX.12,12(&PRFX.13)
         LR    &PRFX.2,&PRFX.13
         BASR  &PRFX.12,0
         BAS   &PRFX.13,8(0,&PRFX.12)
&SVAR    DC    20F'0'
         USING &SVAR&REGS
         AGO   .B5
.REST    AIF   (&REG13SW EQ 1).CKGUSE
         GETMAIN R,LV=84,SP=1
         LTR   &PRFX.15,&PRFX.15
         BZ    *+14
         L     14,12(13)              LOAD THE RETURN ADDDRESS
         LM    0,12,20(13)            RELOAD REGS BUT LEAVE R15
         BSM   0,14
*
         ST    &PRFX.13,4(0,&PRFX.1)    ST BW SYS RSA TO OUR AREA
         ST    &PRFX.1,8(0,&PRFX.13)    ST FW OUR RSA TO SYS AREA
         LR    &PRFX.13,&PRFX.1         PRESERVE OUR SAVEAREA ADDR
.CKGUSE  AIF   (T'&GLABEL EQ 'O').NOSTG1
         MNOTE *,'DYNAMIC STORAGE GETMAIN'
.* IMACGML IS ALWAYS AT LEAST 12 BYTE PFX    4 BYTE FW CHAIN PTR
.*         WHERE FIRST 12 BYTES ARE 2 BYTE RESERVED
.*                                  2 BYTE AREA LNG
.*                                  4 BYTE BW CHAIN PTR
.*                                  4 BYTE FW CHAIN PTR OR NULL
.*         FOLLOWED BY USER DEFINED LABEL FOR USING
.*         FOLLOWED BY USER STORAGE DEFINITIONS
IMACGML  EQU   IMACSTG,4,C'A'
IMACGM   GETMAIN R,LV=IMACGML,SP=1
         LTR   &PRFX.15,&PRFX.15
         BZ    *+20
         LR    &PRFX.1,&PRFX.13          RESET OUR RSA PTR
         L     &PRFX.13,4(&PRFX.1)       RESET PTR TO SYS SAVE AREA
         L     14,12(13)              LOAD THE RETURN ADDDRESS
         LM    0,12,20(13)            RELOAD REGS BUT LEAVE R15
         BSM   0,14
*
         XC    0(12,&PRFX.1),0(&PRFX.1) CLEAR PFX AREA
         AIF   (&REG13SW EQ 1).CKGUSE2
         ST    &PRFX.13,4(0,&PRFX.1)    STORE OUR RSA INTO BW PTR STG
         ST    &PRFX.1,76(0,&PRFX.13)    STORE NEW AUTOSTG INTO OUR RSA
.CKGUSE2 ICM   &PRFX.15,B'0111',IMACGM+5        USE R15 TO HOLD LNG
         STH   &PRFX.15,2(0,&PRFX.1)    STORE LNG AT END OF RSA
         AIF   (T'&GUSEREG EQ 'O').NOGUSE
         LR    &GUSEREG,&PRFX.1
         USING &GLABEL,&GUSEREG
         AGO   .GUSESET
.NOGUSE  ANOP
         MNOTE 4,'AUTO STORAGE ALLOCATED - NO REGISTER USE IDENTIFIED'
.GUSESET ANOP
         AIF   (&REG13SW EQ 1).CKGUSE3
         LR    &PRFX.1,&PRFX.13          SET TO OUR RSA PTR
.NOSTG1  L     &PRFX.13,4(&PRFX.1)       RESET PTR TO SYS SAVE AREA
.CKGUSE3 ANOP
         L     &PRFX.1,24(0,&PRFX.13)   ACCESS PARM REG FROM OLD RSA
         L     &PRFX.13,8(0,&PRFX.13)   REPOINT TO OUR NEW RSA
&SAIMAC  SETB  1
         AGO   .DOMXIT
.B7      ST    &PRFX.2,4(0,&PRFX.13)
         ST    &PRFX.13,8(0,&PRFX.2)
.DOMXIT  ANOP
         MEXIT
.EQUTBLO ANOP
&PRFX    SETC  'R'
.EQUTBL  ANOP
&PRFX.0  EQU   0
&PRFX.1  EQU   1
&PRFX.2  EQU   2
&PRFX.3  EQU   3
&PRFX.4  EQU   4
&PRFX.5  EQU   5
&PRFX.6  EQU   6
&PRFX.7  EQU   7
&PRFX.8  EQU   8
&PRFX.9  EQU   9
&PRFX.10 EQU   10
&PRFX.11 EQU   11
&PRFX.12 EQU   12
&PRFX.13 EQU   13
&PRFX.14 EQU   14
&PRFX.15 EQU   15
         AIF   (&REG13SW EQ 1).B5
         AGO   .B2
.SETID   B     12(0,&PRFX.15)
         AIF   ('&ID'(1,1) EQ '*').CSECTNM
$_PGM_NM DC    CL8'&ID'
         AGO   .B3
.CSECTNM ANOP
$_PGM_NM DC    CL8'&SYSECT'
         AGO   .B3
.NOREG   MNOTE 12,'NO REGISTERS SPECIFIED-MACRO NOT GENERATED'
         MEXIT
.INVREG  MNOTE 12,'INVALID REGISTER SPECIFIED-MACRO GEN TERMINATED'
         MEND
###END INITMAC1
$$$BEG EXPLPGM
**
**
**  WORD     CONTENTS
**
**  0        USED BY LANGUAGE PRODUCTS
**  1        ADDRESS OF PREVIOUS SAVE AREA (STORED BY CALLING PROGRAM)
**  2        ADDRESS OF NEXT SAVE AREA (STORED BY TARGET PROGRAM)
**  3        GPR 14 (RETURN ADDRESS)
**  4        GPR 15 (ENTRY ADDRESS)
**  5 - 17   GPRS 0 - 12
**
** IF THE CALLING PROGRAM IS IN PRIMARY MODE, THE PARAMETER LIST
** MUST BE IN THE PRIMARY ADDRESS SPACE.  ALL ADDRESSES PASSED
** BY THE PROGRAMS MUST BE CONTAINED IN THE PRIMARY ADDRESS
** SPACE AND MUST NOT BE ALET-QUALIFIED. THE PROGRAM THAT
** PASSES PARAMETER DATA CAN USE GPRS 0 AND 1, OR BOTH.  TO
** PASS THE ADDRESS OF A PARAMETER LIST, THE PROGRAM SHOULD USE
** GPR 1.
**
** FOR A GOOD EXAMPLE OF HOW YOUR PRIMARY MODE PROGRAMS CAN
** PASS PARAMETERS, CONSIDER THE WAY THE SYSTEM USES A
** REGISTER TO PASS INFORMATION IN THE PARM FIELD OF AN EXEC
** STATEMENT TO YOUR PROGRAM.  WHEN YOUR PROGRAM RECEIVES
** CONTROL FROM THE SYSTEM, REGISTER 1 CONTAINS THE ADDRESS OF A
** FULLWORD ON A FULLWORD BOUNDARY IN YOUR PROGRAM'S ADDRESS
** SPACE (SEE FIGURE 2-2).  THE HIGH-ORDER BIT (BIT 0) OF THIS WORD
** IS SET TO 1.  THE SYSTEM USES THIS CONVENTION TO INDICATE THE
** LAST WORD IN A VARIABLE-LENGTH PARAMETER LIST. BITS 1-31 OF THE
** FULLWORD CONTAIN THE ADDRESS OF A TWO-BYTE LENGTH FIELD ON A
** HALFWORD BOUNDARY.  THE LENGTH FIELD CONTAINS A BINARY COUNT OF
** THE NUMBER OF BYTES IN THE PARM FIELD, WHICH IMMEDIATELY
** FOLLOWS THE LENGTH FIELD.  IF THE PARM FIELD WAS OMITTED IN THE
** EXEC STATEMENT, THE COUNT IS SET TO ZERO.  TO PREVENT POSSIBLE
** ERRORS, ALWAYS USE THE COUNT AS A LENGTH ATTRIBUTE IN ACQUIRING
** THE INFORMATION IN THE PARM FIELD.
**
**
**  RMODE 24 OR ANY FOR RESIDENCY. MUST BE 24 IF YOU HAVE A QSAM DCB
**  OR YOU MUST LOAD THE QSAM DCB CONTROL BLOCK INTO DYN STORAGE BELOW
**  AND USE A BSM TO SWITCH IN AND OUT OF 24 BIT MODE FOR THE IO.
**  AMODE 24 OR 31 FOR ADDRESSABILITY.
**  RESIDENCY AFFECTS WHERE IN STORAGE THE LOADER WILL PLACE YOUR PGM,
**  RMODE CAN BE 24,31,ANY WHERE ANY WILL IMPLY 31 FIRST AND THEN 24.
**  ADDRESSABILITY SET THE PSW AMODE INDICATOR AND IMPLYS THAT ADDRESSE
**  THAT YOU PROGRAM DEALS WITH ARE 24BIT OR 31 BIT.  REMEMBER, SOME
**  INSTRUCTIONS OPERATE IN EITHER AND LOAD OR STORE 24 BIT VALUES.
**
EXPL_MPB CNLMMPB
**
EXPL_SAV IHASAVER
**
TESTDCBD DCBD DSORG=PS,DEVD=DA
*
*
* DYNAMIC STORAGE THAT MUST RESIDE BELOW 16MB LINE DUE TO DCB & EXIT
* LIST RESTRICTIONS.  GET SEPARATE STORAGE FOR THIS.
DCB_WORKAREA DSECT
SYSPR_DCB DS   XL(SYSPREND) DCB LNG QS  ACTUAL QSAM DCB
* EACH ENTRY IN DCB EXIT LIST IS FOUR BYTES.
SY_EXL      DS    X         LAST ENTRY IN EXIT LIST AND FOR DCB OPENX
SY_EXLOPEN  DS    AL3       ADDRESS OF 24-BIT DCB OPEN EXIT ROUTINE
SYPENLIST DS    XL(LSPROPPL) LEN OPEN PARAMETER LIST
*
*
CLOLIST  DS    XL(LSPRCLPL) LEN CLOS PARAMETER LIST
* THE FOLLOWING IS EXECUTABLE CODE TO BRANCH ABOVE THE 16MB LINE.
         DS    0H
OPEN24   DS    XL(LENOPEN24)   DCB OPEN EXIT BELOW 16MB LINE
ADOPEN31 DS    A         ADDRESS OF DCB OPEN EXIT ABOVE THE LINE
LENAREA  EQU   *-DCB_WORKAREA
*
*** CHECK THIS OUT
*        COPY ASMMSP       THIS IS THE HLASM TOOLKIT-SYSTEM MACRO
*** CHECK THIS OUT
*
**
** REGISTER USAGE
**  R0  WORK FOR MANY INST
**  R1 PASS PARM ADDR AND WORK AND TRT
**  R2 WORK AND USED BY TRT
**  R3 BASE1
**  R4 R5 WORK AND USED FOR EVEN ODD
**  R6 R7 WORK AND USED FOR EVEN ODD
**  R8 WORK
**  R9 WORK AND USED FOR SR LINKAGE
**  R10 DCBPTR AND WORK
**  R11 USED FOR AUTO STORAGE
**  R12 BASE2
**  R13 SAVEAREA
**  R14 WORK
**  R15 PASS DATA IN REG TO SR AND WORK
**
MY_AREA  DSECT
         DS    F            AREA LENGTH
         DS    F            BWCHAIN
         DS    F            FWCHAIN
*
*MYSTK_S  STAKMAC  RTYPE=BUILD,USERLEN=4096
*
MYDYN_S  INITSTG USEREG=11
*
         COPY PASSPAR1
         ORG   MYDYN_S+4096-256
STOPARM  DS    256XL1
*
EXPLPGM CSECT
EXPLPGM RMODE ANY
EXPLPGM AMODE 31
LBLPGM   INITMAC 3,12,EQU=R,ID=EXPLPGM
         ST    R1,PARMAP
         STM   R0,R15,SAV_DUMP_REGS_R0RF
         XR    R1,R1
         ST    R13,SAVRD
         STORAGE OBTAIN,LENGTH=LENAREA,LOC=BELOW  GET DCB & ETC.
         ST    R1,PTR_DCB_WORKAREA
         LR    R10,R1
         USING DCB_WORKAREA,R10
*
         LA    R0,OPEN24           POINT THE EXIT LIST TO THE EXIT RTN
         STCM  R0,B'0111',SY_EXLOPEN    THAT IS BELOW THE LINE
         MVI   SY_EXL,X'85'      SET LAST ENTRY & DCB OPEN EXIT LIST
         MVC   OPEN24,MODOPEN24    MOVE GLUE CODE TO BELOW LINE
         LA    R0,OPEN31           SHOW THE 24-BIT CODE WHERE THE
         ST    R0,ADOPEN31           31-BIT CODE IS ABOVE THE LINE
         OI    ADOPEN31,X'80'      SET BIT 0 TO AMODE 31 IN ADDRESS
*
*
         MVC   SYSPR_DCB,MODSPRDCB CREATE DCB BELOW THE LINE
         LA    R0,SY_EXL
         STCM  R0,B'0111',DCBEXLSA-IHADCB+SYSPR_DCB
         MVC   SYPENLIST,MODSPRPEN  BUILD OPEN PARAMETER LIST
*   OPEN USES NORMAL RSA CONVENTIONS
         OPEN  (SYSPR_DCB),MF=(E,SYPENLIST) LIST IS BELOW THE LINE
*        OPEN  (SYSPRINT,(OUTPUT))
         LA    R14,SYSPR_DCB
         USING IHADCB,R14
         MVC   H_SYSPRINT_LRECL,DCBLRECL
         DROP  R14
         DROP  R10
*
         BAS   R9,INITRTN
*        MHELP 64
         WRITMAC STRLIT='TEST THIS OUT FOR A MULTIPLE LINE ENTRY THAT WX
               ILL PRINT OUT TO MULTIPLE LINES AND I WOULD HOPE THAT ANX
               Y OUTPUT WOULD BE FORMATTED TO MULTIPLE LINES'
         BAS   R9,GETTIME
*
         MVC   MSGAREA(L'BEGNMSG),BEGNMSG
         MVC   MSGAREA+25(5),$DATE+3
         MVC   MSGAREA+31(6),$TIME+1
         BAS   R9,GETJOBN
         BAS   R9,WRTMSG
*
         BAS   R9,DUMP_REGS
*
         L     R1,PARMAP
         LA    R15,1
         BAS   R9,DUMP_REG
*
         LTR   R1,R1
         BZ    NOPARM
         L     R1,0(R1)
         ST    R1,PARMAP
         LH    R15,0(R1)
         LTR   R15,R15
         BZ    NOPARM
         STH   R15,PARMAL
         BCTR  R15,0
         LA    R1,2(R1)
         ST    R1,PARMA
         EX    R15,MVCPARM
         MVC   MSGAREA(L'PRMSG),PRMSG
         XR    R15,R15
         LH    R15,PARMAL
         BAS   R9,X2CX
         MVC   MSGAREA+14(3),EBCDCFLD+5
         BAS   R9,WRTMSG
         B     WRIT_PRMMSG
*
NOPARM   EQU   *
         WRITMAC STRLIT='NO PARM PROVIDED OR ZERO LENGTH'
WRIT_PRMMSG EQU *
         MVI   XC,X'08'
***
*** INSERT CODE HERE
***
         B     DOCLOSE
*
*
NOSTG    EQU   *
EXITRC8  EQU   *
         XR    R15,R15
         LA    R15,8
         B     BYL15
*
*
OPEN31   EQU   *         ENTRY POINT OF DCB OPEN EXIT ABOVE THE LINE
         BSM   0,R14     SWITCH TO 24-BIT MODE AND RETURN TO OPEN
*
DOCLOSE  EQU   *
         MVC   MSGAREA(L'ENDMSG),ENDMSG
         BAS   R9,WRTMSG
         L     R10,PTR_DCB_WORKAREA
         USING DCB_WORKAREA,R10
         MVC   CLOLIST,MODSPRCLO   BUILD OPEN PARAMETER LIST
         CLOSE (SYSPR_DCB),MF=(E,CLOLIST)
*
         IC    R15,XC
BYL15    EQU   *
         RTNMAC  RC=(15)
NORTNCD  EQU   *
         RTNMAC
*
INITRTN  EQU   *
* PLACE ANY INITIALIZATION PROCESSING HERE
         MVC   WRTSTR_LLNG,H_SYSPRINT_LRECL
         MVI   MSGAREA1,X'40'
         MVC   MSGAREA,MSGAREA1
         MVC   SAV_MSGAREA,MSGAREA
         MVI   XC,X'00'
         XC    PTR_STG_STAKB,PTR_STG_STAKB
         XC    PTR_STG_STAKA,PTR_STG_STAKA
         BR    R9
*
***
MVCPARM  MVC   MSGAREA+18(0),0(R1)
MVC2MSG  MVC   MSGAREA(0),0(R10)
WRTSTR   EQU  *
*   REG15 SET TO BEGIN ADDRESS OF A NULL TERMINATED STRING
*   REQUIRES A FW AUTOSTORAGE SAVE AREA FOR R9  WRTSTR_SAVR9
*   REQUIRES A FW AUTOSTORAGE HW VALUE FOR O/P LINE LENGTH 1-255
*                                               WRTSTR_LLNG
*
         STM  R8,R10,WRTSTR_SAVR8_10
         LR   R9,R15
         XR   R0,R0
SRST_AGN SRST R0,R9
         BC   4,WRTSTR_FND
         BC   1,SRST_AGN      SECOND REG CHANGED FOR NEXT SEARCH ADDR
***
BAD_WRTSTR EQU *
         XR    R15,R15
         BCTR  R15,0
         B     WRTSTR_RET
WRTSTR_FND EQU *
         SR    R0,R15         R0 NOW HAVE NULL POS. DERIVE LNG
         BNP   BAD_WRTSTR
         LR    R10,R15        SAVE START
         LR    R8,R0          SAVE DERIVED LENGTH
WRTSTR_TOL EQU *
         CH    R8,WRTSTR_LLNG
         BNH   WRTSTR_DO_EX
         LH    R9,WRTSTR_LLNG
         BCTR  R9,0
         EX    R9,MVC2MSG
         BAS   R9,WRTMSG
         AH    R10,WRTSTR_LLNG
         SH    R8,WRTSTR_LLNG
         B     WRTSTR_TOL
*
WRTSTR_DO_EX   EQU  *
         LTR   R9,R8
         BNP   WRTSTR_FIN
         BCTR  R9,0
         EX    R9,MVC2MSG
         BAS   R9,WRTMSG
WRTSTR_FIN EQU *
         XR    R15,R15
WRTSTR_RET EQU *
         LM    R8,R10,WRTSTR_SAVR8_10
         BR    R9
*
WRTMSG   EQU   *
         STM   R10,R1,WRTMSG_SAVR10_1
         L     R10,PTR_DCB_WORKAREA
         USING DCB_WORKAREA,R10
         LA    R1,SYSPR_DCB
         PUT   (1),MSGAREA
         DROP  R10
         MVC   MSGAREA,MSGAREA1
         LM    R10,R1,WRTMSG_SAVR10_1
         BR    R9
***
GETJOBN  EQU   *
         ST    R9,SAVR9
         LA    R9,TIOTADR
         EXTRACT (R9),'S',FIELDS=TIOT
         L     R1,TIOTADR
         MVC   JOBNAME,0(R1)
         L     R9,SAVR9
         BR    R9
*** GET THE SYSDATE SYSTIME IN ORDER TO CREATE A UNIQUE QUALIFIER
GETTIME  EQU   *
         XR    R0,R0
         XR    R1,R1
         TIME
         ST    R0,$TIMEB
         ST    R0,$DBLWD+4
         OI    $DBLWD+7,X'0F'
         UNPK  $TIME,$DBLWD
         XC    $DBLWD,$DBLWD
         ST    R1,$DATEB
         ST    R1,$DBLWD+4
         OI    $DBLWD+7,X'0F'
         UNPK  $DATE,$DBLWD
         BR    R9
*
* TO USE:
*    LA    R15,N  WHERE N IS 0 TO 15::CONTENTS TO BE DUMPED SYSPRINT
*    BAS   R9,DUMP_REG
*                 TO DUMP REG15: ST R15,HLD_REG
*                                LA R15,15
*                                BAS R9,DUMP_REG
SYSPR_REG_VALU DC C'* KIXEXCIL REGISTER VALUE    IS:'
* __PGM_NM IS EXPECTED TO HOLD THIS PROGRAMS CSECT NAME
*   IF YOU USE INITMAC, THEN THE VAR IS PREFILLED BY MACRO
*   OTHERWISE, YOU NEED TO PROVIDE IS AS A DS CL8
         DC    0H
ST_REG   ST    0,HLD_REG
DUMP_REG EQU   *
         STM   R3,R9,SAV_R3R9
         CHI   R15,15
         BE    ALRDY_SAVED
         SLL   R15,4
         EX    R15,ST_REG
ALRDY_SAVED EQU *
         MVC   MSGAREA(L'SYSPR_REG_VALU),SYSPR_REG_VALU
         MVC   MSGAREA+3(8),__PGM_NM
         BAS   R9,X2CX
         MVC   MSGAREA+26(2),EBCDCFLD+6
         L     R15,HLD_REG
         BAS   R9,X2CX
         MVC   MSGAREA+32(8),EBCDCFLD
         BAS   R9,WRTMSG
         LM    R3,R9,SAV_R3R9
         BR    R9
*
*
* TO USE:
*    STM   R0,R15,DUMP_REGS_R0RF    ::ALL REGS SAVED
*    BAS   R9,DUMP_REGS
DUMP_REGS_VALU DC C'* EXPLPGM  REGISTER VALUE 0 THROUGH 15 AS FOLLOWS:'
* __PGM_NM IS EXPECTED TO HOLD THIS PROGRAMS CSECT NAME
*   IF YOU USE INITMAC, THEN THE VAR IS PREFILLED BY MACRO
*   OTHERWISE, YOU NEED TO PROVIDE IS AS A DS CL8
         DC    0H
DUMP_REGS EQU   *
         ST    R9,SAVR9
         MVC   MSGAREA(L'DUMP_REGS_VALU),DUMP_REGS_VALU
         MVC   MSGAREA+3(8),__PGM_NM
         BAS   R9,WRTMSG
*
         XR    R1,R1        COUNT
DUMP_REGS_TOP EQU *
         LR    R2,R1
         MHI   R2,4
         L     R15,SAV_DUMP_REGS_R0RF(R2)
         BAS   R9,X2CX
*
DUMP_REGS_TRY_4 EQU *
         LR    R2,R1
         CHI   R2,4
         BL    DUMP_REGS_FMT_REG
         CHI   R2,7
         BH    DUMP_REGS_TRY_11
         AHI   R2,-4
         B     DUMP_REGS_FMT_REG
DUMP_REGS_TRY_11 EQU *
         CHI   R2,11
         BH    DUMP_REGS_TRY_15
         AHI   R2,-8
         B     DUMP_REGS_FMT_REG
DUMP_REGS_TRY_15 EQU *
         AHI   R2,-12
DUMP_REGS_FMT_REG EQU *
         LR    R0,R2
         MHI   R2,9
         LA    R2,MSGAREA(R2)
         MVC   0(8,R2),EBCDCFLD
         CHI   R0,3
         BNE   DUMP_REGS_INCR
         BAS   R9,WRTMSG
DUMP_REGS_INCR EQU *
         LA    R1,1(R1)
         CHI   R1,16
         BL    DUMP_REGS_TOP
*
         LM    R0,R15,SAV_DUMP_REGS_R0RF
         L     R9,SAVR9
         BR    R9
*
*
* TO USE:
*    L     R15,START_STORAGE_AREA_ADDR
*          OR
*    LA    R15,SOME_AREA_BEG
*
*    XR    R0,R0
*    LH    R0,HW_LNG_OF_DUMP
*          OR
*    L     R0,END_STORAGE_AREA_ADDR
*          OR
*    LA    R0,SOME_AREA_END
*    O     R0,X'8000'                   SET FIRST BIT OF END AREA ON
*
*    BAS   R9,DUMP_STG
DUMP_STG_ADR   DC C'* EXPLPGM  DUMP STORAGE:'
DUMP_STG_HDR   DC C'XXXXXXXX ........ ........ ........ ........ |____ X
                ____ ____ ____|'
DUMP_STG_MVC_SP MVC 0(0,R2),SPACE255
DUMP_STG_MVC    MVC 0(0,R0),0(R4)
* __PGM_NM  DS CL8 IS EXPECTED TO HOLD THIS PROGRAMS CSECT NAME
*   IF YOU USE INITMAC, THEN THE VAR IS PREFILLED BY MACRO
*   OTHERWISE, YOU NEED TO PROVIDE IT  DS CL8, THEN INITIALIZE IT
         DC    0H
DUMP_STG EQU    *
         ST    R9,SAVR9
         STM   R0,R15,SAV_DUMP_REGS_R0RF
*
         MVC   MSGAREA(L'DUMP_STG_ADR),DUMP_STG_ADR
         MVC   MSGAREA+3(8),__PGM_NM
         BAS   R9,WRTMSG
*
         MVC   MSGAREA(L'DUMP_STG_HDR),DUMP_STG_HDR
         BAS   R9,WRTMSG
*
         TM    SAV_DUMP_REGS_R0RF,B'1000'
         BZ    DUMP_STG_HWL
*
         ST    R0,HLD_REG        SAVE END ADDR
         CR    R0,R15
         BH    DUMP_STG_R0_HI
*
         ST    R15,HLD_REG       R15 IS HIGH, SO SWITCH
         LR    R15,R0
         L     R0,HLD_REG
DUMP_STG_R0_HI EQU *
         LA    R0,1(R0)
         SR    R0,R15
         BNP   DUMP_STG_NONE
*
DUMP_STG_HWL EQU *
         C     R0,F32400
         BH    DUMP_STG_TOO_MUCH
*
         AR    R0,R15          R0 NOW HAS END ADDR + 1
         ST    R0,HLD_REG      SAVE END ADDR (AGAIN, MAYBE)
*
         MVC   MSGAREA(L'DUMP_STG_HDR),DUMP_STG_HDR
*                           R15 HOLDS BEG ADDR
         BAS   R9,X2CX      CVT FOR PRINT
         MVC   MSGAREA(8),EBCDCFLD
*
         LR    R1,R15       START ADDR
         SRL   R1,4         ELIMINATE LOW ORDER BIT SO THAT WE CAN SEE
         SLL   R1,4          IF WE ARE ON A PARAG (16) BOUNDRY
         LR    R0,R15       SUB THE BEG ADDR FROM THE BOUNDRY. IF
         SR    R0,R1         ZERO, THEN WE ARE ALREADY TO START ADDR
         BZ    DUMP_STG_BDY  IS ON PARGH BDY (16)
*
         LA    R2,MSGAREA+9
         LR    R1,R0
         SLL   R1,1         MULT BY 2
         BCTR  R1,0         REDUCE BY 1 FOR EX
         EX    R1,DUMP_STG_MVC_SP   MVC HEX  REPS
         LA    R2,1(R1,R2)
         ST    R2,HLD_MSG_HEX
         LA    R2,MSGAREA+45
         LR    R1,R0
         BCTR  R1,0
         EX    R1,DUMP_STG_MVC_SP   MVC CHAR REPS
         LA    R2,1(R1,R2)
         ST    R2,HLD_MSG_CHAR
*
         LR    R1,R15
         AHI   R0,-16
         MHI   R0,-1
         LR    R3,R0
         XR    R2,R2
         D     R2,F4
         XR    R15,R15
         LR    R4,R2
DUMP_STG_PFX0 EQU *
         IC    R15,0(R1)
         SLL   R15,4
         LA    R1,1(R1)
         BCT   R2,DUMP_STG_PFX0
*
         BAS   R9,X2CX
         LA    R0,EBCDCFLD
         LR    R1,R4          PRESERVE REMAINDER   EX: 3
         SLL   R4,1           MULT BY 2                6
         LR    R2,R4          SET UP SRC AND TARG      6 6
         MHI   R4,-1          MAKE TRG NEG             -6
         AHI   R4,8           ADD EBCDCFLD LNG         -6 + 8 = 2
         AR    R4,R0          DERIVE SRC START ADDR
         L     R0,HLD_MSG_HEX GET PTR TO CUR HEX AREA
         BCTR  R2,0
         EX    R2,DUMP_STG_MVC
         LA    R2,2(R0,R2)    ADD BACK 2 PLUS LNG PLUS HEX MSG ADDR
         ST    R2,HLD_MSG_HEX NEXT TARGET FLD
         L     R0,HLD_MSG_CHAR
         L     R4,HLD_REG
         BCTR  R1,0
         EX    R1,DUMP_STG_MVC
         LA    R0,2(R1,R0)    ADD BACK 2 PLUS LNG PLUS HEX MSG ADDR
         ST    R0,HLD_MSG_CHAR NEXT TARGET FLD
         LA    R1,1(R4,R1)    ADD BACK 1 PLUS LNG PLUS SRC FLD ADDR
         ST    R1,HLD_REG     STORE IT BACK
*
DUMP_STG_PFX1  EQU *
         L     R15,0(R1)      GET NEXT 4 CHARS
         BAS   R9,X2CX        CONVERT
         L     R2,HLD_MSG_HEX
         MVC   0(8,R2),EBCDCFLD     MOVE THE CONVERTED CHAR TO MSGAREA
         LA    R2,9(R2)
         ST    R2,HLD_MSG_HEX
*
         L     R2,HLD_MSG_CHAR
         MVC   0(4,R2),0(R1)        MOVE THE CONVERTED CHAR TO MSGAREA
         LA    R2,5(R2)
         ST    R2,HLD_MSG_HEX
*
         LA    R1,4(R4)
         ST    R1,HLD_REG
         BCT   R3,DUMP_STG_PFX1
         BAS   R9,WRTMSG
*
*
DUMP_STG_TOP EQU *
         MVC   MSGAREA(L'DUMP_STG_HDR),DUMP_STG_HDR
         LR    R15,R1
         BAS   R9,X2CX
         MVC   MSGAREA(8),EBCDCFLD
         LA    R2,MSGAREA+9
         LA    R3,MSGAREA+45
DUM_STG_LOOP0 EQU *
         L     R15,0(R1)      GET NEXT 4 CHARS
         BAS   R9,X2CX        CONVERT
         MVC   0(8,R2),EBCDCFLD     MOVE THE CONVERTED CHAR TO MSGAREA
         LA    R2,9(R2)
*
         MVC   0(4,R3),0(R1)        MOVE THE CONVERTED CHAR TO MSGAREA
         LA    R3,5(R3)
         ST    R3,HLD_MSG_HEX
*
         LA    R1,4(R4)
         ST    R1,HLD_REG
*
         ST    R15,45(R2)
         MHI   R2,4
         L     R15,SAV_DUMP_STG_R0RF(R2)
         BAS   R9,X2CX
*
         LR    R2,R1
         CHI   R2,4
         BL    DUMP_STG_FMT_REG
         CHI   R2,7
         BH    DUMP_STG_TRY_11
         AHI   R2,-4
         B     DUMP_STG_FMT_REG
DUMP_STG_TRY_11 EQU *
         CHI   R2,11
         BH    DUMP_STG_TRY_15
         AHI   R2,-8
         B     DUMP_STG_FMT_REG
DUMP_STG_TRY_15 EQU *
         AHI   R2,-12
DUMP_STG_FMT_REG EQU *
         LR    R0,R2
         MHI   R2,9
         LA    R2,MSGAREA(R2)
         MVC   0(8,R2),EBCDCFLD
         CHI   R0,3
         BNE   DUMP_STG_INCR
         BAS   R9,WRTMSG
DUMP_STG_INCR EQU *
         LA    R1,1(R1)
         CHI   R1,16
         BL    DUMP_STG_TOP
*
         LM    R0,R15,SAV_DUMP_STG_R0RF
         L     R9,SAVR9
         BR    R9
*
*
***
B2C      EQU   *
         CVD   R15,DWORD
         UNPK  HLDSTR,DWORD+4(4)
         OI    HLDSTR+6,X'F0'
         XR    R15,R15
         BR    R9
***
* THIS IS THE ERROR ROUTINE TO FORMAT THE ERROR CODE RETURNED FROM THE
* SVC IF THERE IS AN ERROR ON ALLOCATION.
*
X2CX     EQU   *
         ST    R15,FOUR
         UNPK  EIGHT(9),FOUR(5)
         XC    EBCDCFLD,EBCDCFLD
         MVN   EBCDCFLD(8),EIGHT
         TR    EBCDCFLD,ERRTRAN
         BR    R9
*
FORMERR  EQU   *
         STM   R4,R9,X2CX49
         XR    R6,R6
         LA    R6,8
         ST    R15,HEXFIELD
         LA    R4,HEXFIELD
         LA    R5,EBCDCFLD
*
CONVERT  EQU   *
         SLR   R8,R8
         IC    R8,0(R4)
         SRDL  R8,4
         STC   R8,0(R5)
         LA    R5,1(R5)
         SLR   R8,R8
         SLDL  R8,4
         STC   R8,0(R5)
         LA    R5,1(R5)
         LA    R4,1(R4)
         BCT   R6,CONVERT
*
         TR    EBCDCFLD(8),ERRTRAN
         LM    R4,R9,X2CX49
         BR    R9
         LTORG
DONEEXT  EQU   *
NOEXT    EQU   *
*
         RTNMAC
*
*        PROGRAM CONSTANTS
*
*
*
*
         EJECT
$MODID   DC    CL16'&SYSDATE.-&SYSTIME'
* NEW CONSTANTS
BIN_CONST DC   FL8'95'
BIN_CONST_FD DC   FD'95'
ADR_CONST_8  DC   AD(95)
*UNICODE_CONST DC  CU1(A)
ZEROES   DC    2F'0'
FMIN1    DC    F'-1'
F254     DC    F'254'
BLANKS   DC    CL8'                '
F16      DC    F'16'
         ORG   F16
         DS    H
HW16     DS    H
F80      DC    F'80'
         ORG   F80
         DS    H
HW80     DS    H
Z123     DC    Z'123'
SPACE255 DC    CL255' '
*                0....5....1....5....2....5....3....5....4....5....5
BEGNMSG  DC    C'EXPLDYNA PROGM BEGIN AT'
NOPRMSG  DC    C'NO PARM PROVIDED OR ZERO LENGTH'
PRMSG    DC    C'PARM PROVIDED>'
ENDMSG   DC    C'PROCESSING FINISHED NORMALLY'
L_ENDMSG EQU   *-ENDMSG
ERRTRAN  DC    X'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
***
INV_ENDMSG DS  CL(L'ENDMSG)
***
L_EXPLPGM DC A(*-EXPLPGM)
MODSPRPEN OPEN (,OUTPUT),MF=L,MODE=31 MODEL OPEN PARAMETER LIST
LSPROPPL EQU   *-MODSPRPEN
*
MODSPRCLO CLOSE (),MF=L,MODE=31    MODEL OPEN PARAMETER LIST
LSPRCLPL EQU   *-MODSPRCLO
*
* THE FOLLOWING IS THE MODEL FOR THE DCB OPEN EXIT ROUTINE ENTRY POINT
* WE COPY THIS CODE TO THE WORK AREA, WHICH IS BELOW THE LINE.  THE
* BSM SETS THE CURRENT ADDRESSING MODE (24) IN BIT 0 OF R14 WITHOUT
* CHANGING ANYTHING ELSE IN R14.  IT ALSO SWITCHES TO 31-BIT DUE TO
* BIT 0 IN R15 AND BRANCHES TO THE ADDRESS IN R15.
MODOPEN24 L    R15,ADOPEN31-OPEN24(,R15) ENTRY PT TO DCB OPEN EXIT RTN
         BSM   R14,R15        SAVE AMODE, SWITCH TO 31-BIT AND BRANCH
LENOPEN24 EQU  *-MODOPEN24
*
SYSPR_BEGINMSG DC   C'THIS IS A TEST FOR QSAM ABOVE TO SYSPRINT'
*
* DCB MODEL FOR SYSPRINT, WHICH IS ABOVE THE LINE.
MODSPRDCB DCB  DSORG=PS,DDNAME=SYSPRINT,MACRF=(PM)
SYSPREND EQU   *-MODSPRDCB
*
*SYSUT1   DCB   MACRF=R,BLKSIZE=96,LRECL=96,KEYLEN=44,RECFM=F,
*              DSORG=PS,EXLST=JFCBPTR,DDNAME=SYSUT1,EODAD=DONERD
*YSUT1   DCB   MACRF=PM,LRECL=80,RECFM=FB,                            X
*              DSORG=PS,EXLST=JFCBPTR,DDNAME=SYSUT1
***
         LTORG
         END
###END EXPLPGM
$$$BEG IMITMAC0
         MACRO
&LABEL   INITMAC &EQU=,&ID=,&SA=
.* INITMAC IS MACRO TO INITIALIZE ASM PGM
.*  SPECIFICALLY:
.*   ACCEPTS 1 TO 15 BASE REGS AS POS PARMS
.*     REG 0 INVALID
.*     REG13 OK IF IT IS THE FIRST SPECIFIED
.*   IF REG13 IS USED, THEN YOU CAN USE SA= KW TO POINT PGM USER SA
.*   USE OF REG13 CAUSES NONREENT.
.*   ELSE REG13 IS USED AS THE DEFAULT SAVEAREA
.*   R0 TO R15 EQU GENERATED.  OVERRIDE R WITH 1 TO 6 CHAR PREFIX
.*    BY SPECIFING EQU=______ KW.
         GBLB  &SAIMAC
         GBLB  &SKTMAC
         GBLC  &GLABEL
         GBLC  &GUSEREG
         GBLC  &GDSAREG
         LCLC  &LCSEC
&LCSEC   SETC  '&SYSECT'
&GDSAREG SETC  '13'
         AIF   (T'&GLABEL EQ 'O').NOSTG
         MNOTE *,'DYNAMIC STORAGE '
&GLABEL  DSECT
*        AIF   (&SKTMAC NE 1).NOSTAK
*
*        COPY STAKANCH
.NOSTAK   ANOP
INITSTG_END EQU *-&GLABEL
&LCSEC   CSECT
IMACSTG  EQU   INITSTG_END
         AGO   .DETGML
.NOSTG   ANOP
         MNOTE *,'GLOBAL GLABEL WAS NOT PROVIDED. NO LOCAL STORAGE.'
IMACSTG  EQU   0
.DETGML  ANOP
         LCLA  &POS,&TOTOPD,&REG13SW
         LCLC  &SVAR,&LBL,&PRFX
         LCLC  &REGS,&REG1,&REG2
&SAIMAC  SETB  0
         AIF   (T'&LABEL NE 'O').B1
         MNOTE *,'NO LABEL SPECIFIED'
         AGO   .CHKEQU
.B1      AIF   (K'&LABEL LE 8).LABOK
         MNOTE 'LABEL EXCEEDS 8 CHARACTERS-LEFT MOST 8 USED'
.LABOK   ANOP
&LBL     SETC  '&LABEL'(1,8)
.CHKEQU  AIF   (T'&EQU EQ 'O').B8
         AIF   (K'&EQU LE 6).EQUOK
         MNOTE 'REG PREFIX GREATER THAN 6-USING LEFT MOST 6'
.EQUOK   ANOP
&PRFX    SETC  '&EQU'(1,6)
.B8      ANOP
&SVAR    SETC  'SVAR'.'&SYSNDX'
&TOTOPD  SETA  N'&SYSLIST
         AIF   (&TOTOPD EQ 0).NOREG
         AIF   (&TOTOPD LE 15).PROCEED
         MNOTE 0,'MORE THAN 15 BASE REGS SPECIFIED-SURPLUS IGNORED'
&TOTOPD  SETA  15
.PROCEED ANOP
         AIF   (T'&EQU EQ 'O').EQUTBLO
         AGO   .EQUTBL
.B2      ANOP
         AIF   (T'&ID NE 'O').SETID
.B3      ANOP
.ULOOP   ANOP
&POS     SETA  &POS+1
         AIF   (&POS GT &TOTOPD).USING
         AIF   ('&SYSLIST(&POS)' EQ '13').REG13
         AIF   ('&SYSLIST(&POS)' EQ '0').INVREG
.B4      ANOP
&REGS    SETC  '&REGS'.','.'&PRFX'.'&SYSLIST(&POS)'
         AGO   .ULOOP
.USING   ANOP
         AIF   (&REG13SW EQ 1).USING13
         STM   &PRFX.14,&PRFX.12,12(&PRFX.13)
*        BASR  &PRFX.&SYSLIST(1),&PRFX.14
         BASR  &PRFX.&SYSLIST(1),0
         USING *&REGS
.B5      ANOP
&POS     SETA  1
         AIF   (&TOTOPD EQ 1).REST
.NXLOAD  ANOP
&POS     SETA  &POS+1
         AIF   (&POS GT &TOTOPD).REST
&REG1    SETC  '&SYSLIST(&POS-1)'
&REG2    SETC  '&SYSLIST(&POS)'
         LA    &PRFX.&REG2,2048
         LA    &PRFX.&REG2,2048(&PRFX.&REG1,&PRFX.&REG2)
         AGO   .NXLOAD
.REG13   AIF   (&POS GT 1).INVREG
&REG13SW SETA  1
         AGO   .B4
.USING13 ANOP
         AIF   (T'&SA EQ 'O').B6
&SVAR    SETC  '&SA'(1,8)
.B6      ANOP
         STM   &PRFX.14,&PRFX.12,12(&PRFX.13)
         LR    &PRFX.2,&PRFX.13
         BASR  &PRFX.12,0
         BAS   &PRFX.13,8(0,&PRFX.12)
&SVAR    DC    20F'0'
         USING &SVAR&REGS
         AGO   .B5
.REST    AIF   (&REG13SW EQ 1).CKGUSE
         GETMAIN R,LV=84,SP=1
         LTR   &PRFX.15,&PRFX.15
         BZ    *+14
         L     14,12(13)              LOAD THE RETURN ADDDRESS
         LM    0,12,20(13)            RELOAD REGS BUT LEAVE R15
         BSM   0,14
*
         ST    &PRFX.13,4(0,&PRFX.1)    ST BW SYS RSA TO OUR AREA
         ST    &PRFX.1,8(0,&PRFX.13)    ST FW OUR RSA TO SYS AREA
         LR    &PRFX.13,&PRFX.1         PRESERVE OUR SAVEAREA ADDR
.CKGUSE  AIF   (T'&GLABEL EQ 'O').NOSTG1
         MNOTE *,'DYNAMIC STORAGE GETMAIN'
.* IMACGML IS ALWAYS AT LEAST 12 BYTE PFX    4 BYTE FW CHAIN PTR
.*         WHERE FIRST 12 BYTES ARE 2 BYTE RESERVED
.*                                  2 BYTE AREA LNG
.*                                  4 BYTE BW CHAIN PTR
.*                                  4 BYTE FW CHAIN PTR OR NULL
.*         FOLLOWED BY USER DEFINED LABEL FOR USING
.*         FOLLOWED BY USER STORAGE DEFINITIONS
IMACGML  EQU   IMACSTG,4,C'A'
IMACGM   GETMAIN R,LV=IMACGML,SP=1
         LTR   &PRFX.15,&PRFX.15
         BZ    *+20
         LR    &PRFX.1,&PRFX.13          RESET OUR RSA PTR
         L     &PRFX.13,4(&PRFX.1)       RESET PTR TO SYS SAVE AREA
         L     14,12(13)              LOAD THE RETURN ADDDRESS
         LM    0,12,20(13)            RELOAD REGS BUT LEAVE R15
         BSM   0,14
*
         XC    0(12,&PRFX.1),0(&PRFX.1) CLEAR PFX AREA
         AIF   (&REG13SW EQ 1).CKGUSE2
         ST    &PRFX.13,4(0,&PRFX.1)    STORE OUR RSA INTO BW PTR STG
         ST    &PRFX.1,76(0,&PRFX.13)    STORE NEW AUTOSTG INTO OUR RSA
.CKGUSE2 ICM   &PRFX.15,B'0111',IMACGM+5        USE R15 TO HOLD LNG
         STH   &PRFX.15,2(0,&PRFX.1)    STORE LNG AT END OF RSA
         AIF   (T'&GUSEREG EQ 'O').NOGUSE
         LR    &GUSEREG,&PRFX.1
         USING &GLABEL,&GUSEREG
         AGO   .GUSESET
.NOGUSE  ANOP
         MNOTE 4,'AUTO STORAGE ALLOCATED - NO REGISTER USE IDENTIFIED'
.GUSESET ANOP
         AIF   (&REG13SW EQ 1).CKGUSE3
         LR    &PRFX.1,&PRFX.13          SET TO OUR RSA PTR
.NOSTG1  L     &PRFX.13,4(&PRFX.1)       RESET PTR TO SYS SAVE AREA
.CKGUSE3 ANOP
         L     &PRFX.1,24(0,&PRFX.13)   ACCESS PARM REG FROM OLD RSA
         L     &PRFX.13,8(0,&PRFX.13)   REPOINT TO OUR NEW RSA
&SAIMAC  SETB  1
         AGO   .DOMXIT
.B7      ST    &PRFX.2,4(0,&PRFX.13)
         ST    &PRFX.13,8(0,&PRFX.2)
.DOMXIT  ANOP
         MEXIT
.EQUTBLO ANOP
&PRFX    SETC  'R'
.EQUTBL  ANOP
&PRFX.0  EQU   0
&PRFX.1  EQU   1
&PRFX.2  EQU   2
&PRFX.3  EQU   3
&PRFX.4  EQU   4
&PRFX.5  EQU   5
&PRFX.6  EQU   6
&PRFX.7  EQU   7
&PRFX.8  EQU   8
&PRFX.9  EQU   9
&PRFX.10 EQU   10
&PRFX.11 EQU   11
&PRFX.12 EQU   12
&PRFX.13 EQU   13
&PRFX.14 EQU   14
&PRFX.15 EQU   15
         AIF   (&REG13SW EQ 1).B5
         AGO   .B2
.SETID   B     12(0,&PRFX.15)
         AIF   ('&ID'(1,1) EQ '*').CSECTNM
         DC    CL8'&ID'
         AGO   .B3
.CSECTNM ANOP
__PGM_NM DC    CL8'&SYSECT'
         AGO   .B3
.NOREG   MNOTE 12,'NO REGISTERS SPECIFIED-MACRO NOT GENERATED'
         MEXIT
.INVREG  MNOTE 12,'INVALID REGISTER SPECIFIED-MACRO GEN TERMINATED'
         MEND
###END IMITMAC0
$$$BEG EXPLSTUF
ASSEMBLER OPTION XREF(SHORT,UNREFS) (THE DEFAULT)
UNREFERENCED SYMBOLS DEFINED IN CSECTS
***
BUFLEN EQU 133 DEFINE THE BUFFER LENGTH
MVI BUFFER,C' ' CLEAR A BUFFER TO BLANKS
MVC BUFFER+1(BUFLENS1),BUFFER RIPPLE THE FIRST BLANK
S S S
BUFFER DS CL(BUFLEN)

&NAME START
J S&SYSNDX THE ASSEMBLER KNOWS WHERE TO GO:
DC 18F'0' CORRECTED!
DC C'ASSEMBLED &SYSDATC '
DC C'TIME &SYSTIME '
DC C'AT SITE &THISLOC.' ... ADDITIONAL
DC C'WITH HLASM &SYSVER. ' ... SIGNATURE
DC C'ON SYSTEM &SYSTEM_ID.' ... INFORMATION
S&SYSNDX STM R14,R12,12(R13)

RECHEAD DC Y(RECLEN) RECORD LENGTH VALUE (AS USUAL)
FIELD1 DS CL44
FIELD2 DS CL55
*  MORE FIELDS DEFINED
FIELD999 DS CL66
RECLEN EQU *SRECHEAD DEFINE THE LENGTH
ORG RECHEAD RESPOSITION AT START OF RECORD
ARECORD DS 0CL(RECLEN) DEFINE NAME AND LENGTH OF ENTIRE RECORD
ORG , RESPOSITION AFTER THE RECORD

BUFFER DS CL133
ORG BUFFER+64 FIRST INSERTION POINT
BUFINS1 DS CL12
ORG BUFFER+82 SECOND INSERTION POINT
BUFINS2 DS CL10
ORG , ADJUST LOCATION COUNTER
S S S
MVC BUFINS1,INSERT1 INSERT SOMETHING IN A MESSAGE
MVC BUFINS2,INSERT2 INSERT SOMETHING IN A MESSAGE

OR

STILL BETTER: DEFINE A DSECT TO MAP THE BUFFER AREA
USING BUFFMAP,BUFFER DEPENDENT USING STATEMENT
MVC BUFINS1,INSERT1 INSERT SOMETHING IN A MESSAGE
MVC BUFINS2,INSERT2 INSERT SOMETHING IN A MESSAGE
*
BUFFER DS CL(BUFFMAPL)
INSERT1 DS CL12
INSERT2 DS CL10
*
BUFFMAP DSECT ,
DS CL64 OFFSET TO FIRST INSERTION POINT
BUFINS1 DS CL12 FIRST INSERTION FIELD
DS CL6 POSITION AT SECOND INSERTION POINT
BUFINS2 DS CL10 SECOND INSERTION FIELD
BUFFMAPL EQU *SBUFFMAP LENGTH OF BUFFERSMAPPING DSECT

RECORD DSECT , RECORD DESCRIPTION
RECTYPE DS CL10 RECORD TYPE
RECID DS CL4 RECORD ID
RECNAME DS CL40 NAME
RECADDR DS CL66 ADDRESS
RECPHONE DS CL12 PHONE NUMBER
S S S ETC.
RECYEAR DS F PROCESSING YEAR
RECDAY DS F PROCESSING DAY OF YEAR
S S S ETC.
RECLEN EQU *SRECORD RECORD LENGTH
S S S
NEWREC DS 0D,CL(RECLEN) AREA FOR NEW RECORD
OLDREC DS 0D,CL(RECLEN) AREA FOR OLD RECORD
*
OLD USING RECORD,OLDREC MAP OLDREC (LABELED DEPENDENT USING)
NEW USING RECORD,NEWREC MAP NEWREC (LABELED DEPENDENT USING)
*
MVC NEW.RECNAME,OLD.RECNAME COPY NAME FIELD FROM OLD TO NEW

IF YOU DON'T WANT TO DELETE THE STATEMENTS, SKIP THEM:
AGO .SKIP04 SKIP THE LEFTOVERS
S S S UNREFERENCED ODDS AND ENDS
.SKIP04 ANOP , INTERVENING STATEMENTS NOT ASSEMBLED

REGISTER XREF (SPECIFY THE RXREF OPTION)

OLD WAYS                  BETTER WAYS
L 1,=F'275'               LHI 1,275
LH 2,=H'S5678'            LHI 2,S5678
L 3,=F'123456789'         LGFI 3,123456789 (64SBIT REGISTER)
                          IILF 3,123456789 (32SBIT REGISTER

ELIMINATE UNNECESSARY REGISTER ZEROING, NEEDLESS MEMORY REFERENCES
OLD WAY                   BETTER WAY
SR 1,1
ICM 1,B'11',=C'AB'        LLILL 1,C'AB'

INSTRUCTIONS REFERENCING 32-BIT REGISTERS ARE IMMEDIATELY USEFUL
OLD WAYS                  BETTER WAYS
A 6,=A(OFFSET*4)          AFI 6,OFFSET*4
CH 4,=H'S1'               CHI 4,S1
MH 2,=Y(ITEMLEN)          MHI 2,ITEMLEN
CL 9,=X'107429B3'         CLFI 9,X'107429B3'
FASTER OPERATION, SMALLER PROGRAMS, NO BASE REGISTER NEEDED

ISOLATE THE RIGHTMOST 6 BITS OF GR4:
OLD WAYS                  BETTER WAY
N 4,=X'0000003F'          NILL 4,X'3F'
SLL 4,26
SRL 4,26                  NILL 4,X'3F'
SRDL 4,6 (LOSE R5 BITS!)
SR 4,4
SLDL 4,6                  NILL 4,X'3F'
CAN THE 31-BIT-MODE ADDRESS IN R5 REFER TO ITEMS BELOW THE 16M LINE?
OLD WAY                   BETTER WAY
LR 0,5                    TMLH 5,X'7F00'
SLL 0,1                   JZ ITS_SAFE
SRA 0,25
JZ ITS_SAFE
IS THE INTEGER IN REGISTER 9 A MULTIPLE OF 4?
OLD WAY                  BETTER WAY
LR 0,9                   TMLL 9,X'0003'
N 0,=A(X'3')             JZ MULT4
JZ MULT4
IN EACH CASE: EXTRA REGISTER, EXTRA INSTRUCTIONS, OR MEMORY REFERENCE

WITH SIGNED 20-BIT DISPLACEMENT
NEW INSTRUCTION FORMAT: OPCODE R1 X2 B2 DL2 DH2 OPCODE
TRADITIONAL UNSIGNED 12-BIT DISPLACEMENT FIELD NOW NAMED DL2
HIGH-ORDER 8-BIT SIGNED DISPLACEMENT EXTENSION NAMED DH2

         INSTRUCTION   B   DL-  DH
                           <<|<<<
                           V >>>V
     SIGN BIT EXTENDED     DH   DL  (SIGNED 64SBIT DISPLACEMENT)

? DISPLACEMENT RANGE (?219,+219?1) RATHER THAN (0,4095)
T ADDRESS CALCULATION ADDS BASE/INDEX REGISTER CONTENTS AS APPROPRIATE
? NUMBER OF SIGNIFICANT DIGITS DEPENDS ON CURRENT ADDRESSING MODE
T IF THE DH FIELD IS ZERO, GET USUAL 12-BIT DISPLACEMENT
BENEFITS OF 20-BIT DISPLACEMENTS                         -512K
VERY LARGE DATA STRUCTURES ADDRESSABLE                   |
WITH A SINGLE BASE REGISTER                              |
? ADDRESSES 1MB  +-512 PER BASE REG               @ X'0' BASE REG
BASE REGISTER CAN NOW POINT TO THE                       |
MIDDLE OF A DATA STRUCTURE                               |
12-BIT DISPLACEMENT ADDRESSES ONLY 4KB                   +512K
 (ADDRESSING 1MB COULD REQUIRE 256 BASE
  REGISTERS)                                      (256 * 4K)
FEWER BASE REGISTERS ARE NEEDED TO ADDRESS LARGE AREAS!

REVIEW OF HLASM USING BASE-DISPLACEMENT RESOLUTION RULES
1. EXPRESSION AND USING-TABLE ENTRY RELOCATABILITY ATTRIBUTES MUST MATCH
2. CALCULATE POSSIBLE DISPLACEMENTS; CHOOSE SMALLEST NON-NEGATIVE
3. IF NO NON-NEGATIVE DISPLACEMENTS ARE AVAILABLE, USE SMALLEST NEGATIVE
VALUE
4. IF MORE THAN ONE SUCH SMALLEST DISPLACEMENT, CHOOSE HIGHER-NUMBERED
REGISTER





































###END EXPLSTUF
$$$BEG MVC2
         MACRO
&LAB     MVC2 &TARGET,&SOURCE PROTOTYPE STATEMENT
&LAB     CLC 0(0,0),&SOURCE X'D500 0000',S(&SOURCE)
         ORG *S6 BACK UP TO FIRST BYTE OF INSTRUCTION
         LA 0,&TARGET.(0) X'4100',S(&TARGET),S(&SOURCE)
         ORG *S4 BACK UP TO FIRST BYTE OF INSTRUCTION
         DC AL1(X'D2',L'&SOURCES1) FIRST 2 BYTES OF INSTRUCTION
         ORG *+4 STEP TO NEXT INSTRUCTION
         MEND
###END MVC2
$$$BEG ASMNCOB
*COMPILATION UNIT: LEASMCB
* =====================================================================
*   Bring up the LE/370 environment
* =====================================================================
ASMNCOB  CEEENTRY PPA=MAINPPA,AUTO=WORKSIZE
         USING WORKAREA,13
*
*   Call the COBOL program
*
         CALL  COBNASM,(X,Y)       INVOKE COBOL SUBROUTINE
*
*   Call the CEEMOUT service
*
         CALL  CEEMOUT,(MESSAGE,DESTCODE,FC)  Dispatch message
         CLC   FC(8),CEE000       Was MOUT successful?
         BE    GOOD               Yes.. skip error logic
         LH    2,MSGNO            No.. Get message number
         ABEND (2),DUMP                LIGHTS OUT!
*
*   Terminate the LE/370 environment
*
GOOD     CEETERM  RC=0            Terminate with return code zero
*
* ---------------------------------------------------------------
*
*   Data Constants and Static Variables
*
Y        DC    PL3'+200'          2nd parm to COBOL program (input)
MESSAGE  DS    0H
MSGLEN   DC    Y(MSGEND-MSGTEXT)
MSGTEXT  DC    C'AFTER CALL TO COBOL: X='
X        DS    ZL6                1st parm for COBOL program (output)
MSGEND   EQU   *
DESTCODE DC    F'2'               Directs message to MSGFILE
CEE000   DC    3F'0'              Success condition token
FC       DS    0F                 12-byte feedback/condition code
SEV      DS    H                  severity
MSGNO    DS    H                  message number
CSC      DS    X                  flags - case/sev/control
CASE     EQU   X'C0'  11.....     case (1 or 2)
SEVER    EQU   X'38'  ..111..     severity (0 thru 4)
CNTRL    EQU   X'03'  .....11     control (1=IBM FACID, 0=USER)
FACID    DS    CL3                facility ID
ISI      DS    F                  index into ISI block
*
MAINPPA  CEEPPA                   Constants describing the code block
* ====================================================================
*   Workarea
* ====================================================================
WORKAREA DSECT
         ORG *+CEEDSASZ Leave space for the DSA fixed part
         DS 0D
WORKSIZE EQU *-WORKAREA
         CEEDSA  ,                Mapping of the Dynamic Save Area
         CEECAA  ,                Mapping of the Common Anchor Area
         CEEEDB  ,                Mapping of the Enclave Data Block
*
         END   ASMNCOB
###END ASMNCOB
$$$BEG EXPLQSAM
* DYNAMIC STORAGE THAT MUST RESIDE BELOW 16MB LINE DUE TO DCB & EXIT
* LIST RESTRICTIONS.  GET SEPARATE STORAGE FOR THIS.
* ********************* BEG OF WORKAREA DYN STG
WORKAREA DSECT
* ********************* BEG OF SYSPRINT DYN STG
STAOFDCB   DS   CL8
*
SYSPR_DCB DS   XL(SYSPREND) DCB LNG QS  ACTUAL QSAM DCB
* EACH ENTRY IN DCB EXIT LIST IS FOUR BYTES.
STAOFOPN   DS   CL8
*
SY_EXL      DS    X         LAST ENTRY IN EXIT LIST AND FOR DCB OPENX
SY_EXLOPEN  DS    AL3       ADDRESS OF 24-BIT DCB OPEN EXIT ROUTINE
SYPENLIST DS    XL(LSPROPPL) LEN OPEN PARAMETER LIST
*
ENDOFOPN   DS   CL8
* ********************* END OF SYSPRINT DYN STG
* ********************* BEG OF  MYPRINT DYN STG
*
MYPR_DCB DS   XL(MYPREND) DCB LNG QS  ACTUAL QSAM DCB
* EACH ENTRY IN DCB EXIT LIST IS FOUR BYTES.
MY_EXL      DS    X         LAST ENTRY IN EXIT LIST AND FOR DCB OPENX
MY_EXLOPEN  DS    AL3       ADDRESS OF 24-BIT DCB OPEN EXIT ROUTINE
MYPENLIST DS    XL(LSPROPPL) LEN OPEN PARAMETER LIST
*
* ********************* END OF  MYPRINT DYN STG
* ********************* BEG OF  MYSIN   DYN STG
*
MSIN_DCB DS   XL(MSINEND) DCB LNG QS  ACTUAL QSAM DCB
* EACH ENTRY IN DCB EXIT LIST IS FOUR BYTES.
MS_EXL      DS    X         LAST ENTRY IN EXIT LIST AND FOR DCB OPENX
MS_EXLOPEN  DS    AL3       ADDRESS OF 24-BIT DCB OPEN EXIT ROUTINE
MSPENLIST DS    XL(LSPROPPL) LEN OPEN PARAMETER LIST
*
* ********************* END OF  MYSIN   DYN STG
*
CLOLIST  DS    XL(LSPRCLPL) LEN CLOS PARAMETER LIST
* THE FOLLOWING IS EXECUTABLE CODE TO BRANCH ABOVE THE 16MB LINE.
         DS    0H
OPEN24   DS    XL(LENOPEN24)   DCB OPEN EXIT BELOW 16MB LINE
ADOPEN31 DS    A         ADDRESS OF DCB OPEN EXIT ABOVE THE LINE
*
ENDOFDCB DS    CL8
LENAREA  EQU   *-WORKAREA
*
* ********************* END OF  WORKAREA    STG
*
MYAREA   INITSTG USEREG=4
SINAREA  DS    CL256
*
EXPLQSAM CSECT
EXPLQSAM AMODE 31        EXECUTE IN 31-BIT ADDRESSING MODE
EXPLQSAM RMODE ANY       RESIDE ABOVE THE 16MB LINE
         INITMAC 3,EQU=R,ID=EXPLQSAM
         MVI   MSGAREA1,X'40'
         MVC MSGAREA,MSGAREA1
*
* GET 24 BIT STORAGE BASED ON TOTAL LENGTH OF WORKAREA
         STORAGE OBTAIN,LENGTH=LENAREA,LOC=BELOW  GET DCB & ETC.
         LR    R2,R1
         USING WORKAREA,R2
* MOVE EYE CATCHERS TO 24 BIT WORKAREA
         MVC   STAOFDCB,=C'STAOFDCB'
         MVC   STAOFOPN,=C'STAOFOPN'
         MVC   ENDOFOPN,=C'ENDOFOPN'
         MVC   ENDOFDCB,=C'ENDOFDCB'
*
         LA    R0,OPEN24           POINT THE EXIT LIST TO THE EXIT RTN
         STCM  R0,B'0111',SY_EXLOPEN    THAT IS BELOW THE LINE
         STCM  R0,B'0111',MY_EXLOPEN    THAT IS BELOW THE LINE
         STCM  R0,B'0111',MS_EXLOPEN    THAT IS BELOW THE LINE
         MVI   SY_EXL,X'85'      SET LAST ENTRY & DCB OPEN EXIT LIST
         MVI   MY_EXL,X'85'      SET LAST ENTRY & DCB OPEN EXIT LIST
         MVI   MS_EXL,X'85'      SET LAST ENTRY & DCB OPEN EXIT LIST
         MVC   OPEN24,MODOPEN24    MOVE GLUE CODE TO BELOW LINE
         LA    R0,OPEN31           SHOW THE 24-BIT CODE WHERE THE
         ST    R0,ADOPEN31           31-BIT CODE IS ABOVE THE LINE
         OI    ADOPEN31,X'80'      SET BIT 0 TO AMODE 31 IN ADDRESS
*
         MVC   MSIN_DCB,MODSINDCB CREATE DCB BELOW THE LINE
         LA    R0,MS_EXL
         STCM  R0,B'0111',DCBEXLSA-IHADCB+MSIN_DCB
         MVC   MSPENLIST,MODSINPEN  BUILD OPEN PARAMETER LIST
         OPEN  (MSIN_DCB),MF=(E,MSPENLIST) LIST IS BELOW THE LINE
*
         MVC   SYSPR_DCB,MODSPRDCB CREATE DCB BELOW THE LINE
         LA    R0,SY_EXL
         STCM  R0,B'0111',DCBEXLSA-IHADCB+SYSPR_DCB
         MVC   SYPENLIST,MODSPRPEN  BUILD OPEN PARAMETER LIST
         OPEN  (SYSPR_DCB),MF=(E,SYPENLIST) LIST IS BELOW THE LINE
*
         MVC   MYPR_DCB,MODMPRDCB  CREATE MYPRINT DBC BELOW
         LA    R0,MY_EXL
         STCM  R0,B'0111',DCBEXLSA-IHADCB+MYPR_DCB
         MVC   MYPENLIST,MODSPRPEN  BUILD OPEN PARM LIST USING GENERIC
         OPEN  (MYPR_DCB),MF=(E,MYPENLIST)
*
         MVC   MSGAREA(L'MYPR_BEGINMSG),MYPR_BEGINMSG
         BAS   R9,WRTMSG_MYPR
*
         MVC   MSGAREA(L'SYSPR_BEGINMSG),SYSPR_BEGINMSG
         BAS   R9,WRTMSG_SYSPR
*
TOPOFLOP EQU   *
         GET   MSIN_DCB,SINAREA
         MVC   MSGAREA,SINAREA
         BAS   R9,WRTMSG_MYPR
         MVC   MSGAREA,SINAREA
         BAS   R9,WRTMSG_SYSPR
         B     TOPOFLOP
*
MODSINRX EQU   *
         MVC   CLOLIST,MODSINCLO   BUILD OPEN PARAMETER LIST
         CLOSE (MSIN_DCB),MF=(E,CLOLIST)
*
         MVC   CLOLIST,MODSPRCLO  BUILD OPEN PARAMETER LIST
         CLOSE (SYSPR_DCB),MF=(E,CLOLIST)
*
         MVC   CLOLIST,MODSPRCLO  BUILD OPEN PARAMETER LIST
         CLOSE (MYPR_DCB),MF=(E,CLOLIST)
*
         STORAGE RELEASE,LENGTH=LENAREA,ADDR=(R2)
*
         RTNMAC
***
WRTMSG_SYSPR   EQU   *
         LA    R1,SYSPR_DCB
         B     WRTMSG
WRTMSG_MYPR   EQU   *
         LA    R1,MYPR_DCB
WRTMSG   EQU   *
         PUT   (1),MSGAREA
         MVC   MSGAREA,MSGAREA1
         BR    R9
*
OPEN31   EQU   *         ENTRY POINT OF DCB OPEN EXIT ABOVE THE LINE
         BSM   0,R14     SWITCH TO 24-BIT MODE AND RETURN TO OPEN
*
MODSINPEN OPEN (,INPUT),MF=L,MODE=31 MODEL OPEN PARAMETER LIST
LSINOPPL EQU   *-MODSINPEN
*
MODSINCLO CLOSE (),MF=L,MODE=31    MODEL OPEN PARAMETER LIST
LSINCLPL EQU   *-MODSINCLO
*
MODSPRPEN OPEN (,OUTPUT),MF=L,MODE=31 MODEL OPEN PARAMETER LIST
LSPROPPL EQU   *-MODSPRPEN
*
MODSPRCLO CLOSE (),MF=L,MODE=31    MODEL CLOSE PARAMETER LIST
LSPRCLPL EQU   *-MODSPRCLO
*
* THE FOLLOWING IS THE MODEL FOR THE DCB OPEN EXIT ROUTINE ENTRY POINT
* WE COPY THIS CODE TO THE WORK AREA, WHICH IS BELOW THE LINE.  THE
* BSM SETS THE CURRENT ADDRESSING MODE (24) IN BIT 0 OF R14 WITHOUT
* CHANGING ANYTHING ELSE IN R14.  IT ALSO SWITCHES TO 31-BIT DUE TO
* BIT 0 IN R15 AND BRANCHES TO THE ADDRESS IN R15.
MODOPEN24 L    R15,ADOPEN31-OPEN24(,R15) ENTRY PT TO DCB OPEN EXIT RTN
         BSM   R14,R15        SAVE AMODE, SWITCH TO 31-BIT AND BRANCH
LENOPEN24 EQU  *-MODOPEN24
*
SYSPR_BEGINMSG DC   C'THIS IS A TEST FOR QSAM ABOVE TO SYSPRINT'
MYPR_BEGINMSG DC   C'THIS IS A TEST FOR QSAM ABOVE TO MYPRINT'
*
* DCB MODEL FOR SYSPRINT, WHICH IS ABOVE THE LINE.
MODSPRDCB DCB  DSORG=PS,DDNAME=SYSPRINT,MACRF=(PM),LRECL=80
SYSPREND EQU   *-MODSPRDCB
*
* DCB MODEL FOR MYPRINT,  WHICH IS ABOVE THE LINE.
MODMPRDCB DCB  DSORG=PS,DDNAME=MYPRINT,MACRF=(PM),LRECL=80
MYPREND EQU   *-MODMPRDCB
*
* DCB MODEL FOR SYSIN, WHICH IS ABOVE THE LINE.
MODSINDCB DCB  DSORG=PS,DDNAME=SYSIN,MACRF=(GM),DCBE=MSDCBE
MSINEND EQU   *-MODSINDCB
*
MSDCBE   DCBE  EODAD=MODSINRX
         DCBD  DSORG=PS,DEVD=DA  MAPPING MACRO FOR DCB
*
         END
###END EXPLQSAM
$$$BEG PASSPAR1
*  OS STD PARM PASS
*   INCOMING R1 PTR TO FW PARMAP
*    THIS PTR HAS X'80' ON IN HIGH ORDER BIT OF LAST PARM PASSED
*     AND ADDR TO ACTUAL PARM LL AREA
*    LL AREA HAS LENGTH OF ACTUAL PARM VALUE
*    VALUE IMMEDIATELY FOLLOWS LL AREA
*  SO WE L   R1,0(R1)
*        ST  R1,PARMAP
*        LH  R2,0(R1)
*        STH R2,PARMAL
*        LA  R1,2(R1)
*        ST  R1,PARMA
PARMAP   DS    F
PARMAL   DS    H
PARMA    DS    F
###END PASSPAR1
$$$BEG PASSPARM
         DS    0D
PARMARSA DS    18F
PARMA    DS    F
PARMARSV DS    H
PARMAREA DS    0H
PARMAL   DS    H
PARMAV   DS    F
###END PASSPARM
$$$BEG IGGCSILC
*********************************************************************
*                                                                   *
*  PROGRAM NAME: IGGCSILC                                           *
*                                                                   *
*  DESCRIPTION: THIS PROGRAM PRODUCES OUTPUT SIMILAR TO IDCAMS      *
*               LISTCAT NAME. IT IS FASTER THAN IDCAMS LISTCAT.     *
*                                                                   *
*        INPUT: SYSIN DD (80 BYTE RECORD)                           *
*               CATALOG NAME, LEFT JUSTIFIED TO FIRST POSITION      *
*               MORE THAN ONE RECORD CAN BE SUPPLIED                *
*               PROCESSING ENDS AT END OF DATA                      *
*                                                                   *
*       OUTPUT: SYSOUT DD                                           *
*               LIST OF ENTRY NAMES CONTAINED IN THE CATALOG        *
*               SUMMARY OF NUMBER OF EACH ENTRY TYPE FOUND          *
*               TOTAL OF ALL ENTRIES FOUND IN THE CATALOG           *
*                                                                   *
* REQUIREMENTS: DFP 3.1.0 OR A LATER VERSION IS NECESSARY IN        *
*               ORDER TO RUN THIS PROGRAM                           *
*                                                                   *
*********************************************************************
IGGCSILC CSECT
IGGCSILC AMODE 24
IGGCSILC RMODE 24
         STM   14,12,12(13)
         BALR  12,0
         USING *,12
         ST    13,SAVE+4
         LA    13,SAVE
         OPEN  (PUTDCB,OUTPUT)
         OPEN  (INDCB,INPUT)
         ZAP   PAGECNT,ZERO                 INITILIZE THE PAGE COUNT
NEXTCATN EQU   *
         GET   INDCB,DATAREC                GET CATALOG NAME
         ZAP   AIX,ZERO                     INIT DATA
         ZAP   ALIAS,ZERO                   INIT DATA
         ZAP   CLUSTER,ZERO                 INIT DATA
         ZAP   DATA,ZERO                    INIT DATA
         ZAP   GDG,ZERO                     INIT DATA
         ZAP   INDEX,ZERO                   INIT DATA
         ZAP   NONVSAM,ZERO                 INIT DATA
         ZAP   PAGESPAC,ZERO                INIT DATA
         ZAP   PATH,ZERO                    INIT DATA
         ZAP   USERCAT,ZERO                 INIT DATA
         ZAP   TOTAL,ZERO                   INIT DATA
         MVC   CSICATNM(44),DATAREC         MOVE CATALOG NAME
CATLINE  EQU   *
         ZAP   LINECNT,LINELMT              FORCE FIRST PAGE
         MVC   OUTCAT(44),DATAREC           MOVE CATALOG NAME
NEXTRCD  EQU   *
         LA    1,PARMLIST
         CALL  IGGCSI00
         LTR   15,15                        TEST RETURN CODE
         BZ    NORTCODE                     IF ZERO BYPASS CONVERSION
         CLC   PARMRC(4),FENTERR
         BE    NORTCODE
         MVC   RETDATA(4),PARMRC            MOVE CODES TO WORK AREA
         BAL   3,ERRCNVRT
         B     ENDRTN
NORTCODE EQU   *
         USING DATARET,5
         LA    5,DATAAREA                   LOAD DSECT REG
         L     1,DRETCD                     GET RETURN CODE
         LTR   1,1                          TEST RETURN CODE
         BZ    NEXTFLD                      CONTINUE IF NO ERRORS
         MVC   RETDATA(4),DRETCD            MOVE CODES TO WORK AREA
         BAL   3,ERRCNVRT                   BRANCH TO ERROR CONVERT
         B     ENDRTN
NEXTFLD  EQU *
         LA    4,DATAEND                    GET BEGINNING OF INFO
         LA    7,64                         LENGTH OF ENTRY DATA
         USING ENTRY,4
NEXTENT  EQU   *
         TM    EFLAG,X'40'                  DID ERROR OCCUR FOR ENTRY
         BO    ERRDET                        YES
         B     AIXENT                        NO
ERRDET   EQU   *                            ERROR DETECTED
         MVC   RETDATA(4),EERRCOD           MOVE CODES TO WORK AREA
         BAL   3,ERRCNVRT                   BRANCH TO ERROR CONVERT
         LA    1,50                         ADD ENTRY HDR LENGTH
         AR    7,1                          ADD ENTRY DATA LEN
         AR    4,1                          ADD ENTRY DATA LEN
         C     7,DUSEDLEN                   COMPARE USED TO CALC LEN
         BNM   NEXTRESM                     IF GT OR EQ  RESUME TEST
         B     NEXTENT                      NEXT ENTRY
AIXENT   EQU   *
         CLI   ETYPE,C'G'                   IF AIX     TYPE
         BNE   ALIASENT                       NO
         AP    AIX,ONE                       ADD ONE TO COUNT
         MVC   TITLEOUT(14),AIXOUT           MOVE TYPE INFO
         MVC   OUTNAME(44),ENAME             MOVE NAME INFO
         BAL   3,PRINTNAM                   PRINT NAME OF ENTRY
         B     NEXTKEY                      CONTINUE
ALIASENT EQU   *
         CLI   ETYPE,C'X'                   IF ALIAS   TYPE
         BNE   CLUSTENT                       NO
         AP    ALIAS,ONE                     ADD ONE TO COUNT
         MVC   TITLEOUT(14),ALIASOUT         MOVE TYPE INFO
         MVC   OUTNAME(44),ENAME             MOVE NAME INFO
         BAL   3,PRINTNAM                   PRINT NAME OF ENTRY
         B     NEXTKEY                      CONTINUE
CLUSTENT EQU   *
         CLI   ETYPE,C'C'                   IF CLUSTER TYPE
         BNE   DATAENT                        NO
         TM    ECATTR,X'01'                 TEST FOR PAGESPACE
         BO    PAGEENT
         AP    CLUSTER,ONE                   ADD ONE TO COUNT
         MVC   TITLEOUT(14),CLUSTOUT         MOVE TYPE INFO
         CLI   ENAME,X'00'                  IF CATALOG NAME
         BNE   NOTCAT                         NO NEXT KEY
         MVI   OUTNAME,C'0'                 FAKE CATALOG NAME
         MVC   OUTNAME+1(43),OUTNAME          OF ZEROES
         B     CONTCAT
NOTCAT   EQU   *
         MVC   OUTNAME(44),ENAME             MOVE NAME INFO
CONTCAT  EQU   *
         BAL   3,PRINTNAM                   PRINT NAME OF ENTRY
         B     NEXTKEY                      CONTINUE
DATAENT  EQU   *
         CLI   ETYPE,C'D'                   IF DATA    TYPE
         BNE   GDGENT                         NO
         AP    DATA,ONE                      ADD ONE TO COUNT
         MVC   TITLEOUT(14),DATAOUTX        MOVE TYPE INFO
         MVC   OUTNAME(44),ENAME             MOVE NAME INFO
         BAL   3,PRINTNAM                   PRINT NAME OF ENTRY
         B     NEXTKEY                      CONTINUE
GDGENT   EQU   *
         CLI   ETYPE,C'B'                   IF GDG     TYPE
         BNE   INDEXENT                       NO
         AP    GDG,ONE                       ADD ONE TO COUNT
         MVC   TITLEOUT(14),GDGOUT          MOVE TYPE INFO
         MVC   OUTNAME(44),ENAME             MOVE NAME INFO
         BAL   3,PRINTNAM                   PRINT NAME OF ENTRY
         B     NEXTKEY                      CONTINUE
INDEXENT EQU   *
         CLI   ETYPE,C'I'                   IF INDEX   TYPE
         BNE   NVSAMENT                       NO
         AP    INDEX,ONE                     ADD ONE TO COUNT
         MVC   TITLEOUT(14),INDEXOUX        MOVE TYPE INFO
         MVC   OUTNAME(44),ENAME             MOVE NAME INFO
         BAL   3,PRINTNAM                   PRINT NAME OF ENTRY
         B     NEXTKEY                      CONTINUE
NVSAMENT EQU   *
         CLI   ETYPE,C'A'                   IF NONVSAM TYPE
         BE    NVSMCONT                       YES
         CLI   ETYPE,C'H'                   IF GDS COUNTS AS NONVSAM
         BNE   PATHENT                        NO
NVSMCONT EQU   *
         AP    NONVSAM,ONE                   ADD ONE TO COUNT
         MVC   TITLEOUT(14),NONVOUT         MOVE TYPE INFO
         MVC   OUTNAME(44),ENAME             MOVE NAME INFO
         BAL   3,PRINTNAM                   PRINT NAME OF ENTRY
         B     NEXTKEY                      CONTINUE
PAGEENT  EQU   *
         AP    PAGESPAC,ONE                  ADD ONE TO COUNT
         MVC   TITLEOUT(14),PAGEOUT          MOVE TYPE INFO
         MVC   OUTNAME(44),ENAME             MOVE NAME INFO
         BAL   3,PRINTNAM                   PRINT NAME OF ENTRY
         B     NEXTKEY                      CONTINUE
PATHENT  EQU   *
         CLI   ETYPE,C'R'                   IF PATH    TYPE
         BNE   USERENT                        NO
         AP    PATH,ONE                      ADD ONE TO COUNT
         MVC   TITLEOUT(14),PATHOUT          MOVE TYPE INFO
         MVC   OUTNAME(44),ENAME             MOVE NAME INFO
         BAL   3,PRINTNAM                   PRINT NAME OF ENTRY
         B     NEXTKEY                      CONTINUE
USERENT  EQU   *
         CLI   ETYPE,C'U'                   IF USERCAT TYPE
         BNE   NEXTKEY                        NO
         AP    USERCAT,ONE                   ADD ONE TO COUNT
         MVC   TITLEOUT(14),USEROUT          MOVE TYPE INFO
         MVC   OUTNAME(44),ENAME             MOVE NAME INFO
         BAL   3,PRINTNAM                   PRINT NAME OF ENTRY
NEXTKEY  EQU   *                            CALCULATE NEXT KEY POSITION
         SR    1,1                          CLEAR REG 1
         LH    1,EDATALN                    INSERT ENTRY DATA LEN
         LA    1,46(1)                      ADD ENTRY HDR LENGTH
         AR    7,1                          ADD ENTRY DATA LEN
         AR    4,1                          ADD ENTRY DATA LEN
         C     7,DUSEDLEN                   COMPARE USED TO CALC LEN
         BNM   NEXTRESM                     IF GT OR EQ  RESUME TEST
         B     NEXTENT                      NEXT ENTRY
NEXTRESM CLI   CSIRESUM,C'Y'                IF MORE ENTRIES
         BE    NEXTRCD                      NEXT RECORD
ENDRTN   EQU   *                            ELSE FINISH
         CP    LINECNT,ENDNUM               COMPARE TO SEE IF SUMMARY
         BL    SUMFITS                        FITS ON PAGE
         ZAP   LINECNT,LINELMT              FORCE NEW PAGE
SUMFITS  EQU   *
         MVI   OUTPUT,C' '
         MVC   OUTPUTP1(131),OUTPUT         CLEAR LINE
         MVC   OUTPUTP1(45),OUTLINE3
         BAL   2,PRINTRTN                   BRANCH & LINK TO PRINT
         LA    10,AIX                       CALCULATE TOTAL ENTRIES
         LA    8,10
TOTLOOP  EQU   *
         AP    TOTAL,0(5,10)                ADD ENTRY COUNT TO TOTAL
         LA    10,5(10)                     ADD INDEX FOR NEXT COUNT
         BCT   8,TOTLOOP
         LA    9,AIXOUT
         LA    10,AIX
         LA    8,11
PRTLOOP  EQU   *                            SET UP ENTRY COUNT
         BAL   3,PRINTCNT                   PRINT COUNT
         LA    9,14(9)                      ADD INDEX FOR NEXT LITERAL
         LA    10,5(10)                     ADD INDEX FOR NEXT COUNT
         BCT   8,PRTLOOP
         B     NEXTCATN
CLOSEEND EQU   *
         CLOSE (PUTDCB,)
         CLOSE (INDCB,)
         L     13,SAVE+4
         L     14,12(13)
         LM    00,12,20(13)
         BR    14
*
*        PRINT THE ENTRY COUNT LINE ROUTINE
*
PRINTCNT EQU   *
         MVI   OUTPUT,C' '
         MVC   OUTPUTP1(131),OUTPUT
         MVC   OUTCNT,PATTERN               SET UP THE PATTERN
         ED    OUTCNT,0(10)                 EDIT AMOUNT
         MVC   TITLECNT(14),0(9)
         MVC   OUTPUTP1(43),OUTLINE4
         BAL   2,PRINTRTN
         BR    3
*
*        PRINT THE ENTRY NAME ROUTINE
*
PRINTNAM EQU   *
         MVI   OUTPUT,C' '
         MVC   OUTPUTP1(131),OUTPUT
         MVC   OUTPUTP1(59),OUTLINE2
         BAL   2,PRINTRTN
         BR    3
*
*        CONVERT RETURN REASON CODES AND PRINT ROUTINE
*
ERRCNVRT EQU *
         MVI   OUTPUT,C' '
         MVC   OUTPUT+1(131),OUTPUT
         SR    2,2
         IC    2,RETDATA+3
         CVD   2,DECIMAL
         UNPK  UNPKAREA(4),DECIMAL+6(2)     CONVERT RETURN CODE
         OI    UNPKAREA+3,X'F0'
         MVC   RTN(3),UNPKAREA+1
         SR    2,2                          CONVERT REASON CODE
         IC    2,RETDATA+2
         CVD   2,DECIMAL
         UNPK  UNPKAREA(4),DECIMAL+6(2)
         OI    UNPKAREA+3,X'F0'
         MVC   RSN(3),UNPKAREA+1
         MVC   MODIDO(2),RETDATA             MOVE MODULE ID
         MVC   ERRENT,ENAME
         MVC   OUTPUTP1(105),ERRORMSG
         BAL   2,PRINTRTN
         BR    3
*
*        PRINT OUTPUT LINE ROUTINE
*
PRINTRTN EQU *
         CP    LINECNT,LINELMT              LINECNT REACHED LINE LIMIT?
         BL    PUTLINE                      IF NOT WRITE LINE
         AP    PAGECNT,ONE                  ADD ONE TO PAGE CNT
         MVC   PAGEPRT,PATTERN2             MOVE PATTERN FOR CONVERSION
         ED    PAGEPRT,PAGECNT              CONVERT PAGE COUNT
         PUT   PUTDCB,PAGELINE              PUT LINE
         MVI   OUTPUT1,C' '
         MVC   OUTPUT11(132),OUTPUT1
         MVC   OUTPUT11(97),OUTLINE1
         PUT   PUTDCB,OUTPUT1               PUT LINE
         ZAP   LINECNT,TWO                  PUT ONE IN LINE COUNT
PUTLINE  EQU   *
         MVI   OUTPUT,C' '                  ADVANCE LINE
         PUT   PUTDCB,OUTPUT                PUT LINE
         AP    LINECNT,ONE                  ADD ONE TO LINE COUNT
         BR    2
*
         DS    0D
ZERO     DC    PL1'0'                    PACKED ZERO
ONE      DC    PL1'1'                    PACKED ONE
TWO      DC    PL1'2'                    PACKED ONE
ENDNUM   DC    PL2'15'                   ENDING NUMBER OF LINES
PAGECNT  DC    PL3'0'                    PAGE COUNT
LINECNT  DC    PL2'0'                    LINE COUNT
LINELMT  DC    PL2'26'                   LINE LIMIT
AIX      DC    PL5'0'                    AIX COUNT
ALIAS    DC    PL5'0'                    ALIAS COUNT
CLUSTER  DC    PL5'0'                    CLUSTER COUNT
DATA     DC    PL5'0'                    DATA COUNT
GDG      DC    PL5'0'                    GDG COUNT
INDEX    DC    PL5'0'                    INDEX COUNT
NONVSAM  DC    PL5'0'                    NONVSAM COUNT
PAGESPAC DC    PL5'0'                    PAGESPACE COUNT
PATH     DC    PL5'0'                    PATH COUNT
USERCAT  DC    PL5'0'                    USER CATALOG COUNT
TOTAL    DC    PL5'0'                    TOTAL COUNT
*
**********************************************************************
*                                                                    *
* PARAMETER LIST FOR IGGCSI00 INVOCATION                             *
*                                                                    *
**********************************************************************
*
PARMLIST DS    0D
         DC    A(MODRSNRT)                MODULE/REASON/RETURN
         DC    A(CSIFIELD)
         DC    A(DATAAREA)
*
*
*
**********************************************************************
*                                                                    *
* MODULE ID/REASON CODE/RETURN CODE                                  *
*                                                                    *
**********************************************************************
*
MODRSNRT    DS 0F
PARMRC      DS 0CL4
MODID       DC XL2'0000'     MODULE ID
RSNCODE     DC XL1'00'       REASON CODE
RTNCODE     DC XL1'00'       RETURN CODE
**********************************************************************
*                                                                    *
* PARAMETER FIELDS FOR CATALOG SEARCH INTERFACE (CSI)                *
*                                                                    *
**********************************************************************
*
CSIFIELD    DS 0F
CSIFILTK    DC CL44'**'  FILTER   KEY
CSICATNM    DC CL44' '        CATALOG NAME OR BLANKS
CSIRESNM    DC CL44' '        RESUME NAME OR BLANKS
CSIDTYPD    DS 0CL16          ENTRY TYPES
CSIDTYPS    DC CL16'                '
CSIOPTS     DS 0CL4           CSI OPTIONS
CSICLDI     DC CL1'Y'         RETURN D&I IF C A MATCH Y OR BLNK
CSIRESUM    DC CL1' '         RESUME FLAG         Y OR BLANK
CSIS1CAT    DC CL1'Y'         SEARCH CATALOG      Y OR BLANK
CSIRESRV    DC XL1'00'        RESERVED
CSINUMEN    DC H'1'           NUMBER OF ENTRIES FOLLOWING
CSIENTS     DS 0CL8           VARIABLE NUMBER OF ENTRIES FOLLOW
CSIFLDNM    DC CL8'CATTR   '  FIELD NAME
*
ERRORMSG DS    0CL105
         DC    CL7' ENTRY '
ERRENT   DS    CL44
         DC    CL22' RECEIVED RETURN CODE '
RTN      DS    CL3
         DC    CL13' REASON CODE '
RSN      DS    CL3
         DC    CL11' MODULE ID '
MODIDO   DS    CL2
OUTLINE1 DS    0CL97
         DC    CL29' '
         DC    CL24'LISTING FROM CATALOG -- '
OUTCAT   DS    CL44
*
OUTLINE2 DS    0CL59
TITLEOUT DS    CL14
         DC    CL1' '
OUTNAME  DS    CL44
*
AIXOUT   DC    CL14'AIX ----------'
ALIASOUT DC    CL14'ALIAS --------'
CLUSTOUT DC    CL14'CLUSTER ------'
DATAOUT  DC    CL14'DATA ---------'
GDGOUT   DC    CL14'GDG ----------'
INDEXOUT DC    CL14'INDEX --------'
NONVOUT  DC    CL14'NONVSAM ------'
PAGEOUT  DC    CL14'PAGESPACE ----'
PATHOUT  DC    CL14'PATH ---------'
USEROUT  DC    CL14'USERCATALOG --'
TOTALOUT DC    CL14'TOTAL --------'
*
DATAOUTX DC    CL14'   DATA ------'
INDEXOUX DC    CL14'  INDEX ------'
CATNAM   DC    CL44'0'
*
OUTLINE3 DS    0CL45
         DC    CL9' '
         DC    CL36'THE NUMBER OF ENTRIES PROCESSED WAS:'
*
OUTLINE4 DS    0CL43
         DC    CL19' '
TITLECNT DS    CL14
OUTCNT   DS    CL10
PAGELINE DS    0CL132
         DC    CL1'1'
         DC    CL100' '
         DC    CL5'PAGE '
PAGEPRT  DS    CL8
         DC    CL19' '
*
DATAREC  DS    CL80
SAVE     DS    18F
PUTDCB   DCB   MACRF=PM,DSORG=PS,DDNAME=SYSOUT,RECFM=FA,               X
               BLKSIZE=133
INDCB    DCB   MACRF=GM,DSORG=PS,DDNAME=SYSIN,LRECL=80,RECFM=FB,       X
               BLKSIZE=800,EODAD=CLOSEEND
SAVE15   DC    F'0'
RETDATA  DC    F'0'
DECIMAL  DC    D'0'
UNPKAREA DC    XL4'0'
UNPK1    DC    XL11'0'
PATTERN  DC    XL10'60202020202020202120'
PATTERN2 DC    XL8'40202020202120'
OUTPUT   DS    CL1
OUTPUTP1 DS    132CL1' '
OUTPUT1  DS    CL1
OUTPUT11 DS    132CL1' '
         DS    0F
*
NOTFND   DC    XL4'C5C72A08'            NOT FOUND CODE FROM CATALOG
FENTERR  DC    XL4'C6E20464'            FIELD ENTRY ERROR CODE FROM CAT
DATAAREA DS    0F
         DC    F'65535'
         DS    XL65535
DATARET  DSECT
DWORKLEN DS    F
DREQLEN  DS    F
DUSEDLEN DS    F
DPFPLS   DS    H
DCATFLGS DS    CL1
DCATTYPE DS    CL1
DCATNAME DS    CL44
DRETCD   DS    0CL1
DMODID   DS    CL2
DRSNCOD  DS    CL1
DRETCOD  DS    CL1
DATAEND  DS    0F
ENTRY    DSECT
EFLAG    DS    XL1
ETYPE    DS    XL1
ENAME    DS    CL44
EERRCOD  DS    0XL4
EDATALN  DS    XL2
EFLD1LN  DS    XL2
EFLD2LN  DS    XL2
ECATTR   DS    XL1
ENTEND   DS    0XL1
         END   IGGCSILC
###END IGGCSILC
$$$BEG EXPLBASE
*PROCESS MXREF(FULL)
*PROCESS INFO
* SAMPLE PROGRAM FROM ASM SERVICES GUIDE, BASIC LINKAGE
PGM       CSECT
PGM       AMODE 31
PGM       RMODE ANY
          STM 14,12,12(13) SAVE CALLER'S REGISTERS IN CALLER-
* PROVIDED R13 SAVE AREA
          LR 12,15 SET UP PROGRAM BASE REGISTER
          USING PGM,12
          GETMAIN RU,LV=72 GET MY REENTRANT SAVEAREA
          ST 13,4(,1) SAVE CALLER'S SAVEAREA ADDRESS IN MY
* SAVEAREA (BACKWARD CHAIN)
          ST 1,8(,13) SAVE MY SAVEAREA ADDRESS IN CALLER'S
* SAVEAREA (FORWARD CHAIN)
          LR 13,1 PUT MY SAVEAREA ADDRESS IN R13
* END OF ENTRY CODE, BEGIN PROGRAM CODE HERE ...
          L 15,=V(NEXTPGM)
          BASR 14,15
* BEGIN EXIT CODE
DONIT     EQU *
          LR 1,13 COPY MY SAVEAREA ADDRESS
          L 13,4(,13) RESTORE CALLER'S SAVEAREA ADDRESS
          FREEMAIN RU,A=(1),LV=72 FREE MY REENTRANT SAVEAREA
          SLR 15,15 SET RETURN CODE OF ZERO
          L 14,12(,13) RESTORE CALLER'S R14
          LM 2,12,28(13) RESTORE CALLER'S R2-R12
          BR 14 RETURN TO CALLER
          LTORG
NEXTPGM@  DC V(NEXTPGM)
          END
###END EXPLBASE
$$$BEG CEMVAL2
         DC    CL16'NOTAPPLIC       '  001
         DC    CL16'BDAM            '  002
         DC    CL16'VSAM            '  003
         DC    CL16'REMOTE          '  004
         DC    CL16'ESDS            '  005
         DC    CL16'KSDS            '  006
         DC    CL16'RRDS            '  007
         DC    CL16'KEYED           '  008
         DC    CL16'NOTKEYED        '  009
         DC    CL16'BASE            '  010
         DC    CL16'PATH            '  011
         DC    CL16'FIXED           '  012
         DC    CL16'VARIABLE        '  013
         DC    CL16'UNDEFINED       '  014
         DC    CL16'UNVAILABLE      '  015
         DC    CL16'BLOCKED         '  016
         DC    CL16'UNBLOCKED       '  017
         DC    CL16'OPEN            '  018
         DC    CL16'CLOSED          '  019
         DC    CL16'OPENING         '  020
         DC    CL16'CLOSING         '  021
         DC    CL16'CLOSEREQUEST    '  022
         DC    CL16'ENABLED         '  023
         DC    CL16'DISABLED        '  024
         DC    CL16'DISABLING       '  025
         DC    CL16'OLD             '  026
         DC    CL16'SHARE           '  027
         DC    CL16'NEW             '  028
         DC    CL16'RECOVERABLE     '  029
         DC    CL16'NOTRECOVABLE    '  030
         DC    CL16'EMPTYREQ        '  031
         DC    CL16'NOEMPTYREQ      '  032
         DC    CL16'UNENABLED       '  033
         DC    CL16'UNENABLING      '  034
         DC    CL16'READABLE        '  035
         DC    CL16'NOTREADABLE     '  036
         DC    CL16'UPDATABLE       '  037
         DC    CL16'NOTUPDATABLE    '  038
         DC    CL16'BROWSABLE       '  039
         DC    CL16'UNVAILABLE   040'  040
         DC    CL16'UNVAILABLE   041'  041
         DC    CL16'UNVAILABLE   042'  042
         DC    CL16'UNVAILABLE   043'  043
         DC    CL16'UNVAILABLE   044'  044
         DC    CL16'UNVAILABLE   045'  045
         DC    CL16'UNVAILABLE   046'  046
         DC    CL16'UNVAILABLE   047'  047
         DC    CL16'UNVAILABLE   048'  048
         DC    CL16'UNVAILABLE   049'  049
         DC    CL16'NOTBROWSABLE    '  050
         DC    CL16'ADDABLE         '  051
         DC    CL16'NOTADDABLE      '  052
         DC    CL16'DELETABLE       '  053
         DC    CL16'NOTDELETABLE    '  054
         DC    CL16'HEX             '  055
         DC    CL16'DEC             '  056
         DC    CL16'BLK             '  057
         DC    CL16'EXCTL           '  058
         DC    CL16'NOEXCTL         '  059
         DC    CL16'VTAM            '  060
         DC    CL16'BSAM            '  061
         DC    CL16'BTAM-ES         '  062
         DC    CL16'BGAM            '  063
         DC    CL16'TCAM            '  064
         DC    CL16'TCAMSNA         '  065
         DC    CL16'CONSOLE         '  066
         DC    CL16'CREATE          '  067
         DC    CL16'NOCREATE        '  068
         DC    CL16'ACQUIRED        '  069
         DC    CL16'RELEASED        '  070
         DC    CL16'ACQUIRING       '  071
         DC    CL16'COLDACQ         '  072
         DC    CL16'INSERVICE       '  073
         DC    CL16'OUTSERVICE      '  074
         DC    CL16'ATI             '  075
         DC    CL16'NOATI           '  076
         DC    CL16'TTI             '  077
         DC    CL16'NOTTI           '  078
         DC    CL16'PAGEABLE        '  079
         DC    CL16'AUTOPAGE        '  080
         DC    CL16'UNVAILABLE   081'  081
         DC    CL16'UNVAILABLE   082'  082
         DC    CL16'UNVAILABLE   083'  083
         DC    CL16'UNVAILABLE   084'  084
         DC    CL16'UNVAILABLE   085'  085
         DC    CL16'UNVAILABLE   086'  086
         DC    CL16'UNVAILABLE   087'  087
         DC    CL16'UNVAILABLE   088'  088
         DC    CL16'UNVAILABLE   089'  089
         DC    CL16'UNVAILABLE   090'  090
         DC    CL16'UNVAILABLE   091'  091
         DC    CL16'UNVAILABLE   092'  092
         DC    CL16'UNVAILABLE   093'  093
         DC    CL16'FREEING         '  094
         DC    CL16'AVAILABLE       '  095
         DC    CL16'OBTAINING       '  096
         DC    CL16'UNVAILABLE   097'  097
         DC    CL16'UNVAILABLE   098'  098
         DC    CL16'UNVAILABLE   099'  099
         DC    CL16'NOTTABLE        '  100
         DC    CL16'CICSTABLE       '  101
         DC    CL16'USERTABLE       '  102
         DC    CL16'UNVAILABLE   103'  103
         DC    CL16'UNVAILABLE   104'  104
         DC    CL16'UNVAILABLE   105'  105
         DC    CL16'UNVAILABLE   106'  106
         DC    CL16'UNVAILABLE   107'  107
         DC    CL16'UNVAILABLE   108'  108
         DC    CL16'UNVAILABLE   109'  109
         DC    CL16'PRIMARY         '  110
         DC    CL16'TAKEOVER        '  111
         DC    CL16'UNVAILABLE   112'  112
         DC    CL16'UNVAILABLE   113'  113
         DC    CL16'UNVAILABLE   114'  114
         DC    CL16'UNVAILABLE   115'  115
         DC    CL16'UNVAILABLE   116'  116
         DC    CL16'UNVAILABLE   117'  117
         DC    CL16'UNVAILABLE   118'  118
         DC    CL16'UNVAILABLE   119'  119
         DC    CL16'UNVAILABLE   120'  120
         DC    CL16'IRC             '  121
         DC    CL16'INDIRECT        '  122
         DC    CL16'XM              '  123
         DC    CL16'APPC            '  124
         DC    CL16'LU61            '  125
         DC    CL16'PENDING         '  126
         DC    CL16'NOTPENDING      '  127
         DC    CL16'BISYNCH         '  128
         DC    CL16'UNVAILABLE   129'  129
         DC    CL16'T2770           '  130
         DC    CL16'UNVAILABLE   131'  131
         DC    CL16'T2780           '  132
         DC    CL16'T3780           '  133
         DC    CL16'T2980           '  134
         DC    CL16'UNVAILABLE   135'  135
         DC    CL16'T3735           '  136
         DC    CL16'T3740           '  137
         DC    CL16'T3600BI         '  138
         DC    CL16'UNVAILABLE   139'  139
         DC    CL16'UNVAILABLE   140'  140
         DC    CL16'UNVAILABLE   141'  141
         DC    CL16'UNVAILABLE   142'  142
         DC    CL16'UNVAILABLE   143'  143
         DC    CL16'XNOTDONE        '  144
         DC    CL16'T3277R          '  145
         DC    CL16'T3275R          '  146
         DC    CL16'T3284R          '  147
         DC    CL16'T3286R          '  148
         DC    CL16'C               '  149
         DC    CL16'ASSEMBLER       '  150
         DC    CL16'COBOL           '  151
         DC    CL16'PLIPL1          '  152
         DC    CL16'T3277L          '  153
         DC    CL16'PROGRAM         '  154
         DC    CL16'MAP             '  155
         DC    CL16'PARTITIONSET    '  156
         DC    CL16'UNVAILABLE   157'  157
         DC    CL16'ANY             '  158
         DC    CL16'BELOW           '  159
         DC    CL16'PURGEABLE       '  160
         DC    CL16'NOTPURGEABLE    '  161
         DC    CL16'OLDCOPY         '  162
         DC    CL16'HOLD            '  163
         DC    CL16'NOHOLD          '  164
         DC    CL16'LPA             '  165
         DC    CL16'NOTLPA          '  166
         DC    CL16'NEWCOPY         '  167
         DC    CL16'PHASEIN         '  168
         DC    CL16'ALLCONN         '  169
         DC    CL16'AUTOCONN        '  170
         DC    CL16'NONAUTOCONN     '  171
         DC    CL16'GOINGOUT        '  172
         DC    CL16'SHARED          '  173
         DC    CL16'PRIVATE         '  174
         DC    CL16'SPRSTRACE       '  175
         DC    CL16'STANTRACE       '  176
         DC    CL16'SPECTRACE       '  177
         DC    CL16'DYNAMIC         '  178
         DC    CL16'STATIC          '  179
         DC    CL16'STARTUP         '  180
         DC    CL16'ACTIVE          '  181
         DC    CL16'FIRSTQUIESCE    '  182
         DC    CL16'FINALQUIESCE    '  183
         DC    CL16'SYSDUMP         '  184
         DC    CL16'NOSYSDUMP       '  185
         DC    CL16'TRANDUMP        '  186
         DC    CL16'NOTRANDUMP      '  187
         DC    CL16'SWITCH          '  188
         DC    CL16'CONTNLU         '  189
         DC    CL16'INTACTLU        '  190
         DC    CL16'BATCHLU         '  191
         DC    CL16'BACKOUT         '  192
         DC    CL16'UNVAILABLE   193'  193
         DC    CL16'EXTSECURITY     '  194
         DC    CL16'CICSSECURITY    '  195
         DC    CL16'NOSECURITY      '  196
         DC    CL16'ALTERNATE       '  197
         DC    CL16'DEFAULT         '  198
         DC    CL16'UNVAILABLE   199'  199
         DC    CL16'OFF             '  200
         DC    CL16'ON              '  201
         DC    CL16'RESSECNO        '  202
         DC    CL16'UNVAILABLE   203'  203
         DC    CL16'RESSECYES       '  204
         DC    CL16'CMDSECNO        '  205
         DC    CL16'UNVAILABLE   206'  206
         DC    CL16'CMDSECYES       '  207
         DC    CL16'COMMIT          '  208
         DC    CL16'READBACK        '  209
         DC    CL16'EMPTY           '  210
         DC    CL16'NOTEMPTY        '  211
         DC    CL16'FULL            '  212
         DC    CL16'TERMINAL        '  213
         DC    CL16'NOTERMINAL      '  214
         DC    CL16'PHYSICAL        '  215
         DC    CL16'LOGICAL         '  216
         DC    CL16'UNVAILABLE   217'  217
         DC    CL16'UNVAILABLE   218'  218
         DC    CL16'UNVAILABLE   219'  219
         DC    CL16'UNVAILABLE   220'  220
         DC    CL16'EXTRA           '  221
         DC    CL16'INTRA           '  222
         DC    CL16'NOCTL           '  223
         DC    CL16'ASACTL          '  224
         DC    CL16'SWITCHING       '  225
         DC    CL16'INPUT           '  226
         DC    CL16'OUTPUT          '  227
         DC    CL16'DISPATCHABLE    '  228
         DC    CL16'RUNNING         '  229
         DC    CL16'UNVAILABLE   230'  230
         DC    CL16'SUSPENDED       '  231
         DC    CL16'UNVAILABLE   232'  232
         DC    CL16'TASK            '  233
         DC    CL16'TERM            '  234
         DC    CL16'DEST            '  235
         DC    CL16'PURGE           '  236
         DC    CL16'FORCEPURGE      '  237
         DC    CL16'UNVAILABLE   238'  238
         DC    CL16'UNVAILABLE   239'  239
         DC    CL16'UNVAILABLE   240'  240
         DC    CL16'MCHCTL          '  241
         DC    CL16'PRESETSEC       '  242
         DC    CL16'NOPRESETSEC     '  243
         DC    CL16'SIGNEDON        '  244
         DC    CL16'SIGNEDOFF       '  245
         DC    CL16'UNVAILABLE   246'  246
         DC    CL16'AUXILIARY       '  247
         DC    CL16'MAIN            '  248
         DC    CL16'UNVAILABLE   249'  249
         DC    CL16'TAPE1           '  250
         DC    CL16'TAPE2           '  251
         DC    CL16'DISK1           '  252
         DC    CL16'DISK2           '  253
         DC    CL16'DISK2PAUSE      '  254
         DC    CL16'SMF             '  255
         DC    CL16'OPENINPUT       '  256
         DC    CL16'OPENOUTPUT      '  257
         DC    CL16'READY           '  258
         DC    CL16'NOTREADY        '  259
         DC    CL16'CURRENT         '  260
         DC    CL16'CLOSELEAVE      '  261
         DC    CL16'UNVAILABLE   262'  262
         DC    CL16'NOAUTOARCH      '  263
         DC    CL16'REVERTED        '  264
         DC    CL16'ADVANCE         '  265
         DC    CL16'COLDSTART       '  266
         DC    CL16'WARMSTART       '  267
         DC    CL16'EMERGENCY       '  268
         DC    CL16'LOGTERM         '  269
         DC    CL16'FINPUT          '  270
         DC    CL16'FOUTPUT         '  271
         DC    CL16'FOPEN           '  272
         DC    CL16'FCLOSE          '  273
         DC    CL16'OK              '  274
         DC    CL16'NOWRITE         '  275
         DC    CL16'REMOVE          '  276
         DC    CL16'UNVAILABLE   277'  277
         DC    CL16'UNVAILABLE   278'  278
         DC    CL16'UNVAILABLE   279'  279
         DC    CL16'UNVAILABLE   280'  280
         DC    CL16'UNVAILABLE   281'  281
         DC    CL16'UNVAILABLE   282'  282
         DC    CL16'UNVAILABLE   283'  283
         DC    CL16'UNVAILABLE   284'  284
         DC    CL16'NOSWITCH        '  285
         DC    CL16'SWITCHNEXT      '  286
         DC    CL16'SWITCHALL       '  287
         DC    CL16'SHUTDOWN        '  288
         DC    CL16'NOSHUTDOWN      '  289
         DC    CL16'RESET           '  290
         DC    CL16'ADD             '  291
         DC    CL16'UNVAILABLE   292'  292
         DC    CL16'UNVAILABLE   293'  293
         DC    CL16'UNVAILABLE   294'  294
         DC    CL16'UNVAILABLE   295'  295
         DC    CL16'UNVAILABLE   296'  296
         DC    CL16'UNVAILABLE   297'  297
         DC    CL16'UNVAILABLE   298'  298
         DC    CL16'UNVAILABLE   299'  299
         DC    CL16'UNVAILABLE   300'  300
         DC    CL16'UNVAILABLE   301'  301
         DC    CL16'UNVAILABLE   302'  302
         DC    CL16'UNVAILABLE   303'  303
         DC    CL16'UNVAILABLE   304'  304
         DC    CL16'UNVAILABLE   305'  305
         DC    CL16'UNVAILABLE   306'  306
         DC    CL16'UNVAILABLE   307'  307
         DC    CL16'UNVAILABLE   308'  308
         DC    CL16'UNVAILABLE   309'  309
         DC    CL16'INTSTART        '  310
         DC    CL16'INTSTOP         '  311
         DC    CL16'AUXSTART        '  312
         DC    CL16'AUXPAUSE        '  313
         DC    CL16'AUXSTOP         '  314
         DC    CL16'UNVAILABLE   315'  315
         DC    CL16'UNVAILABLE   316'  316
         DC    CL16'GTFSTART        '  317
         DC    CL16'GTFSTOP         '  318
         DC    CL16'SYSTEMON        '  319
         DC    CL16'SYSTEMOFF       '  320
         DC    CL16'USERON          '  321
         DC    CL16'USEROFF         '  322
         DC    CL16'SINGLEON        '  323
         DC    CL16'SINGLEOFF       '  324
         DC    CL16'UNVAILABLE   325'  325
         DC    CL16'UNVAILABLE   326'  326
         DC    CL16'UNVAILABLE   327'  327
         DC    CL16'UNVAILABLE   328'  328
         DC    CL16'UNVAILABLE   329'  329
         DC    CL16'PERF            '  330
         DC    CL16'NOPERF          '  331
         DC    CL16'EXCEPT          '  332
         DC    CL16'NOEXCEPT        '  333
         DC    CL16'EVENT           '  334
         DC    CL16'NOEVENT         '  335
         DC    CL16'UNVAILABLE   336'  336
         DC    CL16'UNVAILABLE   337'  337
         DC    CL16'UNVAILABLE   338'  338
         DC    CL16'UNVAILABLE   339'  339
         DC    CL16'WAIT            '  340
         DC    CL16'NOWAIT          '  341
         DC    CL16'FORCE           '  342
         DC    CL16'UNVAILABLE   343'  343
         DC    CL16'UNVAILABLE   344'  344
         DC    CL16'UNVAILABLE   345'  345
         DC    CL16'UNVAILABLE   346'  346
         DC    CL16'UNVAILABLE   347'  347
         DC    CL16'UNVAILABLE   348'  348
         DC    CL16'CLOSEFAILED     '  349
         DC    CL16'IMMCLOSE        '  350
         DC    CL16'FORCECLOSE      '  351
         DC    CL16'IMMCLOSING      '  352
         DC    CL16'FORCECLOSING    '  353
         DC    CL16'FWDRECOVABLE    '  354
         DC    CL16'UNDETERMINED    '  355
         DC    CL16'NORMALBKOUT     '  356
         DC    CL16'FAILEDBKOUT     '  357
         DC    CL16'FAILINGBKOUT    '  358
         DC    CL16'INVALID         '  359
         DC    CL16'VALID           '  360
         DC    CL16'NOTFWDRCVBLE    '  361
         DC    CL16'EXITTRACE       '  362
         DC    CL16'NOEXITTRACE     '  363
         DC    CL16'ZCPTRACE        '  364
         DC    CL16'NOZCPTRACE      '  365
         DC    CL16'TCEXITALL       '  366
         DC    CL16'TCEXITSYSTEM    '  367
         DC    CL16'TCEXITNONE      '  368
         DC    CL16'TCEXITALLOFF    '  369
         DC    CL16'CEDF            '  370
         DC    CL16'NOCEDF          '  371
         DC    CL16'SESSION         '  372
         DC    CL16'APPCSINGLE      '  373
         DC    CL16'APPCPARALLEL    '  374
         DC    CL16'COBOL II        '  375
         DC    CL16'NOTINIT         '  376
         DC    CL16'LE370           '  377
         DC    CL16'INACTIVE        '  378
         DC    CL16'CICSDATAKEY     '  379
         DC    CL16'USERDATAKEY     '  380
         DC    CL16'CICSEXECKEY     '  381
         DC    CL16'USEREXECKEY     '  382
         DC    CL16'DPLSUBSET       '  383
         DC    CL16'FULLAPI         '  384
         DC    CL16'FMHPARM         '  385
         DC    CL16'NOFMHPARM       '  386
         DC    CL16'OBOPERID        '  387
         DC    CL16'NOOBOPERID      '  388
         DC    CL16'UNVAILABLE   389'  389
         DC    CL16'UNVAILABLE   390'  390
         DC    CL16'APLKYBD         '  391
         DC    CL16'NOAPLKYBD       '  392
         DC    CL16'APLTEXT         '  393
         DC    CL16'NOAPLTEXT       '  394
         DC    CL16'AUDALARM        '  395
         DC    CL16'NOAUDALARM      '  396
         DC    CL16'BACKTRANS       '  397
         DC    CL16'NOBACKTRANS     '  398
         DC    CL16'COLOR           '  399
         DC    CL16'NOCOLOR         '  400
         DC    CL16'COPY            '  401
         DC    CL16'NOCOPY          '  402
         DC    CL16'DUALCASE        '  403
         DC    CL16'NODUALCASE      '  404
         DC    CL16'EXTENDEDDS      '  405
         DC    CL16'NOEXTENDEDDS    '  406
         DC    CL16'FORMFEED        '  407
         DC    CL16'NOFORMFEED      '  408
         DC    CL16'HFORM           '  409
         DC    CL16'NOHFORM         '  410
         DC    CL16'VFORM           '  411
         DC    CL16'NOVFORM         '  412
         DC    CL16'HILIGHT         '  413
         DC    CL16'NOHILIGHT       '  414
         DC    CL16'KATAKANA        '  415
         DC    CL16'NOKATAKANA      '  416
         DC    CL16'LIGHTPEN        '  417
         DC    CL16'NOLIGHTPEN      '  418
         DC    CL16'MSRCONTROL      '  419
         DC    CL16'NOMSRCONTROL    '  420
         DC    CL16'OBFORMAT        '  421
         DC    CL16'NOOBFORMAT      '  422
         DC    CL16'OUTLINE         '  423
         DC    CL16'NOOUTLINE       '  424
         DC    CL16'PARTITIONS      '  425
         DC    CL16'NOPARTITIONS    '  426
         DC    CL16'PRINTADAPT      '  427
         DC    CL16'NOPRINTADAPT    '  428
         DC    CL16'PROGSYMBOL      '  429
         DC    CL16'NOPROGSYMBOL    '  430
         DC    CL16'ALLQUERY        '  431
         DC    CL16'NOQUERY         '  432
         DC    CL16'COLDQUERY       '  433
         DC    CL16'SOSI            '  434
         DC    CL16'NOSOSI          '  435
         DC    CL16'TEXTKYBD        '  436
         DC    CL16'NOTEXTKYBD      '  437
         DC    CL16'TEXTPRINT       '  438
         DC    CL16'NOTEXTPRINT     '  439
         DC    CL16'VALIDATION      '  440
         DC    CL16'NOVALIDATION    '  441
         DC    CL16'RELREQ          '  442
         DC    CL16'NORELREQ        '  443
         DC    CL16'DISCREQ         '  444
         DC    CL16'NODISCREQ       '  445
         DC    CL16'ALTPRTCOPY      '  446
         DC    CL16'NOALTPRTCOPY    '  447
         DC    CL16'PRTCOPY         '  448
         DC    CL16'NOPRTCOPY       '  449
         DC    CL16'UCTRAN          '  450
         DC    CL16'NOUCTRAN        '  451
         DC    CL16'TRANIDONLY      '  452
         DC    CL16'UNVAILABLE   453'  453
         DC    CL16'UNVAILABLE   454'  454
         DC    CL16'UNVAILABLE   455'  455
         DC    CL16'UNVAILABLE   456'  456
         DC    CL16'UNVAILABLE   457'  457
         DC    CL16'UNVAILABLE   458'  458
         DC    CL16'UNVAILABLE   459'  459
         DC    CL16'UNVAILABLE   460'  460
         DC    CL16'UNVAILABLE   461'  461
         DC    CL16'UNVAILABLE   462'  462
         DC    CL16'UNVAILABLE   463'  463
         DC    CL16'UNVAILABLE   464'  464
         DC    CL16'UNVAILABLE   465'  465
         DC    CL16'UNVAILABLE   466'  466
         DC    CL16'UNVAILABLE   467'  467
         DC    CL16'UNVAILABLE   468'  468
         DC    CL16'UNVAILABLE   469'  469
         DC    CL16'UNVAILABLE   470'  470
         DC    CL16'UNVAILABLE   471'  471
         DC    CL16'UNVAILABLE   472'  472
         DC    CL16'UNVAILABLE   473'  473
         DC    CL16'UNVAILABLE   474'  474
         DC    CL16'UNVAILABLE   475'  475
         DC    CL16'UNVAILABLE   476'  476
         DC    CL16'UNVAILABLE   477'  477
         DC    CL16'UNVAILABLE   478'  478
         DC    CL16'UNVAILABLE   479'  479
         DC    CL16'UNVAILABLE   480'  480
         DC    CL16'UNVAILABLE   481'  481
         DC    CL16'UNVAILABLE   482'  482
         DC    CL16'UNVAILABLE   483'  483
         DC    CL16'UNVAILABLE   484'  484
         DC    CL16'UNVAILABLE   485'  485
         DC    CL16'UNVAILABLE   486'  486
         DC    CL16'UNVAILABLE   487'  487
         DC    CL16'UNVAILABLE   488'  488
         DC    CL16'UNVAILABLE   489'  489
         DC    CL16'UNVAILABLE   490'  490
         DC    CL16'UNVAILABLE   491'  491
         DC    CL16'UNVAILABLE   492'  492
         DC    CL16'UNVAILABLE   493'  493
         DC    CL16'UNVAILABLE   494'  494
         DC    CL16'UNVAILABLE   495'  495
         DC    CL16'UNVAILABLE   496'  496
         DC    CL16'UNVAILABLE   497'  497
         DC    CL16'UNVAILABLE   498'  498
         DC    CL16'UNVAILABLE   499'  499
         DC    CL16'UNVAILABLE   500'  500
         DC    CL16'T7770           '  501
         DC    CL16'SYSTEM7         '  502
         DC    CL16'UNVAILABLE   503'  503
         DC    CL16'RESSECEXT       '  504
         DC    CL16'UNVAILABLE   505'  505
         DC    CL16'UNVAILABLE   506'  506
         DC    CL16'CMDSECEXT       '  507
         DC    CL16'TCONSOLE        '  508
         DC    CL16'ISCMMCONV       '  509
         DC    CL16'LUCMODGRP       '  510
         DC    CL16'LUCSESS         '  511
         DC    CL16'UNVAILABLE   512'  512
         DC    CL16'TERMINAL        '  513
         DC    CL16'UNVAILABLE   514'  514
         DC    CL16'UNVAILABLE   515'  515
         DC    CL16'UNVAILABLE   516'  516
         DC    CL16'UNVAILABLE   517'  517
         DC    CL16'SEQDISK         '  518
         DC    CL16'UNVAILABLE   519'  519
         DC    CL16'MAGTAPE         '  520
         DC    CL16'UNVAILABLE   521'  521
         DC    CL16'UNVAILABLE   522'  522
         DC    CL16'UNVAILABLE   523'  523
         DC    CL16'CDRDLPRT        '  524
         DC    CL16'LU61            '  525
         DC    CL16'UNVAILABLE   526'  526
         DC    CL16'UNVAILABLE   527'  527
         DC    CL16'UNVAILABLE   528'  528
         DC    CL16'UNVAILABLE   529'  529
         DC    CL16'T2770           '  530
         DC    CL16'UNVAILABLE   531'  531
         DC    CL16'T2780           '  532
         DC    CL16'T3780           '  533
         DC    CL16'T2980           '  534
         DC    CL16'UNVAILABLE   535'  535
         DC    CL16'T3735           '  536
         DC    CL16'T3740           '  537
         DC    CL16'T3600BI         '  538
         DC    CL16'UNVAILABLE   539'  539
         DC    CL16'T2740           '  540
         DC    CL16'UNVAILABLE   541'  541
         DC    CL16'T2741COR        '  542
         DC    CL16'XOK             '  543
         DC    CL16'UNVAILABLE   544'  544
         DC    CL16'T3277R          '  545
         DC    CL16'T3275R          '  546
         DC    CL16'T3284R          '  547
         DC    CL16'T3286R          '  548
         DC    CL16'UNVAILABLE   549'  549
         DC    CL16'UNVAILABLE   550'  550
         DC    CL16'UNVAILABLE   551'  551
         DC    CL16'ALTERABLE       '  552
         DC    CL16'T3277L          '  553
         DC    CL16'UNVAILABLE   554'  554
         DC    CL16'T3284L          '  555
         DC    CL16'T3286L          '  556
         DC    CL16'NOTCTRLABLE     '  557
         DC    CL16'UNVAILABLE   558'  558
         DC    CL16'UNVAILABLE   559'  559
         DC    CL16'VTAM            '  560
         DC    CL16'SYSTEM3         '  561
         DC    CL16'BTAM-ES         '  562
         DC    CL16'UNVAILABLE   563'  563
         DC    CL16'TCAM            '  564
         DC    CL16'T2260L          '  565
         DC    CL16'SYS7BSCA        '  566
         DC    CL16'UNVAILABLE   567'  567
         DC    CL16'UNVAILABLE   568'  568
         DC    CL16'UNVAILABLE   569'  569
         DC    CL16'MODEL           '  570
         DC    CL16'SURROGATE       '  571
         DC    CL16'T2260R          '  572
         DC    CL16'UNVAILABLE   573'  573
         DC    CL16'T1053           '  574
         DC    CL16'UNVAILABLE   575'  575
         DC    CL16'SDLC            '  576
         DC    CL16'T3601           '  577
         DC    CL16'T3614           '  578
         DC    CL16'UNVAILABLE   579'  579
         DC    CL16'T3790           '  580
         DC    CL16'T3790UP         '  581
         DC    CL16'T3790SCSP       '  582
         DC    CL16'UNVAILABLE   583'  583
         DC    CL16'T3650PIPE       '  584
         DC    CL16'T3653HOST       '  585
         DC    CL16'T3650ATT        '  586
         DC    CL16'T3650USER       '  587
         DC    CL16'UNVAILABLE   588'  588
         DC    CL16'UNVAILABLE   589'  589
         DC    CL16'UNVAILABLE   590'  590
         DC    CL16'UNVAILABLE   591'  591
         DC    CL16'LUTYPE6         '  592
         DC    CL16'LUTYPE4         '  593
###END CEMVAL2
$$$BEG CALLCEE
ceetest2 CEEENTRY PPA=mainppa,BASE=11,AUTO=DSA_SIZE
*
         TIME  DEC,ZONE=GMT
         ST    R0,TIMEGMT
         ST    R1,DATEGMT
         TIME  DEC,ZONE=LT
         ST    R0,TIMELOC
         ST    R1,DATELOC
*
         CALL  TIME,NULL                   time_t time(NULL)
         ST    R15,CurTimeT
*
         CALL  PUTS,LEGENDSTR,                                         +
               MF=(E,arglist)
*
         CALL  GMTIME,CurTimeT,            struct tm *gmtime(time_t *) +
               MF=(E,arglist)
         ST    R15,CurTimeTM
         LR    R2,R15
         CALL  ASCTIME,((R2)),             char *asctime(strcut tm *)  +
               MF=(E,arglist)
         ST    R15,CharTime
         LR    R2,R15
         L     R3,TIMEGMT
         L     R4,DATEGMT
         CALL  PRINTF,                                                 +
               (GMTSTR,(R4),(R3),(R2)),                                +
               MF=(E,arglist)
*
         CALL  LOCALTIM,CurTimeT,                                      +
               MF=(E,arglist)
         ST    R15,CurTimeTM
         LR    R2,R15
         CALL  ASCTIME,((R2)),             char *asctime(strcut tm *)  +
               MF=(E,arglist)
         ST    R15,CharTime
         LR    R2,R15
         L     R3,TIMELOC
         L     R4,DATELOC
         CALL  PRINTF,                                                 +
               (LOCSTR,(R4),(R3),(R2)),                                +
               MF=(E,arglist)
*
         CEETERM  RC=0
*
LEGENDSTR      DC    C'TIME Macro  CCYYDDDf HHMMSSth     C Runtine'
               DC    X'1500'
GMTSTR         DC    C' ZONE=GMT   %08x %08x     gmtime():    %s'
               DC    X'00'
LOCSTR         DC    C' ZONE=LT    %08x %08x     localtime(): %s'
               DC    X'00'
*
NULL           DC    A(0)
*
mainppa  CEEPPA ,
*
         EJECT  ,
*
         CEEDSA ,
*
arglist        DS    5A
*
DATEGMT        DS    F
TIMEGMT        DS    F
DATELOC        DS    F
TIMELOC        DS    F
*
CurTimeT       DS    F                 time_t
CurTimeTM      DS    A                 *(struct tm)
CharTime       DS    A                 *(char)
*
*
DSA_SIZE EQU    *-CEEDSA
*
         CEECAA ,
*
         YREGS
*
         END    ceetest2
###END CALLCEE
$$$BEG CALLPNTF
ceetest  CEEENTRY PPA=mainppa
         CALL  PRINTF,string
         CEETERM  RC=0
*
string   DC    C'Hello world!'
         DC    X'15'
         DC    X'00'
*
mainppa  CEEPPA ,
*
         EJECT  ,
*
         CEEDSA ,
         CEECAA ,
*
         END    ceetest
###END CALLPNTF
$$$BEG CALLUSS
BPXBAT   CSECT
BPXBAT   AMODE 31
BPXBAT   RMODE ANY
         SAVE  (14,12),T,'BPXBAT-&SYSDATE-&SYSTIME'
         LR    12,15                LOAD THE CSECT BASE ADDRESS
         USING BPXBAT,12            ESTABLISH CSECT ADDRESSABILITY
         GETMAIN RC,LV=WORKLEN      GET SOME WORKING STORAGE
         LR    4,1                  SAVE WORKING STORAGE ADDRESS
         USING WORKDSCT,4           WORKING STORAGE ADDRESSABILITY
         ST    13,4(0,1)            STORE ADDR OF PREVIOUS SAVE AREA
         ST    1,8(0,13)            STORE ADDR OF OUR (NEXT) SAVE AREA
         LR    13,1                 STORE SAVE AREA ADDRESS
START    EQU   *
         MVC   PLEN,=H'80'
         MVC   PARMS(80),=CL80'SH java -fullversion'
*        MVC   PARMS(80),=CL80'PGM /u/cs56011/helloc'
*        MVC   PARMS(80),=CL80'PGM /bin/ps -ej -o pid,jobname,xasid'
         LA    1,PLEN
         ST    1,@PLIST
         OI    @PLIST,X'80'
         LA    1,@PLIST
         LINK  EP=BPXBATCH
EXIT     EQU   *
         L     13,4(13)                 ADDRESS OF CALLER'S SAVE AREA
         FREEMAIN RC,LV=WORKLEN,A=(4)   FREE WORKING STORAGE
         RETURN (14,12),T,RC=0
         LTORG
WORKDSCT DSECT
SAVEAREA DS    18F
@PLIST   DS    F
PLEN     DS    H
PARMS    DS    CL80
WORKLEN  EQU   *-WORKDSCT
         END
###END CALLUSS
$$$BEG PMR68359
         L     R6,MYCT
         LA    R6,1(R6)
         ST    R6,MYCT
*
         ICM   R6,15,SCA1            do we have SCA address?
         BNZ   J0001                  yes, go check subpool
         SR    R6,R6                  CLEAR OUT WORK REG
         SR    R7,R7                  CLEAR OUT WORK REG
         SR    R5,R5                  CLEAR OUT WORK REG
         L     R6,J0004               ADDRESS KERNAL ANCHOR
         L     R6,376(,R6)            ADDRESS SM GATEHEAD
         L     R6,16(,R6)             ADDRESS SM ANCHOR
         L     R7,36(,R6)             SMA_SCA_DOMAIN_LAST
         L     R6,32(,R6)             SMA_SCA_DOMAIN_FIRST
J0000    CLC   0(8,R6),=C'TSMN0128'   CHECK SUBPOOL_ID
         BE    STSCA1                 YES, CHECK QPH'S
         CR    R7,R6                  NO, END OF CHAIN
         BE    J0001                  check next one
         L     R6,8(,R6)              GET SCA_NEXT
         B     J0000                  TEST SCA ID
STSCA1   ST    R6,SCA1                save TSMN0128
J0001    ICM   R6,15,SCA2             already have SCA2?
         BNZ   CHCKSCA                yes, check SCA's
         SR    R6,R6                  CLEAR OUT WORK REG
         SR    R7,R7                  CLEAR OUT WORK REG
         SR    R5,R5                  CLEAR OUT WORK REG
         L     R6,J0004               ADDRESS KERNAL ANCHOR
         L     R6,376(,R6)            ADDRESS SM GATEHEAD
         L     R6,16(,R6)             ADDRESS SM ANCHOR
         L     R7,36(,R6)             SMA_SCA_DOMAIN_LAST
         L     R6,32(,R6)             SMA_SCA_DOMAIN_FIRST
J000A    CLC   0(8,R6),=C'TSTSX   '   CHECK SUBPOOL_ID
         BE    STSCA2                 YES, CHECK QPH'S
         CR    R7,R6                  NO, END OF CHAIN
         BE    CHCKSCA                CHKSCAs
         L     R6,8(,R6)              GET SCA_NEXT
         B     J000A                  TEST SCA ID
STSCA2   ST    R6,SCA2                save address TSTSX
CHCKSCA  ICM   R6,15,SCA1             start with First subpool
         BZ    CHKSCA2
         CLC   36(4,R6),D5VALUE       SCA+24= 000000D5?
         BE    JDUMP                  YES, dump
         L     R7,28(,R6)             LOAD SCA_FIRST_QPH_HEADER
         LA    R9,4(,R6)              Add 4 SCA ADDR
         CR    R9,R7                  TEST FOR END OF CHAIN
         BE    CHKSCA2                IF EQUAL Check other subpool
J0002    CLC   32(4,R7),D5VALUE       offset x'20'=000000D5?
         BE    JDUMP                  yes, dump
         ICM   R7,15,24(R7)           LOAD ADDRESS OF NEXT QPH
         CR    R9,R7                  is it the last?
         BNE   J0002                  no, check it
CHKSCA2  ICM   R6,15,SCA2             now check TSTSX
         BZ    TRAPRTN
         CLC   36(4,R6),D5VALUE       SCA+24= 000000D5?
         BE    JDUMP                  YES, dump
         L     R7,28(,R6)             LOAD SCA_FIRST_QPH_HEADER
         LA    R9,4(,R6)              Add 4 SCA ADDR
         CR    R9,R7                  TEST FOR END OF CHAIN
         BE    TRAPRTN                IF EQUAL RETURN
J0002A   CLC   32(4,R7),D5VALUE       Does QPH+20=000000D5?
         BE    JDUMP                  Yes, dump
         ICM   R7,15,24(R7)           get next QPH
         CR    R9,R7                  at end?
         BNE   J0002A                 no, check next QPH
         B     TRAPRTN                otherwise exit
JDUMP    L     R4,TRACURTA            ADDR OF CURRENT ENRTY
         USING DFHTREN,R4
         STM   R14,R12,12(R13)        STORE OUR REGISTERS
         ST    R6,TRAD1A              DATA AREA 1 IS SCA
         MVC   TRAD1L,=F'100'         SPECIFY LENGTH
         ST    R7,TRAD2A              DATA AREA 2 IS QPH HEADER
         MVC   TRAD2L,=F'100'         SPECIFY LENGTH
         L     R8,TRAFLGSA            GET TRAP FLAGS
         OI    0(R8),200              TRACE, DUMP, & DISABLE
         B     TRAPRTN                RETURN
SCA1     DC    X'00000000'
SCA2     DC    X'00000000'
D5VALUE  DC    X'000000D5'
J0004    DC    X'00007000'
         DC    C'>>'
MYCT     DC    F'0'
MYTSMN   DC    F'0'
         DC    C'<<'
         DS    0F
END_OF_FIX EQU *
###END PMR68359
$$$BEG DFHTRAP5
TRAP     TITLE 'CICS - GLOBAL TRAP EXIT PROGRAM'
DFHTRAP  CSECT ,
*=====================================================================*
*                                                                     *
* MODULE NAME = DFHTRAP                                               *
*                                                                     *
* DESCRIPTIVE NAME = CICS      GLOBAL TRAP EXIT PROGRAM               *
*                                                                     *
*                                                                     *
*    @BANNER_START                           02                       *
*    Licensed Materials - Property of IBM                             *
*                                                                     *
*    "Restricted Materials of IBM"                                    *
*                                                                     *
*    5655-M15              DFHTRAP                                    *
*                                                                     *
*    (C) Copyright IBM Corp. 1984, 2006                               *
*                                                                     *
*    CICS                                                             *
*    (Element of CICS Transaction Server                              *
*      for z/OS, Version 3 Release 2)                                 *
*    @BANNER_END                                                      *
*                                                                     *
* STATUS = 6.5.0                                                      *
*                                                                     *
* FUNCTION =                                                          *
*    This module is a skeleton Global Trap Exit program intended      *
*    for diagnostic use only under the guidance of Service Personnel. *
*    The skeleton exit code can be tailored to suit requirements.     *
*                                                                     *
*    Guidance on using the F.E. Global Trap Exit - activation and     *
*    deactivation, and tailoring the exit to suit requirements - is   *
*    given in the CICS System Problem Determination Guide.            *
*                                                                     *
*    When the F.E. Global Trap has been activated, and has not        *
*    subsequently been either disabled upon the request of the trap   *
*    exit or marked unusable following a program check in the exit,   *
*    the trap exit program DFHTRAP will be invoked by trace domain    *
*    after making a trace entry.  The latest (current) trace entry    *
*    is passed to DFHTRAP for analysis.  Its contents must not be     *
*    changed by DFHTRAP.  The DFHTREN dsect can be used to map the    *
*    data in the current entry.                                       *
*                                                                     *
*    The skeleton DFHTRAP tests the point-id of the current           *
*    trace entry.  If this has been made on entry to DFHTSP for a     *
*    TS GET request, then the appropriate data is set up and the      *
*    action flags are set to indicate that a further trace entry is   *
*    to be made.                                                      *
*                                                                     *
*    Provision is made for various actions to be taken upon return    *
*    from the trap exit, viz. making a further trace entry, taking    *
*    a system dump, abending CICS, or disabling the trap so that      *
*    it is not invoked again until reactivated (see OUTPUT section).  *
*                                                                     *
*---------------------------------------------------------------------*
*                                                                     *
*    IMPORTANT                                                        *
*    ---------                                                        *
*    The Global Trap Exit is strictly limited to looking at the       *
*    current state of the CICS system without changing it, and        *
*    in particular without losing control to another CICS task.       *
*    This means that no requests for CICS services should be issued   *
*    from within the trap exit.                                       *
*                                                                     *
*---------------------------------------------------------------------*
*                                                                     *
*    ACCESSING ADDRESS SPACE STORAGE ABOVE THE 2G BAR                 *
*    ------------------------------------------------                 *
*    To enable this exit to access address space storage above the    *
*    2G bar, do the following:                                        *
*                                                                     *
*    1) Uncomment all the lines of code tagged with "==>ATB".         *
*    2) Surround new code that accesses above bar storage with the    *
*       the following statements:                                     *
*                                                                     *
*        SAM64 ,                   Switch to AMODE64                  *
*        SYSSTATE PUSH                                                *
*        SYSSTATE AMODE64=YES                                         *
*        ...                                                          *
*        SYSSTATE POP                                                 *
*        SAM31 ,                   Switch to AMODE31                  *
*                                                                     *
*---------------------------------------------------------------------*
*                                                                     *
*    ACCESSING DATASPACE STORAGE                                      *
*    ---------------------------                                      *
*    To enable this exit to access dataspace storage, do the          *
*    following:                                                       *
*                                                                     *
*    1) Uncomment all the lines of code tagged with "==>DSP".         *
*    2) Surround new code that accesses dataspace storage with the    *
*       the following statements:                                     *
*                                                                     *
*        SAC   512                 Switch to AR mode                  *
*        SYSSTATE PUSH                                                *
*        SYSSTATE ASCENV=AR                                           *
*        ...                                                          *
*        SYSSTATE POP                                                 *
*        SAC   0                   Switch to primary mode             *
*                                                                     *
*---------------------------------------------------------------------*
*                                                                     *
* NOTES :                                                             *
*    DEPENDENCIES = S/370                                             *
*    RESTRICTIONS = None                                              *
*    REGISTER CONVENTIONS = See INPUT section and comments in code    *
*    PATCH LABEL = None                                               *
*    MODULE TYPE = Executable                                         *
*    PROCESSOR = Assembler                                            *
*    ATTRIBUTES = Read-only, Serially Reusable                        *
*    ADDRESSING MODE = 31                                             *
*    RESIDENCE MODE = ANY                                             *
*                                                                     *
*-------------------------------------------------------------------- *
*                                                                     *
* ENTRY POINT = DFHTRANA                                              *
*                                                                     *
*    PURPOSE =                                                        *
*          See FUNCTION section                                       *
*                                                                     *
*    LINKAGE =                                                        *
*          BASR  R14,R15  from Trace Domain (DFHTRPT)                 *
*                                                                     *
*          The trap exit will be invoked in 31-bit mode.              *
*                                                                     *
*          Registers MUST be saved and restored by DFHTRAP using      *
*          normal OS conventions.                                     *
*                                                                     *
*    INPUT =                                                          *
*          Registers on entry:                                        *
*             R1  = A(4-word Plist, with X'80' bit set in high-order  *
*                     byte of last address).  The plist is mapped     *
*                     by dsect DFHTRADS.  See comments in DFHTRADS    *
*                     for details.                                    *
*             R13 = Register save area                                *
*             R14 = Return address in DFHTRPT                         *
*             R15 = DFHTRAP entry addr                                *
*                                                                     *
*             Other registers (R0, R2-R12) are unpredictable.         *
*                                                                     *
*    OUTPUT =                                                         *
*          Actions to be taken on return from the trap exit are       *
*          indicated in the flag word as follows:                     *
*             Bit 0  Make further trace entry on behalf of exit       *
*                    (using data returned in plist)                   *
*             Bit 1  Take a system dump                               *
*             Bit 3  Abend CICS (with a dump)                         *
*             Bit 4  Disable trap so that it cannot be used again     *
*                    until reactivated                                *
*                                                                     *
*          See DFHTRADS for definitions and more information          *
*          regarding these return actions.                            *
*                                                                     *
*    EXIT-NORMAL =                                                    *
*          Normal return via link register R14.                       *
*          See OUTPUT section for return action indications.          *
*                                                                     *
*    EXIT-ERROR =                                                     *
*          None.                                                      *
*                                                                     *
*          If a program check occurs within the trap exit code,       *
*          this will be detected by the trace domain's recovery       *
*          routine, which will mark the exit unusable, inform the     *
*          operator (message DFHTR1001) and take a system dump with   *
*          dump code TR1001.                                          *
*          Processing continues, but the trap exit will be ignored    *
*          on future invocations of trace domain until it is          *
*          disabled and restarted.                                    *
*                                                                     *
*-------------------------------------------------------------------- *
*                                                                     *
* EXTERNAL REFERENCES =                                               *
*                                                                     *
*    ROUTINES =                                                       *
*          No external routines are called.                           *
*                                                                     *
*    DATA AREAS =                                                     *
*          No operating system data areas are referenced.             *
*                                                                     *
*    CONTROL BLOCKS =                                                 *
*          The following control blocks are not referenced in the     *
*          skeleton DFHTRAP, but their Dsects are included for ease   *
*          of modification: CSA, TCA (system and user areas).         *
*                                                                     *
*    GLOBAL VARIABLES =                                               *
*          No global variables are referenced or set.                 *
*                                                                     *
* TABLES =                                                            *
*       No special purpose tables are used.                           *
*                                                                     *
* MACROS =                                                            *
*       No special internal macros are used.                          *
*                                                                     *
*-------------------------------------------------------------------- *
*                                                                     *
* DESCRIPTION =                                                       *
*       See FUNCTION section                                          *
*                                                                     *
*-------------------------------------------------------------------- *
*                                                                     *
* CHANGE ACTIVITY :                                                   *
*   $MOD(DFHTRAP),COMP(TRACE),PROD(CICS    )   :                      *
*                                                                     *
*    PN= REASON REL YYMMDD HDXIII : REMARKS                           *
*   $L0= 6B0    170 8411   HDIVJH : GLOBAL TRAP FOR SERVICE PERSONNEL *
*   $L1= TR1    310 870724 HD0JADT: Rework due to Trace Domain        *
*   $L2= 438    320 880802 HD2WPGA: TCT VSCR 31 - Bit                 *
*    $L4= 709    530 960802 HD3YIJM : Ease Domain creation            *
*   $D1= I04257 320 900320 HD0JADT: Now invoked from trace domain     *
*   $P1= M32168 170 8604   HDIVJH : USE TRACE IDS DEFINED IN DFHTRACE *
*   $P2= M62658 320 900628 HD9DHC : Use R9 in favour of R13 for CSA   *
*   $P3= M81662 410 930205 HDCDADK: Use DSECTGEN to generate DFHTREN  *
*   $P5= D16067 650 061213 HDIVJPW: defect 16067                      *
*   $01= A68988 630 021217 HDBGNRB: Migrate PQ68988 from SPA R620     *
*                                                                     *
*=====================================================================*
         EJECT ,
*---------------------------------------------------------------------*
*      R E G I S T E R   A N D   O T H E R    E Q U A T E S           *
*---------------------------------------------------------------------*
         DFHREGS ,
         DFHSTD2 TYPE=STANDARD                                     @D1A
         EJECT ,
*---------------------------------------------------------------------*
*      C O N T R O L   B L O C K   D U M M Y   S E C T I O N S        *
*---------------------------------------------------------------------*
         DFHPRINT DSCT=START
         COPY DFHCSADS            CSA
         EJECT ,
         DFHTCA CICSYST=YES       TCA - SYSTEM AND USER AREAS
         EJECT ,
         DFHPRINT DSCT=END
         COPY DFHTREND            Trace entry map                  @P3C
         EJECT ,                                                   @D1A
         COPY DFHTRADS            PLIST TO DFHTRAP
         EJECT ,
*                                                                  @P5A
*  This dsect maps the register savearea.                          @P5A
*                                                                  @P5A
RSADATA  DSECT ,                  Register save areas              @P5A
RSAGRSLO DS    CL72               Low-order words of GRs           @P5A
RSAGRSHI DS    CL64               High-order words of GRs          @P5A
RSAARS   DS    CL64               ARs                              @P5A
*
*  This dsect maps the data traced in DATA1 for old-style AP domain
*  entries (those with point-id less than X'0100').
*
TRDATA   DSECT  ,                 Data for TRACE_PUT               @D1A
TRD_FIELDAB  DS 0CL8              Field A and B                    @D1A
TRD_FIELDA   DS CL4               Field A                          @D1A
TRD_FIELDB   DS CL4               Field B                          @D1A
TRD_RESOURCE DS CL8               Resource name                    @D1A
TRD_REQ      DS 0CL2              Request bytes                    @D1A
TRD_REQ1     DS CL1               Request byte 1                   @D1A
TRD_REQ2     DS CL1               Request byte 2                   @D1A
         EJECT                                                     @D1A
*---------------------------------------------------------------------*
*                 C S E C T   S T A R T                               *
*---------------------------------------------------------------------*
DFHTRAP  CSECT ,
         SYSSTATE ASCENV=P,AMODE64=NO,ARCHLVL=2                    @P5A
         DFHVM TRAP,RMODE=ANY                                      @L2C
*---------------------------------------------------------------------*
*                P R O G R A M   E N T R Y                            *
*---------------------------------------------------------------------*
         ENTRY DFHTRANA
DFHTRANA DS    0F
         STM   R14,R12,12(R13)     Save DFHTRPT's registers        @D1A
         USING DFHTRADS,R1         R1 -> PARM LIST
         L     R15,TRARSAAD        New register save area          @D1A
         ST    R13,4(,R15)         Backward chain save area        @D1A
         ST    R15,8(,R13)         Forward chain save area         @D1A
         LR    R13,R15             Set new save area as current    @D1A
*        PUSH  USING                                 ==>ATB ==>DSP @P5A
*        USING RSADATA,R13                           ==>ATB ==>DSP @P5A
*        STMH  R0,R15,RSAGRSHI     Save top words           ==>ATB @P5A
*        STAM  R0,R15,RSAARS       Save ARs                 ==>DSP @P5A
*        LAE   R13,0(R13,0)        Clear AR13               ==>DSP @P5A
*        LLGTR R13,R13             Clear top word of R13    ==>ATB @P5A
*        POP   USING                                 ==>ATB ==>DSP @P5A
*        LAE   R1,0(R1,0)          Clear AR1                ==>DSP @P5A
*        LLGTR R1,R1               Clear top word of R1     ==>ATB @P5A
*
         BASR  R3,0                Code addressability             @L2C
         USING *,R3
*        LAE   R3,0(R3,0)          Clear AR3                ==>DSP @P5A
*        LLGTR R3,R3               Clear top word of R3     ==>ATB @P5A
*
         L     R4,TRACURTA         Addr of current entry           @D1C
         USING DFHTREN,R4          Establish addressability        @L1A
*        LAE   R4,0(R4,0)          Clear AR4                ==>DSP @P5A
*        LLGTR R4,R4               Clear top word of R4     ==>ATB @P5A
*---------------------------------------------------------------------*
*                                                                     *
*              ANALYSE ENTRY AND SET RETURN ACTIONS                   *
*              ------------------------------------                   *
*                                                                     *
*  The following sample analysis code looks for two types of entry.   *
*                                                                     *
*  (1) An AP domain entry made by DFHTSP on a call for a Temporary    *
*      Storage GET.  When this is detected, an extra trace entry is   *
*      requested.                                                     *
*                                                                     *
*  (2) An SM domain entry made on a call for a getmain from subpool   *
*      'ABCD'.  When this is detected, a system dump is requested as  *
*      return action.  Note that subpool 'ABCD' does not exist.  It   *
*      is used only for the purposes of this example.                 *
*                                                                     *
*  Before either of these tests, this example loads the CSA and TCA   *
*  addresses from the input parameter list.  This is not required     *
*  for the purposes of this example, but is done to demonstrate       *
*  the required code.  Remember that DFHTRAP may be invoked with      *
*  either or both of these addresses zero.                            *
*                                                                     *
*---------------------------------------------------------------------*
*
         DROP  R13                 Drop R13 to use R9 for CSA      @P2A
*
         ICM   R9,15,TRACSAAD      Get CSA address                 @D1A
         BZ    TRAPRTN             Exit if none                    @D1A
         USING DFHCSADS,R9         Tell assembler                  @D1A
*        LAE   R9,0(R9,0)          Clear AR9                ==>DSP @P5A
*        LLGTR R9,R9               Clear top word of R9     ==>ATB @P5A
*
         ICM   R12,15,TRATCAAD     Get TCA address                 @D1A
         BZ    TRAPRTN             Exit if none                    @D1A
         USING DFHTCADS,R12        Tell assembler                  @D1A
*        LAE   R12,0(R12,0)        Clear AR12               ==>DSP @P5A
*        LLGTR R12,R12             Clear top word of R12    ==>ATB @P5A
*
         COPY PMR68359
*---------------------------------------------------------------------*
*  Look for TS GET request                                            *
*---------------------------------------------------------------------*
         CLC   TREN_CALLER,=AL2(DFHAP_DOMAIN)  AP domain entry ?   @D1A
         BNE   CHECKSM             ..No, go look for SM entry      @D1A
         CLC   TREN_POINTID,=XL2'00F7'  TS trace entry ?           @D1C
         BNE   CHECKSM             ..No, go look for SM entry      @D1C
*
         LA    R6,TREN_FIELD_DATA  Point at DATA1                  @D1C
         USING TRDATA,R6           Overlay for old-style entries   @D1C
*        LAE   R6,0(R6,0)          Clear AR6                ==>DSP @P5A
*        LLGTR R6,R6               Clear top word of R6     ==>ATB @P5A
*
         CLI   TRD_REQ2,X'03'      Entry to TSP for APPL REQ ?     @D1C
         BNE   CHECKSM             ..no, go look for SM entry      @D1C
         TM    TRD_REQ1,X'80'      TS GET request ?                @D1C
         BNO   CHECKSM             ..no, look for SM entry         @D1C
         DROP  R6                  TRDATA                          @D1A
*
         LA    R5,TSTRDATA         Addr of data in extra entry     @D1C
         ST    R5,TRAD1A           Return address to TR domain     @D1A
         LA    R5,L'TSTRDATA       Length of data in extra entry   @D1A
         ST    R5,TRAD1L           Return length to TR domain      @D1A
*
         L     R6,TRAFLGSA         Address return actions flagword @L1C
         OI    0(R6),TRAPFTRE      Make another trace entry        @L1C
*
*---------------------------------------------------------------------*
*  Look for SM GETMAIN request                                        *
*---------------------------------------------------------------------*
CHECKSM  DS    0H
         CLC   TREN_CALLER,=AL2(DFHSM_DOMAIN)  SM domain entry ?   @D1A
         BNE   TRAPRTN             ..No, exit                      @D1A
         CLC   TREN_POINTID,=XL2'0301'  SMGF entry ?               @D1A
         BNE   TRAPRTN             ..No, exit                      @D1A
*
* Ensure this SM 0301 has a DATA2 by comparing the total trace     @01A
* entry length with the length of the header + DATA1               @01A
*                                                                  @01A
         LA    R6,L'TREN_FIELD_LEN Get length of length field      @01A
         AH    R6,TREN_HEADER_LENGTH L'Header+len field            @01A
         AH    R6,TREN_FIELD_LEN   L'Header+len field+L'DATA1      @01A
         CH    R6,TREN_LEN         Is there a DATA2 ?              @01A
         BE    TRAPRTN             ..No, exit                      @01A
         AH    R4,TREN_FIELD_LEN   Update entry base pointer so that   *
                                   TREN_FIELD_DATA is now DATA2    @D1A
         LA    R4,2(,R4)           Plus two for the length field   @D1A
*
         CLC   TREN_FIELD_DATA(8),=CL8'ABCD' DATA2 is subpool name @D1A
         BNE   TRAPRTN             Not required subpool            @D1A
*
         L     R6,TRAFLGSA         Address return actions flagword @D1A
         OI    0(R6),TRAPDUMP      Take a system dump              @D1A
*
*---------------------------------------------------------------------*
*  Return to DFHTRPT                                                  *
*---------------------------------------------------------------------*
TRAPRTN  DS    0H
*        PUSH  USING                                 ==>ATB ==>DSP @P5A
*        USING RSADATA,R13                           ==>ATB ==>DSP @P5A
*        LAM   R0,R15,RSAARS       Restore ARs              ==>DSP @P5A
*        LMH   R0,R15,RSAGRSHI     Restore top words        ==>ATB @P5A
*        POP   USING                                 ==>ATB ==>DSP @P5A
         L     R13,4(,R13)         Restore DFHTRPT's save area     @D1A
         LM    R14,R12,12(R13)     Restore DFHTRPT's registers     @D1A
         BR    R14                 Return to DFHTRPT
*
         DROP  R4                  DFHTREN                         @L1A
         DROP  R1                  DFHTRADS
         EJECT ,
*---------------------------------------------------------------------*
*  Constants                                                          *
*---------------------------------------------------------------------*
TSTRDATA DC    C'DFHTRAP TS ENTRY'                                 @D1A
         LTORG ,
         DFHEND DFHTRANA
###END DFHTRAP5
$$$BEG ZP111A00
*          DATA SET ZP111A00   AT LEVEL 009 AS OF 01/06/89
RECDSECT DSECT
INREC    EQU   *
         DS    CL2
RECORD   DS    CL78
INRECLEN EQU   *-INREC
         SPACE
DFHEISTG DSECT
RECNO    DS    F
I        DS    H
RECBLOCK DS    20CL80         BLOCK OF RECORDS
*
ZP111A00 CSECT
ZP111A00 AMODE 31
ZP111A00 RMODE ANY
         EXEC CICS HANDLE CONDITION QIDERR(NOQUEUE)
         EXEC CICS DELETEQ TS QUEUE('BCOP')
NOQUEUE  EQU   *
         MVC   I,=H'0'         TEMP STORAGE RECORD NUMBER
         MVC   RECNO,=F'0'     RECORD NUMBER TO READ
         SPACE
         EXEC CICS HANDLE CONDITION ERROR(ENDRECS)
         SPACE
READLOOP DS    0H
         L     4,RECNO         RECORD NUMBER TO READ (MAX 3)
         AH    4,=H'1'
         ST    4,RECNO
         SPACE
         CH    4,=H'3'         HAVE ALL RECORDS BEEN PROCESSED
         BH    ENDRECS             YES--BRANCH
         SPACE
         EXEC CICS READ DATASET('BRDCAST') INTO(RECBLOCK)              X
               LENGTH(RECLEN)                                          X
               RIDFLD(RECNO)
         SPACE
         LA    6,20            NUMBER OF RECORDS PER BLOCK
         LA    7,RECBLOCK      BEG ADDR OF BLOCK
         USING RECDSECT,7
WRITLOOP DS    0H
         LH    4,I
         AH    4,=H'1'
         STH   4,I
         SPACE
         EXEC CICS WRITEQ TS QUEUE('BCOP') FROM(RECORD) ITEM(I) MAIN
         LA    7,INRECLEN(7)            NEXT INPUT RECORD
         BCT   6,WRITLOOP
         B     READLOOP
ENDRECS  DS    0H
         EXEC  CICS RETURN
RECLEN   DC  H'1600'             BROADCAST FILE RECORD LENGTH
         END
###END ZP111A00
