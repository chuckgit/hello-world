TTED.TSK.P.TCEM.CLIST
$$$BEG ZPNT
 /* REXX */
IDSN='TTED.TSK.P.TCEM.CLIST'
IMBRS='ZPNT DSPAFOE AFOLISTN DSPAFOD AFOLOAD AFOSDSF AFORDOR '||,
' DSPAFOE AFOLISTN DSPAFOD AFOLOAD AFOSDSF AFORDOR GDSNNMBR EXPLLDEF'||,
' EXCITSLB EXPLQLIB              DSPLYA         DSPAFOH AFOCTGJL'||,
' RDOPROC GETKREL TST1 ALOCDSN RDOXTND COPYSEL MYTSO1 DSNWIND SPCAT'||,
' EXPLSIGL COPYINFO AFOLIST GETSIT DSPAFOH0 YZ COPYSELD DSPAFODO'||,
' EXHEXDMP TSTDYNAR TESTPRM GETKREL0 EXPLTSOL'||,
' TSTSCRLA EXPLRAND EXCIS0 EXCIS2 DSPAFOCO EXCITSLA DSPAFOC TRXCNCL2'||,
' DSPCNCCH TSTAFONN DYMWIND ALOCPNL DYNWIN'||,
' EXPLPNS DSPAFO# AFO#NTL1 AFO#NTLE AFO#NTLD AFO#NTLB AFO#TABE'||,
' AFO#TABD DSPAFODN TRXCNCL1 GETAFOCN TSTRXVLS'||,
' REXXTCOB EXPLALTB EXRTNVAL TSTSELCT TSTSELC0 SEYUTSLB TSTCBLVG'||,
' TSTENUMV TRXCNC TRXCNCLK EXCIDADC EXCICNC'||,
' DSPCNCCN IPCSTRCX CPDS2VAR REXXCMT TSDYNFLD RXCOMENT DSPCNCAA'||,
' CPSMESSS FREEISPP DSPAFOCH DSPCNC FASRCHLS'||,
' DSPLY2B CTGSTEDT KIXSOCK3 KIXSOCK1 EXPLSTAK AFOS#PRM KIXSOCK2'||,
' CEMHELP REXXSRC DSPAFOCD AFOLPLAY TSTS#PRM TSTPNL'||,
' KIXLSOCK KI#LSOCK EXPLALOC EXPLTIOT GETDSN1 COPYDS XMLST2 CMNEW'||,
' IBMMKDIR RFWD TSTPARSC TSTCPU EXPLARGS ISRVAR'||,
' TRXCNCP PNTCOBVR MAKEIEBZ OCOPY JRPSET EXCIS0$ EXPLSUPC SDMPGDG'||,
' EXPLSDSF FSATEST EXPLGCPU FSAGETE$ GETCPU1'||,
' OSHELL FAIDSRCH EXCIS1 EXPLZMSG CIXXRUN $CVT330 $$ TSTUNKWN'||,
' MAKEIEBC EXPLLDSI RXVTESTK RXVSET EXCIS0A DSPLYTBL'||,
' DSPLY1B EALCPDSE EXPLSAVT S4MBR EXPLPRM1 EXCIS2A EXCIS1A EXCIDADO'||,
' CA1DTEST RXLISTC MYCALC DSPSDSF SFISKIXX'||,
' SFISKIXA DSPSDSFD MYTSO GIMLIBD ISPF#CMD HLASM#DB ABC ATEST'||,
' WHOHASIT BATSDSFX CTGCNFIG CTGLIST DSPSDSF0'||,
' CVTJN2RG DSPAFOEO DSNL2REX SRCH4FSA RDOPROC# SHOWISFL DSPNSTBL'||,
' MYWAIT VLIB VLIBS JRPPNT JRP4182 JRP4181 FNDINLST'
/* TRACE I */
IMCT=WORDS(IMBRS)
X.1=IDSN
XCT=1
ADDRESS TSO
/* IMCT=3  */
DO I = 1 TO IMCT
 IMBR=WORD(IMBRS,I)
 XCT=XCT+1
 X.XCT='$$$BEG 'IMBR
 EDSN=IDSN||'('||IMBR||')'
 SAY X.XCT
 "ALLOC FI(I) DA('"EDSN"') SHR"
 "EXECIO * DISKR I (STEM JCL. FINIS"
 "FREE FI(I)"
 /*TRACE OFF */
 DO J = 1 TO JCL.0
  XCT=XCT+1
  X.XCT=JCL.J
  END
 /* TRACE I */
 XCT=XCT+1
 X.XCT='###END 'IMBR
 SAY X.XCT
 END
 TRACE I
X.0=XCT
SAY 'XCT IS 'XCT
XDSN=TRANSLATE(IDSN,' ','.')
LQ=WORD(XDSN,WORDS(XDSN))
ODSN='TTED.TSK.S.SAMP.'||LQ
"ALLOC FI(O) DA('"ODSN"') NEW BLKSIZE(8080) DSORG(PS) RECFM(F,B) "||,
"LRECL(80) SPACE(100,1) CYLINDER CATALOG REUSE RELEASE"
IF RC \= 0 THEN DO
 SAY 'ERROR ON WRITE'
 EXIT
 END
"EXECIO * DISKW O (STEM X. FINIS"
"FREE FI(I)"
SAY 'DONE WITH 'IDSN
EXIT
###END ZPNT
$$$BEG DSPAFOE
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA          -                                              */
 /* CEMHELP          - TSO BASE, RESTRICTED                         */
 /* CEMHELP          -                                              */
 /* CEMHELP END                                                     */
  /* THE SR PROMPTS FOR THE DSN(MBR) WHICH CONTAINS YOUR PERSONAL    *\
  |*  REGION LISTS                                                   *|
  \*  EACH ENTRY IS PUT TO A ISPF VAR                                */
    ADDRESS ISPEXEC
    "ISPEXEC CONTROL ERRORS RETURN"
    AFODSLST = ''
    AFO_LSTS=''
    TRUNC_NMS=''
    'ISPEXEC VGET (AFODSLST) PROFILE'
    IF RC ^= 0 THEN SIGNAL GET_AFODSLST
    IF AFODSLST ^= '' THEN DO
     EDSN=AFODSLST
     SIGNAL GOT_AFODSLST_0
     END
GET_AFODSLST:
   AFODSLST=''
   EDSN='YOUR.DSN.GOES.HERE(MBR)'
GOT_AFODSLST_0:
   DSEMSG = 'ENTER SRC DSN(MBR) CONTAINING AFO LISTS'
   MYVERB = 'ABORT BYPASS CANCEL'
   "ISPEXEC VPUT (EDSN DSEMSG MYVERB) ASIS"
   CALL DSNWIND
   XC = RESULT
   IF XC > 4 THEN SIGNAL BYPASS_DSLST
   ADDRESS ISPEXEC "VGET (MYVERB) ASIS"
   IF RC ^= 0 THEN SIGNAL BYPASS_DSLST
 /* SIMPLE TEST OF MYVERB */
   IF MYVERB ^= '' THEN DO
    IF MYVERB='ABORT' | MYVERB='CANCEL' THEN SIGNAL BYPASS_DSLST
    IF MYVERB^='BYPASS' THEN SIGNAL BYPASS_DSLST
    END
 PROCSRC:
   ADDRESS ISPEXEC "VGET (EDSN) ASIS"
   IF RC ^= 0 THEN SIGNAL BYPASS_DSLST
   AFODSLST = EDSN
   "ISPEXEC VPUT (AFODSLST) PROFILE"
    IF RC ^= 0 THEN SIGNAL BYPASS_DSLST
GOT_AFODSLST:
    ADDRESS TSO
    XC=LISTDSI("'"AFODSLST"'" DIRECTORY NORECALL)
    IF XC ^= 0 THEN DO
     DSEMSG='INVALID DS FOR AFOLIST REQUIREMENT'
     AFODSLST=''
    "ISPEXEC VPUT (AFODSLST) PROFILE"
     SIGNAL BYPASS_DSLST
     END
    "ALLOC FI(I) DA('"AFODSLST"') SHR"
    "EXECIO * DISKR I (STEM ALST. FINIS"
    "FREE FI(I)"
    ADDRESS ISPEXEC
/*  IF SYSVAR(SYSUID) = 'TCEM' THEN TRACE I */
    ACNT=ALST.0
    TMP_LST=''
    DUPLS=0
    IN_LST = ''
    DO I = 1 TO ACNT
     TMP = STRIP(SUBSTR(ALST.I,1,72),'B')
     FP = POS('*',TMP)
     IF FP = 1 THEN ITERATE
     IF FP > 1 THEN TMP = STRIP(SUBSTR(TMP,1,FP-1),'T')
/*   TMP = STRIP(TMP,'T') */
     IF IN_LST = '' THEN DO
      PARSE VAR TMP LST_NM '=' TMP
      IF LST_NM = '' THEN ITERATE
      IF LST_NM \='MYCTGJL' THEN DO
       IF LENGTH(LST_NM) >= 8 THEN DO
        TRUNC_NMS=TRUNC_NMS||' '||LST_NM
        LST_NM=SUBSTR(LST_NM,1,8)
        JNLST='$'||SUBSTR(LST_NM,2,7)
        END
        ELSE JNLST='$'||LST_NM
       IF WORDPOS(LST_NM,AFO_LSTS) = 0 THEN DO
        AFO_LSTS=AFO_LSTS||' '||LST_NM
        END
       IF WORDPOS(JNLST,AFO_LSTS) = 0 THEN DO
        AFO_LSTS=AFO_LSTS||' '||JNLST
        END
       END
       ELSE DO
       IF WORDPOS(LST_NM,AFO_LSTS) = 0 THEN DO
        AFO_LSTS=AFO_LSTS||' '||LST_NM
        END
       END   /* NOT MYCTGJL */
      IN_LST='('
      END
     IF IN_LST = '(' THEN DO
      FP=POS('(',TMP)
      IF FP > 0 THEN DO
       TMP=SUBSTR(TMP,FP+1)
       IN_LST=')'
       END
       ELSE DO
       IF POS(')',TMP)>0 | POS('=',TMP>0) THEN IN_LST=''
       END
      END
     IF IN_LST = ')' THEN DO
      EP = POS(')',TMP)
      IF EP > 0 THEN DO
       IN_LST=''
       TMP = STRIP(SUBSTR(TMP,1,EP-1),'B')
       END
      TMP=TRANSLATE(TMP,' ',',')
      NWD=WORDS(TMP)
      IF NWD > 0 THEN TMP_LST=TMP_LST||' '||TMP
      END
     IF IN_LST='' THEN DO
      IF LST_NM ='MYCTGJL' THEN DO
      INTERPRET LST_NM' = TMP_LST'
      ADDRESS ISPEXEC 'VPUT ('LST_NM') ASIS'
      TMP_LST=''
      END
      ELSE DO
       X = OUTTRAP('JNL.')
       CALL CVTJN2RG TMP_LST
       X = OUTTRAP('OFF')
       JOBLIST=''
       APLLIST=''
       DO S = 1 TO JNL.0
        JOBLIST=JOBLIST||' '||WORD(JNL.S,2)
        APLLIST=APLLIST||' '||WORD(JNL.S,1)
        END
       INTERPRET JNLST' = JOBLIST'
       INTERPRET LST_NM' = APLLIST'
       ADDRESS ISPEXEC 'VPUT ('JNLST') ASIS'
       ADDRESS ISPEXEC 'VPUT ('LST_NM') ASIS'
       TMP_LST=''
       END
      END
     END     /* END MYCTGJL */
     IF TRUNC_NMS \= '' THEN DO
      CALL MSGBOX 'TRUNCATED JOB NAMES:'TRUNC_NMS
      END
BYPASS_DSLST:
     MAFOLSTS=STRIP(AFO_LSTS,'B')
     ADDRESS ISPEXEC 'VPUT (MAFOLSTS) ASIS'
     RETURN
###END DSPAFOE
$$$BEG AFOLISTN
/* REXX */
/* CEMHELP BEGIN                                                     */
/* CEMHELA AFOLISTN - LIST AFO CICS ONLINES ON THIS SYSPLEX V3.0     */
/* CEMHELP AFOLISTN - ISPF BASED, READS THE AFO FILE AND BUILDS A    */
/* CEMHELP          - ISPF SCREEN WHICH DISPLAYS ALL TEST, ACCP AND  */
/* CEMHELP          - PROD CICS APPLIDS FOR THIS SYSPLEX.            */
/* CEMHELP          - DATA DISPLAYED CAN BE SELECTED: USE AFOLIST ?  */
/* CEMHELP          - TO SELECT FIELDS FROM AFOPER FILE.             */
/* CEMHELP          - EACH CICS APPLID HAS AN INPUT FIELD IN WHICH   */
/* CEMHELP          - OTHER PROCESSING CAN BE DRIVEN (COPYINFO,ECT)  */
/* CEMHELP          - VERSION 2. UPDATED TO ALLOW FOR EXCI INTERFACE.*/
/* -                                                                 */
/* - THIS VERSION (V3) NOW ALLOWS CHANNEL AND CONTAINERS IN ADDITION */
/* -   TO COMMAREA SOURCE REQUEST DATA                               */
/* -   ALSO: ADDED LIBDEF LOGIC TO ALLOC ISPPLIB AND ISPLLIB UP FRONT*/
/* -   NOTE: LIBDEF WITH STACK, ALLOWS THESE LIBDEF TO UNSTACK       */
/* -         AUTOMATICALLY AT END OF THIS EXEC                       */
/* -   ISPP LIB CALLS CAN NOW OMIT OTHER LIBDEF CALLS (DSPAFOD       */
/* - IT RUNS THE COPYINFO EXEC FOR THIS ONLINE                       */
/* - NOTE: FOR THE FOLLOWING, YOU NEED TO HAVE RUN THE FOLLOWING     */
/* - COMMAND FROM THE TSO 'READY' PROMPT:                            */
/* - EX 'TTED.TS.P.TCEM.CLIST(EXCITSLB)' '540'                       */
/* - WHICH ADDS TO THE TSO RUN ENVIR                                 */
/* - THEN RUN CICLOGON TO GET ISPF BACK                              */
/* - G RUNS THE EXCI PING                                            */
/* - D RUNS THE EXCI CEDA                                            */
/* - E RUNS THE EXCI CEMT                                            */
/* - L RUNS THE EXCI LINK                                            */
/* - N CREATES  CHANNEL AND CONTAINER DATA (REXX STEM VARS)          */
/* G,D,E, AND L PROCESSING:                                          */
/* ALL REQUIRE EXCITSLB EXEC TO BE RUN FROM TSO READY, TO ADD A      */
/* - TSOLIB EXECUTABLE TO THE TSO STEPLIB CONCATENATION              */
/* G DOES NOT PROMPT FOR A COMMAREA                                  */
/* - RUNS THE PING PROGRAM FOR THE SELECTED ONLINES                  */
/* D, E, AND L WILL PRESENT A PANEL TO CAPTURE THE INPUT DATA FOR    */
/* - THE REQUESTED COMMAND. THIS DATA IDENTIFIES THE COMMAREA AND THE*/
/* - COMMAREA LENGTH. THE COMMAREA MUST BE VALID FOR THE COMMAND     */
/* - REQUESTED (I.E. >CEMT INQUIRE TASK                              */
/* - IS VALID FOR A CEMT OR E LINE COMMAND) NO SYNTAX CHECKING IS    */
/* - PERFORMED.                                                      */
/* - IF L FOR LINK IS SELECTED, THEN ADDITIONAL FIELDS ON THE        */
/* - INPUT DATA PANEL IS REQUESTED. THAT IS, THE TARGET PROGRAM, AND */
/* - A REQUIRED TRANSACTION TO RUN UNDER. THE COMMAREA IS OPTIONAL   */
/* - FOR THE PROGRAM.                                                */
/* - ALL COMMAREA LENGTHS ARE IN RANGE 0 - 32400                     */
/* - THE DATA INPUT PANEL WILL ONLY ALLOW YOU TO ENTER INPUT COMMAREA*/
/* - DATA UP TO 20*60 CHARACTERS. HEX DATA IS NOT POSSIBLE (THIS IS  */
/* - A PLANNED ENHANCEMENT AS TIME PERMITS).                         */
/* -                                                                 */
/* - N CALLS DSPCNC TO COLLECT A  SET OF CONTAINERS                  */
/* -   CONTAINERS ARE UNIQUELY NAMED, AND NOT SPECIFIC TO A CHANNEL  */
/* -   THE CNC COMMAND OR THE N SELECTION WILL ALLOW YOU TO CREATE   */
/* -   A SET OF REQUEST CONTAINERS AS A TEMPLATE                     */
/* -   THE SET OF NAMED TEMPLATE CONTAINERS CAN BE USED TO POPULATE  */
/* -   A CHANNEL WITH A 'COPY' OF A DEFINED TEMPLATE CN.             */
/* -   THE TEMPLATE IS MEANT TO BE REUSED; IT IS NOT USED ON THE     */
/* -   ACTUAL EXCI CALL; THE COPY OF THE TEMPLATE IS SENT.           */
/* -   THE DSPAFOCD PANEL NOW ALLOWS YOU TO CHOOSE THE SOURCE:       */
/* -   'COMMAREA' IS THE DEFAULT. ANY OTHER SPECIFICATION IS ASSUMED */
/* -   TO BE A CNC REQUEST.                                          */
/* -   THE CHANNEL PROCESSING PRESENTS A TABLE OF THE TEMPLATE       */
/* -   CONTAINERS (ALL THAT EXIST AT THE MOMENT). YOU SELECT EACH    */
/* -   TEMPLATE CONTAINER THAT YOU WANT TO COPY TO THE CHANNEL       */
/* -                                                                 */
/* - NOTE - FOR CEDA, TO DISPLAY DETAILS ON AN OBJECT, USE THE VIEW  */
/* -        COMMAND:                                                 */
/* -   CEDA VIEW   GROUP(IPICTCPS) TCPIPS(IPICCTGN)                  */
/* -   CEDA ALTER PROGRAM(KOCOME00) GROUP(OMEGAMON) CONCURRENCY(ANY) */
/* -   CEDA DISPLAY LIST(\@) - '\@' IS SYBOLIC SUB FOR APPLID        */
/* -   THE \@ AND \$ SYMBOLIC SUB FOR APPLID AND JOBNAME RESPECTIVLY */
/* -   THIS FEATURE IS AVAILABLE TO COMMAREA DATA CONTENT            */
/* -     (CEMT CEDA LINK PING)                                       */
/* -                                                                 */
/* PROCESSING INTERACTION IS CONTROLLED BY THE FOLLOWING:            */
/* - (Q)UIET MSGBOX(O)NLY MSGBOX(A)LL (V)ERBOSE                      */
/* - - BUT WILL COLLECT THE OUTPUT AND WRITE IT TO A NEW DSN         */
/* - (Q)UIET WILL RUN THE REQUEST(S) WITHOUT ANY PROGRESS INFORMATION*/
/* - MSGBOX(A)LL PROCESS THE SELECTION, SHOWING A PROGRESS BOX, AND  */
/* - - PRESENTING A FINAL DISPLAY WITH ALL RESULTS.                  */
/* - MSGBOX(O)NLY PRESENTS THE RESULTS FROM EACH INDIVIDUAL ONLINE   */
/* - - WHERE YOU CAN PF3 TO CONTINUE WITH THE NEXT ONLINE, OR CANCEL */
/* - (V)ERBOSE IS A TSO LINE BY LINE DISPLAY                         */
/* AFOLIST ALLOWS THE FOLLOWING PRIMARY COMMAND LINE ENTRIES:        */
/* - CEDA X, CEMT X LINK X PLAY X                                    */
/* - - WHERE X IS ONE OF TEST, ACCP OR PROD                          */
/* -                   @SYS WHICH IS LPAR SYSID ON SYSPLEX           */
/* -       X IS ONE OF OF YOUR SAVED REGION LISTS                    */
/* -       X IS 'CURRLIST' A DYNAMIC LIST CREATED BY MAKE AND APPEND */
/* -                   COMMANDS                                      */
/* - - WHICH SELECTS ALL ONLINES FROM THE RESPECTIVE LIST            */
/* - LISTS? SHOWS ALL OF THE KNOWN LISTS                             */
/* - SHOWLIST X WHERE X IS ONE THE (ABOVE ) KNOWN LISTS              */
/* - MAKE AND APPEND WILL CREATE|RESET/APPEND REGIONS SELECTIONS TO  */
/* -       THE DYNAMIC 'CURRLIST' REGIONS LIST.                      */
/* -       USE 'M' OR 'A' TO SELECT A REGION TO ADD TO CURRLIST      */
/* - PLAY - WILL INVOKE A MSGBOX TO COLLECT YOUR SCRIPT.             */
/* -      - SYNTAX IS NOT VERIFIED                                   */
/*         - IF YOU PLAY A LINK COMMAND, THEN YOU MUST HAVE          */
/*           INCLUDED A MYPROG(XXXXXXXX) VARIABLE  AND               */
/*           OPTIONALY A MYTRANID(YYYY)                              */
/*           OPTIONALY A MYCA(COMMAREA)                              */
/*           OPTIONALY A MYCAL(NNN)                                  */
/*           AFTER LINK PROGRAM(XXXX), THE OTHER VARIABLES IN ANY    */
/*           ORDER.                                                  */
/*   LINK MYPROG(UCEMPING) MYTRANID(UXXX) MYCAL(1016) MYCA(PING)     */
/* - CEMT AND CEDA - SYNTAX REQUIRES THAT YOU FULLY SPELL OUT THE    */
/* -       - SECOND PARAMETER (INQUIRE,SET,EXPAND,VIEW,DISPLAY...)   */
/* -       - SUBSEQUENT MUST BE VALID TO THE CICS COMMAND            */
/* -       - MYCAL IS CODED TO 4096 - PROGRAM CHANGE TO MAKE IT BIGER*/
/* -       - MYTRANID IS CODED AS THE DEFAULT CSMI                   */
/* - RELATED: THE FOLLOWING EXEC CAN BE EXECUTED AS A 'TSO CEM XXX'  */
/*         - AND UTILIZE THE VARIOUS AFOLIST REGIONS LIST VARIABLES  */
/* -       - (INCLUDING THE CURRLIST DYNAMIC LIST)                   */
/* -       - USE CEMHELP XXX FOR SPECIFIC INFORMATION                */
/* -         AFOSDSF - EXECUTE SDSF OPERATOR COMMANDS(S) FOR REGION(S)*/
/* -         AFORDOR - RUN DFHCSDUP COMMND(S) FOR REGION(S)          */
/* -         DSPSDSF - CAPTURE SDSF OUTPUT FOR REGION(S)             */
/* -                                                                 */
/* CEMHELP END                                                       */
/* COPIED FROM AFOLIST AS PRE CNC VERSION 20181017 */
/* ALTERED TO ADD CNC LOGIC               20181017 */
/* COPIED FROM AFOLIST AS PRE CNC VERSION 20181017 */
/* ALTERED TO ADD CNC LOGIC               20181017 */
/* COPIED FROM AFOLIST AS PRE CNC VERSION 20181017 */
/* ALTERED TO ADD CNC LOGIC               20181017 */
/* COPIED FROM AFOLIST AS PRE CNC VERSION 20181017 */
/* ALTERED TO ADD CNC LOGIC               20181017 */
 ADDRESS ISPEXEC
  'ISPEXEC CONTROL ERRORS RETURN'
 AFOLSTNV='3.0'
 AFOLISNM='AFOLISTN'
  "ISPEXEC VPUT (AFOLISNM AFOLSTNV) ASIS"
  PNLLOADED=0
  PLLLOADED=0
  MYPNLIB='TTED.TSK.D.TCEM.ISPPLIB'
  MYPLLIB='TTEP.TSK.E.TCEM.PDSE'
  IF PNLLOADED > 0 THEN SIGNAL GOTMYPNLIB
  IDVAL_CT = 0
 TRYAGN:
  IDVAL=''
  'ISPEXEC QLIBDEF 'ISPPLIB' ID(IDVAL)'
  XC = RC
  IF IDVAL \= '' THEN DO
   IF IDVAL_CT > 1 THEN DO
    SAY 'COULD NOT LIBDEF ISPPLIB. LOOP??'
    RETURN 8
    END
   XDSN=TRANSLATE(IDVAL,"  ",",'")
   IF WORDPOS(MYPNLIB,XDSN) \= 0 THEN SIGNAL GOTMYPNLIB
   CALL EXPLLDEF 'ISPPLIB' MYPNLIB 'STACK' 'QUIET'
   XC=RESULT
   IDVAL_CT = IDVAL_CT + 1
   SIGNAL TRYAGN
   END
  IF IDVAL = '' THEN DO
   STKLIBS=MYPNLIB
   CALL EXPLLDEF 'ISPPLIB' STKLIBS 'STACK' 'QUIET'
   XC=RESULT
   IF RC > 4 THEN DO
    SAY 'COULD NOT LIBDEF ISPPLIB. RC WAS'RC
    RETURN 8
    END
   END
 GOTMYPNLIB:
  PNLLOADED = 1
  IF PLLLOADED > 0 THEN SIGNAL GOTMYPLLIB
   IDVAL_CT = 0
 TRYAGN_ISPL:
   IDVAL=''
   'ISPEXEC QLIBDEF 'ISPLLIB' ID(IDVAL)'
   XC = RC
   IF IDVAL \= '' THEN DO
    IF IDVAL_CT > 1 THEN DO
     SAY 'COULD NOT LIBDEF ISPLLIB. LOOP??'
     RETURN 8
     END
    XDSN=TRANSLATE(IDVAL,"  ",",'")
    IF WORDPOS(MYPLLIB,XDSN) \= 0 THEN SIGNAL GOTMYPLLIB
    CALL EXPLLDEF 'ISPLLIB' MYPLLIB 'STACK' 'QUIET'
    XC=RESULT
    IDVAL_CT = IDVAL_CT + 1
    SIGNAL TRYAGN_ISPL
    END
   IF IDVAL = '' THEN DO
    CALL EXPLLDEF 'ISPLLIB' MYPLLIB 'STACK' 'QUIET'
    XC=RESULT
    IF XC > 4 THEN DO
     SAY 'COULD NOT LIBDEF ISPLLIB. RC WAS'RC
     RETURN 8
     END
    END
 GOTMYPLLIB:
    PLLLOADED = 1
 XC = 0
 UCEMPIN_='UCEMPINR'
LGP1:
 /* IF SYSVAR(SYSUID) = 'TCEM' THEN TRACE I */
 CALL GETCPU1
 XC=RESULT
 IF XC ^= 0 THEN SIGNAL EXITRC8
 "ISPEXEC VGET (CURGRP CURCPUG) PROFILE"
 IF RC ^= 0 THEN SIGNAL EXITRC8
GOTCPUG:
 L_CPUG=LENGTH(CURCPUG)
 HOSTLIST=''
 DO I = 1 TO L_CPUG
  /* H = 'CPUHOST'SUBSTR(CURCPUG,I,1) */
  TH = SUBSTR(CURCPUG,I,1)||'SYS'
  INTERPRET TH'=""'
  HOSTLIST = HOSTLIST||" "TH
  END
 SELTYP=''
 /* CALL AFOFLD TO LOAD THE AFOFILE AND FIND THE REQUIRED VARIABLE */
 /*  META DATA : NAME OFFSET ANAD LENGTH. RETURN THIS INFO         */
 DFTVARS='MYAPLID MYCOLDJ MYCPU MYREL MYTYP'
 HLDVARS=DFTVARS
 THLDVARS=''
 HLDTMP=''
 CALL AFOFLD DFTVARS
 XC = RESULT
 PULL SRTVARS
 /* SAY SRTVARS */
 IF XC ^= 0 THEN SIGNAL EXITRC8
 /* SETLBL= 1     */   /* USED TO RETURN TO SETLBL1 */
 HLDLIT=''
 H_SRTVARS=SRTVARS
 CALL SETUPVAR
 H_HLDLIT=HLDLIT
SETRET1:
/* CHECK TO SEE IF AFOPER SELECTION VARIABLES WERE PROVIDED ON THE   */
/* COMMAND INVOKATION. IF SO, THEN FIND THE META DATA FOR THESE.     */
/* IF NONE, THEN USE THE DEFAULT LIST                                */
/* TRACE I */
 ARG SRTVARS
 I_SRTVARS=SRTVARS
 IF SRTVARS='' THEN SIGNAL USEDFT_VARS
/* GOT OVERRIDES. IF '?' OR 'INPUT' THEN PROMPT FOR SELECTION CRITRIA*/
 IF SRTVARS='?' | SRTVARS = 'INPUT' THEN DO
  SELTYP='INPUT'
  SELSTR = ''
  "ISPEXEC VPUT (SELSTR) ASIS"
  CALL AFOFLDS SELTYP
  XC=RESULT
/*IF XC ^= 0 THEN SIGNAL USEDFT_VARS */
  "ISPEXEC VGET (SELSTR) ASIS"
  PULL SRTVARS
  IF SELSTR = '' THEN SIGNAL USEDFT_VARS
  IF SRTVARS = '' THEN SIGNAL USEDFT_VARS
  END
  ELSE DO
  SELSTR = SRTVARS
  END
 THLDVARS=''
DOPARSE:
/* WE NEED 3 REQUIRED VARS: MYAPLID MYCPU AND MYTYP. INSURE THE LIST */
/* INCLUDES THESE IN THE SELECTION CRITERIA                      */
/* WARNING!!! MYAPLID HAS TO BE FIRST                            */
 SELSTR = 'MYAPLID '||SELSTR
 XC=WORDPOS('MYAPLID',SELSTR,2)
 IF XC \= 0 THEN SELSTR=DELWORD(SELSTR,XC,1)
 IF WORDPOS('MYCPU',SELSTR) = 0 THEN SELSTR=SELSTR||' MYCPU'
 IF WORDPOS('MYTYP',SELSTR) = 0 THEN SELSTR=SELSTR||' MYTYP'
 /* PULL */
 CALL AFOFLD SELSTR
 XC = RESULT
 PULL SRTVARS
 IF XC > 8 THEN SIGNAL EXITRC12
 IF XC = 8 THEN SIGNAL BAD_PARM
 IF SRTVARS = '' THEN SIGNAL USEDFT_VARS
 THLDVARS=''
DOSET2:
 /* SETLBL= 2     */   /* USED TO RETURN TO SETLBL2 */
 HLDLIT=''
 HLDVARS = SELSTR
 CALL SETUPVAR
 SIGNAL SETRET2
USEDFT_VARS:
 HLDVARS = DFTVARS
 HLDLIT=H_HLDLIT
 SRTVARS=H_SRTVARS
SETRET2:
 "ISPEXEC VGET (MYAFOIND SVAFO0) SHARED"
 IF RC = 0 THEN SIGNAL AFLD
 CALL AFOLOAD1
 "ISPEXEC VGET (MYAFOIND SVAFO0) SHARED"
 IF RC ^= 0 THEN SIGNAL EXITRC8
AFLD:
 "ISPEXEC VGET (GPAFO0) SHARED"
 IF RC ^= 0 THEN SIGNAL LGP
 IF GPAFO0 ^= 0 THEN SIGNAL GPLD
LGP:
 TLST=''
 ALST=''
 PLST=''
 J = 0
 T = 0
 A = 0
 P = 0
 MYCB=MYCPU.B
 MYCL=MYCPU.L
 MYTB=MYTYP.B
 MYTL=MYTYP.L
 J = 0
 DO I = 1 TO SVAFO0
  INTERPRET '"ISPEXEC VGET (SVAFO'||I') SHARED"'
  INTERPRET 'TMP=SVAFO'||I
  MYCPU=SUBSTR(TMP,MYCB,MYCL)
  IF POS(MYCPU,CURCPUG) = 0 THEN ITERATE
  MYTYP=SUBSTR(TMP,MYTB,MYTL)
  IF POS(MYTYP,'EDTAP') = 0 THEN ITERATE
  TA=SUBSTR(TMP,2,8)
  /* INTERPRET 'CPUHOST'MYCPU' = CPUHOST'MYCPU'||" "||STRIP(TA,"B")' */
  INTERPRET MYCPU'SYS = 'MYCPU'SYS||" "||STRIP(TA,"B")'
  ST = MYTYP
  IF POS(ST,'DTAP') = 0 THEN ST='T'
  IF ST = 'E' | ST = 'D' THEN ST = 'T'
  INTERPRET ST '= 'ST' + 1'
  INTERPRET ST"LST = "ST"LST||STRIP(TA,'B')||' '"
  B = 'SRC'||ST||'.'
  INTERPRET 'TMP = 'HLDLIT
  INTERPRET B||ST' = LEFT(TMP,24)'
  J = J + 1
  TRACE OFF
  END
 TEST=TLST
 ACCP=ALST
 PROD=PLST
 DROP TLST ALST PLST
 'ISPEXEC VPUT (TEST ACCP PROD) ASIS'
 K = MAX(T,A,P)
 IF K = 0 THEN SIGNAL EXITRC12
/*  TRACE I */
  HOSTLIST = STRIP(HOSTLIST,'B')
  'ISPEXEC VPUT ('HOSTLIST') ASIS'
  CALL AFOCTGJL
  HOSTLIST=HOSTLIST||' CTGDEVJL CTGTSTJL CTGPRDJL'
  HOSTLIST=HOSTLIST||' ATGDEVJL ATGTSTJL ATGPRDJL'
  'ISPEXEC VPUT (HOSTLIST) ASIS'
/*  TRACE OFF */
 PUTSTR=''
 SP24=COPIES(' ',24)
 DO I = 1 TO K
  IF I > T THEN ST = SP24
   ELSE ST = SRCT.I
  IF I > A THEN SA = SP24
   ELSE SA = SRCA.I
  IF I > P THEN SP = SP24
   ELSE SP = SRCP.I
  INTERPRET 'AFOL'||I||'= ST SA SP'
  PUTSTR=PUTSTR||' AFOL'||I
  END
 PUTSTR=STRIP(PUTSTR,'L')
 MYTYP='AFOL'
 MYTYTOT=K
 DSEMSG = THLDVARS
 "ISPEXEC VPUT (MYTYP MYTYTOT DSEMSG) ASIS"
 "ISPEXEC VPUT ("PUTSTR") ASIS"
GPLD:
 /*  THIS INVOKES THE MAIN PROCESSING PROGRAM AND PANEL */
 AUTOSAVE='N'
 "ISPEXEC VPUT (AUTOSAVE) ASIS"
 /* ENTER PRIMARY LOGIC                                           */
 CALL DSPAFOD
 /* EXIT  PRIMARY LOGIC                                           */
 XC = RESULT
 SIGNAL EXITIT
BAD_PARM:
  XC = 8
  SAY 'RC' XC 'INVALID PARAMETER NOT RECOGNISED.'I_SRTVARS
 SIGNAL EXITIT
EXITRC8:
  XC = 8
  SAY 'RC' XC 'COULD NOT ESTABLISH CPU VARIABLES. SORRY.'
 SIGNAL EXITIT
EXITRC12:
  SAY 'NO RECORDS ON AFOPER FILE MEET CRITERIA'
  XC = 12
 SIGNAL EXITIT
EXITRC4:
  XC = 4
  SAY 'RC' XC 'COULD NOT ESTABLISH CPU VARIABLES. SORRY.'
 SIGNAL EXITIT
EXITIT:
 RETURN XC
/* SUBROUTINE TO STRIP AND SETUP AFO VAR SELECTION */
SETUPVAR:
  MWD=WORDS(HLDVARS)
  K = 0
  DO WHILE(SRTVARS^='')
   K = K+1
   IF K > MWD THEN RETURN 4
   HLDSTR=WORD(HLDVARS,K)
   PARSE VAR SRTVARS TMPSTR '#' SRTVARS
   PARSE VAR TMPSTR TL TB TE TLIT
   IF WORDPOS(HLDSTR,THLDVARS) ^= 0 THEN ITERATE
    ELSE THLDVARS = THLDVARS||' '||HLDSTR
   INTERPRET HLDSTR'.L = 'TL
   INTERPRET HLDSTR'.B = 'TB
   LTL=TL+1
/* HLDLIT IS BEING SET UP TO BE EXECUTED IN A INTERPRET LATER */
/*  NOTICE THAT THE VAR 'TMP' IS ACTUALLY SET UP LATER. THEN THIS */
/*  HLDLIT MAKES SENSE                                        */
   HLDLIT=HLDLIT||'LEFT(SUBSTR(TMP,'TB','TL'),'LTL')'
   END
  RETURN 0
  EXIT
###END AFOLISTN
$$$BEG DSPAFOD
 /* REXX */
 /* CEMHELP BEGIN                                                   *\
 |  CEMHELA DSPAFOD  - SUBROUTINE TO AFOLIST. SEE AFOLIST           *|
 |* CEMHELP DSPAFOD  - SUBROUTINE TO AFOLIST. SEE AFOLIST           *|
 |* CEMHELP          - V3.0                                         *|
 |* CEMHELP END                                                     *|
 |* WHEN SELECTING INDIVIDUAL REGIONS, YOU CAN DEFER INDIVIDUAL     *|
 |* BY ENTERING THE PRIMARY COMMAND (CEMT, CEDA,...) FOLLOWED BY    *|
 |*  THE WORD LIST.                                                 *|
 |* THE VAR D_STR  IS PREPENDED WITH '@ ' AND THEN THE CMD WORD     *|
 |*  EACH RGN FLD SELECTED WILL BE CONCAT TO THE D_STR              *|
 |*  FINALLY WHEN THE ALL FLDS ARE PROCESSED, INVOKE THE DSPAFOC    *|
 |*  TO GET THE 'CMD' DATA REQUEST, AND THE RETURN HERE TO          *|
 |*  CALL EXCI ONE AFTER ANOTHER                                    *|
 |* COPIED TO DSPAFODO TO PRESERVE PRE CNC VERSION 2                *|
 |*  V3 ADDS LOGIC TO GET THE COMMAREA OR A CNC                     *|
 |*  V3 CALLS DSPAFOH INSTEAD OF DSPAFOC                            *|
 |*                                                                 *|
 |*                                                                 *|
 \*                                                                 */
 ADDRESS ISPEXEC
 /* TRACE I */
 TRCCMD = 'TRACE OFF'
 ARG MYTYP MYTYTOT
 FSAVSTR=''
 AFOLISTV=''
 AFOLISNM=''
 "ISPEXEC VGET (AFOLISNM AFOLISTV) ASIS"
 IF MYTYTOT = '' THEN DO
  "ISPEXEC VGET (MYTYP MYTYTOT DSEMSG) ASIS"
  IF RC \= 0 THEN SIGNAL NOPOOL
  AFOLISTV = DSEMSG
  END
 DSEMSG=' '
 MYAREA=''
 IF MYTYTOT \> 0 THEN SIGNAL NOPOOL
 A = VALUE(MYTYP)
 MXLNG = 0
 APLP=WORDPOS('MYAPLID',AFOLISTV)
 DO I = 1 TO MYTYTOT
  VGETSTR=VGETSTR||' '||MYTYP||I
  END
 BKSLH = ' \'
 FNDWDS='\@ \$ \! \\'  /* SUBSTITUTE \ APPLID JOBNAME */
 RWCT=WORDS(FNDWDS)
 SUBWDS='MYAPLID JOBN S#PARM BKSLH'
 TECCMDS = 'CEMT CEDA PLAY'
 TC1='E D P'
 VALCMDS = 'PING LINK '||TECCMDS||' PING MAKE APPEND'
 VALCMD1 = 'G L '||TC1||' Q M A'
 DFT_UCEMPIN='UCEMPINQ'
 DFT_PING_CAL=1008
 MAX_CAL=32400
 DFT_CAL=4080
 TEST=''
 ACCP=''
 PROD=''
 MYCCPU = MVSVAR('SYSNAME')
 "ISPEXEC VGET ("VGETSTR") ASIS"
 DO I = 1 TO MYTYTOT
  INTERPRET 'TMP = 'A||I
  SRCT.I = SUBSTR(TMP,1,24)
  TEST=TEST||' '||WORD(SRCT.I,APLP)
  SRCA.I = SUBSTR(TMP,26,24)
  ACCP=ACCP||' '||WORD(SRCA.I,APLP)
  SRCP.I = SUBSTR(TMP,51,24)
  PROD=PROD||' '||WORD(SRCP.I,APLP)
  END
 TEST=STRIP(TEST,'B')
 ACCP=STRIP(ACCP,'B')
 PROD=STRIP(PROD,'B')
 APLLSTALL = TEST||' '||ACCP||' '||PROD
 VALLISTS='TEST ACCP PROD APLLSTALL '
  "ISPEXEC VGET (MYAFOIND CURGRP CURCPU CURCPUG) ASIS"
 VALCPU = ''
 L_CPUG=LENGTH(CURCPUG)
 VALCPU = ''
 DO I = 1 TO L_CPUG
  TH = SUBSTR(CURCPUG,I,1)
  INTERPRET 'VALCPU = VALCPU || " 'TH'SYS"'
  END
 VALCPU = STRIP(VALCPU,'B')
 'ISPEXEC VGET (HOSTLIST) ASIS'
 'ISPEXEC VGET ('HOSTLIST') ASIS'
 VALLISTS=VALLISTS||HOSTLIST
 CURRLIST = ''
 TMPLST='CURRLIST'
 MAFOLSTS=''
/* DSPAFOE PROMPTS FOR THE DSN(MBR) WHICH CONTAINS YOUR PERSONAL   *\
|*  REGION LISTS                                                   *|
\*  EACH ENTRY IS PUT TO A ISPF VAR                                */
 CALL DSPAFOE
 'ISPEXEC VGET (MAFOLSTS) ASIS'
 'ISPEXEC VGET ('MAFOLSTS') ASIS'
 /* TRACE I
 NW=WORDS(MAFOLSTS)
 DO I = 1 TO NW
  INTERPRET 'XX='WORD(MAFOLSTS,I)
  END
 */
 MAFOLSTS='CURRLIST '||MAFOLSTS
 VALLISTS=VALLISTS||' '||MAFOLSTS
 TRACE OFF
 MXLNG = 79
 SUDT=DATE('U')
 BOTLN=MYTYTOT
 CURLN=1
 CURCL=1
 SP78=COPIES(' ',78)
 DL78=SUBSTR('-'||SP78,1,78)
  "ISPEXEC VGET (ZSCREEND) ASIS"
  MYSCRD=ZSCREEND-4
  MYPNLD='AFOLTABD'
  IF MYSCRD > 20 THEN DO
   IF MYSCRD > 39 THEN MYSCRD = 39
   MYPNLD='AFOLTABE'
   END
  UP_PG=MYSCRD-1
  D_STR = ''
DSPLOOP:
  /* TRACE I */
 CMDIND=0
 "ISPEXEC VPUT (CMDIND) ASIS"
 STIM=TIME()
 TOPLN=CURLN
 TOPCL=CURCL
 DO I = 1 TO MYSCRD
  INTERPRET 'MITAT'I'= ""'
  INTERPRET 'MITAA'I'= ""'
  INTERPRET 'MITAP'I'= ""'
  IF CURLN > BOTLN THEN DO
   INTERPRET 'MYDST'I' = DL78'
   INTERPRET 'MYDSA'I' = DL78'
   INTERPRET 'MYDSP'I' = DL78'
   END
   ELSE DO
   TLNG = 80
   INTERPRET 'MYDST'I' = SRCT.CURLN'
   INTERPRET 'MYDSA'I' = SRCA.CURLN'
   INTERPRET 'MYDSP'I' = SRCP.CURLN'
   END
  CURLN = CURLN + 1
  TRACE OFF
  END
 /* TRACE I */
 CMD = ''
 CMD1 = ''
 MYVERB=''
 MYEND=''
 DSEMSG=D_STR
 "ISPEXEC DISPLAY PANEL("MYPNLD")"
 LASTCC=RC
 IF LASTCC > 16 THEN DO
  SAY 'DISPLAY PANEL:'MYPNLD': RETURNED ERROR:'LASTCC':ABORT'
  RETURN 20
  END
 /* TRACE ?I */
 MYCMD = WORD(CMD,1)
 IF CMD = 'END' THEN SIGNAL TRYEND
 IF LASTCC = 8 THEN RETURN 8
 IF CMD = 'CANCEL' THEN RETURN 8
 IF CMD = '' THEN DO
  CMD1 = ''
  CMD_W2 = ''
  SIGNAL DO_LOOP
  END
 IF CMD = '?' THEN SIGNAL SHOWNLOOP
 IF CMD = 'LISTS?' THEN SIGNAL SHOWLISTS
 IF MYCMD = 'SHOWLIST' THEN SIGNAL SHOWONELIST
 /* TRACE I  */
 WP=WORDPOS(MYCMD,VALCMDS)
 IF WP = 0 THEN DO
  ERRMSG = 'CMD:'||CMD||': IS NOT A VALID COMMAND.'
  CMD = ''
  MYCMD=''
  CMD1 = ''
  CMD_W2 = ''
  SIGNAL DO_LOOP
  END
 /* TRACE I */
 CMD1 = WORD(VALCMD1,WP)
 CMD_W2 = WORD(CMD,2)
 /* TRACE I */
 IF CMD1 = 'M' THEN DO
  /* TRACE ?I */
  IF CMD_W2 = '' THEN TMPLST='CURRLIST'
   ELSE DO
    IF LENGTH(CMD_W2) < 1 | LENGTH(CMD_W2) > 8 | ,
     (DATATYPE(SUBSTR(CMD_W2,1,1)) \= 'CHAR') THEN DO
     ERRMSG = 'MAKE VAR NAME INVALID'
     SIGNAL DO_LOOP
     END
    IF CMD_W2 = 'LIST' THEN DO
     ERRMSG = 'MAKE NAME "LIST" RESTRICTED'
     SIGNAL DO_LOOP
     END
    TMPLST=CMD_W2
   END
  IF WORDPOS(TMPLST,MAFOLSTS) = 0 THEN DO
   MAFOLSTS=MAFOLSTS||' '||TMPLST
   VALLISTS=VALLISTS||' '||TMPLST
   END
 /* MAKE WILL EITHER CREATE NEW LIST, OR REPLACE EXISTING */
  INTERPRET TMPLST'=""'
  "ISPEXEC VPUT ("TMPLST") ASIS"
  D_STR = ''
  MYCMD='APPEND'
  ZCMD='APPEND'
  CMD1='A'
  ERRMSG = 'MAKEING LIST NAMED:'TMPLST':'
  SIGNAL DO_LOOP
  END                  /* END CMD1 = 'M' */
/* APPEND PROCESSES ALL SELECTED REGIONS */
 IF CMD1 = 'A' THEN DO
  ERRMSG = 'APPENDING LIST NAMED:'TMPLST':'
  SIGNAL DO_LOOP
  END                  /* END CMD1 = 'M' */
/* NOT MAKE OR APPEND CMD                */
/* PLAY CMD REQUIRES A LIST              */
 IF CMD1 \= 'P' THEN SIGNAL ARNDPLAY
 /* TRACE I */
 IF CMD_W2 = '' THEN DO
  CMD1=''
  CALL MSGBOX 'ERROR:PLAY LIST SELECT MISSING.VALID LISTS:'MAFOLSTS
  SIGNAL ARND_LOOP
  END
  /*                 */
ARNDPLAY:
 /* TRACE I */
  /* IF 2ND WORD IS LIST; THEN WE CONSIDER THIS AN IMMEDIATE REQUEST *\
  |*  WHERE THE CMD IS RECODED, AND ALL 'S' REGIONS WILL BE          *|
  \*  TREATED AS AN IMMEDIATE LIST; AND EXECUTION PROCEEDS FOR EACH  */
 IF CMD_W2 = 'LIST' THEN DO
  IF D_STR = '' THEN  D_STR = '@ '||MYCMD||' '
   ELSE DO
   IF SUBSTR(D_STR,1,1) \= '@' THEN D_STR = '@ '||MYCMD||' '||D_STR
   END
  SIGNAL DO_LOOP
  END
  /* AT THIS POINT, THE 2ND WORD MAY BE A LIST; BASED ON CPU; REGION *\
  |*  D,T,A,P; A LIST FROM YOUR PERSONAL DS(MBR); OR CURRLIST        *|
  \* WHEN WE HAVE A LIST, WE DO NOT ITERATE THE REGIONS SELECTION FLD*/
 TX=WORDPOS(CMD_W2,VALCPU)
 IF TX \= 0 THEN DO
  TH = SUBSTR(WORD(VALCPU,TX),1,1)
  /* INTERPRET "D_STR = CPUHOST"TH */
  INTERPRET "D_STR = "TH"SYS"
  IF WORDS(D_STR) = 0 THEN SIGNAL DO_LOOP
  SIGNAL DO_INTGI
  END
 IF WORDPOS(CMD_W2,'TEST ACCP PROD') \= 0 THEN DO
  INTERPRET "D_STR = "CMD_W2
  SIGNAL DO_INTGI
  END
 TX=WORDPOS(CMD_W2,MAFOLSTS)
 IF TX = 0 THEN DO
  CMD1=''
  CALL MSGBOX 'ERROR:LIST('CMD_W2') IS NOT KNOWN'
  D_STR = ''
  SIGNAL ARND_LOOP
  END
 TH = CMD_W2
/* IF TH = 'CURRLIST' THEN D_STR=CURRLIST
                                           */
 'ISPEXEC VGET ('TH') ASIS'
 IF RC \= 0 THEN DO
  CMD1=''
  CALL MSGBOX 'ERROR:INV LIST:'TH'<MISSING ISPF VAR'
  D_STR = ''
  SIGNAL ARND_LOOP
  END
 TMPLST = TH
 INTERPRET 'D_STR = 'TH
 IF WORDS(D_STR) = 0 THEN DO
  CMD1=''
  CALL MSGBOX 'ERROR:EMPTY LIST:'TH'<'
  D_STR = ''
  SIGNAL ARND_LOOP
  END
 SIGNAL DO_INTGI
 /* TRACE I  */
DO_INTGI:
 TMP=CMD1
 CALL INTGI
DO_INTGI_X:
 D_STR = ''
 MYCMD = ''
 CMD = ''
 ZCMD=''
 TRACE OFF
 SIGNAL ARND_LOOP
SHOWLISTS:
 CALL MSGBOX 'KNOWN LISTS:'||VALLISTS
 SIGNAL ARND_LOOP
SHOWONELIST:
  CMD_W2 = WORD(CMD,2)
  IF WORDPOS(CMD_W2,VALLISTS) \= 0 THEN DO
   INTERPRET 'XXX = 'CMD_W2
   IF XXX = CMD_W2 THEN 'ISPEXEC VGET ('XXX') ASIS'
   INTERPRET 'MSGBOXTX = 'XXX
   END
   ELSE MSGBOXTX = CMD_W2' IS NOT A VALID LIST'
 CALL MSGBOX 'LIST:'CMD_W2'='MSGBOXTX
 SIGNAL ARND_LOOP
SHOWNLOOP:
 CALL MSGBOX 'COMMANDS: '||VALCMDS||' LISTS? SHOWLIST END OR CANCEL'
 SIGNAL ARND_LOOP
DO_LOOP:
 /* TRACE I */
 CL=TOPLN
 HYCMD = ''
 DO I = 1 TO MYSCRD
  Q = I + TOPLN -1
  DO T = 1 TO 1
   INTERPRET 'TMP = MITAT'I
   TMPSRC = WORD(SRCT.Q,1)
   TP=WORDPOS(TMP,VALCMD1)
   IF TP \= 0 THEN DO
    IF TMP = 'M' | TMP = 'A' THEN DO
     "ISPEXEC VGET ("TMPLST") ASIS"
     IF RC > 0 THEN INTERPRET TMPLST" = ''"
     INTERPRET 'TMP = 'TMPLST
     IF WORDPOS(TMPSRC,TMP) = 0 THEN DO
      TMP = TMP ||' '||TMPSRC
      D_STR=TMP
      INTERPRET TMPLST '= TMP'
      "ISPEXEC VPUT ("TMPLST") ASIS"
      LEAVE T
      END
     END        /* END M OR A */
     ELSE DO    /* BEG NOT M OR A */
     IF MYCMD = '' THEN MYCMD=WORD(VALCMDS,TP)
     IF WORD(D_STR,1) = '@' THEN DO
      IF WORDPOS(TMPSRC,D_STR) = 0 THEN D_STR=D_STR||' '||TMPSRC
      LEAVE T
      END
      ELSE DO
      LNREST = SRCT.Q
      D_STR=TMPSRC
      CALL INTGI
      LEAVE T
      END
     END        /* END NOT M OR A */
    END   /* END VAL CMD */
   IF TMP = 'S' THEN DO
    IF WORDPOS(TMPSRC,D_STR) = 0 THEN DO
     D_STR=D_STR||' '||TMPSRC
     LEAVE T
     END
    END
   IF TMP = "I" THEN DO
    LNREST = SRCT.Q
    CALL INTCI
    LEAVE T
    END
   IF TMP = "V" THEN DO
    LNREST = SRCT.Q
    CALL INTVI
    LEAVE T
    END
   END T
 /* TRACE  I */
  DO A = 1 TO 1
   INTERPRET 'TMP = MITAA'I
   TMPSRC = WORD(SRCA.Q,1)
   TP=WORDPOS(TMP,VALCMD1)
   IF TP \= 0 THEN DO
    IF TMP = 'M' | TMP = 'A' THEN DO
     "ISPEXEC VGET ("TMPLST") ASIS"
     IF RC > 0 THEN INTERPRET TMPLST" = ''"
     INTERPRET 'TMP = 'TMPLST
     IF WORDPOS(TMPSRC,TMP) = 0 THEN DO
      TMP = TMP ||' '||TMPSRC
      D_STR=TMP
      INTERPRET TMPLST '= TMP'
      "ISPEXEC VPUT ("TMPLST") ASIS"
      LEAVE A
      END
     END        /* END M OR A */
     ELSE DO    /* BEG NOT M OR A */
     IF MYCMD = '' THEN MYCMD=WORD(VALCMDS,TP)
     IF WORD(D_STR,1) = '@' THEN DO
      IF WORDPOS(TMPSRC,D_STR) = 0 THEN D_STR=D_STR||' '||TMPSRC
      LEAVE A
      END
      ELSE DO
      LNREST = SRCA.Q
      D_STR=TMPSRC
      CALL INTGI
      LEAVE A
      END
     END        /* END NOT M OR A */
    END   /* END VAL CMD */
   IF TMP = 'S' THEN DO
    IF WORDPOS(TMPSRC,D_STR) = 0 THEN DO
     D_STR=D_STR||' '||TMPSRC
     LEAVE A
     END
    END
   IF TMP = "I" THEN DO
    LNREST = SRCA.Q
    CALL INTCI
    LEAVE A
    END
   IF TMP = "V" THEN DO
    LNREST = SRCA.Q
    CALL INTVI
    LEAVE A
    END
   END A
 /* TRACE  I */
  DO P = 1 TO 1
   INTERPRET 'TMP = MITAP'I
   TMPSRC = WORD(SRCP.Q,1)
   TP=WORDPOS(TMP,VALCMD1)
   IF TP \= 0 THEN DO
    IF TMP = 'M' | TMP = 'A' THEN DO
     "ISPEXEC VGET ("TMPLST") ASIS"
     IF RC > 0 THEN INTERPRET TMPLST" = ''"
     INTERPRET 'TMP = 'TMPLST
     IF WORDPOS(TMPSRC,TMP) = 0 THEN DO
      TMP = TMP ||' '||TMPSRC
      D_STR=TMP
      INTERPRET TMPLST '= TMP'
      "ISPEXEC VPUT ("TMPLST") ASIS"
      LEAVE P
      END
     END        /* END M OR A */
     ELSE DO    /* BEG NOT M OR A */
     IF MYCMD = '' THEN MYCMD=WORD(VALCMDS,TP)
     IF WORD(D_STR,1) = '@' THEN DO
      IF WORDPOS(TMPSRC,D_STR) = 0 THEN D_STR=D_STR||' '||TMPSRC
      LEAVE P
      END
      ELSE DO
      LNREST = SRCP.Q
      D_STR=TMPSRC
      CALL INTGI
      LEAVE P
      END
     END        /* END NOT M OR A */
    END   /* END VAL CMD */
   IF TMP = 'S' THEN DO
    IF WORDPOS(TMPSRC,D_STR) = 0 THEN DO
     D_STR=D_STR||' '||TMPSRC
     LEAVE P
     END
    END
   IF TMP = "I" THEN DO
    LNREST = SRCP.Q
    CALL INTCI
    LEAVE P
    END
   IF TMP = "V" THEN DO
    LNREST = SRCP.Q
    CALL INTVI
    LEAVE P
    END
   END P
 /* ADJUST BELOW FOR MOR ITERATIONS */
  IF I > 1 THEN TRACE OFF
  END
 /*TRACE I */
ARND_LOOP:
 IF CMD_W2 = 'LIST' THEN DO
  IF MYCMD = '' THEN DO
   IF WORD(D_STR,1) = '@' THEN DO
    CMD_W2 = WORD(D_STR,2)
    IF WORDPOS(CMD_W2,VALCMDS) = 0 THEN DO
 ERRMSG = 'IMMEDIATE LIST CMD:'CMD_W2': INVALID. TRY CMD "LIST" AGAIN.'
     CMD_W2 = ''
     SIGNAL NO_LIST_PROC
     END
    PARSE VAR DSTR '@' MYCMD D_STR
    END
   END       /* END MYCMD IS EMPTY */
   ELSE DO   /* MYCMD WAS SET FOR LIST */
   IF WORD(D_STR,1) = '@' THEN DO
    PARSE D_STR '@' . D_STR
    END
   END
  CMD_W2 = ''
  TP=WORDPOS(MYCMD,VALCMDS)
  TMP = WORD(VALCMD1,TP)
  CALL INTGI
  D_STR = ''
  END        /* END 'LIST' IMMEDIATE CMD */
NO_LIST_PROC:
 IF MYVERB = 'LEFT' THEN DO
  CURCL = CURCL-78
  IF CURCL < 1 THEN CURCL=1
  SIGNAL REDSPLY
  END
 IF MYVERB = 'LEFT M' THEN DO
  CURCL = 1
  SIGNAL REDSPLY
  END
 IF MYVERB = 'RIGHT' THEN DO
  CURCL = CURCL+78
  IF CURCL > MXLNG THEN DO
   CURCL=MXLNG-77
   IF CURCL < 1 THEN CURCL = 1
   END
  SIGNAL REDSPLY
  END
 IF MYVERB = 'RIGHT M' THEN DO
  CURCL = MXLNG-77
  IF CURCL < 1 THEN CURCL = 1
  SIGNAL REDSPLY
  END
 IF MYVERB = 'UP' THEN DO
  CURLN = TOPLN-UP_PG
  IF CURLN < 1 THEN CURLN=1
  SIGNAL DSPLOOP
  END
 IF MYVERB = 'UP M' THEN DO
  CURLN = 1
  SIGNAL DSPLOOP
  END
 IF MYVERB = 'DOWN M' THEN DO
  CURLN = BOTLN-MYSCRD
  IF CURLN < 1 THEN CURLN=1
  SIGNAL DSPLOOP
  END
 IF MYVERB = 'DOWN' THEN DO
  IF CURLN > BOTLN THEN SIGNAL REDSPLY
  CURLN = CURLN - 1
  SIGNAL DSPLOOP
  END
 /* TRACE I */
  IF WORD(D_STR,1) = '@' THEN DO
   PARSE VAR D_STR '@' CMD  D_STR
   WP=WORDPOS(MYCMD,VALCMDS)
   TMP = WORD(VALCMD1,WP)
   IF D_STR \= '' THEN DO
    CALL INTGI
    D_STR = ''
    MYCMD = ''
    CMD = ''
    ZCMD=''
    END
    ELSE CMD = ''
   END
  TRACE OFF
 CURCL=TOPCL
REDSPLY:
 CURLN=TOPLN
 SIGNAL DSPLOOP
NOPOOL:
  ZEDSMSG = "NO POOLED DATA"
  ZEDLMSG = "NO DATA PREVIOUSLY POOLED FOR RECALL"
  XC = 4
 SIGNAL WRITIT
 WRITIT:
 IF FSAVSTR \= '' THEN SAY FSAVSTR
 "ISPEXEC SETMSG MSG(ISRZ001)"
 RETURN XC
 TRYEND:
 IF FSAVSTR \= '' THEN DO
  FSAVSTR = SUBSTR(FSASTR,2)
  MYTYRSP=FSAVSTR
  "ISPEXEC VPUT (MYTYRSP) ASIS"
  END
 RETURN 0
/* INTGI: PROCEDURE EXPOSE MYCMD HYCMD LNREST APLP TMP D_STR CMDIND */
  /*                                                                 *\
  |*   PROCESS A REQUEST BASED ON SINGLE SELECTION, OR A LIST        *|
  \*                                                                 */
INTGI:
 /* TRACE I */
   IF APLP = 0 THEN RETURN 8
   IF D_STR = '' THEN DO
    ERRMSG = 'ATTEMPTING INTGI BUT MYAPLID LIST EMPTY.'
    RETURN 8
    END
 /* TRACE I */
   IF TMP = 'P' THEN DO
    MYCMD='PLAY'
    MYCAL = MAX_CAL
    MYCA=''
    MYPROG=''
    MYFUNC = 'MSGBOXALL'
    CALL GET_PLAY
    IF RC > 4 THEN SIGNAL BYP_CMD
    IF SUBSTR(D_STR,1,1) = '@' THEN PARSE VAR D_STR '@' . D_STR
    MYAPLID=D_STR
    "ISPEXEC VPUT (MYAPLID MYCMD MYCA MYCAL MYPROG MYFUNC) ASIS"
    CALL AFOLPLAY
    XC = RESULT
    MYAREA = ''
   "ISPEXEC VPUT (MYAREA) ASIS"
    RETURN XC
    END
 /* TRACE I */
   IF MYCMD = '' THEN DO
    ERRMSG = 'ATTEMPTING INTGI BUT MYCMD IS EMPTY'
    RETURN 8
    END
   IF WORDPOS(MYCMD,VALCMDS) = 0 THEN DO
    ERRMSG = 'ATTEMPTING INTGI BUT 'MYCMD' IS NOT VALID'
    RETURN 8
    END
   IF SUBSTR(D_STR,1,1) = '@' THEN PARSE VAR D_STR '@' . MYAPLID
    ELSE MYAPLID = D_STR
 /* TRACE I */
  /* DSPAFOH - REPLACES DSPAFOC -                                    *\
  |*  ENABLES THE CNC FUNCTION                                       *|
  \*  EXPECTS THE FF ISPF VARS                                       */
   MYAPLID=D_STR
   "ISPEXEC VPUT (MYCMD MYAPLID) ASIS"
   "ISPEXEC CONTROL DISPLAY REFRESH"
   CALL DSPAFOH
   XC = RESULT
   MYAREA = ''
/* TRACE OFF */
   "ISPEXEC VPUT (MYAREA) ASIS"
   IF D_STR = '' THEN RETURN XC
BYP_CMD:
   RETURN 8
/* INTCI: PROCEDURE EXPOSE LNREST */
INTCI:
   IF LNREST = '' THEN RETURN 4
   ARGAFO =STRIP(SUBSTR(LNREST,1,8),'T')
   CALL COPYINFO ARGAFO
   XC = RESULT
   RETURN XC
INTVI: PROCEDURE EXPOSE LNREST FSAVSTR
   IF LNREST = '' THEN RETURN 4
   ARGAFO =STRIP(SUBSTR(LNREST,1,8),'T')
   XC=POS(ARGAFO,FSAVSTR)
   IF XC = 0 THEN FSAVSTR=FSAVSTR||','||ARGAFO
   NOVAR:
   RETURN XC
GET_PLAY:
 DROP AFOSC.
 SCRPCMDI=0
 AFOSCTOT=0
 ADDRESS TSO "NEWSTACK"
 HDSEMSG = DSEMSG
 DSEMSG='ENTER VALID COMMANDS OR ? FOR HELP'
 "ISPEXEC VPUT (DSEMSG) ASIS"
 CALL REXXSRC "PULL(AFOSC)"
 XC = RESULT
 DSEMSG = HDSEMSG
 IF XC > 2 THEN DO
  CMD1=''
  CALL MSGBOX 'ERROR:PLAY LIST: COULD NOT CAPTURE SCRIPT.'
  RETURN 8
  END
 MY#VCT = QUEUED()
 IF MY#VCT > 99 THEN DO
  CMD1=''
  CALL MSGBOX 'ERROR:PLAY LIST: TOO MANY COMMANDS IN SCRIPT:'MY#VCT
  RETURN 4
  END
 K=0
 SCRPTLST=''
 DO J = 1 TO MY#VCT
  PULL AFOSC.J
  SCRPTMP=STRIP(AFOSC.J,'B')
  IF SCRPTMP  \= '' THEN DO
   IF SUBSTR(SCRPTMP,1,1) = '#' THEN ITERATE
   K=K+1
   INTERPRET 'AFOSC'K' = SCRPTMP'
   SCRPTLST=SCRPTLST||' AFOSC'||K
   END
  END
 ADDRESS TSO "DELSTACK"
 IF K < 1 THEN DO
  CMD1=''
  CALL MSGBOX 'ERROR:PLAY LIST: NO COMMANDS IN SCRIPT!'
  RETURN 8
  END
 AFOSCTOT=K
 "ISPEXEC VPUT (AFOSCTOT) ASIS"
 "ISPEXEC VPUT ("SCRPTLST") ASIS"
 IF RC \= 0 THEN DO
  CMD1=''
  CALL MSGBOX 'ERROR:PLAY LIST: COULD NOT SAVE COMMANDS'
  RETURN 8
  END
 RETURN 0
/* ROUTINE TO SUBSTITUTE JOB OR APPLID VALUE IN CA */
SUBJOBN:
/* JOB#PTR IS THE CURRENT JOBNAME FROM THE SUPPLIED LIST */
/* IF ZERO JOBNAMES WERE SUPPLIED, THEN WE CAN NOT PERFORM */
/*   THE $ SUBSTITUTION.                                 */
/* WE SHOULD NOT BE HERE IF THE JOB#PTR IS > NUMBER OF   */
/*   JOBNAMES PROVIDED IN THE JOBLIST ARGUMENT.          */
/* TRACE ?I */
  "ISPEXEC VGET (MYCA MYCAL) ASIS"
  IF RC \= 0 THEN RETURN 8
  IF LENGTH(MYCA) < 1 THEN RETURN 0
  LOOPCT=100
  V=1
  X = OUTTRAP('JNL.')
  CALL CVTJN2RG MYAPLID
  X = OUTTRAP('OFF')
  IF WORD(JNL.1,1) = '!!!!!!!!' THEN RETURN 8
  JOBN=WORD(JNL.1,2)
  SUBCMD=STRIP(MYCA,'T')
  CURL=LENGTH(SUBCMD)
  CURP=1
  CURS=0
  NEWCMD=''
  /* NEW CODE V2 */
  TRACE I
  S#APLID = MYAPLID
  IF LENGTH(S#APLID) < 7 THEN INTERPRET "T#PARM = 'S#"||S#APLID||"'"
    ELSE INTERPRET "T#PARM = 'S#"||SUBSTR(S#APLID,3)||"'"
  INTERPRET T#PARM " = S#VALUE"
  'ISPEXEC VGET ('T#PARM') ASIS'
  IF RC > 0 THEN S#PARM = MYAPLID
   ELSE INTERPRET 'S#PARM = 'T#PARM
  /* NEW CODE V2 */

TOPOFQLOP:
  JP = WORDPOS(SUBSTR(SUBCMD,CURP,1),FNDWDS)
  IF JP = 0 THEN SIGNAL NXT_POS
  /* TRACE ?I */

  SUBWD = WORD(SUBWDS,JP)
  INTERPRET 'REPWD = 'SUBWD
  IF CURP = 1 THEN DO
   NEWCMD = REPWD
   END
   ELSE DO
   IF CURS = 0 THEN NEWCMD = SUBSTR(SUBCMD,1,CURP - 1)
   NEWCMD=SUBSTR(NEWCMD,1)||REPWD
   END
  LOOPCT = LOOPCT - 1
  IF LOOPCT < 1 THEN RETURN 8
  CURS = CURP + 1
NXT_POS:
  CURP=CURP + 1
  IF CURP <= CURL THEN SIGNAL TOPOFQLOP
  IF CURS < CURP THEN DO
   IF CURS = 0 THEN NEWCMD = SUBCMD
   ELSE NEWCMD=SUBSTR(NEWCMD,1)||SUBSTR(SUBCMD,CURS)
   END
  IF LENGTH(NEWCMD) > MYCAL THEN MYCA = SUBSTR(NEWCMD,1,MYCAL)
   ELSE MYCA =  NEWCMD
  "ISPEXEC VPUT (MYCA MYCAL) ASIS"
  IF RC \= 0 THEN RETURN 8
  TRACE OFF
 RETURN 0
###END DSPAFOD
$$$BEG AFOLOAD
/* REXX */
/* CEMHELP BEGIN                                                     */
/* CEMHELP RESTRICTED                                                */
/* CEMHELP END                                                       */
/* OLD VERSION - SEE AFOLOAD1                                        */
 ARG PCT
 IF PCT ^= '%' THEN S4DS='TTEP.TSK.F.CICS.AFOPER.CONTROL'
  ELSE S4DS='TCEM.TSK.F.CICS.AFOPER.CONTROL'
 ADDRESS TSO
 "ALLOC FI(SAFOI) DA('"S4DS"') SHR"
 "EXECIO * DISKR SAFOI (STEM SAFOLST. FINIS"
 "FREE FI(SAFOI)"
 S4DS='TTEP.TSK.F.CICSJOB.INFO'
 "ALLOC FI(SAFOJ) DA('"S4DS"') SHR"
 "EXECIO * DISKR SAFOJ (STEM SAFOJLS. FINIS"
 "FREE FI(SAFOJ)"
 ADDRESS ISPEXEC
 DO I = 1 TO SAFOJLS.0
  IF SUBSTR(SAFOJLS.I,1,1) = '*' THEN ITERATE
  SAPPLID = STRIP(SUBSTR(SAFOJLS.I,2,8),'T')
  INTERPRET SAPPLID ' = ' I
  END
 J = 0
 DO I = 1 TO SAFOLST.0
  IF SUBSTR(SAFOLST.I,1,1) = '*' THEN ITERATE
  J = J + 1
  SAPPLID = STRIP(SUBSTR(SAFOLST.I,2,8),'T')
  INTERPRET "Z =SYMBOL('"SAPPLID"')"
  INTERPRET 'K = 'SAPPLID
  INTERPRET SAPPLID ' = ' J
  IF Z ^= 'VAR' THEN INTERPRET 'SVAFO'||J' = SAFOLST.I'
  ELSE INTERPRET 'SVAFO'||J' =  SAFOLST.I||SUBSTR(SAFOJLS.K,9)'
  INTERPRET '"ISPEXEC VPUT (SVAFO'||J' 'SAPPLID') SHARED"'
  IF RC ^= 0 THEN SIGNAL EXITRC4
  END
 SVAFO0=J
 MYAFOIND = TIME('N')
 GPAFO0 = 0
 "ISPEXEC VPUT (MYAFOIND SVAFO0 GPAFO0) SHARED"
 RETURN 0
EXITRC4:
 RETURN 4
###END AFOLOAD
$$$BEG AFOSDSF
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA AFOSDSF  - ISPF, CALLS SDSF REXX                        */
 /* CEMHELP AFOSDSF  - ISPF BASED, USED WITH AFOLIST. USES PARMS    */
 /* CEMHELP          - PROVIDED BY AFOLIST TO GENERATE SDSF OPER    */
 /* CEMHELP          - COMMANDS AGAINST A LIST OF REGIONS SELECTED  */
 /* CEMHELP          - AND SENT AS A PARM.                          */
 /* CEMHELP          - 3 PARMS IN FORMAT X(A) Y(B,B) Z() WAIT(N)    */
 /* CEMHELP          - PARMS IDENTIFIED AS CONSOLE, COMMAND, JOBLIST*/
 /* CEMHELP          -     AND WAIT (WAIT IS OPTIONAL)              */
 /* CEMHELP          - (A) CONSOLE(A) SPECIFY A SINGLE CICS CONSOLE */
 /* CEMHELP          -            WHICH IS OPTIONAL (LIMITED NUMBER)*/
 /* CEMHELP          -   NOTE - TO SEE THE AVAILABLE CONSOLES, YOU  */
 /* CEMHELP          -        NEED TO KNOW WHAT CONSOLES ARE DEFINED*/
 /* CEMHELP          -        TO THE CICS REGION FOR THIS LPAR.     */
 /* CEMHELP          -        YOU CAN THEN PROVIDE A DIFFERENT CON  */
 /* CEMHELP          -        FROM OUR DEFAULTS: (_ DENOTES LPAR)   */
 /* CEMHELP          -            _MAST _ALT _ALTV _VIEW            */
 /* CEMHELP          - (B) COMMAND(?) OR                            */
 /* CEMHELP          -            OR COMMAND(F ODT0403P,CEMT I TAS) */
 /* CEMHELP          -            OR COMMAND(F $,CEMT I TAS)        */
 /* CEMHELP          -        IF ?, THEN WE COLLECT 1 TO MANY SDSF  */
 /* CEMHELP          -        COMMAND TO EXECUTE IN ORDER (SAME     */
 /* CEMHELP          -        FORMAT AS ABOVE). PANEL REXXSRC.      */
 /* CEMHELP          -        USE A $ IN THE COMMAND(S) TO INDICATE */
 /* CEMHELP          -        THAT YOU WANT TO SUBSTITUTE A JOBNAME */
 /* CEMHELP          -        INTO THAT POSITION, EXECUTING THE CMD */
 /* CEMHELP          -        (OR SET OF CMDS) WITH THE RESOLVED    */
 /* CEMHELP          -        JOBNAME (FROM THE JOBLIST)            */
 /* CEMHELP          -        USE A @ IN THE COMMAND(S) TO INDICATE */
 /* CEMHELP          -        REGION APPLID.                        */
 /* CEMHELP          - (C) JOBLIST(JOBNAME) OR LIST(LISTNAME)       */
 /* CEMHELP          -        OR JOBLIST(JOBNAME1,JOBNAME2,...)     */
 /* CEMHELP          -        COMMA SEPARATED.                      */
 /* CEMHELP          -        LIST(LISTNAME) IS A SINGLE ENTRY      */
 /* CEMHELP          -        WHERE THE LISTNAME NAMES A  SET OF    */
 /* CEMHELP          -        APPLID NAMES CREATED WITH AFOLIST     */
 /* CEMHELP          -        (LIKE HSYS OR TEST OR TEMPLIST)       */
 /* CEMHELP          - LIST AND JOBLIST IS NOT REQUIRED             */
 /* CEMHELP          - HOWEVER, BOTH CANNOT BE SPECIFIED            */
 /* CEMHELP          - ORDER OF EXECUTION IS:                       */
 /* CEMHELP          -        EACH IS OF SDSF COMMANDS IS EXECUTED  */
 /* CEMHELP          -        SEQUENTIALLY 1-N, IN JOBLIST ORDER    */
 /* CEMHELP          - WAIT(N)  - AMOUNT OF TIME TO WAIT FOR A      */
 /* CEMHELP          -        COMMAND RESPONSE. DEFAULT IS 3 SEC.   */
 /* CEMHELP          -        RANGE IS 0 - 9.                       */
 /* CEMHELP          -        WITHOUT WAIT(N), RESPONSE DATA MAY    */
 /* CEMHELP          -        NOT BE GATHERED; YOU WOULD NEED TO    */
 /* CEMHELP          -        REFERENCE THE SYSTEM LOG(S) FOR       */
 /* CEMHELP          -        RESPONSE DATA.                        */
 /* CEMHELP          - USEAFO Y OR N - Y USES AFOFILE (DEFAULT)     */
 /* CEMHELP          -        N BYPASSES, IN WHICH CASE             */
 /* CEMHELP          -        LIST OR JOBLIST ENTRIES ARE NOT       */
 /* CEMHELP          -        VALIDATED AGINST THE AFOFILE. THIS    */
 /* CEMHELP          -        LIMITS THE USE OF ZOS ROUTE CMD       */
 /* CEMHELP          -        ALLOWS ANY LIST OF JOB NAMES.         */
 /* CEMHELP          -        '$' JOBNAME IS THE ONLY LOGICAL VAR   */
 /* CEMHELP          -        SUBSTITUTION POSSIBLE.                */
 /* CEMHELP NOTE: CTG REGIONS CAN BE ACCESS VIA CTGLIST NAMES       */
 /* CEMHELP  ATGTSTJL ATGPRDJL ATGLIST                              */
 /* CEMHELP  CTGDEVJL CTGTSTJL CTGPRDJL CTGLIST                     */
 /* CEMHELP  OR                                                     */
 /* CEMHELP  A DYNAMIC LIST NAMED MYCTGJL                           */
 /* CEMHELP          - WHICH CAN BE CREATED VIA ISRPTVAR OR         */
 /* CEMHELP END                                                     */
 ADDRESS TSO
/******************************** REXX ********************************/
/*                                                                    */
/*TRACE ?I  */
/*                                                                    */
  XC = 0
  AFOYN = 'Y'       /* DEFAULT USES AFO FILE. 'N' BYPASS AFOFILE CHK  */
  CURCPU=''         /* RETURNS 1 CHAR CPU */
  CURGRP=''         /* RETURNS GRPX 4 CHAR PLEX PREFIX */
  CURCPUG=''        /* RETURNS GRPX CLUSTER OF ASSOCIATED CPUS */
  CALL GETCPU1
  ADDRESS ISPEXEC "VGET (CURCPU,CURGRP,CURCPUG) PROFILE"
  MYAREA=''
  FFX='FF'X
  MYAREA#=FFX
  MSGLOCK='Y'
  MSGSTAT='ADDPOP'
  MSGBOXTX='AFOSDSF: BEGIN:'||DATE('U') TIME()
  MSGTITLE="AFOSFSF: PROCESSING"
  ADDRESS ISPEXEC "VPUT (MSGBOXTX) ASIS"
  ADDRESS ISPEXEC "VPUT (MSGLOCK MSGSTAT MSGTITLE) ASIS"
  CALL MSGBOX
  JUNK = ''
  CALL SLEEP_NOW 1
  ARG MYARGSTR
  MYARGS='CONSOLE COMMAND JOBLIST LIST WAIT NOAFO'
  MYCONLST='ALTV MAST ALT VIEW'
  MYCONSFXCT=WORDS(MYCONLST)
  MYCON=''
  MYCMD='?'
  MYJOBL = ''
  TRYCON#=0
  WTTIME=3
  ACUMMSG=FFX||'AFOSDSF START:'DATE('U') TIME()
  MSGBOXTX=ACUMMSG
  CTGIND=''
  CTGDEVJL=''
  ATGDEVJL=''
  CTGTSTJL=''
  ATGTSTJL=''
  CTGPRDJL=''
  ATGPRDJL=''
  CTGLIST=''
  ATGLIST=''
  CTGJLISTS = 'CTGDEVJL CTGTSTJL CTGPRDJL CTGLIST '||,
              'ATGTSTJL ATGPRDJL ATGLIST ATGLIST MYCTGJL'
  LISTYP=''
  DO WHILE MYARGSTR \= ''
   PARSE VAR MYARGSTR MYKEY '(' MYVAL ')' MYARGSTR
   SELECT
    WHEN MYKEY = 'CONSOLE' THEN DO
     MYCON = MYVAL
     TRYCON#=5
     END
    WHEN MYKEY = 'COMMAND' THEN DO
     MYCMD = MYVAL
     END
    WHEN MYKEY = 'WAIT' THEN DO
     TEMP = MYVAL
     IF DATATYPE(TEMP) = 'NUM' THEN DO
      IF TEMP < 0 THEN WTTIME = 0
       ELSE IF TEMP > 9 THEN WTTIME = 9
       ELSE WTTIME = TEMP
      END
     END
    WHEN MYKEY = 'USEAFO' THEN DO
     IF MYVAL \= 'N' THEN MYVAL = 'Y'
     AFOYN = MYVAL
     END
    WHEN MYKEY = 'JOBLIST' THEN DO
     IF LISTYP \= '' THEN SIGNAL DUP_LST
     LISTYP=MYKEY
     MYJOBL = TRANSLATE(MYVAL,' ',',')
     END
    WHEN MYKEY = 'LIST' THEN DO
     IF LISTYP \= '' THEN SIGNAL DUP_LST
     LISTYP=MYKEY
     XXX = MYVAL
     IF WORDPOS(XXX,CTGJLISTS) > 0 THEN DO
      CTGIND=XXX
      END
 /*  'ISPEXEC VGET ('XXX') ASIS'
     IF RC ^= 0 THEN SIGNAL BADLIST
     INTERPRET "MYJOBL = TRANSLATE("XXX",' ',',')" */
     END
    OTHERWISE
    SIGNAL INV_CMD
    END
   END
/*TRACE ?I */
/* WHEN USING AFOYN = 'Y', JOBLIST, JOBCPUL, AND APPLID:HOLD THE */
/*  RESPECTIVE AFOLIST VALUES FOR EACH ENTRY.                    */
/* WHEN USING AFOYN = 'N', JOBLIST IS THE ONLY VALID LOGICAL     */
/*  SET OF ENTRIES; AND '$' IS THE ONLY POSSIBLE SUBSTITUTION    */
/* IF SYSVAR(SYSUID) = 'TCEM' THEN TRACE I */
  JOBLIST=''
  JOBCPUL=''
  APLLIST=''
/* IF SYSVAR(SYSUID) = 'TCEM' THEN TRACE I  */
/*IF AFOYN = 'N' THEN DO */
  IF LISTYP = '' THEN DO
   AFOYN = 'N'
   SIGNAL ARNDKIX
   END
  IF LISTYP = 'JOBLIST' THEN DO
   JOBLIST=MYJOBL
   SIGNAL GOT_JOBLIST
   END
 /* USING THE AFOFILE */
  IF CTGIND \= '' THEN DO
   "ISPEXEC VGET (ATGTSTJL ATGPRDJL ATGLIST) ASIS"
   "ISPEXEC VGET (ATGTSTCP ATGPRDCP ATGLISTP) ASIS"
   "ISPEXEC VGET (CTGDEVCP CTGTSTCP CTGPRDCP CTGLISTP) ASIS"
   "ISPEXEC VGET (CTGDEVJL CTGTSTJL CTGPRDJL CTGLIST) ASIS"
   IF RC \= 0 THEN DO
    CALL AFOCTGJL
    "ISPEXEC VGET (ATGTSTJL ATGPRDJL ATGLIST) ASIS"
    "ISPEXEC VGET (ATGTSTCP ATGPRDCP ATGLISTP) ASIS"
    "ISPEXEC VGET (CTGDEVCP CTGTSTCP CTGPRDCP CTGLISTP) ASIS"
    "ISPEXEC VGET (CTGDEVJL CTGTSTJL CTGPRDJL CTGLIST) ASIS"
    IF RC ^= 0 THEN SIGNAL BADLIST
    END
   CTGLIST=CTGDEVJL||' '||CTGTSTJL||' '||CTGPRDJL
   ATGLIST=ATGTSTJL||' '||ATGPRDJL
   ALLCTGJL=CTGLIST||' '||ATGLIST
   ALLCTGCP=CTGLISTP||' '||ATGLISTP
   INTERPRET 'JOBLIST = 'XXX
   LISTYP='JOBLIST'
   END
  IF XXX = 'MYCTGJL' THEN DO
/*  TRACE I */
   MXXX=''
   MXXXCP=''
   "ISPEXEC VGET ("XXX") ASIS"
   INTERPRET 'XXXLIST='XXX
   DO WHILE XXXLIST \= ''
    PARSE VAR XXXLIST AXXX XXXLIST
    WPXXX = WORDPOS(AXXX,ALLCTGJL)
    IF WPXXX > 0 THEN DO
     MXXX=MXXX||' '||AXXX
     MXXXCP=MXXXCP||' '||WORD(ALLCTGCP,WPXXX)
     ITERATE
     END
    WPXXX = WORDPOS(AXXX,ATGLIST)
    IF WPXXX > 0 THEN DO
     MXXX=MXXX||' '||AXXX
     MXXXCP=MXXXCP||' '||WORD(ATGLISTP,WPXXX)
     ITERATE
     END
    END
   IF MXXX = '' THEN SIGNAL BADLIST
   JOBLIST = MXXX
   JOBCPUL=MXXXCP
   SIGNAL ARNDKIX
   END
 /* ALL OTHER LIST REQUESTS */
 /*                         */
 /*                         */
  "ISPEXEC VGET ("XXX") ASIS"
  IF RC \= 0 THEN SIGNAL BAD_LST
  INTERPRET 'APLLIST='XXX
  IF APLLIST = '' THEN SIGNAL BAD_LST
  T = WORDS(APLLIST)
  DO S = 1 TO T
   MYCPU = ''
   MYCOLDJ = ''
   CALL GETCPU4APLID
   IF RC = 0 THEN DO
    JOBCPUL=JOBCPUL||' '||MYCPU
    JOBLIST=JOBLIST||' '||MYCOLDJ
    END
    ELSE DO
    JOBCPUL=JOBCPUL||' -'
    JOBLIST=JOBLIST||' !!!!!!!!'
    END
   END
  SIGNAL ARNDKIX
GOT_JOBLIST:
  IF MYJOBL \= '' & AFOYN = 'Y' THEN DO
   X = OUTTRAP('JNL.')
   CALL CVTJN2RG MYJOBL
   X = OUTTRAP('OFF')
   JOBLIST = ''
   DO S = 1 TO JNL.0
    JOBLIST=JOBLIST||' '||WORD(JNL.S,2)
    APLLIST=APLLIST||' '||WORD(JNL.S,1)
    MYCPU = ''
 /* TRACE I */
    CALL GETCPU4APLID
    IF RC = 0 THEN DO
     JOBCPUL=JOBCPUL||' '||MYCPU
     END
     ELSE DO
     JOBCPUL=JOBCPUL||' -'
     END
    END
   END
 ARNDKIX:
  ACUMMSG=ACUMMSG||FFX||'USING WAIT TIME:'||WTTIME||':'
  MYJOBL = JOBLIST
  MYAPLL = APLLIST
  JOB#=WORDS(MYJOBL)
  IF JOB# < 1 THEN JOB#PTR=0
   ELSE JOB#PTR = 1
  IF MYCMD = '?' THEN SIGNAL GETCMD
  IF MYCMD \= '' THEN DO
   SRC#=1
   SRC.1 = MYCMD
   SIGNAL GOTCMD
   END
 GETCMD:
 /*TRACE  I */
   ADDRESS TSO "NEWSTACK"
   ADDRESS ISPEXEC
   ACTN='PULL'         /* PULL MEANS DON'T LOOK FOR ISPVARS */
   EXECSEL = 'EXPLSDSF'
 /* IF USING AFO THEN SUBSTITUTE FOR APPLID; OTHERWISE JUST JOBNAME */
 /*  IS ONLY POSSIBLE SUBSTITUTION '$'                              */
   IF AFOYN = 'Y' THEN DO
     FNDWDS='@ $ !'
     SUBWDS='MYAPLID JOBN MYAPLID'
     SUBMSG = '$=JOBN;@|!=APLID'
     END
     ELSE DO
     FNDWDS='$'
     SUBWDS='JOBN'
     SUBMSG = '$=JOBN'
     END
   RWCT=WORDS(FNDWDS)
   DSEMSG = 'SDSF OPER STMTS (NO SLASH PFX) '||SUBMSG||'. PF3 END'
   ADDRESS ISPEXEC "VPUT (EXECSEL DSEMSG) ASIS"
   MYVARO = 'MSDSF'
   CALL REXXSRC ACTN"("MYVARO")"
   XC = RESULT
   IF XC ^= 0 THEN SIGNAL ERR_REXXSRC
   CC=QUEUED()
   IF CC = 0 THEN SIGNAL NO_CMDS
 /*TRACE ?I   */
   ACUMMSG=ACUMMSG||'....> PULLING REXX STATEMENTS <.....'||FFX
   MSGLOCK='Y'
   MSGSTAT='CONTPOP'
   MSGBOXTX=ACUMMSG
   ADDRESS ISPEXEC "VPUT (MSGBOXTX) ASIS"
   ADDRESS ISPEXEC "VPUT (MSGLOCK MSGSTAT) ASIS"
   CALL MSGBOX
   MYVARCT = QUEUED()
   SRC#=0
   DO K = 1 TO MYVARCT
    PULL SRC.K
    ACUMMSG=ACUMMSG||SRC.K||FFX
    SRC#=K
    END
  ADDRESS TSO "DELSTACK"
/*                                                                    */
/*TRACE ?I */
/*                                                                    */
GOTCMD:
/*TRACE I  */
  IF SRC# < 1 THEN SIGNAL NO_CMDS
  IF SRC.1 = '' THEN SIGNAL NO_CMDS
  TRYSTR=''
  SRC#PTR=1
  SUBCMD=SRC.SRC#PTR
  DO Q = 1 TO RWCT
   JP = POS(WORD(FNDWDS,Q),SUBSTR(SUBCMD,2))
   IF JP > 0 THEN SIGNAL DO_SUB0
   END
  SIGNAL NO_SUB0
 DO_SUB0:
  CALL SUBJOBN
  IF RESULT \= 0 THEN SIGNAL BADJOB
/*                                                                    */
/*TRACE ?I  \*                                                        */
/*                                                                    */
NO_SUB0:
  RC = ISFCALLS('ON')
  ADDRESS SDSF
  ISFDELAY = WTTIME
  IF MYCON \= '' THEN SIGNAL ONETRY
  MYCPU1=SUBSTR(MVSVAR(SYSNAME),1,1)
/*  CONLST='1 2 V 1V' */
  CONLST=MYCONLST
TRYAGN:
  TRYCON#=TRYCON# + 1
  IF TRYCON# > MYCONSFXCT  THEN SIGNAL NO_CONS_AVBL
  MYCONSFX=WORD(CONLST,TRYCON#)
  MYCON=MYCPU1||MYCONSFX
ONETRY:
 /*  TRACE ?I */
  ISFCONS=MYCON
  TRYSTR=TRYSTR||' '||MYCON
  MSGBOXTX=TIME()||' '||'CON('||MYCON||')... PROCESSING >'||SUBCMD
  ADDRESS ISPEXEC "VPUT (MSGBOXTX) ASIS"
  CALL MSGBOX
 /* TRACE ?I */
  "ISFSLASH '"SUBCMD"' (WAIT)"
  XC=RC
  IF XC \= 0 THEN SIGNAL GOTERRS
  ACUMMSG=ACUMMSG||SUBCMD||'>>ULOG CT:'||ISFULOG.0||FFX
  #ULOG=ISFULOG.0
  IF #ULOG < 1 THEN SIGNAL TRYAGN
  IF POS('FAILED',ISFULOG.1) \= 0 THEN SIGNAL TRYAGN
  UG#=0
  MYAREA=''
  DO I = 1 TO #ULOG
   UG#=UG#+1
   UG.UG# = STRIP(ISFULOG.I,'B')
   MYAREA=MYAREA||UG.UG#||FFX
   END
/*                                                                    */
/*TRACE ?I  \*                                                        */
/*                                                                    */
  SIGNAL TOPCMDLP
/* BECAUSE WE SERVICED THE FIRST CMD FOR THE EITHER: */
/*  THE FIRST JOBNAME IN THE LIST WE CONTINUE TO USE THE */
/*  SAME JOBN FOR SUBSEQUENT SRC COMMANDS.           */
/* IF THE JOBLIST WAS EMPTY, THEN JOB#PTR IS 0, SO   */O
/* WE KNOW WE CAN BYPASS ANY $ SUBSTITUTION          */
/*  */
 TOPJOBNLP:
  JOB#PTR=JOB#PTR+1
  IF JOB#PTR > JOB# THEN SIGNAL DONEALL
  SRC#PTR=0
 TOPCMDLP:
 /* ITERATE THRU THE CMD LIST, ONCE PER JOB NAME IN JOBLIST */
 /* USE SUBCMD AS THE SUBSTITUTE COMMAND - LOOK AND REPLACE $ */
 /* ONE $ PER CMD - OTHER $ ARE TRANSLATED TO NULL */
 /* IF NO $ ARE FOUND IN THE SUBCMD, THEN EXECUTE WITHOUT ANY SUB */
 /* SRC# HAS NUMBER OF CMDS */
 /* JOB# HAS NUMBER OF JOB NAMES IN JOBLIST */
 /* NEXTJOBN IS AT END OF COMMAND LOOP - JOB#PTR IS SET TO THE */
 /*  CURRENT JOB NAME (IF ANY) */
  SRC#PTR=SRC#PTR+1
  IF SRC#PTR > SRC# THEN SIGNAL TOPJOBNLP
  TMP=STRIP(SRC.SRC#PTR,'B')
  IF TMP = '' THEN SIGNAL TOPCMDLP
  IF SUBSTR(TMP,1,1) = '*' THEN SIGNAL TOPCMDLP
  SUBCMD=TMP
  DO Q = 1 TO RWCT
   JP = POS(WORD(FNDWDS,Q),SUBSTR(SUBCMD,2))
   IF JP > 0 THEN SIGNAL DO_SUB1
   END
  SIGNAL NO_SUB1
/*                      */
DO_SUB1:
  CALL SUBJOBN
  IF RESULT \= 0 THEN SIGNAL BADJOB
/*                                                                    */
/*TRACE ?I  \*                                                        */
/*                                                                    */
NO_SUB1:
  MSGBOXTX=TIME()||' '||'... PROCESSING >'||SUBCMD
  ADDRESS ISPEXEC "VPUT (MSGBOXTX) ASIS"
  CALL MSGBOX
  "ISFSLASH '"SUBCMD"' (WAIT)"
  XC =RC
  IF XC \= 0 THEN SIGNAL GOTERRS
  ACUMMSG=ACUMMSG||SUBCMD||'>>ULOG CT:'||ISFULOG.0||FFX
  #ULOG=ISFULOG.0
  DO I = 1 TO #ULOG
   UG#=UG#+1
   UG.UG# = STRIP(ISFULOG.I,'B')
   MYAREA=MYAREA||UG.UG#||FFX
   END
/*                                                                    */
/*TRACE ?I  \*                                                        */
/*                                                                    */
 SIGNAL TOPCMDLP
DONEALL:
 ZRC=ISFCALLS("OFF")
 MSGSTAT='REMPOP'
 MSGBOXTX= '< FINISHED PROCESSING SELECTION LIST. WRITING RESULTS'
 ADDRESS ISPEXEC "VPUT (MSGSTAT MSGBOXTX) ASIS"
 CALL MSGBOX
 ADDRESS ISPEXEC "VPUT (EXECSEL MYAREA MYAREA#) ASIS"
 CALL DSPLYA
 XC = 0
 SIGNAL EXITIT
NO_CONS_AVBL:
 ACUMMSG=ACUMMSG||'COULD NOT FIND AN OPEN CONSOLE IN THIS LIST:'||FFX
 ACUMMSG=ACUMMSG||TRYSTR||FFX
 ACUMMSG=ACUMMSG||'RETRY WITH A DIFFERENT, KNOWN, UNUSED CONSOLE'||FFX
 ACUMMSG=ACUMMSG||'TRY A SINGLE CONSOLE(CON_NAME) ARGUMENT'||FFX
 XC = 8
 SIGNAL DONEALL
GOTERRS:
 CALL DISPLAYMESSAGES
INV_CMD:
 ACUMMSG=ACUMMSG||'INVALID COMMA:'||MYKEY||':'||MYVAL||': ENDING'||FFX
 XC = 4
 SIGNAL EXITIT
NO_CMDS:
 ACUMMSG=ACUMMSG||'NO CAMMANDS WERE REQUESTED. ENDING'||FFX
 XC = 4
 SIGNAL EXITIT
DUP_LST:
 ACUMMSG=ACUMMSG||'MULT LIST AND OR JOBLIST SPECIFIED. ENDING'||FFX
 XC = 4
 SIGNAL EXITIT
BADJOB:
 ACUMMSG=ACUMMSG||'ERROR IN JOBNAME SUBSTITUTION:'JOB#PTR JOBN||FFX
 ACUMMSG=ACUMMSG||'COMMAND:'SRC#PTR SUBCMD||FFX
 XC = 4
 SIGNAL EXITIT
BADLIST:
 ACUMMSG=ACUMMSG||'ERROR: ISPF LIST VAR:'XXX||FFX
 ACUMMSG=ACUMMSG||': WAS NOT FOUND IN ISPF.'||FFX
 XC = 4
 SIGNAL EXITIT
ERR_REXXSRC:
 ACUMMSG=ACUMMSG||'ERRORS ATTEMPTING TO PULL COMMANDS.'||FFX
 XC = 8
 SIGNAL EXITIT
EXITIT:
 IF XC = 0 THEN RETURN 0
 MSGSTAT='REMPOP'
 MSGBOXTX= '< FINISHED PROCESSING SELECTION LIST. WRITING RESULTS'
 ADDRESS ISPEXEC "VPUT (MSGSTAT MSGBOXTX) ASIS"
 CALL MSGBOX
 MYAREA=ACUMMSG
 ADDRESS ISPEXEC "VPUT (EXECSEL MYAREA MYAREA#) ASIS"
 CALL DSPLYA
 RETURN XC
/* *\
\* */
   DISPLAYMESSAGES:
      /*  DISPLAY THE MESSAGES ASSOCIATED WITH THE ACTION  */

      ACUMMSG=ACUMMSG||"ISFMSG: '"ISFMSG"'"|FFX
ACUMMSG=ACUMMSG||ISFMSG2.0 "LONG MESSAGES IN THE ISFMSG2 STEM"||FFX
      DO I = 1 TO ISFMSG2.0
         ACUMMSG=ACUMMSG||">"||ISFMSG2.I"<"||FFX
         END
      RETURN
/****************************\
|* SUBSTITUTE JOBNAME FOR $ *|
\****************************/
SUBJOBN:
/* JOB#PTR IS THE CURRENT JOBNAME FROM THE SUPPLIED LIST */
/* IF ZERO JOBNAMES WERE SUPPLIED, THEN WE CAN NOT PERFORM */
/*   THE $ SUBSTITUTION.                                 */
/* WE SHOULD NOT BE HERE IF THE JOB#PTR IS > NUMBER OF   */
/*   JRBNAMES PROVIDED IN THE JOBLIST ARGUMENT.          */
/* TRACE ?I */
 IF LENGTH(SUBCMD) < 1 THEN RETURN 8
 IF JOB#PTR = 0 THEN RETURN 8
 IF JOB#PTR > JOB# THEN RETURN 8
  LOOPCT=100
  JOBN=WORD(MYJOBL,JOB#PTR)
  MYAPLID=WORD(MYAPLL,JOB#PTR)
  IF JOB# < 1 THEN RETURN 8
  IF  AFOYN = 'N' THEN SIGNAL TOPOFQLOP
  MYCPU=WORD(JOBCPUL,JOB#PTR)
  IF POS(MYCPU,CURCPUG)=0 THEN RETURN 8
/*  SIGNAL TOPOFQLP1 */
 TOPOFQLOP:
  JP = POS(WORD(FNDWDS,Q),SUBSTR(SUBCMD,2))
  IF JP < 1 THEN SIGNAL NEXT_Q_LOP
 TOPOFQLP1:
  IF LOOPCT < 1 THEN RETURN 8
  SUBWD = WORD(SUBWDS,Q)
  INTERPRET 'REPWD = 'SUBWD
  IF JP = 1 THEN DO
   SUBCMD = REPWD||SUBSTR(SUBCMD,2)
   SIGNAL DONE_SUBJOBN
   END
  SUBCMD=SUBSTR(SUBCMD,1,JP)||REPWD||SUBSTR(SUBCMD,JP+2)
  IF  AFOYN = 'N' THEN SIGNAL DONE_SUBJOBN
  IF MYCPU = CURCPU THEN SIGNAL DONE_SUBJOBN
  IF JP = 2 THEN DO
   IF SUBSTR(SUBCMD,1,2) = 'F ' THEN DO
    SUBCMD='RO '||MYCPU||'SYS,F '||SUBSTR(SUBCMD,3)
    END
   END
DONE_SUBJOBN:
  LOOPCT = LOOPCT - 1
  JP = POS(WORD(FNDWDS,Q),SUBSTR(SUBCMD,2))
  IF JP > 0 THEN SIGNAL TOPOFQLOP
NEXT_Q_LOP:
  Q = Q + 1
  IF Q \> RWCT THEN SIGNAL TOPOFQLOP
  TRACE OFF
 RETURN 0
/****************************\
|* SLEEP ROUTINE            *|
\****************************/
SLEEP_NOW:
ARG SLEEP_TIME
IF SLEEP_TIME = '' THEN SLEEP_TIME = 10
IF JUNK = '' THEN JUNK = SYSCALLS('ON')
ADDRESS SYSCALL "SLEEP" SLEEP_TIME
RETURN
/****************************\
|* GET CPU 4 APLID          *|
\****************************/
GETCPU4APLID:
 /*  TRACE ?I */
  IF S > 1 THEN SIGNAL ARNDLOAD
  "ISPEXEC VGET (MYAFOIND SVAFO0) SHARED"
  IF RC = 0 THEN SIGNAL TOPOFLOP0
  CALL AFOLOAD1
  XC = RESULT
  IF XC = 0 THEN SIGNAL TOPOFLOP0
  SIGNAL ERRORAFO1
 TOPOFLOP0:
  EXPLSTR='MYAPLID MYTYP MYREL MYCPU MYCOLDJ'
  NWD=WORDS(EXPLSTR)
  CALL AFOPOS EXPLSTR
  PULL AFOSTR
  IF AFOSTR='' THEN SIGNAL EXITRC8
  DO WHILE (AFOSTR ^='')
   PARSE VAR AFOSTR AFONM AFOL AFOB AFOE AFOT '#' AFOSTR
   IF AFOL = '-' | AFOB = '-' THEN ITERATE
   INTERPRET 'B'||AFONM' = AFOB'
   INTERPRET 'L'||AFONM' = AFOL'
   END
ARNDLOAD:
  MYSELID=WORD(APLLIST,S)
  IF MYSELID = '!!!!!!!!' THEN DO
   MYSELID=WORD(JOBLIST,S)
   CTGWP= WORDPOS(MYSELID,CTGLIST)
   IF CTGWP > 0 THEN DO
    MYAPLID='-'
    MYCPU=WORD(CTGLISTP,CTGWP)
    RETURN 0
    END
   END
  ADDRESS ISPEXEC "VGET ("MYSELID") ASIS"
  IF RC \= 0 THEN DO
   ACUMMSG=ACUMMSG||'COULD NOT FIND AFO REC FOR APLID:'||MYSELID||FFX
   MXRC=8
   SIGNAL RET_NO_CPU
   END
  INTERPRET 'TMP='MYSELID
  ADDRESS ISPEXEC "VGET (SVAFO"TMP") ASIS"
  IF RC \= 0 THEN DO
   ACUMMSG=ACUMMSG||'COULD NOT FIND AFO REC FOR APLID:'||MYSELID||FFX
   MXRC=8
   SIGNAL RET_NO_CPU
   END
  INTERPRET 'TMP=SVAFO'TMP
  MYAPLID=LEFT(SUBSTR(TMP,BMYAPLID,LMYAPLID),9)
  MYREL=SUBSTR(TMP,BMYREL,LMYREL)
  MYCPU=SUBSTR(TMP,BMYCPU,LMYCPU)
  MYTYP=SUBSTR(TMP,BMYTYP,LMYTYP)
  MYCOLDJ=SUBSTR(TMP,BMYCOLDJ,LMYCOLDJ)
  IF POS(MYCPU,CURCPUG) = 0 THEN DO
   ACUMMSG=ACUMMSG||'APLID NOT VALID THIS SYSPLEX:'||MYSELID||FFX
   MXRC=8
   SIGNAL RET_NO_CPU
   END
  IF FORCEREL = 1 THEN MYREL=MYSREL
  IF MYREL = '320' THEN MYREL='.'
    ELSE MYREL='.R'||MYREL||'.'
  IF MYTYP='E' THEN MYSTYP='D'
   ELSE MYSTYP=MYTYP
  RETURN 0
RET_NO_CPU:
 MYCPU=''
 RETURN MXRC
###END AFOSDSF
$$$BEG AFORDOR
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA AFORDOR  - ISPF, CALLS DFHCSDUP FOR SELECTED REGIONS    */
 /* CEMHELP AFORDOR  - ISPF BASED, USED WITH AFOLIST. USES PARMS    */
 /*                  - PROVIDED BY AFOLIST TO GENERATE RDO          */
 /*                  - COMMANDS AGAINST A LIST OF REGIONS SELECTED  */
 /*                  - AND SENT AS A PARM (SEE BELOW)               */
 /*                  - AFORDOR WRITE SYSPRINT REPORT TO A DSN       */
 /*                  - AFORDOR DOES NOT REQUIRE AFOLIST AS THE      */
 /*                  - PARENT RX. AFOLIST MAKES IT EASIER TO SUPPLY */
 /*                  - A LIST(Y) PARAMETER (AFOLIST HAS MANY STD    */
 /*                  - LIST OF REGIONS, AS WELL AS YOUR OWN SET)    */
 /*                  - YOU CAN INVOKE AFORDOR WITH A JOBLIST SET    */
 /*                  - OF REGION APPLIDS, AND AFORDOR WILL RUN      */
 /*                  - WITH NO REQUIREMENT FOR AFOLIST              */
 /* - VALID PARAMETERS ARE:                                         */
 /* - JOBLIST(X,X...) WHERE X IS ONE OR MORE REGION APLIDS (REQUIRED)*/
 /* - OR                                                            */
 /* - LIST(Y)         WHERE Y IS A ISPFVAR NAMED Y, WHICH CONTAINS  */
 /* -                 A LIST OF REGION APLIDS (REQ IF JOBLIST OMITD)*/
 /* - NOTE!!! OPTIONAL COMMAND PARAMETER (BELOW)                    */
 /* -     COMMAND USES MATCHING BRACKETS, BUT NOT '(..)'            */
 /* - COMMAND<A B(C)> SINGLE RDO COMMAND, OR ? TO PROMPT FOR COMMAND*/
 /* -        {      } IF OMITTED OR ?, THEN YOU ARE PROMPTED FOR    */
 /* -        \      / RDO COMMANDS (NOTE - SYNTAX NOT CHECKED)      */
 /* -        [      ] TO SPECIFY A SINGLE LINE COMMAND, YOU MUST    */
 /* -                 BRACKET THE COMMAND WITH ONE OF THE FOLLOWING */
 /* -                 PAIRS OF DELIMITERS: {} [] \/ (1ST CHAR TO    */
 /* -                 FOLLOW COMMAND KEYWORD INDICATES THE BEGINING */
 /* -                 AND ENDING BRACKET PAIR:EX: COMMAND{A B(C) D} */
 /* -                 THE PROMPT OPTION DISPLAYS A PANEL IN WHICH   */
 /* -                 YOU ENTER COMMANDS. THE PANEL  COLLECTS YOUR  */
 /* -                 RDO COMMANDS,  AND USES THESE AS THE SYSIN    */
 /* -                 TO THE DFHCSDUP.                              */
 /* -     NOTE: [   ] BRACKETS CAN BE PROBLEMATIC AS HOD CODEPAGE   */
 /* -                 FOR [] MAY BE DIFFERENT FROM THE RX CODE      */
 /* -           USE <   > FOR THE MOST STANDARD KEY CODE MATCH      */
 /* - NOTE!!! - YOU CAN USE ONE OF THE FOLLOWING                    */
 /* -           SPECIAL CHARACTERS TO PERFROM SUBSTITUTION:         */
 /* -                 YOU CAN USE A  \@ REPLACED WITH APPLID        */
 /* -                 YOU CAN USE A  \$ REPLACED WITH JOBNM         */
 /* -                 YOU CAN USE A  \! REPLACED WITH STEM VARIABLE */
 /* -                 YOU CAN USE A  \\ REPLACED WITH ' \'          */
 /* -            EX:  SUBSTITUTE THE APLID (EXPL:LIST LIST(\@))     */
 /* -                                                               */
 /* - NOTE!!! - WHEN ENTERING CMDS IN THE REXXSRC PANEL:            */
 /* -                 YOU CAN ALSO ENTER A 'COPY' COMMAND TO THE    */
 /* -                 PANEL, WHICH ALLOWS YOU TO SPECIFY A PDS      */
 /* -                 MEMBER CONTAINING A   RDO COMMAND SET.  THE   */
 /* -                 CONTENTS ARE COPIED AS IF YOU ENTERED         */
 /* -                 EACH COMMAND FREEFORM IN THE PANEL.           */
 /* -                                                               */
 /* - OPTIONAL PARMS:                                               */
 /* - FORCEREL(RRR)   FOR ALL REGIONS RDOFILES TO USE RELEASE RRR   */
 /* -                   (520 OR 540....)                            */
 /* -                                                               */
 /* - INCSD(DSN)      NEEDED IF YOU ARE EXECUTING A RDO COMMAND     */
 /* -                 WHICH SPECIFIES THE INCSD(PARAMETER)          */
 /* -                 DSN IS THE SECONDARY RDOFILE                  */
 /* -                                                               */
 /* - DESTINATION FOR THE REPORT IS REQUIRED, BUT DEFAULT SUPPLIED  */
 /* - ODSN(@|DSN)     DFHCSDUP SYSPRINT DSN OPTION. MUTUALLY        */
 /* -                 EXCLUSIVE WITH OPDS. DEFAULT VALUE IS         */
 /* -                 THIS OPTION IS THE DEFAULT VALUE WHEN DEST IS */
 /* -                 OMITTED - WHICH IMPLIES NEW, SEQUENTIAL DSN   */
 /* -                 WITH APLID DELIMITER IN DSN. '@' MEANS  THE   */
 /* -                 SAME. ODSN WITH AN '@' QUALIFIER, INDICATES   */
 /* -                 THAT YOUR DSN IS USED EXCEPT '@' APLID        */
 /* -                 SUBSTITUTION OCCURS.                          */
 /* -                 IF ODSN, AND A '@' IS NOT INCLUDED IN THE DSN */
 /* -                 THEN THE ODSN FILE IS TREATED AS A 'DISP=MOD' */
 /* -                 IF DSN DOES NOT EXIST, IT WILL BE ALLOCATED.  */
 /* -                 IF A DSN DOES EXIST,                          */
 /* -                 IT MUST BE SEQ, VBA, LRECL=125.               */
 /* -                                                               */
 /* - NOTE!! FOR DESTINATION OF PDS                                 */
 /* -     OPDS USES MATCHING BRACKETS, BUT NOT '(..)'               */
 /* - OPDS<@|DSN>     DFHCSDUP SYSPRINT DSN OPTION. MUTUALLY        */
 /* -     {     }     EXCLUSIVE WITH ODSN. NO DEFALT VALUE - OPDS[@]*/
 /* -     \     /     WILL IMPLYS A NEW PDSE DSN , WITH EACH        */
 /* -     [     ]     APLID AS A MBR. DSN(APLID) MBMR FOR EACH APLID*/
 /* -                 OPDS[AAA.@.BBB(CCC) WILL SUBSTITUTE APLID, BUT*/
 /* -                 REUSE THE CCC MEMBER.                         */
 /* -     NOTE: [   ] BRACKETS CAN BE PROBLEMATIC AS HOD CODEPAGE   */
 /* -                 FOR [] MAY BE DIFFERENT FROM THE RX CODE      */
 /* -           USE <   > FOR THE MOST STANDARD KEY CODE MATCH      */
 /* -                 OPDS<AAA.BBB.CCC(@)> WILL USE THE SPECIFIED   */
 /* -                 DSN, SUBSTITUTING APLID FOR EACH MEMBER.      */
 /* -                 IF DSN DOES NOT EXITS:                        */
 /* -                        IT WILL BE ALLOCATED.                  */
 /* -                 IF A DSN DOES:                                */
 /* -                        IT MUST BE PO,  VBA, LRECL=125.        */
 /* -                                                               */
 /* - XTRK2VBS(NEW|TGTDSN|) EXPECTING TO USE EXTRACT COMMAND        */
 /* -          ADD THIS PARM TO ALLOCATE TWO OUTPUT DSN CBDOUT      */
 /* -                 AND VBDOUT USED BY EXTRACT COMMAND PROGRAMS   */
 /* -           USERPROG=UFH$CBDA    CIGNA EXTRACT TO DEFINE CBDOUT */
 /* -           USERPROG=UFH0CBDC    COB EXTRACT FORMAT WRITES BOTH */
 /* -                 CBDOUT AND VBDOUT (SINGLE LINE PER RDO ENTRY) */
 /* -           NEW  DSN ARE CREATED DYNAMICALLY BASED ON           */
 /* -           SYSUID.APPLID.REL.DXXXXX.TYYYYYY.CBDOUT OR VBDOUT   */
 /* -  OR                                                           */
 /* - EXTRACT(NEW|TGTDSN|) EXPECTING TO USE EXTRACT COMMAND         */
 /* -          ADD THIS PARM TO ALLOCATE ONE OUTPUT DSN USED BY     */
 /* -           USERPROG=UFH$CBDA    CIGNA EXTRACT TO DEFINE CBDOUT */
 /* -          NEW  DSN ARE CREATED DYNAMICALLY BASED ON            */
 /* -           SYSUID.APPLID.REL.DXXXXX.TYYYYYY.CBDOUT OR VBDOUT   */
 /* -          TGTDSN SPECIFIES A SPECIFIC DATASET NAME IS          */
 /* -                 TO   BE USED AS THE TARGET FOR EACH EXTRACT   */
 /* -             IF TGTDSN IS DOES NOT EXIST, THEN A NEW SEQ       */
 /* -                 DATASET WILL BE CREATED.                      */
 /* -             IF DSN SPECIFIED, THE DSN CAN INCLUDE A '@'       */
 /* -                 PLACEHOLDER TO SUBSTITUTE THE REGION APLID    */
 /* -                 AS ONE OF THE DSN QUALIFIRS. DSN PRESUMED NEW.*/
 /* -             IF EXISTING, AND DSN IS SEQ, THE DSN WILL BE      */
 /* -                 REUSED AND ALL EXTRACTED DATA IS 'MOD' TO END.*/
 /* -             IF EXISTING AND A PDS(E), THEN EACH REGION        */
 /* -                 EXTRACT WILL BE WRITTEN TO A MEMBER NAMED     */
 /* -                 AS THE APLID.                                 */
 /* - NOTE!!! - FOR EITHER SEQ OR PDS, THE EXISTING DSN MUST BR     */
 /* -                 RECFM=FB, WITH A LRECL=80                     */
 /* -                                                               */
 /* - NOTE!!! - FOR EXTRACT TO VBS,    THE EXISTING DSN MUST BR     */
 /* -                 RECFM=VB, WITH A LRECL=4093                   */
 /* -         - LRECL IS SET TO EXPECTED MAX REC SIZE FOR EXTRACT   */
 /* -           AND IS SET IN VAR MAXVBSLRECL                       */
 /* -                                                               */
 /* - FOR EXAMPLE VALID                                             */
 /* AFORDOR JOBLIST(CGTA,CGAA) COMMAND[?] OPDS[TCEM.RDO.EXPLRTCP]   */
 /* AFORDOR LIST(CURRLIST) COMMAND[?] OPDS[TCEM.RDO.EXPLRTCP]       */
 /* AFORDOR LIST(CURRLIST) COMMAND<?>  OPDS<TCEM.RDO.EXPLRTCP>      */
 /*         COMMAND<LIST LIST(\@) FORCEREL(520)                     */
 /* -                                                               */
 /* COMMAND[?] PROMPTS FOR VALID COMMAND                            */
 /* LIST GROUP(EXPLRTCP) OBJECTS                                    */
 /* LIST LIST(\@)            NOTE - \@ WILL HAVE APPLID SUBSTITUTED */
 /* SPECIAL SUBSTITUTION PARM \! IS DESIGNED TO LET YOU SUPPLY A    */
 /*         SET OF VARIABLE TO BE SUBSTITUTED BASED ON THE APPLID   */
 /*         SEE RX AFOS#PRM   FOR SPECIFIC INFORMATION              */
 /*                                                                 */
 /*                                                                 */
 /* CEMHELP          -                                              */
 /* CEMHELP END                                                     */
 ADDRESS TSO
/******************************** REXX ********************************/
/*                                                                    */
/*TRACE ?I  */
/*TRACE I */
/*                                                                    */
  ARG MYARGSTR
  IF MYARGSTR = '' | MYARGSTR = '?' THEN DO
   CALL MSGBOX 'YOU NEED TO SUPPLY A PARAMETER TO AFORDOR.'
   CALL CEMHELP AFORDOR
   EXIT
   END
  'GETCPU1 <PUSH>'
  PULL CURCPU CURCPUG
  XC = 0
  MXRC=XC
  MYAREA=''
  FFX='FF'X
  MYAREA#=FFX
  BKSLH = '\'
  FNDWDS='\@ \$ \! \\'  /* SUBSTITUTE \ APPLID JOBNAME */
  RWCT=WORDS(FNDWDS)
  SUBWDS='MYAPLID JOBN S#PARM BKSLH'
  JUNK = ''
  CALL SLEEP_NOW 1
  CALL GETUDSN '@'
  PULL EDSN
  EP=POS('@',EDSN)
  EDSNPFX = SUBSTR(EDSN,1,EP-1)
  EDSNSFX = SUBSTR(EDSN,EP+1)
  MYARGS='COMMAND JOBLIST LIST FORCEREL ODSN INCSD EXTRACT XTRK2VBS'
  "GETKREL ???"    /* E.G. RETURNS '2 540 550' */
  PULL KIXRELLST
  IF KIXRELLST='' THEN DO
   KIXRELLST='2 540 550'
   END
  PARSE VAR KIXRELLST KIXCT KIXRELLST
  KIXRELLST=TRANSLATE(KIXRELLST,' ',',')
  KIXCT=WORDS(KIXRELLST)
  MYSREL=''
  FORCEREL=0
  MYCMD='?'
  MYAPLL = ''
  LISTNM = ''
  LIST_HAS_ERRS='N'
  MYAFOIND=''
  MYJOBL = ''
  OPDS=''
  OPDS@=''
  OMBR=''
  ODSNDS=''
  ODSNOUT=''
  ODSN=''
  ODSNDISP=''
  INCSD=''
  EXTRKCMD=''
  EXTRKDS=''
  EXTRKOUT=''
  CBDOUTDS=''
  MYRECFM='V B A'
  MYLRECL='125'
  MYBLKSZ='6450'
  MAXVBSLRECL = '4093'
  BB='{[\<'
  EB='}]/>'
  ACUMMSG=FFX||'AFORDOR START:'DATE('U') TIME()||FFX
/*TRACE  I */
  MYARGSTR=MYARGSTR||' '
  CP = POS('COMMAND',MYARGSTR)
  ARGERRSTR='COMMAND'
  IF CP \= 0 THEN DO
   CPB = CP+7
   CBBRK=SUBSTR(MYARGSTR,CPB,1)
   CPE=POS(CBBRK,BB)
   IF CPE=0 THEN SIGNAL BADBRACKETS
   CEBRK=SUBSTR(EB,CPE,1)
   CPE=POS(CEBRK,MYARGSTR,CPB+1)
   IF CPE=0 THEN SIGNAL BADBRACKETS
   CPL=CPE-(CPB+1)
   MYCMD=SUBSTR(MYARGSTR,CPB+1,CPL)
   IF MYCMD = '' THEN MYCMD = '?'
   IF CP = 1 THEN MYARGSTR = SUBSTR(MYARGSTR,CPE+1)
    ELSE MYARGSTR=SUBSTR(MYARGSTR,1,CP-1)||SUBSTR(MYARGSTR,CPE+1)
   END
/*TRACE ?I*/
  CP = POS('OPDS',MYARGSTR)
  ARGERRSTR='OPDS'
  IF CP \= 0 THEN DO
   CPB = CP+4
   CBBRK=SUBSTR(MYARGSTR,CPB,1)
   CPE=POS(CBBRK,BB)
   IF CPE=0 THEN SIGNAL BADBRACKETS
   CEBRK=SUBSTR(EB,CPE,1)
   CPE=POS(CEBRK,MYARGSTR,CPB+1)
   IF CPE=0 THEN SIGNAL BADBRACKETS
   CPL=CPE-(CPB+1)
 /* ASSIGN OPDS WITH PARM BASED ON BB AND EB FOUND */
   OPDS=SUBSTR(MYARGSTR,CPB+1,CPL)
   IF OPDS = '' THEN SIGNAL BADCOMMAND
   IF CP = 1 THEN MYARGSTR = SUBSTR(MYARGSTR,CPE+1)
    ELSE MYARGSTR=SUBSTR(MYARGSTR,1,CP-1)||SUBSTR(MYARGSTR,CPE+1)
   END
 /* CONTINUE PARSING ARGS                          */
  DO WHILE MYARGSTR \= ''
   MYVAL=''
/* TRACE ?I  */
   PARSE VAR MYARGSTR MYKEY '(' MYVAL ')' MYARGSTR
   SELECT
    WHEN MYKEY = 'INCSD' THEN DO
     INCSD = MYVAL
     IF SYSDSN("'"INCSD"'") \= 'OK' THEN SIGNAL BADINCSD
     END
    WHEN MYKEY = 'EXTRACT' | MYKEY = 'XTRK2VBS' THEN DO
 /* THE EXTRACT PROGRAMS EXIST IN THE CIGNA CICS LOADLIB */
 /*  THEREFOR IT MUST BE PREALLOCATED TO TSOLIB          */
     CALL EXPLTSOL 'EXCILIB'
     XC=RESULT
     IF XC  \= 0 THEN SIGNAL EXTRKNOTSO
/*   TRACE I */
     EXTRKCMD=MYKEY
     EXTRKVS = MYVAL
     EXTRKDS = MYVAL
     IF MYKEY = 'XTRK2VBS' THEN DO
/*    TRACE I */
      IF MYVAL = '' THEN EXTRKVS = 'NEW'
       CALL CHKEXTRKVS
       'FREE ATTR(VDBATT)'
       'ATTR VDBATT LRECL('MAXVBSLRECL') BLKSIZE(0) RECFM(V B)'
      END
     IF EXTRKDS = '' THEN EXTRKDS = 'NEW'
     CALL CHKEXTRKDS
     'FREE ATTR(CDBATT)'
     'ATTR CDBATT LRECL(80) BLKSIZE(4080) RECFM(F B)'
     TRACE OFF
     END
    WHEN MYKEY = 'FORCEREL' THEN DO
     IF SUBSTR(MYVAL,1,1) = 'R' THEN MYVAL=SUBSTR(MYVAL,2)
     MYSREL = MYVAL
     IF WORDPOS(MYSREL,KIXRELLST) = 0 THEN DO
      OKCAN1 = 'FORCEREL:'FORCEREL':IS NOT KNOWN:'KIXRELLST
      OKCAN2 = '(O)K TO CONTINUE, (C)ANCEL TO ABORT'
      OKCANX = 'C'
      ADDRESS ISPEXEC 'VPUT (OKCAN1 OKCAN2 OKCANX) ASIS'
      CALL OKCANBOX
      IF RESULT ^= 0 THEN SIGNAL BADFORCEREL
      END
     FORCEREL=1
     END
    WHEN MYKEY = 'JOBLIST' THEN DO
     MYAPLL = TRANSLATE(MYVAL,' ',',')
     LISTNM='JOBLIST'
     END
    WHEN MYKEY = 'ODSN' THEN DO
     IF OPDS \= '' THEN SIGNAL BADODSN_OPDS
     ODSN=MYVAL
     IF POS('(',ODSN) \= 0 THEN SIGNAL BADODSN
     END
    WHEN MYKEY = 'LIST' THEN DO
     LISTNM = MYVAL
     'ISPEXEC VGET ('LISTNM') ASIS'
     IF RC ^= 0 THEN SIGNAL BADLIST
     INTERPRET "MYAPLL = TRANSLATE("LISTNM",' ',',')"
     END
    OTHERWISE
     SIGNAL BADPARM
    END
   END
/* TRACE ?I */
  IF OPDS = '' THEN SIGNAL CHKODSN
/* OPDS VALID VALUES
   AAA.BBB.CCC()     EACH APLID IS MBR
   AAA.BBB.CCC(@)    EACH APLID IS MBR
   AAA.BBB.CCC(DDD)  MBR DDD IS DISP=MOD
   AAA.@.CCC(DDD)    EACH APLID IS OWN PDS WITH MBR DDD
   OTHERWISE, INVALID PDS NAME
   IF ANY AAA.BBB.CCC SPECIFIED THEN CHECK FOR EXISTENCE
   IF DSN EXISTS, IT MUST BE PDS(E), VBA AND LRECL 125
    ELSE DOES NOT EXIST WE ALOC WITH THESE ATTRIBUTES.
*/
/* TRACE ?I */
  UPPER OPDS
  PARSE VAR OPDS OPDS '(' OMBR ')'
  IF OPDS = '' THEN SIGNAL BADOPDS
  IF LENGTH(OPDS) > 51 THEN SIGNAL BADOPDS
  IF LENGTH(OMBR) > 8 THEN SIGNAL BADOPDS
  IF OPDS = '@' THEN DO
   ODSNDS = EDSNPFX||'@'||EDSNSFX
   ODSNDISP='NEW'
   OPDS@='@'
/* IF OMBR = '' | OMBR='@' THEN SIGNAL BADOPDS_MBR_SYMB */
   SIGNAL DONEODSN
   END
  FP=POS('@',OPDS)
  IF FP \= 0 THEN DO
 /* DSN HAS @ PLACE HOLDER; SO MBR MUST BE SPECIFIED, AND STATIC */
/* IF OMBR = '' | OMBR='@' THEN SIGNAL BADOPDS_MBR_SYMB */
   OPDS@='@'
   ODSNDS=OPDS
   ODSNDISP='NEW'
   SIGNAL DONEODSN
   END
   ELSE DO
 /* DSN IS STATIC (NO @ SUBSTITUTION) CHK MBR FOR '' OR @        *\
 |* IF NOT EITHER VALUE, THEN CAN NOT USE STATIC PDS WITH A      *|
 \* SINGLE PDS MBR TO ACCUMULATE ALL OUTPUT AS IN DISP=MOD       */
   ODSNDX = OPDS
   CALL CHKPDSDISP
 /* ODSNDISP IS SET TO EITHER NEW OR SHR */
 /* ODSNDS WILL HAVE THE OPDS VALUE      */
   IF XC > 16 THEN SIGNAL BADOPDS
   IF XC > 0 THEN ODSNDISP = 'NEW'
             ELSE ODSNDISP = 'SHR'
   IF OMBR = '' THEN OMBR = '@'
   SIGNAL DONEODSN
/* IF OMBR = '@' THEN SIGNAL DONEODSN
    ELSE SIGNAL BADOPDS   */
 /* CHECKING FOR SEQUENTIAL DSN TO HANDKLE OUTPUT                *\
 |* IF ODSN (AND OPDS) IS OMMITTED OR ODSN = '@'                 *|
 |*   THEN EACH REGN GETS OWN DSN                                *|
 \* OTHERWISE DSN MUST BE SEQ, AND WILL BE REUSE MODE            */
CHKODSN:
  IF OPDS \= '' THEN SIGNAL BADODSN
  IF ODSN = '' | ODSN = '@' THEN DO
   ODSN='@'
   END
  ODSNDS=ODSN
DONEODSN:
 /*  TRACE I */
  JOBLIST=''
  APLLIST=''
  JOBCPUL=''
  IF MYAPLL \= '' THEN DO
   X = OUTTRAP('JNL.')
   CALL CVTJN2RG MYAPLL
   X = OUTTRAP('OFF')
   DO S = 1 TO JNL.0
    IF WORD(JNL.S,1) = '!!!!!!!!' THEN DO
     IF LIST_HAS_ERRS = 'N' THEN DO
      ACUMMSG = ACUMMSG||'WARN:  LIST:'||LISTNM||,
                ': HAS UNKNOWN REGIONS'||FFX
      LIST_HAS_ERRS = 'Y'
      END
     ITERATE
    END
    JOBLIST=JOBLIST||' '||WORD(JNL.S,2)
    APLLIST=APLLIST||' '||WORD(JNL.S,1)
    APLLIST# = WORDS(APLLIST)
    MYCPU = ''
    CALL GETCPU4APLID
    /* RETURNS MYAPLID MYREL MYCPU MYTYP */
    IF RC = 0 THEN DO
     JOBCPUL=JOBCPUL||' '||MYCPU
     END
     ELSE DO
     JOBCPUL=JOBCPUL||' -'
     END
    END
   END
  TRACE OFF
 /* TRACE ?I */
  MYJOBL = JOBLIST
  MYAPLL = APLLIST
  JOB#=WORDS(MYAPLL)
  IF JOB# < 1 THEN SIGNAL ERRORJOB#0
  JOB#PTR = 0
  IF MYCMD = '?' THEN SIGNAL GETCMD
  IF MYCMD \= '' THEN DO
   SRC#=1
   SRC.1 = MYCMD
   SIGNAL GOTCMD
   END
 GETCMD:
   ADDRESS TSO "NEWSTACK"
   ADDRESS ISPEXEC
   ACTN='PULL'         /* PULL MEANS DON'T LOOK FOR ISPVARS */
   EXECSEL = 'AFORDOR'
   DSEMSG = 'RDO CMD STMTS. USE \@ APPLID \$ JOBNAME. PF3 END'
   ADDRESS ISPEXEC "VPUT (EXECSEL DSEMSG) ASIS"
   MYVARO = 'MRDOR'
   CALL REXXSRC ACTN"("MYVARO")"
   XC = RESULT
   IF XC ^= 0 THEN SIGNAL ERR_REXXSRC
   CC=QUEUED()
   IF CC = 0 THEN SIGNAL NO_CMDS
 /*TRACE ?I   */
   ACUMMSG=ACUMMSG||'....> PULLING REXX STATEMENTS <.....'||FFX
   MYVARCT = QUEUED()
   SRC#=0
   DO K = 1 TO MYVARCT
    PULL SRC.K
    ACUMMSG=ACUMMSG||SRC.K||FFX
    SRC#=K
    END
  ADDRESS TSO "DELSTACK"
/*                                                                    */
/*TRACE ?I  \*                                                        */
/*                                                                    */
GOTCMD:
  TRACE OFF
  IF SRC# < 1 THEN SIGNAL NO_CMDS
  IF SRC.1 = '' THEN SIGNAL NO_CMDS
  TRYSTR=''
  REALSRC.0 = 0
  ADDRESS TSO
  'FREE ATTR(SYSPRATT SYSINATT OPDSATT)'
  'FREE FI(SYSPRINT SYSIN DFHCSD)'
  'ATTR SYSPRATT LRECL('MYLRECL||,
    ') BLKSIZE('MYBLKSZ') RECFM('MYRECFM')'
  'ATTR OPDSATT LRECL('MYLRECL||,
    ') BLKSIZE('MYBLKSZ') RECFM('MYRECFM||,
    ') DSORG(PO)'
  'ATTR SYSINATT LRECL(80) BLKSIZE(80) RECFM(F B)'
  JOB#PTR = 0
 TOPOFLOP:
  JOB#PTR=JOB#PTR+1
  IF JOB#PTR > JOB# THEN SIGNAL DONEALL
  MYSELID=WORD(MYAPLL,JOB#PTR)
  IF SUBSTR(MYSELID,1,1) = '!' THEN SIGNAL TOPOFLOP
  ADDRESS ISPEXEC "VGET ("MYSELID") ASIS"
  IF RC \= 0 THEN DO
   ACUMMSG=ACUMMSG||'1 COULD NOT FIND AFO REC FOR APLID:'||MYSELID||FFX
   SIGNAL TOPOFLOP
   MXRC=8
   END
  INTERPRET 'TMP='MYSELID
  ADDRESS ISPEXEC "VGET (SVAFO"TMP") ASIS"
  IF RC \= 0 THEN DO
   ACUMMSG=ACUMMSG||'2 COULD NOT FIND AFO REC FOR APLID:'||MYSELID||FFX
   SIGNAL TOPOFLOP
   MXRC=8
   END
  TRACE OFF
  INTERPRET 'TMP=SVAFO'TMP
  MYAPLID=LEFT(SUBSTR(TMP,BMYAPLID,LMYAPLID),9)
  MYREL=SUBSTR(TMP,BMYREL,LMYREL)
  MYCPU=SUBSTR(TMP,BMYCPU,LMYCPU)
  MYTYP=SUBSTR(TMP,BMYTYP,LMYTYP)

  IF POS(MYCPU,CURCPUG) = 0 THEN DO
   ACUMMSG=ACUMMSG||'APLID NOT VALID THIS SYSPLEX:'||MYSELID||FFX
   SIGNAL TOPOFLOP
   MXRC=8
   END
  IF FORCEREL = 1 THEN MYREL=MYSREL
  IF MYTYP='E' THEN MYSTYP='D'
   ELSE MYSTYP=MYTYP
/*SAY MYAPLID  MYREL  MYTYP MYSTYP */
/*   DO FNDWDS SUBSTITUTION */
  DROP REALSRC.
/*TRACE ?I */
  SRC#PTR = 1
TOPOFSRCLOP:
  SUBCMD=SRC.SRC#PTR
  DO Q = 1 TO RWCT
   JP = POS(WORD(FNDWDS,Q),SUBSTR(SUBCMD,2))
   IF JP > 0 THEN SIGNAL DO_SUB0
   END
  SIGNAL NO_SUB0
DO_SUB0:
  CALL SUBJOBN
  IF RESULT /= 0 THEN SIGNAL BADJOB
NO_SUB0:
  REALSRC.SRC#PTR=SUBCMD
  SRC#PTR = SRC#PTR + 1
  IF SRC#PTR \> SRC# THEN SIGNAL TOPOFSRCLOP
  REALSRC.0=SRC#
/*                                                                    */
/*TRACE ?I  */
/*                                                                    */
/* TRACE ?I */
  FAILED_DD=''
  CALL RUNRPT
  XC =RC
  ACUMMSG=ACUMMSG||'REGION:'||MYSELID||':'||FFX
  IF XC \= 0 THEN DO
   IF FAILED_DD \= '' THEN
    ACUMMSG=ACUMMSG||'DFHCSDUP RC:'||XC||', ALLOCATION ERROR:'||,
          FAILED_DD||' FOR REGION:'||MYSELID||FFX
    ELSE
    ACUMMSG=ACUMMSG||'DFHCSDUP RC:'||XC||', DFHCSDUP ERROR '||,
          ' FOR REGION:'||MYSELID||FFX
   END
   ELSE DO
   ACUMMSG=ACUMMSG||'DFHCSDUP RC:'||XC||', WRITTEN TO:'||ODSNDX||FFX
   END
/*                                                                    */
/*TRACE ?I  \*                                                        */
/*                                                                    */
 SIGNAL TOPOFLOP
DONEALL:
  DROP REALSRC.
 'FREE ATTR(SYSPRATT SYSINATT OPDSATT)'
 "DELETE '"IDSN"'"
 IF EXTRKDS \= '' THEN DO
  'FREE ATTR(CDBATT)'
  'FREE FILE(CBDOUT)'
  END
 IF INCSD \= '' THEN 'FREE FI(INCSD)'
 MSGSTAT='REMPOP'
 ACUMMSG=ACUMMSG||'AFORDOR END:'DATE('U') TIME()||FFX
 XC = 0
 SIGNAL EXITIT
BADBRACKETS:
 ACUMMSG=ACUMMSG||'ERROR IN COMMAND:BRACKETS:<'||ARGERRSTR||,
   '> ARGSTR<'||MYARGSTR||'> EXPECTING ONE OF:'||BB||':'||FFX||,
   '> USE CEMHELP AFORDOR.'||FFX
 XC = 8
 SIGNAL EXITIT
BADCOMMAND:
 ACUMMSG=ACUMMSG||'ERROR IN COMMAND:<'||ARGERRSTR||,
   '> ARGSTR<'||MYARGSTR||'> USE CEMHELP AFORDOR.'||FFX
 XC = 8
 SIGNAL EXITIT
BADOPDS:
 ACUMMSG=ACUMMSG||'OUTPUT PDS DSN(MBR) IS NOT VALID.'||FFX||,
                  'PDS MUST BE VBA AND LRECL(125).ENDING'||FFX||,
                  'OPDS:'||OPDS||FFX
 XC = 8
 SIGNAL EXITIT
BADOPDS_MBR_SYMB:
 ACUMMSG=ACUMMSG||'OUTPUT PDS DSN(MBR) IS NOT VALID.'||FFX||,
                  'PDS IS @ SYMB AND MBR IS @ SYMB. ABORT:'||FFX
 XC = 8
 SIGNAL EXITIT
BADODSN_OPDS:
 ACUMMSG=ACUMMSG||'OUTPUT DSN (ODSN) AND OPDS BOTH SPECIFIED:'||FFX||,
  'ODSN:'||ODSN||FFX||'OPDS:'||OPDS||FFX||'ONLY ONE IS VALID.'||FFX
 XC = 8
 SIGNAL EXITIT
BADODSN:
 ACUMMSG=ACUMMSG||'OUTPUT DSN (ODSN) CANNOT CONTAIN MBR. ENDING'||FFX||,
  ODSN||FFX
 XC = 8
 SIGNAL EXITIT
BADPARM:
 CALL CEMHELP AFORDOR
 ACUMMSG=ACUMMSG||'ONE OR MORE PARAMETERS ARE INVALID.'||FFX||,
  'KEY<'||MYKEY||'> VALUE<'||MYVAL||'>'||FFX||'ENDING'||FFX
 XC = 8
 SIGNAL EXITIT
BADEXTRKDSO:
 ACUMMSG=ACUMMSG||'EXTRACT DS:||'EXTRKDS'|| WRONG DSORG. ENDING'||FFX
 XC = 8
 SIGNAL EXITIT
BADEXTRKBLK:
 ACUMMSG=ACUMMSG||'EXTRACT DS:||'EXTRKDS'|| WRONG RECFM. ENDING'||FFX
 XC = 8
 SIGNAL EXITIT
BADEXTRKLRECL:
 ACUMMSG=ACUMMSG||'EXTRACT DS:||'EXTRKDS'|| WRONG LRECL. ENDING'||FFX
 XC = 8
 SIGNAL EXITIT
ERRORAFO1:
 ACUMMSG=ACUMMSG||'AFOOPER (AFOLOAD1) DID NOT RUN. ENDING'||FFX
 XC = 12
 SIGNAL EXITIT
BADINCSD:
 ACUMMSG=ACUMMSG||'INCSD:'||INCSD||' INVALID OR NOT FND. ENDING,'||FFX
 XC = 4
 SIGNAL EXITIT
EXTRKNOTSO:
 ACUMMSG=ACUMMSG||'NEED TO RUN EXCITSLB FROM TSO READY. ENDING'||FFX
 XC = 4
 SIGNAL EXITIT
ERRORJOB#0:
 ACUMMSG=ACUMMSG||'NO JOBLIST OR LIST(X) SPECIFIED. ENDING'||FFX
 XC = 4
 SIGNAL EXITIT
NO_CMDS:
 ACUMMSG=ACUMMSG||'NO CAMMANDS WERE REQUESTED. ENDING'||FFX
 XC = 4
 SIGNAL EXITIT
BADLIST:
 ACUMMSG=ACUMMSG||'ERROR: LIST PARM:'||LISTNM||':NOT VALID'||FFX
 XC = 8
 SIGNAL EXITIT
BADFORCEREL:
 ACUMMSG=ACUMMSG||'ERROR IN FORCEREL:'MYSREL':NOT IN:'KIXRELLST||FFX
 ACUMMSG=ACUMMSG||'PARM:FORCEREL('MYSREL')INVALID'||FFX
 XC = 8
 SIGNAL EXITIT
BADJOB:
 ACUMMSG=ACUMMSG||'ERROR IN JOBNAME SUBSTITUTION:'JOB#PTR JOBN||FFX
 ACUMMSG=ACUMMSG||'COMMAND:'SRC#PTR SUBCMD||FFX
 XC = 8
 SIGNAL EXITIT
ERR_REXXSRC:
 ACUMMSG=ACUMMSG||'ERRORS ATTEMPTING TO PULL COMMANDS.'||FFX
 XC = 8
 SIGNAL EXITIT
NO_REXPARMS:
 ACUMMSG=ACUMMSG||'ERRORS ATTEMPTING TO PULL PARAMETERS'||FFX
 XC = 8
 SIGNAL EXITIT
EXITIT:
 /* IF XC = 0 THEN RETURN 0 */
 IF MXRC > XC THEN XC = MXRC
 ACUMMSG=ACUMMSG||'** REMEMBER TO CLEAN UP EXTRACT AND REPORT FILES '||,
   'WHEN FINISHED WITH YOUR TASK!!!'||FFX
 MYAREA=ACUMMSG
 ADDRESS ISPEXEC "VPUT (EXECSEL MYAREA MYAREA#) ASIS"
 CALL DSPLYA
 RETURN XC
/* *\
\* */
SUBJOBN:
/* JOB#PTR IS THE CURRENT JOBNAME FROM THE SUPPLIED LIST */
/* IF ZERO JOBNAMES WERE SUPPLIED, THEN WE CAN NOT PERFORM */
/*   THE $ SUBSTITUTION.                                 */
/* WE SHOULD NOT BE HERE IF THE JOB#PTR IS > NUMBER OF   */
/*   JOBNAMES PROVIDED IN THE JOBLIST ARGUMENT.          */
  /* TRACE ?I */
  IF LENGTH(SUBCMD) < 1 THEN RETURN 8
  IF JOB#PTR = 0 THEN RETURN 8
  IF JOB#PTR > JOB# THEN RETURN 8
  LOOPCT=100
  JOBN=WORD(MYJOBL,JOB#PTR)
  MYAPLID=WORD(MYAPLL,JOB#PTR)
  IF JOB# < 1 THEN RETURN 8
  MYCPU=WORD(JOBCPUL,JOB#PTR)
  IF POS(MYCPU,CURCPUG)=0 THEN RETURN 8
  V = 1
  /* NEW CODE V2 */
  /* TRACE I */
  S#APLID = MYAPLID
  IF LENGTH(S#APLID) < 7 THEN INTERPRET "T#PARM = 'S#"||S#APLID||"'"
    ELSE INTERPRET "T#PARM = 'S#"||SUBSTR(S#APLID,3)||"'"
  INTERPRET T#PARM " = S#VALUE"
  'ISPEXEC VGET ('T#PARM') ASIS'
  IF RC > 0 THEN S#PARM = MYAPLID
   ELSE INTERPRET 'S#PARM = 'T#PARM
  TRACE OFF
  /* NEW CODE V2 */
TOPOFQLOP:
  JP = POS(WORD(FNDWDS,V),SUBSTR(SUBCMD,2))
  IF JP < 1 THEN SIGNAL NEXT_V_LOP
  IF LOOPCT < 1 THEN RETURN 8
  SUBWD = WORD(SUBWDS,V)
  INTERPRET 'REPWD = 'SUBWD
  IF JP = 1 THEN DO
   SUBCMD = REPWD||SUBSTR(SUBCMD,2)
   SIGNAL DONE_SUBJOBN
   END
  SUBCMD=SUBSTR(SUBCMD,1,JP)||REPWD||SUBSTR(SUBCMD,JP+3)
DONE_SUBJOBN:
  LOOPCT = LOOPCT - 1
  JP = POS(WORD(FNDWDS,V),SUBSTR(SUBCMD,2))
  IF JP > 0 THEN SIGNAL TOPOFQLOP
NEXT_V_LOP:
  V = V + 1
  IF V \> RWCT THEN SIGNAL TOPOFQLOP
  TRACE OFF
 RETURN 0
/* OLD SUBJOBN IS BELOW - SINGLE REPLACEMENT FOR @       */
SUBJOBN1:
/* JOB#PTR IS THE CURRENT JOBNAME FROM THE SUPPLIED LIST */
/* IF ZERO JOBNAMES WERE SUPPLIED, THEN WE CAN NOT PERFORM */
/*   THE @ SUBSTITUTION (APPLID).                        */
/* VAR JOB# IS THE COUNT OF APPLIDS REQUESTED            */
/* VAR JP HOLDS POS OF '@' IN THE SUBCMD VAR             */
/* WE SHOULD NOT BE HERE IF THE JOB#PTR IS > NUMBER OF   */
/*   JOBNAMES PROVIDED IN THE JOBLIST ARGUMENT.          */
 IF JOB#PTR = 0 THEN RETURN 8
 IF JOB#PTR > JOB# THEN RETURN 8
 IF JP > 0 THEN DO
  JOBN=WORD(MYAPLL,JOB#PTR)
  IF JOB# < 1 THEN RETURN 8
  IF JP = 1 THEN DO
   SUBCMD = JOBN||SUBSTR(SUBCMD,2)
   END
   ELSE DO
   SUBCMD=SUBSTR(SUBCMD,1,JP-1)||JOBN||SUBSTR(SUBCMD,JP+1)
   END
  JP=POS('@',SUBCMD,2)
  DO WHILE JP > 0
   SUBCMD=SUBSTR(SUBCMD,1,JP-1)||SUBSTR(SUBCMD,JP+1)
   JP=POS('@',SUBCMD)
   END
  END
 SUBCMD = LEFT(' '||STRIP(SUBCMD,'B'),80)
 IF LENGTH(SUBCMD) < 2 OR LENGTH(SUBCMD) > 80 THEN RETURN 8
 RETURN 0
/*******************/
/* SLEEP ROUTINE   */
/*******************/
SLEEP_NOW:
ARG SLEEP_TIME
IF SLEEP_TIME = '' THEN SLEEP_TIME = 10
IF JUNK = '' THEN JUNK = SYSCALLS('ON')
ADDRESS SYSCALL "SLEEP" SLEEP_TIME
RETURN
/****************************\
|* GET CPU 4 APLID          *|
\****************************/
GETCPU4APLID:
 IF MYAFOIND \= '' THEN SIGNAL ARNDLOAD
  "ISPEXEC VGET (MYAFOIND SVAFO0) SHARED"
  IF RC = 0 THEN SIGNAL TOPOFLOP0
  CALL AFOLOAD1
  XC = RESULT
  IF XC = 0 THEN SIGNAL TOPOFLOP0
  SIGNAL ERRORAFO1
 TOPOFLOP0:
  EXPLSTR='MYAPLID MYTYP MYREL MYCPU'
  NWD=WORDS(EXPLSTR)
  CALL AFOPOS EXPLSTR
  PULL AFOSTR
  IF AFOSTR='' THEN SIGNAL EXITRC8
  DO WHILE (AFOSTR ^='')
   PARSE VAR AFOSTR AFONM AFOL AFOB AFOE AFOT '#' AFOSTR
   IF AFOL = '-' | AFOB = '-' THEN ITERATE
   INTERPRET 'B'||AFONM' = AFOB'
   INTERPRET 'L'||AFONM' = AFOL'
   END
ARNDLOAD:
/* TRACE I */
  MYSELID=WORD(APLLIST,APLLIST#)
/*SAY 'LINE# 706: MYSELID:' MYSELID ':' */
  ADDRESS ISPEXEC "VGET ("MYSELID") ASIS"
  IF RC \= 0 THEN DO
   ACUMMSG=ACUMMSG||'COULD NOT FIND AFO REC FOR APLID:'||MYSELID||FFX
   MXRC=8
   SIGNAL RET_NO_CPU
   END
  INTERPRET 'TMP='MYSELID
  ADDRESS ISPEXEC "VGET (SVAFO"TMP") ASIS"
  IF RC \= 0 THEN DO
   ACUMMSG=ACUMMSG||'COULD NOT FIND AFO REC FOR APLID:'||MYSELID||FFX
   MXRC=8
   SIGNAL RET_NO_CPU
   END
  INTERPRET 'TMP=SVAFO'TMP
  MYAPLID=LEFT(SUBSTR(TMP,BMYAPLID,LMYAPLID),9)
  MYREL=SUBSTR(TMP,BMYREL,LMYREL)
  MYCPU=SUBSTR(TMP,BMYCPU,LMYCPU)
  MYTYP=SUBSTR(TMP,BMYTYP,LMYTYP)
  IF POS(MYCPU,CURCPUG) = 0 THEN DO
   ACUMMSG=ACUMMSG||'APLID NOT VALID THIS SYSPLEX:'||MYSELID||FFX
   MXRC=8
   SIGNAL RET_NO_CPU
   END
  IF FORCEREL = 1 THEN MYREL=MYSREL
  IF MYTYP='E' THEN MYSTYP='D'
   ELSE MYSTYP=MYTYP
  RETURN 0
RET_NO_CPU:
 MYCPU=''
 RETURN MXRC
/*******************/
/* RUN REPORT      */
/*******************/
RUNRPT:
/* TRACE I */
  IF JOB#PTR = 1 THEN DO
  /* ON FIRST APLID, WE NEED TO ALLOC THE SYSIN DS A *\
  |   AND THE INCSD IF SPECIFIED.                     |
  \* ON SUBSEQUENT RUNS, THE SYSIN DATASET IS REUSED */
/* TRACE ?I*/
   IDSN= EDSNPFX||'RDOSYSIN'||EDSNSFX
   "ALLOC FI(SYSIN) DA('"IDSN"') NEW USING(SYSINATT) CYL SPACE(1,1)"
   IF RC \= 0 THEN DO
    FAILED_DD='SYSIN'
    SIGNAL RETURN_8
    END
   "EXECIO * DISKW SYSIN (STEM REALSRC. FINIS"
   IF INCSD \= '' THEN DO
    "ALLOC FI(INCSD) DA('"INCSD"') SHR"
    IF RC \= 0 THEN DO
     FAILED_DD='INCSD'
     SIGNAL RETURN_8
     END
    END
   END           /* END JOBPTR = 1 */
   ELSE DO       /* JOBPTR > 1)    */
   "ALLOC FI(SYSIN) DA('"IDSN"') SHR REUSE"
   IF RC \= 0 THEN DO
    FAILED_DD='SYSIN(OLD)'
    SIGNAL RETURN_8
    END
   "EXECIO * DISKW SYSIN (STEM REALSRC. FINIS"
   END           /* END JOBPTR > 1)    */
/* TRACE I */
  IF EXTRKDS = '' THEN SIGNAL NO_EXTRACT
  IF EXTRKDS \= 'NEW' THEN DO
   CBDOUTDS=EXTRKOUT
   IF EXTDSO = 'PS' THEN DO
    IF JOB#PTR > 1 THEN EXTRKDS = 'MOD'
     ELSE EXTRKDS = 'SHR REUSE'
    END
    ELSE DO
    EXTRKDS = 'SHR'
    CBDOUTDS = CBDOUTDS||'('||MYSELID||')'
    END
   "ALLOC FI(CBDOUT) DA('"CBDOUTDS"') "EXTRKDS
   IF RC \= 0 THEN DO
    FAILED_DD='CBDOUT (EXTRACT OLD)'
    SIGNAL RETURN_8
    END
   SIGNAL NO_EXTRACT
   END           /* END EXTRKDS \= NEW    */
  RP=POS('@',EXTRKOUT)
  IF RP \= 0 THEN DO
   CBDOUTDS=SUBSTR(EXTRKOUT,1,RP-1)||MYSELID||SUBSTR(EXTRKOUT,RP+1)
   EXTRKDS = 'NEW'
   END
   ELSE DO
   CBDOUTDS=EXTRKOUT
   IF JOB#PTR > 1 THEN EXTRKDS = 'MOD'
     ELSE EXTRKDS = 'NEW'
   END
  "ALLOC FI(CBDOUT) DA('"CBDOUTDS"') "EXTRKDS||,
                   " USING(CDBATT) CYL SPACE(1,1)"
  IF RC \= 0 THEN DO
   FAILED_DD='CBDOUT (EXTRACT)'
   SIGNAL RETURN_8
   END
  IF EXTRKCMD \= 'XTRK2VBS' THEN SIGNAL NO_EXTRACT
  IF EXTRKVS \= 'NEW' THEN DO
   VBDOUTDS=VXTRKOUT
   IF VXTDSO = 'PS' THEN DO
    IF JOB#PTR > 1 THEN EXTRKVS = 'MOD'
     ELSE EXTRKDS = 'SHR REUSE'
    END
    ELSE DO
    EXTRKVS = 'SHR'
    VBDOUTDS = VBDOUTDS||'('||MYSELID||')'
    END
   "ALLOC FI(VBDOUT) DA('"VBDOUTDS"') "EXTRKDS
   IF RC \= 0 THEN DO
    FAILED_DD='VBDOUT (EXTRACT OLD)'
    SIGNAL RETURN_8
    END
   SIGNAL NO_EXTRACT
   END           /* END EXTRKDS \= NEW    */
  RP=POS('@',VXTRKOUT)
  IF RP \= 0 THEN DO
   VBDOUTDS=SUBSTR(VXTRKOUT,1,RP-1)||MYSELID||SUBSTR(VXTRKOUT,RP+1)
   EXTRKVS = 'NEW'
   END
   ELSE DO
   VBDOUTDS=VXTRKOUT
   IF JOB#PTR > 1 THEN EXTRKDS = 'MOD'
     ELSE EXTRKVS = 'NEW'
   END
  "ALLOC FI(VBDOUT) DA('"VBDOUTDS"') "EXTRKVS||,
                   " USING(VDBATT) CYL SPACE(1,1)"
  IF RC \= 0 THEN DO
   FAILED_DD='CBDOUT (EXTRACT)'
   SIGNAL RETURN_8
   END
/*  ALLOC OPDS OR ODSN */
NO_EXTRACT:
/* TRACE I */
/* ODSNDS IS SET UP WITH EITHER OPDS OR ODSN     */
  IF OPDS \= '' THEN SIGNAL ALOC_OPDS
  IF ODSN = '' THEN DO
   ODSN   = '@'
   ODSNDS = '@'
   ODSNDISP='NEW'
   END
/* ------------                                  */
  IF ODSNDS = '@' THEN DO
/* ODSNDX=SUBSTR(EDSN,1,FP-1)||MYSELID||'.RDOSYSPR'||SUBSTR(EDSN,FP+1)*/
   ODSNDX=EDSNPFX||MYSELID||'.RDOSYSPR'||EDSNSFX
   SIGNAL TST_ODSN_OLD
   END
/* ------------------                            */
  FP = POS('@',ODSNDS)
  IF FP > 5 THEN DO
   ODSNDX=SUBSTR(ODSNDS,1,FP-1)||MYSELID||SUBSTR(ODSNDS,FP+1)
   END
   ELSE DO
   IF FP \= 0 THEN DO
    FAILED_DD='SYSPRINT (ODSN SYMB ERR)'
    SIGNAL RETURN_8
    END
   ODSNDX=ODSNDS
   END
 TST_ODSN_OLD:
  XC=LISTDSI("'"ODSNDX"'" DIRECTORY NORECALL)
  IF XC > 16 THEN DO
    FAILED_DD='SYSPRINT (ODSN LDSI ERR)'
    SIGNAL RETURN_8
    END
   IF XC \= 0 THEN DO
 "ALLOC FI(SYSPRINT) DA('"ODSNDX"') NEW USING(SYSPRATT) CYL SPACE(1,1)"
    IF RC \= 0 THEN DO
     FAILED_DD='SYSPRINT (ODSN NEW)'
     SIGNAL RETURN_8
     END
     ELSE DO
     SIGNAL DONE_ALOC_ODSN
     END
    END
/* ODSN EXISTS XC = 0 */
  MYDSO=SYSDSORG
  IF MYDSO = 'PO' THEN DO
    FAILED_DD='SYSPRINT (ODSN NOT SEQ)'
    SIGNAL RETURN_8
    END
/* AT THIS POINT, ODSN EXISTS AND IS SEQ - SO ALOC MOD  */
   "ALLOC FI(SYSPRINT) DA('"ODSNDX"') MOD"
   IF RC \= 0 THEN DO
    FAILED_DD='SYSPRINT (SEQ SHR REUSE)'
    SIGNAL RETURN_8
    END
  SIGNAL  DONE_ALOC_ODSN
/* ------------------   PROCESS OPDS             */
 ALOC_OPDS:
  IF OMBR = '' THEN DO
    FAILED_DD='SYSPRINT (PDS NO MBR)'
    SIGNAL RETURN_8
    END
  IF OPDS = '@' & OMBR = '@' THEN DO
    FAILED_DD='SYSPRINT (PDS & MBR SYMB)'
    SIGNAL RETURN_8
    END
  IF OPDS = '@' THEN DO
/* ODSNDX=SUBSTR(EDSN,1,FP-1)||MYSELID||'.RDOSYSPR'||SUBSTR(EDSN,FP+1)*/
   ODSNDX=EDSNPFX||MYSELID||'.RDOSYSPR'||EDSNSFX
   SIGNAL TST_OPDS_OLD
   END
/* ------------------                            */
  FP = POS('@',OPDS)
  IF FP > 5 THEN DO
   ODSNDX=SUBSTR(OPDS,1,FP-1)||MYSELID||SUBSTR(OPDS,FP+1)
   END
   ELSE DO
   IF FP \= 0 THEN DO
    FAILED_DD='SYSPRINT (ODSN SYMB ERR)'
    SIGNAL RETURN_8
    END
   ODSNDX=OPDS
   END
 TST_OPDS_OLD:
     CALL CHKPDSDISP
   /* ODSNDX WILL BE TESTED LISTDSI        */
   /* ODSNDISP IS SET TO EITHER NEW OR SHR */
   /* ODSNDS WILL HAVE THE ODSNDX VALUE    */
     IF XC > 16 THEN SIGNAL BADOPDS
     IF XC > 0 THEN ODSNDISP = 'NEW'
               ELSE ODSNDISP = 'SHR'
     IF OMBR = '' THEN OMBR = '@'
 /*  IF OMBR = '@' THEN SIGNAL DONEODSN
      ELSE SIGNAL BADOPDS */
   /* CHECKING FOR SEQUENTIAL DSN TO HANDLE OUTPUT                */
  IF ODSNDISP = 'NEW' THEN DO
     "ALLOC FI(SYSPRINT) DA('"ODSNDX"') NEW USING(OPDSATT) "||,
        "DSNTYPE(LIBRARY) CYL SPACE("JOB#",10)"
     IF RC \= 0 THEN DO
      FAILED_DD='SYSPRINT (NEW PDS)'
      SIGNAL RETURN_8
      END
     "FREE FI(SYSPRINT)"
    END
 /*TRACE I */
   ODSNDISP = 'SHR'
   IF OMBR = '@' THEN ODSNDX=ODSNDX||'('||MYSELID||')'
     ELSE DO
     ODSNDX=ODSNDX||'('||OMBR||')'
     IF OPDS@ = '' THEN DO
      IF JOB#PTR > 1 THEN DO
       IF JOB#PTR = 2 THEN DO
        ACUMMSG=ACUMMSG||'STATIC MBR NAME:'||OMBR||,
        ': CAN NOT BE APPENDED TO. SUBSEQUENT REPORTS FAIL'||FFX||,
        'SUGGEST YOU USE A SINGLE SEQ DSN TO COLLECT ALL REPORTS.'||FFX
        END
       FAILED_DD='SYSPRINT (MOD PDS)'
       SIGNAL RETURN_8
       END
      END
     END
   TRACE OFF
   "ALLOC FI(SYSPRINT) DA('"ODSNDX"') "ODSNDISP
   IF RC \= 0 THEN DO
     FAILED_DD='SYSPRINT (OLD PDS)'
     SIGNAL RETURN_8
     END
/* ------------------   OMBR IS EMPTY - ALOC SEQ */
/* ------------------                            */
  SIGNAL DONE_ALOC_ODSN
DONE_ALOC_ODSN:
  IF MYSTYP = 'A' THEN MYSTYPLL = 'T'
   ELSE MYSTYPLL = MYSTYP
  RDODS='TTE'||MYSTYP||'.TSK.B.R'||MYREL||'.'||MYSELID||'.RDOFILE'
 /* SAY RDODS */
 "ALLOC FI(DFHCSD) DA('"RDODS"') SHR"
   IF RC \= 0 THEN DO
    FAILED_DD='DFHCSD'
    SIGNAL RETURN_8
    END
 KIXLL='TTE'||MYSTYPLL||'.TSK.F.R'||MYREL||'.SYS.LOADLIB'
 /* "CALL '"KIXLL||"(DFHCSDUP)'" */
 ADDRESS LINK "DFHCSDUP"
 XC=RC
RETURN_8:
 'FREE FI(SYSIN SYSPRINT DFHCSD)'
 IF EXTRKDS \= '' THEN DO
  'FREE FILE(CBDOUT)'
  END
 IF EXTRKVS \= '' THEN DO
  'FREE FILE(VBDOUT)'
  END
 RETURN XC
/*************************\
|* DERIVE THE EXTRACT DSN |
\*************************/
CHKPDSDISP:
  IF POS('@',ODSNDX) \= 0 THEN SIGNAL CHKPDSDISP8
  ELSE DO
/* OPDS IS SPECIFIED, SO SEE IF IT EXISTS */
/* OPDS/ODSN HAS NO @ PLACEHOLDER, SO THE PDS COULD BE NEW OR OLD */
   XC=LISTDSI("'"ODSNDX"'" DIRECTORY NORECALL)
   IF XC ^= 0 THEN DO
   IF XC > 16 THEN SIGNAL CHKPDSDISP0
    ODSNDS=ODSNDX
    ODSNDISP='NEW'
    END
    ELSE DO
    IF SYSDSORG \= 'PO' |,
       SYSRECFM \= 'VBA' |,
       SYSLRECL \= '125' THEN CHKPDSDISP8
    ODSNDS=ODSNDX
    ODSNDISP='SHR'
    XC = 0
    END
   END
  SIGNAL CHKPDSDISP0
CHKPDSDISP8:
  XC = 8
CHKPDSDISP0:
  RETURN XC
/*************************\
|* DERIVE THE EXTRACT DSN |
\*************************/
CHKEXTRKDS:
 IF EXTRKDS = 'NEW' THEN DO
/*EXTRKOUT=SUBSTR(EDSN,1,RP-1)||'@.EXTRACT'||SUBSTR(EDSN,RP+1) */
  EXTRKOUT=EDSNPFX||'@.XTRKCBD'||EDSNSFX
  EXTDSO='PS'
  EXTRECFM='FB'
  EXTLRECL='80'
  RETURN 0
  END
 RP=POS('@',EXTRKDS)
 IF RP \= 0 THEN DO
  EXTRKOUT=EXTRKDS
  EXTRKDS = 'NEW'
  EXTDSO='PS'
  EXTRECFM='FB'
  EXTLRECL='80'
  RETURN 0
  END
 XC=LISTDSI("'"EXTRKDS"'" DIRECTORY NORECALL)
 IF XC \= 0 THEN DO
  EXTRKOUT=EXTRKDS
  EXTRKDS = 'NEW'
  EXTDSO='PS'
  EXTRECFM='FB'
  EXTLRECL='80'
  RETURN 0
  END
 EXTRKOUT=EXTRKDS
 EXTRKDS = 'SHR'
 EXTDSO=SYSDSORG
 IF EXTDSO = 'PS' THEN EXTRKDS='SHR REUSE'
  ELSE DO
  IF EXTDSO \= 'PO' THEN SIGNAL BADEXTRKDSO
  EXTRECFM=SYSRECFM
  IF EXTRECFM \= 'FB' THEN SIGNAL BADEXTRKBLK
  EXTLRECL=SYSLRECL
  IF EXTLRECL \= '80' THEN SIGNAL BADEXTRKLRECL
  END
  RETURN 0
/*************************\
|* DERIVE THE EXTRACT VDS |
\*************************/
CHKEXTRKVS:
 VXTDSO='PS'
 VXTRECFM='VB'
 VXTLRECL=MAXVBSLRECL
 VXTRKDS = 'NEW'
 IF EXTRKVS = 'NEW' THEN DO
/*EXTRKOUT=SUBSTR(EDSN,1,RP-1)||'@.EXTRACT'||SUBSTR(EDSN,RP+1) */
  VXTRKOUT=EDSNPFX||'@.XTRKVBD'||EDSNSFX
  RETURN 0
  END
 RP=POS('@',EXTRKVS)
 IF RP \= 0 THEN DO
  VXTRKOUT=EXTRKVS
  RETURN 0
  END
 XC=LISTDSI("'"EXTRKVS"'" DIRECTORY NORECALL)
 IF XC \= 0 THEN DO
  VXTRKOUT=EXTRKVS
  VXTRKDS = 'NEW'
  RETURN 0
  END
 VXTRKOUT=EXTRKVS
 VXTRKDS = 'SHR'
 VXTDSO=SYSDSORG
 IF VXTDSO = 'PS' THEN EXTRKVS='SHR REUSE'
  ELSE DO
  IF VXTDSO \= 'PO' THEN SIGNAL BADEXTRKDSO
  VXTRECFM=SYSRECFM
  IF VXTRECFM \= 'FB' THEN SIGNAL BADEXTRKBLK
  VXTLRECL=SYSLRECL
  IF VXTLRECL \= MAXVBSLRECL THEN SIGNAL BADEXTRKLRECL
  END
  RETURN 0
###END AFORDOR
$$$BEG GDSNNMBR
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA          -                                              */
 /* CEMHELP          - TSO BASE, RESTRICTED                         */
 /* CEMHELP          - GET DSN AND MEMBER                           */
 /* CEMHELP END                                                     */
/* TRACE I */
 MYPNLIB='TTED.TSK.D.TCEM.ISPPLIB'
 CALL EXPLLDEF 'ISPPLIB' MYPNLIB 'STACK' 'QUIET'
 XC = RESULT
 "ISPEXEC ADDPOP ROW(1) COLUMN(10)"
 "ISPEXEC VGET (EDSN EMBR DSEMSG EXECSEL) ASIS"
 IF RC ^= 0 THEN SIGNAL CANCEL8
 "ISPEXEC VGET (MYAT) ASIS"
 IF RC ^= 0 THEN MYAT='INPUT'
 IF MYAT='INPUT' THEN MYINT='HIGH'
SRCLOOP:
 CMD = ''
 "ISPEXEC DISPLAY PANEL(COPYSELM)"
 IF RC = 8 THEN SIGNAL CANCEL8
 SELECT
  WHEN ABBREV('ABORT',CMD,1) ^= 0 THEN SIGNAL CANCEL8
  WHEN ABBREV('BYPASS',CMD,1) ^= 0 THEN SIGNAL CANCEL8
  WHEN ABBREV('CANCEL',CMD,1) ^= 0 THEN SIGNAL CANCEL8
  OTHERWISE NOP
  END
 "ISPEXEC VPUT (EDSN EMBR) ASIS"
 IF RC ^= 0 THEN SIGNAL CANCEL8
 "ISPEXEC REMPOP"
 RETURN 0
CANCEL8:
 "ISPEXEC REMPOP"
 RETURN 8
###END GDSNNMBR
$$$BEG EXPLLDEF
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA          -                                              */
 /* CEMHELP          - TSO BASE, RESTRICTED                         */
 /* CEMHELP          -                                              */
 /* CEMHELP END                                                     */
 /* TRACE ?I */
  ADDRESS ISPEXEC
  QMODE=''
  ARG MDDN MDSN STK QMODE
  /*   AS IN EXPLLDEF ISPLLIB TTED.TSK.E.TCEM.PDSE UNCOND */
  MDDN = TRANSLATE(MDDN,' ',"'")
  MDSN = TRANSLATE(MDSN,' ',"'")
  STK  = TRANSLATE(STK,' ',"'")
  QMODE = TRANSLATE(QMODE,' ',"'")
  IF MDDN = '' THEN SIGNAL SHOWFMT
  IF MDDN = 'QUERY' THEN SIGNAL DISPALL
 VALDT:
  VALDDN = 'QUERY ISPPLIB ISPMLIB ISPSLIB ISPTLIB ISPLLIB '
  WP=WORDPOS(MDDN,VALDDN)
  IF WP = 0 THEN SIGNAL SHOWFMT
  IF WP = 1 THEN SIGNAL DISPALL
  IF MDSN = '' | MDSN = '?' THEN SIGNAL DISPIT
  QLDEFDS=''
  QLDEFID=''
  "ISPEXEC QLIBDEF "MDDN" TYPE(QLDEFDS) ID(QLDEFID)"
  XC = RC
  IF XC = 4 THEN SIGNAL DO_LDEF
  IF XC \= 0 THEN DO
    IF QMODE \= 'QUIET' THEN SAY "QUERY LIBDEF FOR "MDDN" HAS RC:"XC
    RETURN XC
    END
  QLDEFID = TRANSLATE(QLDEFID,"  ","',")
  IF WORDPOS(MDSN,QLDEFID) > 0 THEN DO
    IF QMODE \= 'QUIET' THEN SAY "QUERY LIBDEF EXISTS:"MDDN":"MDSN
    RETURN 0
    END
 DO_LDEF:
  STKWDS = 'COND UNCOND STACK STKADD STACKADD'
  IF STK = 'STACKADD' THEN STK = 'STKADD'
  IF WORDPOS(STK,STKWDS) = 0 THEN STK = 'UNCOND'
  NDSN = TRANSLATE(MDSN,' ',',')
  J = WORDS(NDSN)
  IF J < 1 | J > 15 THEN SIGNAL SHOWFMT
  PDSN=""
  DO I = 1 TO J
   ODSN=WORD(NDSN,I)
   XC=LISTDSI("'"ODSN"'" DIRECTORY NORECALL)
   IF XC ^= 0 THEN DO
    SAY '"'ODSN'" NOT FOUND IN CATALOGUE'
    SIGNAL SHOWFMT
    END
   PDSN=PDSN||"'"||ODSN||"',"
   END
  MDSN=SUBSTR(PDSN,1,(LENGTH(PDSN) - 1))
  "ISPEXEC LIBDEF "MDDN" DATASET ID("MDSN") "STK
  XC = RC
   IF RC \= 0 THEN SIGNAL EXITRC4
   IF QMODE = 'QUIET' THEN EXIT 0
 DISPIT:
   QLDEFDS=''
   QLDEFID=''
   "ISPEXEC QLIBDEF "MDDN" TYPE(QLDEFDS) ID(QLDEFID)"
   XC = RC
   IF XC = 4 THEN DO
    IF QMODE \= 'QUIET' THEN SAY "QUERY LIBDEF FOR "MDDN" SHOWS NONE"
    RETURN XC
    END
   IF XC = 0 THEN DO
     SAY QLDEFID
     SAY QLDEFDS
     END
   SIGNAL DOWAIT
  DOWAIT:
   SAY "DATASET>"QLDEFDS"<"
   SAY "     ID>"QLDEFID"<"
   SAY "OK? OR (D) TO DISPLAY ALL LIBDEFS"
   PULL ANS
   IF ANS = 'D' THEN SIGNAL DISPALL
   EXIT 0
 DISPALL:
 "ISPEXEC SELECT PGM(ISPLLS) SCRNAME(LIBDEF)"
 EXIT 0
 SHOWFMT:
  IF MDDN = '?' THEN SIGNAL DISPALL
  SAY 'EXPLLDEF DDN DSN OPTVAR'
  SAY '         WHERE DDN IS A VALID DDN 'VALDDN
  SAY '         AND   DSN IS A SET OF VALID DSN'
  SAY '               TO BE CONCATENATED TO DDN'
  SAY '               (NO QUOTES, COMMA SEPARATED LIST)'
  SAY '         AND   OPTVAR IS COND|UNCOND|STACK|STKADD'
 EXITRC4:
  EXIT 4
###END EXPLLDEF
$$$BEG EXCITSLB
PROC 1 KIXREL KIXCTYP(D) KIXENV(SYS)
CONTROL NOCONLIST NOSYMLIST
SET &KIXLNG = &LENGTH(&KIXREL)
IF &SUBSTR(1:1,&KIXREL) EQ R THEN +
   SET &KIXREL = &SUBSTR(2:&KIXLNG,&KIXREL)
SET &KIXLNG = &LENGTH(&KIXREL)
IF &LENGTH(&KIXREL) LT 3 THEN GOTO BADPARM
IF &LENGTH(&KIXREL) GT 3 THEN GOTO BADPARM
IF (&KIXCTYP NE D) AND +
   (&KIXCTYP NE T) AND +
   (&KIXCTYP NE P) THEN GOTO BADPARM
IF (&KIXENV NE SYS) AND +
   (&KIXENV NE PUT) THEN GOTO BADPARM
RETRYIT: -
SET &EDSN1='TTE&KIXCTYP..TSK.G.R&KIXREL..&KIXENV..EXCILIB'
SET &EDSN2='TTE&KIXCTYP..TSK.F.R&KIXREL..&KIXENV..LOADLIB'
SET &EDSN3='TTE&KIXCTYP..TSK.F.R&KIXREL..LOADLIB'
LISTDSI &EDSN1 NORECALL
DO WHILE &LASTCC > 3
 IF &KIXCTYP = D THEN GOTO BADPARM
 SET &KIXCTYP = D
 GOTO RETRYIT
 END
LISTDSI &EDSN2 NORECALL
DO WHILE &LASTCC > 3
 IF &KIXCTYP = D THEN GOTO BADPARM
 SET &KIXCTYP = D
 GOTO RETRYIT
 END
PROFILE VARSTORAGE(HIGH)
TSOLIB ACTIVATE DATASET(&EDSN1 &EDSN2 &EDSN3)
TSOLIB DISPLAY
EXIT
BADPARM: -
WRITE INVALID PARM:
WRITE CICS 3 DIGIT RELEASE: &KIXREL
WRITE KIXCTYP : &KIXCTYP
WRITE KIXENV  : &KIXENV
WRITE OR THE LIBRARY &EDSN1 DOES NOT EXIST
WRITE OR THE LIBRARY &EDSN2 DOES NOT EXIST
WRITE OR THE LIBRARY &EDSN3 DOES NOT EXIST
SHOWMSG: -
WRITE PROVIDE A 3 DIGIT CICS RELEASE NUMBER (540, 550, ...)
WRITE AND SPECIFY AN OVERRIDE VARIABLE
WRITE     KIXCTYP(D)
WRITE OR  KIXCTYP(T)
WRITE OR  KIXCTYP(P)
WRITE     KIXENV(SYS)
WRITE OR  KIXENV(PUT)
EXIT
###END EXCITSLB
$$$BEG EXPLQLIB
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA          -                                              */
 /* CEMHELP          - TSO BASE, RESTRICTED                         */
 /* CEMHELP          -                                              */
 /* CEMHELP END                                                     */
 ADDRESS ISPEXEC
 TRACE I
  "ISPEXEC SELECT PGM(ISPLLS) SCRNAME(LIBDEF)"
 ARG ISPLB IDOPT
 IF ISPLB = '' THEN ISPLB='ISPPLIB'
  IDVAL=''
  'ISPEXEC QBASELIB 'ISPLB' ID(IDVAL)'
  IDVAL=IDVAL
  IDVAL=''
  IDTYP=''
  'ISPEXEC QLIBDEF 'ISPLB' ID(IDVAL) TYPE(IDTYP)'
  IDVAL=IDVAL
  IDTYP=IDTYP
###END EXPLQLIB
$$$BEG DSPLYA
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA DSPLYA   - SUBROUTINE TO DISPLAY DATA IN VAR MYAREA     */
 /* CEMHELP          - ISPF BASED - SUBROUTINE                      */
 /* CEMHELP          - DISPLAYS MYAREA BASED ON GIVEN VARIABLES     */
 /* CEMHELP          - VARS ARE PASSED VIA ISPF DIALOGUE VARIABLES  */
 /* CEMHELP          - IN ASIS POOL: (ALL VARS ARE REQUIRED):       */
 /* CEMHELP          -  EXECSEL  - IDENTIFIES THE SOURCE PANEL/EXEC */
 /* CEMHELP          -             (ANY 1 - 8 VARIABLE DATA)        */
 /* CEMHELP          -  MYAREA   - CONTAINS A STING OF MANY STRINGS */
 /* CEMHELP          -             (MAX LENGTH 32K)                 */
 /* CEMHELP          -  MYAREA#  - CONTAINS THE SUBSTRING SEPARATOR */
 /* CEMHELP          -             VARIABLE (DEF IS X'FF')          */
 /* CEMHELP          - VALID COMMANDS:                              */
 /* CEMHELP          -  SAVE, MOD OR APPEND                         */
 /* CEMHELP          -  WHICH PROMPTS YOU FOR A SEQ OR PDS(E)       */
 /* CEMHELP          -  DATASET AS THE TARGET.                      */
 /* CEMHELP          -  IF THE DSN DOES NOT EXIST, IT WILL BE       */
 /* CEMHELP          -  CREATED.                                    */
 /* CEMHELP          -  THE DSN AND MBR IS SAVE IS ASIS VARS        */
 /* CEMHELP          -  FOR REPEAT USE.                             */
 /* CEMHELP          -  FOR PDS(E) MEMBERS: YOU CAN ENTER A SINGLE  */
 /* CEMHELP          -    '$', WHICH WILL USE THE VARIABLE VALUE    */
 /* CEMHELP          -    SENT IN THE EXECSEL VARIABLE.             */
 /* CEMHELP          -                                              */
 /* CEMHELP          - OS2PW  OR PMBRW    SEND DATAQ TO JRP PRINT   */
 /* CEMHELP          - OS2PNTN OR PMBRN                             */
 /* CEMHELP          -                                              */
 /* CEMHELP          -                                              */
 /* CEMHELP END                                                     */
  CUTV = 'DSPC'
  CUTCNT=0
  ADDRESS ISPEXEC
  "ISPEXEC VGET (EXECSEL) ASIS"
  IF RC ^= 0 THEN DO
   EXECSEL = 'DSPLYA'
   "ISPEXEC VPUT (EXECSEL) ASIS"
   END
  "ISPEXEC VGET (MYAREA#) ASIS"
  /* TRACE ?I */
  IF RC ^= 0 THEN SIGNAL NOPOOL
  IF MYAREA# ^= ' ' THEN,
       IF MYAREA# = '' THEN SIGNAL NOPOOL
  IF LENGTH(MYAREA#) > 1 THEN DO
   FP=POS('<',MYAREA#)
   IF FP ^= 2 THEN SIGNAL NOPOOL
   LP=POS('>',MYAREA#)
   IF LP = 0 THEN SIGNAL NOPOOL
   MYAREA0=SUBSTR(MYAREA#,FP+1,LENGTH(MYAREA#)-3)
   IF MYAREA0 < 1 | MYAREA0 > 255 THEN SIGNAL NOPOOL
   MAVAR=''
   DO I = 1 TO MYAREA0
    MAVAR=MAVAR||' MYARE'||I
    END
   MAVAR = STRIP(MAVAR,'B')
   "ISPEXEC VGET ("MAVAR") ASIS"
   IF RC ^= 0 THEN SIGNAL NOPOOL
   MYAREA#=SUBSTR(MYAREA#,1,1)
   MYAREA=''
   DO I = 1 TO MYAREA0
    INTERPRET 'MYAREA=MYAREA||MYARE'I
    END
   END
   ELSE DO
   "ISPEXEC VGET (MYAREA) ASIS"
   END
  IF MYAREA = '' THEN SIGNAL NOPOOL
  MYVERB = ''
  XC = 0
  MXLNG = 0
  SEP=MYAREA#
  I = 0
  DO WHILE(MYAREA ^= '')
   PARSE VAR MYAREA TMP (SEP) MYAREA
   TL = LENGTH(TMP)
   IF TL > MXLNG THEN MXLNG = TL
   I = I+1
   MYA.I = TMP
   END
  MYA.0 = I
  SVC = I
  TOPLN = 1
  BOTLN = 1
  MXLN = I
  NEWMX = 0
  MYSCLN=21
  MYSCLA=''
  MYSCLD='PAGE'
  MYSC = 'PAGE'
  MYAREA1 = ''
  MYAT = ''
  MYAW=0
  MYDP=0
  MYLVLN = 0
  "ISPEXEC PQUERY PANEL(MYDSPAD1) AREANAME(MYAREA1) "||,
   "AREATYPE(MYAT) WIDTH(MYAW) DEPTH(MYDP)"
  DN = MYDP-2
  MYSCLN=DN
  SH = MYAW
  SV = MYDP
  SUDT=DATE('U')
  CURLN=1
  CURCL=1
  /* TRACE ?I */
  "ISPEXEC VGET (AUTOSAVE) ASIS"
  IF RC \= 0 THEN AUTOSAVE = 'N'
  IF AUTOSAVE = 'Y' THEN  DO
   CALL SAVIT
   AUTOSAVE='N'
   "ISPEXEC VGET (AUTOSAVE) ASIS"
   END
  TRACE OFF
 DSPLOOP:
  TRACE OFF
  STIM=TIME()
  TOPLN=CURLN
  TOPCL=CURCL
  BOTLN = TOPLN + DN
  IF BOTLN > MXLN THEN BOTLN = MXLN
   MYAREA1 = ''
   I = TOPLN
   DO J = 1 TO MYDP
    IF I > MXLN THEN MYA.I = ' '
    MYAREA1 = MYAREA1||LEFT(SUBSTR(MYA.I,TOPCL),MYAW)
    I = I + 1
    END
 DSPLOOP1:
  IF MYVERB = '' & CMD = '' THEN DO
   ZEDSMSG = ""
   ZEDLMSG = ""
   "ISPEXEC SETMSG MSG(ISRZ001)"
   END
  CMD = ''
  ZCMD = ''
  MYVERB=''
  HLDSCLN=MYSCLN
  "ISPEXEC DISPLAY PANEL(MYDSPAD1)"
  XC=RC
/* TRACE I */
  AVERB = MYVERB
  ACMD = CMD
  PARSE VAR CMD CMD RESP
  GG='CMD='CMD'  MYVERB='MYVERB
  "ISPEXEC VPUT (GG) ASIS"
  IF MYSCLN=0 THEN MYSCLN=HLDSCLN
  MYSCLD = MYSCLA
  IF XC = 8 THEN SIGNAL EXITRC0
  SELECT
   WHEN MYSCLD = 'HALF' THEN DO
    SV = MYSCLN/2
    SH = MYAW/2
    END
   WHEN MYSCLD = 'PAGE' THEN DO
    SV = MYSCLN
    SH = MYAW
    END
   WHEN MYSCLD = 'MAX' THEN DO
    SV = MXLN
    SH = MXLNG
    END
   OTHERWISE DO
    IF DATATYPE(MYSRCD) ^= 'NUM' THEN MYSCLD = 'PAGE'
     ELSE DO
     SV = MYSCLD
     SH = MYSCLD
     END
    END
   END
   IF CMD='HELP' | CMD='?' THEN DO
    CALL CEMHELP 'DSPLYA'
    CMD = ''
    SIGNAL DONE_CMD1
    END
   IF CMD='SAVE' | CMD='MOD' | CMD='APPEND' THEN DO
    CALL SAVIT
    IF RESULT = 0 THEN DO
     ZEDSMSG = 'DATA SAVED'
     ZEDLMSG = 'DATASET SAVED AS DIRECTED'
     END
     ELSE DO
     ZEDSMSG = 'DATA NOT SAVED'
     ZEDLMSG = 'ERROR OCCURRED, OR ABORT SELECTED. NOTHING SAVED'
     END
    CMD = ''
    "ISPEXEC SETMSG MSG(ISRZ001)"
    SIGNAL REDSPLY
    END
   IF CMD = 'CUT' | CMD = 'CUTA' THEN DO
    IF RESP ^= '' THEN CUTV=RESP
     ELSE CUTV='DSPA'
    IF CMD='CUT' THEN DO
     CUTCNT=0
     END
    CALL CUTIT
    IF RESULT = 0 THEN DO
     ZEDSMSG = 'DATA 'CMD
     ZEDLMSG = 'DATA 'CMD' AS DIRECTED'
     END
     ELSE DO
     ZEDSMSG = 'DATA NOT 'CMD
     ZEDLMSG = 'ERROR OCCURRED, DATA WAS NOT 'CMD
     END
    CMD = ''
    "ISPEXEC SETMSG MSG(ISRZ001)"
    SIGNAL REDSPLY
    END
   IF CMD='OS2PW' | ABBREV('OS2PNTN',CMD,4) = 1 |,
      CMD='PMBRW' | ABBREV('PMBRN',CMD,4) = 1 THEN DO
    CALL OS2PNT
    XC=RESULT
    IF XC=0 THEN DO
     IF CMD = 'OS2PW' | CMD='PMBRW' THEN DO
      CALL JRPPNT 'JRPPNTW'
      XC=RESULT
      END
      ELSE DO
      IF CMD='PMBRC' THEN CALL JRPPNT 'JRPPNTC'
       ELSE CALL JRPPNT 'JRPPNT'
      XC=RESULT
      END
     END
     IF XC = 0 | XC > 20 THEN DO
      ZEDSMSG = 'DATA PRINTED 'XC
      ZEDLMSG = 'DATASET PRINTED AS DIRECTED TO JRP'XC
      END
      ELSE DO
      ZEDSMSG = 'DATA NOT PRINTED'
      ZEDLMSG = 'ERROR OCCURRED, OR ABORT SELECTED. NOTHING PRINTED.'
      END
/*   END    */
    CMD = ''
    "ISPEXEC SETMSG MSG(ISRZ001)"
    SIGNAL REDSPLY
    END
   IF CMD = 'PFAPNT'| CMD='PFAEDIT'  THEN DO
    'ISPEXEC VGET (EXECSEL FAIDODSN) ASIS'
    IF EXECSEL = 'PFA' & FAIDODSN ^= '' THEN DO
     IF FAIDODSN = '' | FAIDODSN = 'FAIDODSN' THEN RESULT=4
      ELSE DO
       IF CMD='PFAPNT' THEN JRPPNT 'JRPPNT' FAIDODSN
       IF CMD='PFAEDIT' THEN ,
        "ISPEXEC EDIT DATASET ('"FAIDODSN"')"
       END
      END
     IF RESULT = 0 THEN DO
      ZEDSMSG = 'FAID PRINTED'
      ZEDLMSG = 'DATASET PRINTED AS DIRECTED'
      END
      ELSE DO
      ZEDSMSG = 'DATASET NOT PRINTED'
      ZEDLMSG = 'FAID DATASET COULD NOT BE PRINTED.'
      END
    CMD = ''
    "ISPEXEC SETMSG MSG(ISRZ001)"
    SIGNAL REDSPLY
    END
DONE_CMD1:
   IF CMD ^= '' & MYVERB = '' THEN MYVERB=CMD
  IF MYVERB = 'TOP' THEN DO
   MYVERB = 'UP'
   MYSCLD = 'MAX'
   END
  IF MYVERB = 'BOT' THEN DO
   MYVERB = 'DOWN'
   MYSCLD = 'MAX'
   END
  SELECT
   WHEN MYVERB = '' THEN SIGNAL DSPLOOP1
   WHEN MYVERB = 'END' THEN SIGNAL EXITRC0
   WHEN MYVERB = 'ABORT' THEN SIGNAL EXITRC4
   WHEN MYVERB = 'BYPASS' THEN SIGNAL EXITRC4
   WHEN MYVERB = 'CANCEL' THEN SIGNAL EXITRC4
   WHEN MYVERB = 'LEFT' THEN DO
    IF MYSCLD \= 'MAX' THEN DO
     CURCL = CURCL-SH
     IF CURCL < 1 THEN CURCL=1
     SIGNAL DSPLOOP
     END
     ELSE DO
     CURCL = 1
     SIGNAL DSPLOOP
     END
    END
   WHEN MYVERB = 'RIGHT' THEN DO
    IF MYSCLD \= 'MAX' THEN DO
     CURCL = CURCL+SH
     IF CURCL > MXLNG THEN DO
      CURCL=(MXLNG-SH)+1
      IF CURCL < 1 THEN CURCL = 1
      END
     SIGNAL DSPLOOP
     END
     ELSE DO
     CURCL = MXLNG-MYAW+1
     IF CURCL < 1 THEN CURCL = 1
     SIGNAL DSPLOOP
     END
    END
   WHEN MYVERB = 'UP' THEN DO
    IF MYSCLD \= 'MAX' THEN DO
     CURLN = TOPLN-MYSCLN
     IF CURLN < 1 THEN CURLN=1
     SIGNAL DSPLOOP
     END
     ELSE DO
     CURLN = 1
     SIGNAL DSPLOOP
     END
    END
   WHEN WORD(MYVERB,1)='L' THEN DO
    IF WORDS(MYVERB) ^= 2 THEN LEAVE
    TMPLN=WORD(MYVERB,2)
    IF DATATYPE(TMPLN) ^= 'NUM' THEN LEAVE
    IF TMPLN < 1 THEN TMPLN = 1
     ELSE IF TMPLN > MXLN THEN TMPLN = MXLN
    CURLN = TMPLN
    SIGNAL DSPLOOP
    END
   WHEN MYVERB = 'DOWN' THEN DO
    IF MYSCLD \= 'MAX' THEN DO
     CURLN = TOPLN + MYSCLN
     IF CURLN > MXLN THEN CURLN = MXLN - MYSCLN + 1
     IF CURLN < 1 THEN CURLN = 1
     SIGNAL DSPLOOP
     END
     ELSE DO
     CURLN = MXLN-MYSCLN+1
     IF CURLN < 1 THEN CURLN=1
     SIGNAL DSPLOOP
     END
    END
   OTHERWISE DO
    ZEDSMSG = MYVERB" INVALID"
    ZEDLMSG = "INVALID COMMAND ENTERED. NORMAL NAVIGATE CMD"
    "ISPEXEC SETMSG MSG(ISRZ001)"
    END
   END
 REDSPLY:
  CURCL=TOPCL
  CURLN=TOPLN
  SIGNAL DSPLOOP
 EXITRC0:
  XC = 0
  ZEDSMSG = "DATA DISP OK"
  ZEDLMSG = "DATA DISPLAYED FINISHED NORMALLY"
  SIGNAL WRITIT
 EXITRC4:
  XC = 4
  ZEDSMSG = "DATA DISP ABORT"
  ZEDLMSG = "DATA DISPLAY ABORTED BY COMMAND"
  SIGNAL WRITIT
 NOPOOL:
  XC = 8
  ZEDSMSG = "NO POOLED DATA"
  ZEDLMSG = "NO DATA PREVIOUSLY POOLED FOR RECALL"
  SIGNAL WRITIT
  WRITIT:
  "ISPEXEC SETMSG MSG(ISRZ001)"
  RETURN XC
 SAVIT: PROCEDURE EXPOSE MYA. MXLNG EXECSEL CMD AUTOSAVE
/*   TRACE ?I */
  "ISPEXEC VGET (DSPLYADS EMBR) ASIS"
  IF RC \= 0 THEN DO
   EDSN=SYSVAR(SYSUID)'.'EXECSEL'.DATA'
   EMBR=''
   END
   ELSE EDSN=DSPLYADS
  IF AUTOSAVE = 'Y' THEN DO
   EDSN=DSPLYADS
   EMBR='$'
   TDSN=EDSN
   SIGNAL DO_AS
   END
  DSEMSG='ENTER TARGET DSN (NO MBR)'
  MYAT='INPUT'
  "ISPEXEC VPUT (EDSN EMBR DSEMSG MYAT) ASIS"
  CALL GDSNNMBR
  IF RESULT = 8 THEN RETURN 8
  "ISPEXEC VGET (EDSN EMBR) ASIS"
  IF RC ^= 0 THEN RETURN
  EMBR=STRIP(EMBR,'B')
  XMBR = ''
  /* DSN COULD HAVE BEEN SPECIFIED AS DSN(MBR)
     OR THE DSN AND MBR INPUT IN PANEL FIELDS,
     OR (CONFUSED) BOTH (IN WHICH CASE WE TAKE THE DSN(MBR)
     FORMATED BECAUSE WE FIGURE IT WAS INTENTIONAL).
  */
  PARSE VAR EDSN EDSN '(' XMBR ')'
  TDSN=EDSN
  IF XMBR \= '' THEN EMBR = XMBR
DO_AS:
  IF EMBR = '$' THEN EMBR = EXECSEL
  /* SIMPLE CHECK TO INSURE DSN NOT MIGRATED */
  CALL MALOC TDSN
  XC=RESULT
  IF XC = 0 THEN SIGNAL CHKORG
  IF EMBR = '' THEN MYDSO='PS)'
   ELSE MYDSO='PO) DSNTYPE(LIBRARY)'
  MODDSN = ''
  IF MXLNG < 128 THEN MXLNG = 128
  M=MXLNG+4
  DSEMSG = '(D) DEL/REALLOC,(A) ABORT'
  MODATTR="NEW BLKSIZE("M+4") DSORG("MYDSO" RECFM(V,B) SPACE(1,1)"||,
   "CYLINDER LRECL("M") CATALOG REUSE"
  EDSN = TDSN
  ADDRESS ISPEXEC "VPUT (EDSN EXECSEL DSEMSG MODATTR MODDSN) ASIS"
  IF RC ^= 0 THEN SIGNAL EXITRC8
  CALL ALOCDSN
  XC = RESULT
  "ISPEXEC VGET (EDSN) ASIS"
  IF RC ^= 0 THEN RETURN 4
  SIGNAL DOWRITE
 CHKORG:
  XC=LISTDSI("'"TDSN"'" DIRECTORY NORECALL)
  MYDSO=SYSDSORG
  IF EMBR \= '' THEN DO
   IF MYDSO = 'PS' THEN SIGNAL BADOPDSNORG
   END
   ELSE DO
   IF MYDSO = PO THEN SIGNAL BADOPDSNORG
   IF AUTOSAVE = 'Y' THEN DSPVAL='MOD'
   END
 DOWRITE:
  /* TRACE ?I */
  DSPLYADS=EDSN
  "ISPEXEC VPUT (DSPLYADS EMBR) ASIS"
  IF EMBR \= '' THEN EDSN=TDSN||'('||EMBR||')'
  IF XC = 0 THEN DO
   M# = MYA.0
   MSTM='MYA.'
   IF CMD = 'MOD' | CMD = 'APPEND' THEN DSPVAL='MOD'
    ELSE DSPVAL='SHR REUSE'
   IF EMBR \= '' THEN DO
    IF DSPVAL = 'MOD' THEN DO
     DSPVAL='SHR REUSE'
     ADDRESS TSO "ALLOC FI(I) DA('"EDSN"') "DSPVAL
     ADDRESS TSO "EXECIO * DISKR I (STEM MYB. FINIS"
     ADDRESS TSO "FREE FI(I)"
     MSTM='MYB.'
     MB#=MYB.0
     DO I = 1 TO M#
      MB#=MB# + 1
      MYB.MB#=MYA.I
      END
     M#=MB#
     END
    END
   ADDRESS TSO "ALLOC FI(O) DA('"EDSN"') "DSPVAL
   ADDRESS TSO "EXECIO "M#" DISKW O (STEM "MSTM" FINIS"
   ADDRESS TSO "FREE FI(O)"
   AUTOSAVE = 'N'
   CALL MSGBOX 'DATA SAVED TO 'EDSN
   RETURN 0
  END
  RETURN XC
BADOPDSNORG:
   CALL MSGBOX 'SAVE TO DSN DSORG INCONSISTENT WITH EXISTING DSN'
   RETURN 4
OS2PNT: PROCEDURE EXPOSE SVC MYA. XC
 IF SVC ^> 0 THEN RETURN 4
 DO I = 1 TO SVC
  INTERPRET 'OS2C'||I'= MYA.I'
  'ISPEXEC VPUT (OS2C'I') ASIS'
  END
 MYCN = 'OS2C'
 OS2CTOT = SVC
  ZEDSMSG = "DATA PRINTED"
  ZEDLMSG = "DATA SENT TO PRINTER"
 "ISPEXEC SETMSG MSG(ISRZ001)"
 "ISPEXEC VPUT (MYCN OS2CTOT) ASIS"
 RETURN 0
CUTIT: PROCEDURE EXPOSE SVC MYA. CUTV CUTCNT XC
 IF SVC ^> 0 THEN RETURN 4
 CVSTR=''
 DO I = 1 TO SVC
  CUTCNT=CUTCNT+1
  INTERPRET CUTV||CUTCNT'= MYA.I'
  'ISPEXEC VPUT ('CUTV||CUTCNT') ASIS'
  END
  INTERPRET CUTV'TOT = CUTCNT'
 'ISPEXEC VPUT ('CUTV'TOT) ASIS'
 RETURN 0
###END DSPLYA
$$$BEG DSPAFOH
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA DSPAFOH  - SUBROUTINE TO AFOLIST. SEE AFOLIST           */
 /* CEMHELP DSPAFOH  - SUBROUTINE TO AFOLIST. SEE AFOLIST           */
 /* CEMHELP          - CALLED BY DSPAFOD                            */
 /* CEMHELP          - replaces  DSPAFOC                            */
 /* CEMHELP          - calls:address link "RXCNCLN2 RX_CNC_CH_NM"   */
 /* CEMHELP          - V3.0 - CNC ENABLED VERSION                   */
 /* CEMHELP          - V3.1 - FIXED SUBSYM PROBLEM                  */
 /* CEMHELP          - V3.2 - ADD LOGIC FOR CN DATATYPE             */
 /* CEMHELP          - V3.3 - ADD LOGIC TO GROUP SELECT DISPLAY     */
 /* CEMHELP END                                                     */
 /* this is the new interface to the exci function                  */
 /*    based on successful testing of trxcncl2                      */
 /* 001703     NEED TO ACCUMULATE BIT DATA TO A DIFFERENT MYA VAR   */
 /*                                                                 */
 /*  backed up to dspafoh# prior to adding excis0 logic             */
 /*                                                                 */
 /* TRACE I */
 /* ALWAYS RETURN THIS VAR WITH A QUICK NOTE SUCCESS/FAILURE */
 /* TRACE ?I */
  ADDRESS ISPEXEC
  'ISPEXEC CONTROL ERRORS RETURN'
  DSPAFOH_V='3.3'
  /*                                                                 *\
  |*  EXPECT THE FOLLOWING ISPF VARS TO BE SET                       *|
  |*   MYCMD - CEMT,CEDA,PING,PLAY,LINK                              *|
  |*         - BUT THIS IS NOT NECESSIARLY A DRIVER FOR THE CNC LOGIC*|
  |*         -  BECAUSE AS WE PROMPT FOR CN NAMES, EACH MAY BE DIFF  *|
  |*   MYAPLID - ONE TO MANY REGIONS                                 *|
  |*                                                                 *|
  \*                                                                 */
  'ISPEXEC VGET (MYCMD MYAPLID) ASIS'
  LASTCC=RC
  IF LASTCC  \= 0 THEN DO
   RETURN 20
   END
  /*                                                                 *\
  |* test tsolib for excilib allocation                              *|
  \*                                                                 */
  CALL EXPLTSOL 'EXCILIB'
  XC=RESULT
  IF XC  \= 0 THEN DO
   RETURN 18
   END
 /*   REMOVE THIS AT SOME TIME AFTER TESTING  */
/*CALL DO_TBL_CLO */
 /*                                           */
  MSGOUT_NOTE='INITIAL'
  /* ALWAYS RETURN THESE VARS: AS A STEM VARIABLE */
  /*  WITH THE APPLID AS THE PREFIX, AND THE FOLLOWING AS THE SUFFIX */
  TECCMDS='CEMT CEDA PING PLAY'
  RXCNCLN2_RSP_LOG='INITIAL'
  RETURN_CN_LIST=''
  /* REQUIRED RX VARS ON EACH CALL TO THE EXCI INTERFACE PROGRAM */
  PROGRAM_NM='UCEMPINR'
  APPLID_NM='CGE5'
  TRANID_NM='UXXX'
  /* AND THEN WE PROVIDE A SINGLE RX VAR AS THE SINGLE PARM TO       *\
  |*   THE PROGRAM IN WHICH WE ISSUE THE RX CMD:                     *|
  |* ADDRESS LINK 'RXCNCLN2 RXVARPARM'                               *|
  |* THE RXVARPARM IS EITHER                                         *|
  |*   COMMAREA  - YEP THE ACTUAL 'COMMAREA' LITERAL                 *|
  |*   OR                                                            *|
  |*   SOME_CHAN_NAME - A RX VAR WHICH DEFINES A CHANNEL NAME        *|
  |*             - AND WHO'S CONTENTS IS A COMMA SEPARATED LIST      *|
  |*             - OF CONTAINERS (WHICH ARE RX VARS WITH THE ACTUAL  *|
  |*             - CN DATA)                                          *|
  |*   FOR EACH, YOU CAN OPTIONALLY CODE ADDITIONAL RX STEM VARS     *|
  |*    WHICH HAVE THE 'COMMAREA' OR SOME_CONT_NAME WITH A '.L'      *|
  |*    SUFFIX. THIS IS USED TO CONVEY A LENGTH FOR THE CA OR CN     *|
  |*   AND FOR CN VARS, THE SAME SOME_CONT_NAME WITH A '.T' CAN      *|
  |*    OPTIONALLY CONVEY THE CN DATATYPE                            *|
  |*                                                                 *|
  |*                                                                 *|
  |*                                                                 *|
  \*                                                                 */
  /*  THE MYCMD AND MYAPLID ISPF PARMS PROVIDE SOME NECESSARY  INFO  *\
  |*  USE PANEL TO INDICATE COMMAREA OR CHANNEL                      *|
  \*                                                                 */
   RETRYCT = 0
   ZCMD=''
   MYSC='PAGE'
   EXECSEL = 'DSPAFOH'
   HYPROG = PROGRAM_NM
   HYDSRC = 'COMMAREA'
   HYFUNC1 = 'A'
   VALFUNC1='E A'
   VALFUNC = 'EACH ALL'
   AUTOSAVE = 'N'
   HYTRANID = TRANID_NM
   DSEMSG = 'INDICATE YOUR DATA SOURCE'
   "ISPEXEC ADDPOP ROW(1) COLUMN(10)"
GET_CA_OR_CHANNEL:
   'ISPEXEC DISPLAY PANEL (DSPAFOSL)'
   LASTCC=RC
  IF LASTCC  \= 0 THEN DO
   RETURN 20
   END
/*    TRACE I */
   CMD_1 = WORD(CMD,1)
   IF CMD = 'END' THEN SIGNAL GOT_DATA_SRC
   IF LASTCC = 8 THEN SIGNAL GOT_DATA_SRC
   IF CMD = 'CANCEL' | CMD = 'ABORT' THEN DO
    'ISPEXEC REMPOP'
    RETURN 8
    END
   ZCMD=''
   DSEMSG = 'PRESS PF3 TO CONTINUE'
GOT_DATA_SRC:
  TMP = HYDSRC
  PROGRAM_NM = HYPROG
  IF LENGTH(PROGRAM_NM) > 7 THEN DO
   IF WORDPOS(MYCMD,TECCMDS) > 0 THEN DO
   IF SUBSTR(PROGRAM_NM,1,7) = 'UCEMPIN' THEN HYTRANID = 'CSMI'
   END
   END
  TRANID_NM = HYTRANID
  IF AUTOSAVE \= 'Y' THEN AUTOSAVE = 'N'
   ELSE DO
   CALL SET_ODSN
   IF XC \= 0 THEN AUTOSAVE = 'N'
   END
  UPPER HYFUNC1
  MYFUNC1 = HYFUNC1
  IF MYFUNC1 \= 'E' THEN MYFUNC1 = 'A'
  RX_RQ_DATA = ''
  RX_RQ_DATA.L = '0'
  RX_RQ_DATA.T = 'CHAR'
  CNCCHNM = HYDSRC
  CN_CMD = CMD_1
  H_CNTO = ''
  H_CNTY = 'BIT'
  H_LR1LNG = '0'
  H_CNSTRIP = 'Y'
  LR1 = ''
  ZCMD = ''
  CALL DORESET HYDSRC
  /* TEST FOR COMMAREA OR anyname_CH CHANNEL NAME */
  IF HYDSRC = 'COMMAREA' THEN DO
   MAXRQL=32400
   CALL GET_COMMAREA
   IF XC \= 0 THEN DO
 MSGBOX 'ABORT OR CANCEL ENCOUNTERED GETTING THE COMMAREA DATA. BYE'
    'ISPEXEC REMPOP'
    RETURN XC
    END
 /* the RX var passed to the RXCNCLN2 program is either the word   *\
 |*  'COMMAREA' or a channel name. The RX var RX_CNC_CH_NM will    *|
 |*  contain one those two options.                                *|
 |*  address LINK 'RXCNCLN2 RX_CNC_CH_NM'                          *|
 |*  where RX_CNC_CH_NM contains the 'list' of request elements    *|
 |*   a list of CN names, or COMMAREA                              *|
 |*   each element is a RX var of that name, in which is the req   *|
 |*  so RX_CNC_CH_NM = 'COMMAREA'                                  *|
 |*  and RX var commarea=RX_RQ_DATA                                *|
 \*   which is the commearea data collected                        */
   RX_CNC_CH_NM = HYDSRC  /* SET THE RX PARM TO 'COMMAREA' AS THE  */
                          /*     RX var containing the list of req */
                          /*     variable names; in this case only */
                          /*     the one RX var named commarea     */
   CNLST = 'RX_RQ_DATA'   /* now put the 'list' of RX req var names*/
                          /*     into the RX var holding that list */
                          /* for commarea, ther is only one RX req */
   /* Later, the var named by RX_CNC_CH_NM will be set to 'CNLST'  */
   SIGNAL DONE_DATA_SRC
   END
 /* NOT COMMAREA                */
  /* HERE WE HAVE A CHANNEL NAME */
  /* HERE WE HAVE A CHANNEL NAME */
 GOT_CHANNEL_SRC:
 /* TRACE I */
   CNCCHNM = HYDSRC   /* was already set above - here to remind us */
/*RX_CNC_CH_NM = LEFT(HYDSRC,16,' ')    SET THE RX PARM TO THE     */
  RX_CNC_CH_NM = STRIP(HYDSRC,'T')   /* SET THE RX PARM TO THE     */
                                     /* CHANNEL NAME               */
  CN_CT = 0
  CNLST=''
  MAXRQL=2000000
  CALL GET_CN_SRC_DATA RX_CNC_CH_NM

 DONE_CN_LOOP:
  IF XC > 0 THEN SIGNAL DO_CANCEL
/*RX_RQ_DATA = CNLST
  CNLST = 'RX_RQ_DATA' */ /* now put the 'list' of RX req var names*/
  CN_CT = CNLSTCNT
  IF CNLSTCNT  < 1 THEN DO
   CALL GO_OR_NO  'YOU HAVE ENTERED ZERO CONTAINERS. OK (CONTINUE)  '||,
    ' OR CANCEL TO ABORT'
   IF RC > 0 THEN SIGNAL DO_CANCEL
   END
   ELSE DO
   CNLST=STRIP(CNLST,'B')
   END
 DONE_DATA_SRC:
    /*                                                              *\
    |* note: the RX_CNC_CH_NM is a var that we pass to pgm RXCNCLN2 *|
    |*  that var contents is either 'COMMAREA' or a channel name    *|
    |*  is either case: that value content is used as a name of the *|
    |*  RX var, in which a list of RX request var names define the  *|
    |*  set of RX reqest vars with data.                            *|
    |*  for commarea:                                               *|
    |*   RX_CNC_CH_NM = 'COMMAREA'                                  *|
    |*     and interpret resolves to COMMAREA='CNLST'               *|
    |*         for which CNLST='RX_RQ_DATA'                         *|
    |*  for CnC:                                                    *|
    |*   RX_CNC_CH_NM = 'Some_Channel__NM'                          *|
    |*     and interpret resolves to Some_Channel__NM='CNLST'       *|
    |*         for which CNLST='Cn_one,CN_2,CN_nn'                  *|
    |*   RX_RQ_DATA is the commarea data                            *|
    |*   and each CONTAINER NAME                                    *|
    |*   is utilized via an INTERPRET                               *|
    |*     INTERPRET rx_cnc_cn_nm' = rx_rq_data'                    *|
    |*       where the rx_cnc_cn_nm = 'Cn_one'    etc               *|
    |*             and rx_rq_data= 'is the cn data contents'        *|
    |*             as each new CN is created as a RX var            *|
    \*                                                              */
  APLCNT = WORDS(MYAPLID)
  APLCUR = 0
  APLID_BD  = 0
  APLID_GD  = 0
  /*                                                                 *\
  |* ACCUMULATE 3 RESPONSE STRINGS FOR PRESENTATION (OPTION)         *|
  \*                                                                 */
  EXCI_NOTE = 'ALL EXCI CALLS SUCCESSFUL'
  MSGNOTE_TEXT = ''
  RSPNOTE_TEXT = ''
  RETNOTE_TEXT = ''
  X15='15'X
  XFF='FF'X
  ERRMSG = ''
  I=0
  PRM_RC = 0
  DLM='(<{[='
  MDLM=')>}] '
  #DMM=LENGTH(DLM)
  REPWDS='\@ \$ \! \\'  /* SUBSTITUTE \ APPLID JOBNAME */
  RW_CT = WORDS(REPWDS)
  /*                                                                 *\
  |* HERE WE GO;                                                     *|
  |* EACH APPLID IS PROCESSED. THE COMMAREA OR CONTAINER REQUEST DATA*|
  |*  IS NEVER OVERWRITTEN BY THE EXCI CALL; THE COBOL PROGRAM WILL  *|
  |*  SEND RESPONSE DATA BACK WITH A APPLID_NM_ PREFIX VALUE         *|
  |* THIS ALLOWS THE REQUEST DATA TO REMAIN  UNALTERED AND           *|
  |*% THE RESPONSE DATA IS IN APPLID_NM SPECIFIC RESPONSE RX VARS    *|
  |* ADDRESS LINK 'RXCNCLN2 RXVARPARM'                               *|
  |* THE RXVARPARM IS EITHER                                         *|
  |*  'COMMAREA' - YEP THE ACTUAL 'COMMAREA' LITERAL                 *|
  |*   OR                                                            *|
  |*  'SOME_CHAN_NAME'- A RX VAR WHICH DEFINES A CHANNEL NAME        *|
  |*   USE AS A RX VAR WHO'S CONTENTS IS A COMMA SEPARATED LIST      *|
  |*             - OF CONTAINERS (WHICH ARE RX VARS WITH THE ACTUAL  *|
  |*             - CN DATA)                                          *|
  |*   FOR EACH, YOU CAN OPTIONALLY CODE ADDITIONAL RX STEM VARS     *|
  |*    WHICH HAVE THE 'COMMAREA' OR SOME_CONT_NAME WITH A '.L'      *|
  |*    SUFFIX. THIS IS USED TO CONVEY A LENGTH FOR THE CA OR CN     *|
  |*   AND FOR CN VARS, THE SAME SOME_CONT_NAME WITH A '.T' CAN      *|
  |*    OPTIONALLY CONVEY THE CN DATATYPE                            *|
  \*                                                                 */
  INTERPRET RX_CNC_CH_NM' = CNLST'
  JOBLS='N'
  "ISPEXEC VGET (AFOJOBLS AFOAPLLS) SHARED"
  IF RC = 0 THEN JOBLS='Y'
/* OK HERE WE GO */
  IF MYFUNC1 = 'A' | MYFUNC1 = 'Q' THEN DO
   /* trace i */
   MSGLOCK='Y'
   MSGSTAT='CONTPOP'
   MSGBOXTX='STARTING: PROCESSING ALL APPLIDS...'
   "ISPEXEC  VPUT (MSGBOXTX) ASIS"
   "ISPEXEC  VPUT (MSGLOCK MSGSTAT) ASIS"
   CALL MSGBOX
   END
   ELSE DO
   'ISPEXEC REMPOP'
   END
  GOT_SYMSUB = '?'
  J = 0
 TOPAPLLOP:
  APLCUR = APLCUR + 1
  IF APLCUR > APLCNT THEN DO
  /*   WHEN WE ARE DONE:                                             *\
  |* WHEN MYFUNC1=E THEN EACH RESPONSE HAS ALREADY BEEN PRESENTED    *|
  |* WHEN MYFUNC1\=E THEN PRESENT ALL ACCUM RESPONSE DATA            *|
  \*                                                                 */
   IF MYFUNC1 = 'E' THEN SIGNAL FINEXCI
   ELSE SIGNAL FINAPLLOP
   END
  /*                                                                 *\
  |* GET THE APPLID FOR EXCI CALL, AND SET UP THE PROGRAM PARM       *|
  |*  RX_CNC_CH_NM EQUAL TO THE LITERAL 'CNLST'                      *|
  |* THE RX VAR CNLST HOLDS COMMAREA OR A LIST OF CN NAMES           *|
  |* ACTUAL REQUEST DATA IS IN RX VARS: COMMAREA OR THE CN NAME      *|
  \*                                                                 */
  APPLID_NM = WORD(MYAPLID,APLCUR)
  APL_STM.APPLID_NM=APL_STM.APPLID_NM||':START:'||APPLID_NM||':'||XFF
  MSGOUT_NOTE = 'INITIAL'
  RXCNCLN2_RSP_LOG='INITIAL'
  RETURN_CN_LIST = ''
  /*                                                                 *\
  |* Perform the symbols substitution in the request data            *|
  |* If jobls is y, then we can do substitution                      *|
  |*     \@ WILL SUBSTITUTE APPLID                                   *|
  |*     \$ WILL SUBSTITUTE JOBNAME                                  *|
  |*     \! WILL SUBSTITUTE PARM NAMED S#PARM                        *|
  |*     \\ WILL SUBSTITUTE A SINGLE BACK SLASH                      *|
  |*        AND NOT INTERPRET THIS FURTHER                           *|
  |*  call sr: sr runs substitution logic, once                      *|
  |*  for each request data in the cnlst of commarea or cn           *|
  \*                                                                 */
  /* NEW CODE V3.1                                                   *\
  |*                                                                 *|
  |* GOT_SYMSUB INITIALLY SET TO '?', SO WE ALWAY ENTER ONCE         *|
  |* ON FIRST PASS, SET GOT_SYMSUB TO 'N'                            *|
  |* IF WE FIND A SUBSITUTION, THEN THE GOT_SYMSUB IS 'Y' AND        *|
  |*  WE ALWAYS PROCESS ADDITIONAL APPLID FROM THE BKUP_X DATA SRC   *|
  |*  OTHERWISE, WITHOUT ANY SUBSITUTIONS, THE GOT_SYMSUB IS 'N'     *|
  |*  AND WE NEVER ENTER THIS LOGIC AGAIN                            *|
  \*                                                                 */
  /* TRACE I */
  IF JOBLS = 'Y' THEN DO
   IF GOT_SYMSUB \= 'N' THEN DO
    APLPOS=WORDPOS(APPLID_NM,AFOAPLLS)
    IF APLPOS = 0 THEN SIGNAL NOSUB_CA
    JOBNM=WORD(AFOJOBLS,APLPOS)
    IF GOT_SYMSUB = '?' THEN GOT_SYMSUB = 'N'
  /* NEW CODE V2 */
  /* TRACE I */
    S#APLID = APPLID_NM
    IF LENGTH(S#APLID) < 7 THEN INTERPRET "T#PARM = 'S#"||S#APLID||"'"
     ELSE INTERPRET "T#PARM = 'S#"||SUBSTR(S#APLID,3)||"'"
    INTERPRET T#PARM " = S#VALUE"
    'ISPEXEC VGET ('T#PARM') ASIS'
    IF RC > 0 THEN S#PARM = APPLID_NM
     ELSE INTERPRET 'S#PARM = 'T#PARM
  /* NEW CODE V2                                                     */
    SUBWDS= APPLID_NM||' '||JOBNM||' '||S#PARM||' \'
  /* NEW CODE V3.1                                                   */
  /*                                                                 */
    CALL SUB_SYMS
    END     /* END GOT_SYMSUB */
   END      /* END JOBLS      */
  IF MYFUNC1 = 'A' | MYFUNC1 = 'Q' THEN DO
   MSGBOXTX='PROCESS ALL:'||MYCMD||'..CUR APPLID >'||APPLID_NM
   ADDRESS ISPEXEC "VPUT (MSGBOXTX) ASIS"
   CALL MSGBOX
   END
/* TRACE ?I */
/*    CALL COBOL PROGRAM   */
/*ADDRESS TSO */
/*ALLOC FI(SYSOUT) DA(*) SHR REUSE' */
/* "CALL 'TTED.TSK.P.TCEM.LOADLIB(EXPLPGM3)' 'TVAR1,TVAR2'" */
/* CALL DOES NOT INITIALIZE THE ENVIRONMENT BLOCK */
/*"CALL 'TTEP.TSK.E.TCEM.PDSE(RXVARS)' 'TVAR1,TVAR2'" */
/*  "CALL 'TTEP.TSK.E.TCEM.PDSE(RXCNCLNK)' 'PROGRAM_NM,"||,         *\
|*  "APPLID_NM,RX_CNC_CH_NM,RX_CNC_CN_REQ_LST,RX_CNC_CN_RSP_LST,"||,*|
\*  "TRANID_NM'"                                                    */
/*    CALL COBOL PROGRAM   */
/*    CALL COBOL PROGRAM   */
  address link "RXCNCLN2 RX_CNC_CH_NM"
  XC = RC
  /* TRACE ?I */
  /*                                                                 *\
  |* ON RETURN FROM EXCI CALL, FIRST CHECK RC. IF IT IS NOT ZERO     *|
  |*  THEN JUST USE THE MSGOUT_NOTE RX VAR TO INDICATE THE REASON    *|
  |*  FOR THE ERROR. OTHERWISE COLLECT THE RESPONSE DATA.            *|
  |* IF WE HAVE MYFUNC1 SET TO 'E' EVERY, THEN PRESENT THE RESONSE   *|
  |*  DATA VIA THE MYDSP                                             *|
  |*  response data is gathered                                      *|
  |*    APL_STM.APPLID_NM                                            *|
  |*    APPLID_NM||'_MN'                                             *|
  |*    APPLID_NM||'_RL'                                             *|
  |*    RETLST.APPLID_NM                                             *|
  |*  IF WE HAVE MUFUNC1 = 'A' OR 'Q' THEN WE JUST ITERATE TO NEXT   *|
  |*   APPLID_NM IN THE MYAPLID  LIST - PRESENT DATA AT END          *|
  |*  fOR MYFUNC1 = 'E' WE PRESENT THE DATA AS WE GET RESPONSES      *|
  |*                                                                 *|
  |* RETURN_CN_LIST                                                  *|
  |*  CGE5(CGE5_UCEMPINR_RESP_CN,CGE5_CEMT0001,CGE5_CEDA0001,        *|
  |*  CGE5(RX_RQ_DATA            <<<<<< COMMAREA DATA IN RX_RQ_DATA  *|
  |*                             SO WE NEED TO PRESERVE IT IN A      *|
  |*                             APL_CA.APLCUR STEM                  *|
  |*                                                                 *|
  \*                                                                 */
  /* TRACE I */
  EXCI_STR = 'EXCI SUCCESSFUL'
  IF XC > 4 THEN DO
   IF EXCI_MESSAGE \= 'INITIALIZE' THEN DO
    EXCI_STR = 'EXCI FIALURE:'||,
     'RESP1:'||EXCI_RESP1||,
     ':RESP2:'||EXCI_RESP2||,
     ':ABCODE:'||EXCI_ABCODE||,
     ':MESSAGE:'||EXCI_MESSAGE||':'
    END
   APLID_BD = APLID_BD + 1
   APL_STM.APPLID_NM=APL_STM.APPLID_NM||'FAILED:RC:'||XC||':'||,
    EXCI_STR||XFF
   EXCI_NOTE = 'ONE OR MORE EXCI CALLS IN ERROR'
   END
   ELSE DO
   APLID_GD = APLID_GD + 1
   APL_STM.APPLID_NM=APL_STM.APPLID_NM||'SUCCESS:'||XFF
   END
  /*TRACE OFF */
  /*  ACCUM RESPONSE TEXT                           */
  IF RETURN_CN_LIST = '' THEN DO
   ZMP='WARNING::RETURN_CN_LIST IS EMPTY. NO DATA TO DISPLAY:'||XFF
   APL_STM.APPLID_NM=APL_STM.APPLID_NM||ZMP
   MSGOUT_NOTE=MSGOUT_NOTE||XFF||ZMP
   APPLID_NM||'_NO_LIST' = APPLID_NM||':RETURN_CN_LIST NOT RETURNED'
   RETURN_CN_LIST=APPLID_NM||'('||APPLID_NM||'_NO_LIST'
   END
   ELSE DO
   FP = POS('(',RETURN_CN_LIST)
   IF FP > 0 THEN TMP_CN_LIST = SUBSTR(RETURN_CN_LIST,FP+1)
    ELSE TMP_CN_LIST = RETURN_CN_LIST
   ZMP_CN_LIST = ''
   TMP_CN_CT = WORDS(TMP_CN_LIST)
   TPPLID_NM = STRIP(APPLID_NM,'T')
   TPPLID_NM_L = LENGTH(TPPLID_NM)
   DO I = 1 TO TMP_CN_CT
    TMP_CN = WORD(TMP_CN_LIST,I)
    IF SUBSTR(TMP_CN,1,TPPLID_NM_L) \= TPPLID_NM THEN DO
     ZMP_CN=TPPLID_NM||'_'||TMP_CN
     INTERPRET 'WMP = 'TMP_CN
     IF EXCI_STR \= 'EXCI SUCCESSFUL' THEN DO
      WMP = EXCI_STR||XFF||WMP
      END
     INTERPRET ZMP_CN' = WMP'
     TMP_CN = ZMP_CN
     END
    ZMP_CN_LIST = ZMP_CN_LIST||' '||TMP_CN
    END
   ZMP_CN_LIST = STRIP(ZMP_CN_LIST,'B')
   RETURN_CN_LIST = TPPLID_NM||'('||ZMP_CN_LIST
   IF AUTOSAVE = 'Y' THEN CALL DO_AUTOSAVE
   END
  /*                                                                 *\
  |* PROCESS RETURNING DATA; FOR ALL, JUST ITERATE; FOR EACH SHOWDATA*|
  \*                                                                 */
  ZMP = APPLID_NM||'_MSGNOTE'
  INTERPRET ZMP" ="APPLID_NM||"':MSGNOTE:'||MSGOUT_NOTE"
  YMP = APPLID_NM||'_RSPLOG'
  INTERPRET YMP" ="APPLID_NM||"':RSPLOG:'||RXCNCLN2_RSP_LOG"
  EXCIRSP.APPLID_NM = EXCI_STR
  RETLST.APPLID_NM=RETURN_CN_LIST||' '||ZMP||' '||YMP
  IF MYFUNC1 = 'A' THEN DO
   SIGNAL TOPAPLLOP
   END
  NOT_DONE = 'FIN'
DSP_EVERY_RSP:
  SELRGNS = APPLID_NM
  CALL DSP_SEL_RGN_DATA
  IF XC = 20 THEN SIGNAL FINEXCI
  IF XC = 8 THEN SIGNAL TOPAPLLOP
  IF XC = 4 THEN DO
   SIGNAL TOPAPLLOP
   END
  NOT_DONE = 'MORE'
  SECT=WORDS(SELELMS)
  IF SECT < 1 THEN DO
   SIGNAL TOPAPLLOP
   END
  SELELMS_LST = SELELMS
  CALL DSP_SEL_ELM
  IF XC = 20 THEN SIGNAL FINEXCI
  IF XC = 8 THEN SIGNAL TOPAPLLOP
  IF XC = 4 THEN DO
   SIGNAL TOPAPLLOP
   END
  IF NOT_DONE = 'MORE' THEN SIGNAL DSP_EVERY_RSP
  SIGNAL TOPAPLLOP
FINAPLLOP:
  IF MYFUNC1 \= 'A' THEN DO
   SIGNAL FINEXCI
   END
  MSGSTAT='REMPOP'
  MSGBOXTX= '< FINISHED PROCESSING SELECTION LIST.'
  ADDRESS ISPEXEC "VPUT (MSGSTAT MSGBOXTX) ASIS"
  CALL MSGBOX
  NOT_DONE = 'FIN'
FINAPLNXT:
  CALL SEL_RSP_RGNS
  IF XC > 4 THEN DO
   MSGTXT = 'ABORT/CANCEL SELECTED'
   CALL SHOWMBOX
   RETURN 8
   END
  IF XC = 4 THEN SIGNAL FINEXCI
  IF WORDS(SELRGNS) < 1 THEN DO
   DSEMSG = 'DISPLAY FUNCTION ALL, BUT NO REGIONS SELECTED'
   SIGNAL FINAPLNXT
   END
 FINDATANXT:
  CALL DSP_SEL_RGN_DATA
  IF XC > 4 THEN DO
   MSGTXT = 'ABORT/CANCEL SELECTED'
   CALL SHOWMBOX
   RETURN 8
   END
  IF XC = 4 THEN SIGNAL FINAPLNXT
  SECT=WORDS(SELELMS)
  IF SECT < 1 THEN DO
   SIGNAL FINDATANXT
   END
  SELELMS_LST = SELELMS
  CALL DSP_SEL_ELM
  IF XC > 4 THEN DO
   MSGTXT = 'ABORT/CANCEL SELECTED'
   CALL SHOWMBOX
   RETURN 8
   END
  IF XC = 4 THEN SIGNAL FINAPLNXT
  SIGNAL FINDATANXT
 FINEXCI:
  RETURN 0
/* SUB ROUTINE TO DISPLAY RETURNED DATA */
SHOWRXDATA: PROCEDURE EXPOSE TMP_NM TMP_CN_MSG
  MSG_LF_DLM='15'X
  CPY_#=COPIES('-',60)
  RSPCT = 0
  DO WHILE TMP_CN_MSG \= ''
   PARSE VAR TMP_CN_MSG TMP (MSG_LF_DLM) TMP_CN_MSG
   IF TMP \= '' THEN DO
    RSPCT = RSPCT + 1
    RSP.RSPCT = TMP
    END
   END
  SAY 'FOUND<' RSPCT '> LINES IN RESP_CN_MSG'
  M0 = 1
  ANS = '>'
  DO WHILE ((POS(ANS,'<=>')) \= 0)
   CURLN = M0
   MXLN = RSPCT - CURLN
   IF MXLN > 60 THEN MXLN = CURLN + 60
    ELSE MXLN = CURLN + MXLN
   DO I = CURLN TO MXLN
     SAY RSP.I
     SAY CPY_#
     END
    SAY 'LAST DISPLAY: LINE:' CURLN ' THRU:' MXLN ' OF:' RSPCT
    SAY 'ENTER > TO CONTINUE FORWARD'
    SAY '      = TO RE DISPLAY CURRRENT SET'
    SAY '      < TO CONTINUE FORWARD'
    SAY ' OR ANY OTHER KEY STOP THIS MESSAGE DISPLAY'
    PULL ANS
    SELECT
     WHEN ANS = '>' THEN DO
                    M0 = CURLN + MXLN
                    IF M0 >= RSPCT THEN M0 = (RSPCT - MXLN) + 1
                    END
     WHEN ANS = '=' THEN M0 = CURLN
     WHEN ANS = '<' THEN DO
                    M0 = CURLN - MXLN
                    IF M0 <= 0 THEN M0 = 1
                    END
     OTHERWISE SAY 'SELECTED TO LEAVE:' ANS ':'
     END
   END
   RETURN
  /* GET THE COMMAREA */
  /* GET THE COMMAREA */
  /* GET THE COMMAREA */
 GET_COMMAREA:
   CNCMSG = 'ENTER COMMAREA DATA AND LENGTH; OPTIONS'
 GET_COMMAREA_AGN:
   RX_RQ_DATA = LR1
   BKUP_RX_RQ_DATA = LR1
   RX_RQ_DATA.L = '4096'
   CALL GET_CA_SRC_DATA 'COMMAREA'
   IF XC > 4  THEN RETURN 8
   cal = RX_RQ_DATA.L
   IF CAL = '' then signal get_cal_retry0
   IF DATATYPE(CAL,'W') = 0 then signal get_cal_retry1
   IF CAL = 0 THEN SIGNAL GET_CAL_RETRY4
   IF CAL < 0 | CAL > MAXRQL THEN SIGNAL GET_CAL_RETRY3
   return 0
  get_cal_retry0:
 DSEMSG='YOU SPECIFIED AN INVALID VALUE FOR THE COMMAREA LENGTH:'
   signal GET_COMMAREA_AGN
  get_cal_retry1:
 DSEMSG='YOU SPECIFIED AN NON NUMERIC VALUE FOR THE COMMAREA LENGTH:'
   signal GET_COMMAREA_AGN
  get_cal_retry2:
   CALL GO_OR_NO 'CA LNG IS ZERO. CONFIRM WITH (C)CONTINUE'
   IF RC > 0 THEN RETURN 0
 DSEMSG='YOUR COMMAREA LENGTH WAS ZERO. RETRY WITH ANOTHER VALUE'
   signal GET_COMMAREA_AGN
  GET_CAL_RETRY3:
 DSEMSG='YOUR COMMAREA LENGTH IS NOT IN A VALID RANGE 0 - 'MAXRQL':'
   signal GET_COMMAREA_AGN
 GET_COMMAREA_L_XIT:
    RETURN 16
/* TRACE  I */
  /*                                                                 *\
  |* DISPLAY CA OR CN PANEL TO GET SRC REQUEST DATA                  *|
  \*   EXPECTS ARG COMMAREA OR SOMEOTHERNAME                         */
 GET_CA_SRC_DATA:
/* trace ?i */
  XC = 0
  CA_OR_CN = ''
  ARG CA_OR_CN
  IF CA_OR_CN = '' THEN RETURN 8
  mysc = 'PAGE'
  LR1 = RX_RQ_DATA
  LR1LNG = RX_RQ_DATA.L
   EXECSEL='GETAFOCA'
   DSEMSG = 'ENTER TO UPDATE, PF3 TO CONTINUE'
   cnto='COMMAREA'
   cnty = ''
   cntystr=''
   cncchnm='COMMAREA'
   GET_PNL_NM = 'GETAFOCA'  cnlstcnt
  canstr='ABORT CANCEL'
  CMDSTR='END COPY RESET SETODSN '||CANSTR
  cnstrip='Y'
  h_cnto=cnto
  h_cnty=cnty
  h_LR1LNG=LR1LNG
  h_cnstrip=cnstrip
  xc = 0
  acmd = ''
  "ISPEXEC ADDPOP"
 TOPOFCALOP:
   zcmd = ''
   "ISPEXEC DISPLAY PANEL(GETAFOCA)"
   xc = rc
   acmd = zcmd
   IF WORDPOS(ACMD,CANSTR) > 0 THEN SIGNAL CAN_CA_SRC_DATA
   IF XC = 8 THEN DO
    IF ACMD = '' THEN ACMD = 'DONE'
    END
   IF ACMD = 'SETODSN' THEN DO
    CALL SET_ODSN
    SIGNAL topofcalop
    END
   IF ACMD = 'END' THEN SIGNAL FIN_CA_SRC_DATA
   IF ACMD = 'DONE' THEN SIGNAL FIN_CA_SRC_DATA
   if acmd = 'RESET' then do
    CALL DORESET HYDSRC
    signal topofcalop
    end
   if acmd = 'COPY' then do
    call docopy
    signal topofcalop
    end
   cncmsg='ENTER more COMMAREA DATA'
   signal topofcalop
 FIN_CA_SRC_DATA:
   XC = 0
   if cnstrip = 'Y' then do
    lr1 = strip(lr1,'T')
    IF CA_OR_CN \= 'COMMAREA' THEN LR1LNG = length(LR1)
    end
   RX_RQ_DATA = LR1
   BKUP_RX_RQ_DATA = LR1
   RX_RQ_DATA.L = LR1LNG
   CAL = LR1LNG
   RX_RQ_DATA.T = cnty
   SIGNAL RET_CA_SRC
 CAN_CA_SRC_DATA:
   XC = 8
 RET_CA_SRC:
   "ISPEXEC REMPOP"
   RETURN XC
/* sub routines */
/* sub routines */
/* sub routines */
 docopy:
  edsn = 'src.for.cn.dsn'
  embr = 'src_mbr'
  dsemsg = 'Enter DSN (opt MBR) for 'CA_OR_CN' data'
  "ISPEXEC VPUT (EDSN EMBR DSEMSG EXECSEL) ASIS"
  IF RC > 0 THEN DO
   cmcmsg = 'COPY failed to get 'CA_OR_CN' data (vput)'
   signal donecopy
   end
  call gdsnnmbr
  if rc > 4 then do
   cmcmsg = 'COPY failed to get 'CA_OR_CN' data (gdsn)'
   signal donecopy
   end
  "ISPEXEC Vget (EDSN EMBR) ASIS"
  IF RC > 0 THEN DO
   cmcmsg = 'COPY failed to get 'CA_OR_CN' data (vget_gdsn)'
   signal donecopy
   end
  if EDSN = '' THEN DO
   cmcmsg = 'COPY failed to get 'CA_OR_CN' data (vget_EDSN)'
   signal donecopy
   end
  if EMBR \= '' THEN DO
   EDSN = EDSN||'('||EMBR||')'
   "ISPEXEC VPUT (EDSN) ASIS"
   IF RC > 0 THEN DO
    cmcmsg = 'COPY failed to get CN DSN (VPUT)'
    signal donecopy
    end
   end
  if mcmd \= 'COPY' then return xc
  tgtdata = ''
  CALL CPDS2VAR "<EDSN> <TGTDATA>"
  if rc = 0 then do
   "ISPEXEC VGET (TGTDATA) ASIS"
   IF RC > 0 THEN DO
    cmcmsg = 'COPY failed to get CN data(VGET)'
    signal donecopy
    end
   LR1 = TGTDATA
   lr1lng = length(TGTDATA)
 donecopy:
  xc = rc
  return xc

 DORESET:
   CA_OR_CN = ''
   ARG CA_OR_CN
   IF CA_OR_CN = '' THEN RETURN 8
   CN_CMD=SUBSTR(MYCMD,1,4)
   IF CA_OR_CN = 'COMMAREA' THEN
    cncmsg='(reset)ENTER COMMAREA DATA'
    ELSE DO
    CNCMSG='(RESET)ENTER CONTAINER DATA'
    RX_CNC_CN_NM =CN_CMD||'0000'
    END
   cnto=h_cnto
   cnty=h_cnty
   LR1LNG=h_LR1LNG
   cnstrip=h_cnstrip
   SELECT
   WHEN CN_CMD = 'CEMT' THEN LR1 = 'CEMT INQUIRE SYSTEM'
   WHEN CN_CMD = 'CEDA' THEN LR1 = 'CEDA EXPAND GROUP(XXXXXXXX)'
   WHEN CN_CMD = 'PING' THEN LR1 = 'PINGThis is a PING test'
   WHEN CN_CMD = 'LINK' THEN LR1 = 'LINK,PROGRAM(UCEMPINQ)'
   OTHERWISE LR1 = 'ENTER REQUEST DATA'
   END
   return
  /*                                                                 *\
  |* OK CANCEL BOX - DETERMINES HOW TO CONTINUE WHEN WE NEED TO KNOW *|
  \*                                                                 */
 GO_OR_NO:
    ARG OKCAN1
    OKCAN2 = '(O)K TO CONTINUE, (C)ANCEL TO ABORT'
    OKCANX = 'C'
    ADDRESS ISPEXEC 'VPUT (OKCAN1 OKCAN2 OKCANX) ASIS'
    CALL OKCANBOX
    IF RESULT \= 0 THEN RETURN 8
    ADDRESS ISPEXEC 'VGET (OKCANX) ASIS'
    IF OKCANX \= 'O' THEN RETURN 4
    RETURN 0
  /*                                                                 *\
  |* GET THE OUTPUT DATASET FOR SAVING DATA                          *|
  \*                                                                 */
 SET_ODSN:
     XC = 0
     CALL GET_ODSN
     IF XC > 4 THEN SIGNAL RESET_SVDSN
     ADDRESS ISPEXEC "VGET (EDSN) ASIS"
     IF RC \= 0 THEN SIGNAL RESET_SVDSN
     ODSN = EDSN
     ADDRESS ISPEXEC "VGET (MYVERB) ASIS"
     IF RC \= 0 THEN SIGNAL RESET_SVDSN
     IF MYVERB \= '' THEN DO
      IF MYVERB='ABORT' | MYVERB='CANCEL' THEN SIGNAL RESET_SVDSN
      END
     DSPLYADS = ODSN
    "ISPEXEC VPUT (DSPLYADS) ASIS"
     RETURN
  RESET_SVDSN:
     XC = RC
     ODSN = ''
     RETURN
  /*                                                                 *\
  |* GET THE OUTPUT DATASET FOR SAVING DATA                          *|
  \*                                                                 */
 GET_ODSN:
    "ISPEXEC VGET (DSPLYADS) ASIS"
    IF RC \= 0 THEN DO
     CALL GETUDSN 'AFOLIST'
     PULL EDSN
     END
     ELSE EDSN=DSPLYADS
    TMP = EXECSEL
    EXECSEL = 'AUTOSAVE'
    DSEMSG = 'CHANGE AFOLIST SAVE TO PDS'
    MYVERB = 'CANCEL ABORT END'
    "ISPEXEC VPUT (EDSN) ASIS"
    "ISPEXEC VPUT (DSEMSG EXECSEL) ASIS"
    "ISPEXEC VPUT (MYVERB) ASIS"
    CALL DSNWIND
    EXECSEL = TMP
    XC = RESULT
    RETURN XC
  /*                                                                 *\
  |* logic to get containers for respective channel                   *|
  |* Expect arg to be the channel name, but it exists in CNCCHNM      *|
  |*  just want to be assured we are invoking for a CHANNEL NAME      *|
  \*                                                                 */
 GET_CN_SRC_DATA:
   get_ch_nm = ''
   arg get_ch_nm
   if get_ch_nm = '' then signal do_cn_cancel
   chnm_l = length(get_ch_nm)
   if chnm_l < 1 | chnm_l > 16 then signal do_cn_cancel
   CNOSTR='DONE ABORT CANCEL DELETE ?'
   CANSTR='ABORT CANCEL'
   CMDSTR='GO BACK CDSN BDSN '||CANSTR
   CNTYSTR='CHAR,BIT,CDSN,BDSN'
   CNTO=''
   CNTY='CHAR'
/* CNCCHNM = 'TEST_CH_NM' */
   GET_PNL_NM = 'GETAFOCN'
   CNLST=''
   CNLSTCNT=0
   LR1LSCRL='<'
   LR1RSCRL='>'
/* TRACE I */
/* "ISPEXEC ADDPOP ROW(1) COL(10)" */
   "ISPEXEC ADDPOP"
   LASTCC = RC
  /*                                                                 *\
  |* TOP: GET CONTAINER NAMES, OR DONE/CANCEL                        *|
  \*                                                                 */
 TOPOFCNLOP:
   IF CNOMSG = '' THEN CNOMSG='USE COMMAND OR ENTER NEW CN NM'
   EXECSEL='TSTAFONN'
   ZCMD = ''
   CNLSTL=LENGTH(CNLST)
   CNLSTCNT=WORDS(CNLST)
   CMDACTN='ADD'
   "ISPEXEC DISPLAY PANEL(GETAFONN)"
   LASTCC=RC
/* TRACE ?I */
   MCMD = WORD(ZCMD,1)
   IF MCMD = 'DONE' THEN SIGNAL GOT_ALL_CNTO
   IF MCMD = '?' THEN DO
    CALL SHOWHELP
    SIGNAL TOPOFCNLOP
    END
   IF MCMD = 'CANCEL' | MCMD = 'ABORT' THEN SIGNAL DO_CN_CANCEL
   IF LASTCC = 8 THEN SIGNAL GOT_ALL_CNTO
   IF MCMD = 'DELETE' THEN DO
    IF CNTO = '' THEN DO
     CNOMSG='DELETE:MISSING CN NAME'
     SIGNAL TOPOFCNLOP
     END
    WP = WORDPOS(CNTO,CNLST)
    IF WP = 0 THEN DO
     CNOMSG='DELETE:'CNTO' NOT ON CN LIST'
     SIGNAL TOPOFCNLOP
     END
    CNLST=DELWORD(CNLST,WP,1)
    CNOMSG='DELETED:'CNTO' FROM CN LIST'
    SIGNAL TOPOFCNLOP
    END
  /* PROCESS A CNTO */
   IF CNTO = '' THEN DO
    CNOMSG='MISSING A CONTAINER NAME. RETRY.'
    SIGNAL TOPOFCNLOP
    END
   WP = WORDPOS(CNTO,CNLST)
   IF WP > 0 THEN DO
    CMDACTN='EDIT'
    CNCMSG = 'EDIT THIS CONTAINER DATA'
    INTERPRET 'TMP = 'CNTO
    INTERPRET 'LR1 = "'TMP'"'
    INTERPRET 'LR1LNG  = 'CNTO'.L'
    INTERPRET 'CNTY    = 'CNTO'.T'
    SIGNAL GET_CN_DATA
    END
    ELSE DO
    IF WORDS(CNLST) > 98 THEN DO
     CNOMSG='MAX CN NAMES; DELETE, ABORT OR DONE'
     SIGNAL TOPOFCNLOP
     END
    IF LENGTH(CNTO) > 3 THEN CN_CMD=SUBSTR(CNTO,1,4)
     ELSE CN_CMD=CNTO
    SELECT
      WHEN CN_CMD = 'CEMT' THEN LR1 = 'CEMT INQUIRE SYSTEM'
      WHEN CN_CMD = 'CEDA' THEN LR1 = 'CEDA EXPAND GROUP(XXXXXXXX)'
      WHEN CN_CMD = 'PING' THEN LR1 = 'PINGTHIS IS A PING TEST'
      WHEN CN_CMD = 'LINK' THEN LR1 = 'LINK,PROGRAM(UCEMPINQ)'
      OTHERWISE LR1 = 'ENTER REQUEST DATA'
      END
    LR1LNG = LENGTH(LR1)
    CNTY = 'CHAR'
    END
 GET_CN_DATA:
   CNSTRIP = 'Y'
   CNCMSG='ENTER DATA FOR:'CNTO
   ZCMD = ''
   "ISPEXEC DISPLAY PANEL("GET_PNL_NM")"
   XC = RC
   ACMD = ZCMD
   IF ACMD = 'GO' THEN SIGNAL DON_AFO_SRC_DATA
   IF ACMD = 'BACK' THEN DO
    CNOMSG='BACK OFF LAST CN NAME'
    SIGNAL TOPOFCNLOP
    END
   IF ACMD = 'END' THEN SIGNAL DON_AFO_SRC_DATA
   IF ACMD = 'SETODSN' THEN DO
    CALL SET_ODSN
    SIGNAL GET_CN_DATA
    END
   IF WORDPOS(ACMD,CANSTR) > 0 THEN DO
    CNOMSG='CANCEL GETDATA FOR CN'
    SIGNAL TOPOFCNLOP
    END
   IF XC = 8 THEN SIGNAL DON_AFO_SRC_DATA
   IF ACMD = 'CDSN' | ACMD = 'BDSN' THEN DO
    IF SUBSTR(CNTY,1,1) \= SUBSTR(ACMD,1,1) THEN DO
     CNCMSG = ACMD':INCONSIST TYPE:'CNTY
     SIGNAL GET_CN_DATA
     END
     CALL DOCOPY
     IF RC \= 0 THEN DO
      CMCMSG = ACMD':FAILED:GDSN'
      SIGNAL GET_CN_DATA
      END
     LR1 = '<'||EDSN||'>'
    CNTY=ACMD
    SIGNAL GET_CN_DATA
    END
   CNCMSG='ENTER MORE CONTAINER DATA'
   SIGNAL GET_CN_DATA
DON_AFO_SRC_DATA:
   CNCMSG = 'ADDED THIS CONTAINER:'CNTO
   IF CNSTRIP = 'Y' THEN DO
    LR1=STRIP(LR1,'T')
    LR1LNG = LENGTH(LR1)
    END
   INTERPRET CNTO'.L = LR1LNG'
   INTERPRET CNTO'.T = CNTY'
   INTERPRET CNTO' = LR1'
   INTERPRET 'BKUP_'CNTO' = LR1'
   IF WORDPOS(CNTO,CNLST) = 0 THEN DO
    CNOMSG = 'CONT:'||CNTO||':ADDED. MORE OR DONE?'
    CNLST=CNLST||' '||CNTO
    END
    ELSE DO
    CNOMSG = 'CONT:'||CNTO||':EDITED. MORE OR DONE?'
    END
   SIGNAL TOPOFCNLOP
GOT_ALL_CNTO:
   CNLSTCNT = WORDS(CNLST)
  IF CNLSTCNT < 1 THEN DO
   CALL GO_OR_NO  'YOU HAVE ENTERED ZERO CONTAINERS. OK (CONTINUE)  '||,
    ' OR CANCEL TO ABORT'
   IF RESULT > 0 THEN SIGNAL DO_CN_CANCEL
   END
   ELSE DO
   CNLST=STRIP(CNLST,'B')
   END
   /*
   DO I = 1 TO CNLSTCNT
    TMP = WORD(CNLST,I)
    SAY 'CN:'TMP
    INTERPRET 'LR1 = 'TMP
    SAY LR1
    INTERPRET 'LR1LNG = 'TMP'.L'
    SAY 'LENGTH:'LR1LNG
    INTERPRET 'CNTY   = 'TMP'.T'
    SAY '  TYPE:'CNTY
    END
    */
   XC = 0
   SIGNAL DONE_CN
 DO_CN_CANCEL:
  DSEMSG = EXECSEL||' REQUESTED CANCEL'
  "ISPEXEC VPUT (DSEMSG) ASIS"
  XC = 8
 DONE_CN:
  "ISPEXEC REMPOP"
  RETURN XC
  /*                                                                 *\
  |* substitution sr for request data                                *|
  \*                                                                 */
 SUB_SYMS:
/*TRACE ?I */
  SSCT=WORDS(CNLST)
  SSCUR=0
  /*                                                                 *\
  |* DO SYMBOLS SUBSTITUTION                                         *|
  |* EVERY APPLID_NM HAS TO HAVE SYMBOLS SUBSTITUTED; SO WE USE THE  *|
  |*  BKUP_X VERSION TO RESEED THE REQUEST                           *|
  |* IF ON THE FIRST REGION, WE DO NOT FIND ANY SYMBOLS SUBSTITUTED  *|
  |*  WE CAN BYPASS SIMILAR PROCESSING SETTING   GOT_SYMSUB TO 'N'   *|
  |*  AND WE ARE NEVER CALLED AGAIN FROM MAIN LOGIC                  *|
  |* HOWEVER, IF WE DO FIND SYMBOLS, THEN SET GOT_SYMSUB TO 'Y'      *|
  \*                                                                 */

 TOPSUBSYMLOP:
  SSCUR = SSCUR + 1
  IF SSCUR > SSCT THEN RETURN 0
  SSTMP=WORD(CNLST,SSCUR)
  INTERPRET 'ZMP = BKUP_'SSTMP
  DOSUB = 0
  /*                                                                 *\
  |* REPWDS='\@ \$ \! \\'   APPLID JOBNAME SPECIFIC \\               *|
  |* RW_CT = WORDS(REPWDS)                                           *|
  \*                                                                 */
/* GOT THE REQUEST DATA IN ZMP - DO SUB FOR EACH VAR */
   DO K = 1 TO RW_CT     /* RW_CT IS NUMBER OF SYMS */
    TMPCAL=LENGTH(ZMP)
    SWD = WORD(REPWDS,K)
    RWD = WORD(SUBWDS,K)
    WP = 999             /* WE IMPOSE 999 MAX SUBS TO STOP LOOPER */
    DO UNTIL WP = 0
     WP = POS(SWD,ZMP)
     IF WP > 0 THEN DO
      IF WP = 1 THEN DO
       ZMP=RWD||SUBSTR(ZMP,WP+2)
       END
       ELSE DO
       IF WP = TMPCAL - 1 THEN ,
        ZMP=SUBSTR(ZMP,1,WP-1)||RWD
        ELSE ,
        ZMP=SUBSTR(ZMP,1,WP-1)||RWD||SUBSTR(ZMP,WP+2)
       END
      TMPCAL=LENGTH(ZMP)
      DOSUB = 1
      GOT_SYMSUB = 'Y'
      END
     END
    END
   IF DOSUB = 0 THEN SIGNAL TOPSUBSYMLOP
   INTERPRET SSTMP' = ZMP'
/* DOES NEW AREA EXCEED REQ TYPE MAX? */
   IF TMPCAL > MAXRQL THEN DO
    TMPCAL = MAXRQL
    ZMP=SUBST(ZMP,1,MAXRQL)
    END
   ZMPL = 0
/* DOES NEW AREA EXCEED REQ LNG .L STEM */
   INTERPRET 'ZMPL = 'SSTMP'.L'
   IF TMPCAL > ZMPL THEN DO
    ZMPL=TMPCAL
    INTERPRET SSTMP'.L = ZMPL'
    END
  SIGNAL TOPSUBSYMLOP
 BOTSUBSYMLOP:
  RETURN 0
/*       */
 SHOWHELP:
  IF HYDSRC = 'COMMAREA' THEN DO
   MSGBOX 'HELP INFO FOR CA REQUEST DATA SRC'
   END
   ELSE DO
   MSGBOX 'HELP INFO FOR CN REQUEST DATA SRC'
   END
  RETURN
  /*                                                                 *\
  |* AUTOSAVE FUNCTION - SAVE CURRENT RSP ELEMENT TO DSN             *|
  \*                                                                 */
 DO_AUTOSAVE:
  /*  TRACE ?I */
   "ISPEXEC VGET (DSPLYADS) ASIS"
   IF RC \= 0 THEN DO
    ZEDSMSG = 'AUTOSAVE VAR NF'
    ZEDLMSG = 'AUTOSAVE FOR REGION 'APPLID_NM' DSN VAR NOT FOUND'
    'ISPEXEC SETMSG MSG(ISRZ000)'
    APL_STM.APPLID_NM ='AUTOSAVE FAIL:DSN BAD:'APPLID_NM||XFF||,
                                                   APL_STM.APPLID_NM
    AUTOSAVE = 'N'
    RETURN 8
    END
   PARSE VAR DSPLYADS EDSN '(' EMBR ')'
   TDSN = EDSN
 /* DO THE AUTOSAVE ACTION FOR EACH RETURNED RSP DATA IN */
 /*  THE ZMP_CN_LIST (RETURN_CN_LIST)                    */
   RSPCT=WORDS(ZMP_CN_LIST)
   IF RSPCT < 1 THEN DO
    ZEDSMSG = 'AUTOSAVE:NO LIST'
    ZEDLMSG = 'AUTOSAVE:'APPLID_NM':EMPTY RETURN_CN_LIST'
    'ISPEXEC SETMSG MSG(ISRZ000)'
    APL_STM.APPLID_NM ='AUTOSAVE FAIL:LIST BAD:'APPLID_NM||XFF||,
                                                    APL_STM.APPLID_NM
    RETURN 8
    END
   RSPCUR=0
 TOPSAVITLOP:
   RSPCUR = RSPCUR + 1
   IF RSPCUR > RSPCT THEN RETURN 0
   RSPTMP=WORD(ZMP_CN_LIST,RSPCUR)
   INTERPRET 'ZMP = 'RSPTMP
   ZMP=TRANSLATE(ZMP,XFF,X15)
   TMP = SUBSTR(ZMP,LENGTH(ZMP),1)
   IF TMP > '39'X THEN TMP = '40'X
   ZMP = STRIP(ZMP,'T',TMP)
   L = 0
   DROP MYA.
   DO WHILE ZMP \= ''
     L = L + 1
     PARSE VAR ZMP MYA.L (XFF) ZMP
     WL=LENGTH(MYA.L)
     IF WL > MXLNG THEN MXLNG = WL
     TRACE OFF
     END
    /* TRACE ?I */
   MYA.0 = L
   M# = L
   EMBR=APPLID_NM
   MYSTM='MYA.'
   CALL SAVIT
   DROP MYA.
   IF XC \= 0 THEN DO
    ZEDSMSG = 'AUTOSAVE FAILED.'
    ZEDLMSG = 'AUTOSAVE:'APPLID_NM':'RSPTMP':FAILED.'
    'ISPEXEC SETMSG MSG(ISRZ000)'
    APL_STM.APPLID_NM ='AUTOSAVE FAIL:SAVIT:'APPLID_NM||XFF||,
                                                 APL_STM.APPLID_NM
    END
    ELSE DO
    ZEDSMSG = 'AUTOSAVE SUCCESS'
    ZEDLMSG = 'AUTOSAVE:'APPLID_NM':'RSPTMP':SUCCESSFUL'
    'ISPEXEC SETMSG MSG(ISRZ000)'
    APL_STM.APPLID_NM ='AUTOSAVE SUCCESSFUL:'APPLID_NM':'RSPTMP
    END
   SIGNAL TOPSAVITLOP
 DONE_AUTOSAVE:
   RETURN
  /*                                                                 *\
  |*  SAVIT SAVES STEM MYSTM VAR (M# RECORDS) TO DSN SELECTED        *|
  \*                                                                 */
 /* MYFUNC = QUIET : WRITE OP TO ODSN */
 SAVIT:
 /* TRACE ?I */
  EXECSEL='SAVIT'
  DSPVAL='SHR REUSE'
  CALL MALOC TDSN
  XC=RESULT
  IF XC = 0 THEN SIGNAL CHKORG
  IF EMBR = '' THEN MYDSO='PS)'
   ELSE DO
    MYDSO='PO) DSNTYPE(LIBRARY)'
   END
  MODDSN = ''
  M=MXLNG+4
  DSEMSG = '(D) DEL/REALLOC,(A) ABORT'
  MODATTR="NEW BLKSIZE("M+4") DSORG("MYDSO" RECFM(V,B) SPACE(1,1)"||,
   "CYLINDER LRECL("M") CATALOG REUSE"
  "ISPEXEC VPUT (EDSN EXECSEL DSEMSG MODATTR MODDSN) ASIS"
  IF RC \= 0 THEN SIGNAL EXITRC8
  CALL ALOCDSN
  XC = RESULT
  "ISPEXEC VGET (EDSN) ASIS"
  IF RC \= 0 THEN RETURN 4
  SIGNAL DOWRITEx
 CHKORG:
   XC=LISTDSI("'"TDSN"'" DIRECTORY NORECALL)
   MYDSO=SYSDSORG
   IF EMBR \= '' THEN DO
    IF MYDSO = 'PS' THEN SIGNAL BADOPDSNORG
    END
    ELSE DO
    IF MYDSO = PO THEN SIGNAL BADOPDSNORG
    IF AUTOSAVE = 'Y' THEN DSPVAL='MOD'
    END
   EDSN = TDSN
 DOWRITEx:
   /* TRACE ?I */
   DSPLYADS=EDSN
    IF EMBR \= '' THEN EDSN=EDSN||'('||EMBR||')'
   "ISPEXEC VPUT (DSPLYADS EMBR) ASIS"
   ADDRESS TSO "ALLOC FI(O) DA('"EDSN"') "DSPVAL
   ADDRESS TSO "EXECIO "M#" DISKW O (STEM "MYSTM" FINIS"
   ADDRESS TSO "FREE FI(O)"
   RETURN 0
BADOPDSNORG:
   CALL MSGBOX 'SAVE TO DSN DSORG INCONSISTENT WITH EXISTING DSN'
   RETURN 4
  END
 EXITRC8:
    ERR='NO VALID FUNCTION REQUESTED'
    SIGNAL DOERR
 EXITRC10:
    ERR='FUNCTION:QUIET, BUT NO OUTPUT DESTINATION PROVIDED.'
    SIGNAL DOERR
 EXITRC12:
 EXITRC16:
 EXITRC20:
 DOERR:
 RETURN XC
  /*                                                                 *\
  |*                                                                 *|
  \*                                                                 */
 SEL_RSP_RGNS:
  NOP
 HELPTOP:
 /*                                                                 *\
 |* MANAGE RESPONSE DATA FOR MYFUNC1 'E'                            *|
 |*  SELECT ONE OR MORE REGIONS                                     *|
 |*  OR                                                             *|
 |*  SELECT THE 'ALL' LINE ENTRY                                    *|
 |*                                                                 *|
 |*  BASED ON YOUR SELECTION, FOR EACH SELECTION (OR ALL)           *|
 |*   A SECOND PANELS ALLOWS YOU TO CHOOSE                          *|
 |*   WHICH RESPONSE DATA YOU WISH TO SEE                           *|
 |*                                                                 *|
 |*  PF3 OR END WILL PROCESS; CANCEL WILL ABORT CNC ACTION          *|
 |*  ? TO SEE THIS HELP DATA                                        *|
 \*                                                                 */
 HELPBOT:
  HELPTOP_SRCLN = 1189
  HELPBOT_SRCLN = 1199
 /*                                                                 *\
 |* THE ABOVE SRCLN VARS ARE USE IN THE HELP OPTION                 *|
 |*  IF YOU ADD OR DELETE LINES WITHIN THE HELPTOP:HELPBOT LABELS   *|
 |*   YOU MUST ADJUST THE SCRLN VARS ACCORDINGLY                    *|
 \*                                                                 */
  HELPDATA=XFF
 /* TRACE I */
  XC = 8
  CHNM_DFT=RX_CNC_CH_NM
  AMT='CSR'
  SIGNAL OFF ERROR
  "ISPEXEC ADDPOP ROW(2) COLUMN(20)"
  /* TBLAPLID HAS 2 COLS: ACTION APPLID */
  "ISPEXEC TBCREATE TBLAPLID "||,
    "NAMES(ACTION FA FB) NOWRITE REPLACE"
   IF RC > 4 THEN DO
   MSGTXT ='COULD NOT CREATE THE TBLAPLID LIST OF RESPONSE REGIONS.'||,
    'WILL DEFAULT TO ALL REGIONS.'
   CALL   SHOWMBOX
   SELRGNS=MYAPLID
   XC = 4
   SIGNAL DO_FIN
   END
  ACTION = '-'
  FA='ALL'
  FB='-'
  "ISPEXEC TBADD TBLAPLID"
  APLCT = WORDS(MYAPLID)
  DO I = 1 TO APLCT
   FA = WORD(MYAPLID,I)
   "ISPEXEC TBADD TBLAPLID"
   END
  /* TRACE I */
  EXECSEL='DSPAFOH$'
  "ISPEXEC TBTOP TBLAPLID"
  "ISPEXEC VPUT (EXECSEL) ASIS"
  CANSTR='CANCEL ABORT'
  DONSTR='DONE END'
  CMDSTR=CANSTR||' '||DONSTR||' RESET'
  PROCLST='-,S,U,X'
  PROCLST_WDS=TRANSLATE(PROCLST,' ',',')
  PROCLSTWD='- SELECT UNSELECT EXCLUDE'
  MCMD=''
  LSTHDR='RESPONSE REGION LIST'
  CHORCN=CHNM_DFT
  MYCRP = 0
  DSEMSG=''
  SELRGNS=''
  XCLRGNS=''
 /*  TRACE ?I */
  "ISPEXEC TBDISPL TBLAPLID PANEL(AFORSPAP) ROWID(MDROW#) POSITION(MYCRP)"
  SIGNAL ARND_TOP
 TOPOFLOP:
  ZCMD = ''
  "ISPEXEC TBTOP   TBLAPLID"
  "ISPEXEC TBSKIP  TBLAPLID NUMBER("ZTDTOP")"
  "ISPEXEC TBDISPL TBLAPLID PANEL(AFORSPAP)"
 ARND_TOP:
  XC = RC
  IF XC > 8 THEN DO
   MSGTXT ='SEVERE ERROR FROM TBDISPL FUNCTION.  ABORT.'
   CALL   SHOWMBOX
   XC = 20
   SIGNAL DO_TBL_CLO
   END
  IF WORDPOS(MCMD,CANSTR) \=  0 THEN DO
   DSEMSG='COMMAND:'MCMD' SIGNALS ABORT'
   SIGNAL DO_CAN
   END
  IF MCMD = 'RESET' THEN DO
   SELRGNS = ''
   XCLRGNS=''
   "ISPEXEC TBTOP TBLAPLID"
   DO I = 1 TO ZTDROWS
    "ISPEXEC TBSKIP  TBLAPLID NUMBER(1)"
    ACTION = '-'
    FB = '-'
    "ISPEXEC TBPUT TBLAPLID"
    END
   SIGNAL TOPOFLOP
   END
  NUD=ZTDSELS
  HR#=MDROW#
  HC#=MYCRP
  IF ZTDSELS > 0 THEN DO
   DO WHILE (ZTDSELS > 0)
    R#=MDROW#
    R#=MYCRP
    ACT_W#=WORDPOS(ACTION,PROCLST_WDS)
    SELECT
    WHEN ACTION = 'S' THEN DO
     IF FA = 'ALL' THEN DO
      XCLRGNS = ''
      SELRGNS=MYAPLID
      DO I = 2 TO ZTDROWS
       "ISPEXEC TBSKIP  TBLAPLID NUMBER(1)"
       QQQ=FA
       ACTION = '-'
       FB = 'S'
       "ISPEXEC TBPUT TBLAPLID"
       END
      SIGNAL TOPOFLOP
      END
      ELSE DO
      IF WORDPOS(FA,SELRGNS) = 0 THEN SELRGNS = SELRGNS||' '||FA
      XP=WORDPOS(FA,XCLRGNS)
      IF XP > 0 THEN XCLRGNS=DELWORD(XCLRGNS,XP,1)
      END
     END           /* END 'S' */
    WHEN ACTION = 'X' THEN DO
     IF FA = 'ALL' THEN DO
      SELRGNS = ''
      XCLRGNS=MYAPLID
      DO I = 1 TO ZTDROWS
       "ISPEXEC TBSKIP  TBLAPLID NUMBER(1)"
       ACTION = '-'
       FB = 'X'
       "ISPEXEC TBPUT TBLAPLID"
       END
      SIGNAL TOPOFLOP
      END
      ELSE DO
      IF WORDPOS(FA,XCLRGNS) = 0 THEN XCLRGNS = XCLRGNS||' '||FA
      XP=WORDPOS(FA,SELRGNS)
      IF XP > 0 THEN SELRGNS=DELWORD(SELRGNS,XP,1)
      END
     END
    WHEN ACTION = 'U' THEN DO
     IF FA = 'ALL' THEN DO
      SELRGNS = ''
      XCLRGNS=''
      DO I = 1 TO ZTDROWS
       "ISPEXEC TBSKIP  TBLAPLID NUMBER(1)"
       ACTION = '-'
       FB = '-'
       "ISPEXEC TBPUT TBLAPLID"
       END
      SIGNAL TOPOFLOP
      END
      ELSE DO
      XP=WORDPOS(FA,SELRGNS)
      IF XP > 0 THEN SELRGNS=DELWORD(SELRGNS,XP,1)
      XP=WORDPOS(FA,XCLRGNS)
      IF XP > 0 THEN XCLRGNS=DELWORD(XCLRGNS,XP,1)
      END
     END
    OTHERWISE NOP
    END                      /* END SELECT */
    FB = ACTION
    ACTION = '-'
    "ISPEXEC TBPUT TBLAPLID"
    IF ZTDSELS > 1 THEN "ISPEXEC TBDISPL TBLAPLID"
     ELSE LEAVE
 /* IF ZTDSELS < 1 THEN LEAVE */
    END
   END
 /*  TRACE I */
  IF XC = 8 THEN DO
   IF MCMD = '' THEN MCMD = 'END'
   END
  IF MCMD = '?'THEN DO
   CALL DO_HELP
   MCMD = ''
   SIGNAL TOPOFLOP
   END
  IF WORDPOS(MCMD,CMDSTR) = 0 THEN SIGNAL TOPOFLOP
  IF WORDPOS(MCMD,DONSTR) \= 0 THEN SIGNAL OKDOIT
  SIGNAL TOPOFLOP
/*PROCESS COMMANDS */
/*LOOP TO TOPOFLOP UNTIL SAVE COMMAND */
 OKDOIT:
 /* TRACE I */
  IF SELRGNS = '' THEN DO
   IF MCMD = 'DONE' THEN DO
    XC = 4
    SIGNAL DO_TBL_CLO
    END
   DSEMSG ='PF3/END: ZERO REGIONS; USE CANCEL/ABORT/DONE'
   SIGNAL TOPOFLOP
   END
  IF MCMD = 'DONE' THEN XC = 4
     ELSE XC = 0
  SIGNAL DO_TBL_CLO
 DO_CAN:
  IF MCMD = 'ABORT' THEN XC = 20
     ELSE XC = 8
 DO_TBL_CLO:
  "ISPEXEC TBCLOSE TBLAPLID"
 DO_FIN:
/*                                                                   *\
|* ADDPOP/REMPOP service in relation to CONTROL service              *|
|*                                                                   *|
|* The ADDPOP service performs the equivalent of a                   *|
|* CONTROL DISPLAY SAVE                                              *|
|* prior to creating the pop-up window and the REMPOP service        *|
|* performs the equivalent of a CONTROL DISPLAY RESTORE after        *|
|* removing the current  pop-up window.                              *|
|*  A dialog should not issue its own                                *|
|* CONTROL DISPLAY SAVE/RESTORE around an ADDPOP/REMPOP sequence     *|
|*                                                                   *|
|*                                                                   *|
\* A                                                                 */
  "ISPEXEC REMPOP"
   RETURN XC
  /*                                                                 *\
  |* UTILITY SUBROUTINES                                             *|
  \*                                                                 */
 SHOWMBOX:
   CALL MSGBOX MSGTXT
   RETURN
 DO_HELP:
  IF LENGTH(HELPDATA) < 2 THEN DO
   DO I = HELPTOP_SRCLN TO  HELPBOT_SRCLN
    TMP=STRIP(SOURCELINE(I),'B')
    TMP=TRANSLATE(TMP,'    ','/\|*')
    HELPDATA=HELPDATA||STRIP(TMP,'B')||XFF
    END
   END
  CALL MSGBOX HELPDATA
    RETURN XC
  /*                                                                 *\
  |*  DISPLAY THE RESPONSE DATA ELEMENTS FOR EACH REGION IN SELRGNS  *|
  \*                                                                 */
 DSP_SEL_RGN_DATA:
  IF WORDS(SELRGNS) < 1 THEN DO
   MSGTXT = 'ERROR: CALL TO DISPLAY DATA FOR SELETED REGIONS, BUT'||,
    ' THERE ARE NO REGIONS IN THE SELECT LIST.'
   CALL SHOWMBOX
   XC = 8
   RETURN
   END
 HELPTOP2:
 /*                                                                 *\
 |* MANAGE RESPONSE DATA FOR MYFUNC1 'E'                            *|
 |*  SELECT ONE OR MORE REGIONS                                     *|
 |*  OR                                                             *|
 |*  SELECT THE 'ALL' LINE ENTRY                                    *|
 |*                                                                 *|
 |*  BASED ON YOUR SELECTION, FOR EACH SELECTION (OR ALL)           *|
 |*   A SECOND PANELS ALLOWS YOU TO CHOOSE                          *|
 |*   WHICH RESPONSE DATA YOU WISH TO SEE                           *|
 |*                                                                 *|
 |*  PF3 OR END WILL PROCESS; CANCEL WILL ABORT CNC ACTION          *|
 |*  ? TO SEE THIS HELP DATA                                        *|
 \*                                                                 */
 HELPBOT2:
  HELPTOP_SRCLN = 1347
  HELPBOT_SRCLN = 1357
 /*                                                                 *\
 |* THE ABOVE SRCLN VARS ARE USE IN THE HELP OPTION                 *|
 |*  IF YOU ADD OR DELETE LINES WITHIN THE HELPTOP:HELPBOT LABELS   *|
 |*   YOU MUST ADJUST THE SCRLN VARS ACCORDINGLY                    *|
 \*                                                                 */
 /* TRACE I */
  XC = 8
  CHNM_DFT=RX_CNC_CH_NM
  AMT='CSR'
  IF RX_CNC_CH_NM \= 'COMMAREA' THEN SHOWYN='LOW'
   ELSE SHOWYN='NON'
  SELNMSG='List of Respnse Data Elements'
  SIGNAL OFF ERROR
  "ISPEXEC ADDPOP"
  /* TBLAPLID HAS 2 COLS: ACTION APPLID */
  "ISPEXEC TBCREATE TBLAPLDD "||,
    "NAMES(ACTION FA FB FC) NOWRITE REPLACE"
   IF RC > 4 THEN DO
   MSGTXT ='COULD NOT CREATE THE TBLAPLDD LIST OF RESPONSE DATA '||,
    'FOR SELECT REGIONS. WILL DEFAULT TO ALL DATA.'
   CALL   SHOWMBOX
   XC = 4
   SIGNAL DO_FIND
   END
 /*TRACE I */
  APLCT = WORDS(SELRGNS)
  ACTION = '-'
  FB='-'
  RSP_LST=''
  ALLCA_LST = ''
  ALLCN_LST = ''
  CNLSTCNT = WORDS(CNLST)
  DO I = 1 TO APLCT
   APLNM = WORD(SELRGNS,I)
   RETURN_CN_LIST = RETLST.APLNM
   WP=POS('(',RETURN_CN_LIST)
   IF WP > 1 THEN DO
    RETURN_CN_LIST=SUBSTR(RETURN_CN_LIST,WP + 1)
    END
   RETURN_CN_LIST = TRANSLATE(RETURN_CN_LIST,' ',',')
   CN_CT = WORDS(RETURN_CN_LIST)
   IF CN_CT > 1 & I = 1 THEN DO
    FA='ALL'
    "ISPEXEC TBADD TBLAPLDD"
    END
   CN_WD_NUM=0
   CN_WD=''
   DO CN_WD_NUM = 1 TO CN_CT
    RSPNM=WORD(RETURN_CN_LIST,CN_WD_NUM)
    IF CA_OR_CN = 'COMMAREA' THEN DO
     IF POS('_RX_RQ_DATA',RSPNM)>0 THEN ALLCA_LST=ALLCA_LST||' '||RSPNM
     END
     ELSE DO
     DO RSP_CN_I = 1 TO CNLSTCNT
      RSP_CN_T = WORD(CNLST,RSP_CN_I)
      IF POS(RSP_CN_T,RSPNM) > 0 THEN ALLCN_LST=ALLCN_LST||' '||RSPNM
      END
     END
    FA = RSPNM
    INTERPRET 'FC = 'RSPNM'_DATATYPE'
    IF FC \= 'B' THEN FC = 'C'
    "ISPEXEC TBADD TBLAPLDD"
    RSP_LST = RSP_LST||' '||RSPNM
    END
   END
  /* TRACE I */
  TRACE OFF
  EXECSEL='DSPAFOH@'
  "ISPEXEC TBTOP TBLAPLDD"
  "ISPEXEC VPUT (EXECSEL) ASIS"
  CANSTR='CANCEL ABORT'
  DONSTR='DONE END'
  IF CA_OR_CN = 'COMMAREA' THEN ALLRSP = 'ALLCA'
   ELSE ALLRSP = 'ALLCN'
  CMDSTR=CANSTR||' '||DONSTR||' RESET 'ALLRSP
  PROCLST='-,S,U,X'
  PROCLST_WDS=TRANSLATE(PROCLST,' ',',')
  PROCLSTWD='- SELECT UNSELECT EXCLUDE'
  MCMD=''
  LSTHDR='RESPONSE REGION DATA LIST'
  CHORCN=CHNM_DFT
  MYCRP = 0
  DSEMSG=EXCI_NOTE
  SELNTYP='1'
  SELNMSG='DISPLAYING RESPONSE ELEMENTS'
  SELELMS = ''
  XCLELMS=''
 /*  TRACE ?I */
  "ISPEXEC TBDISPL TBLAPLDD PANEL(AFORSPDA) ROWID(MDROW#) POSITION(MYCRP)"
  SIGNAL ARND_DOP
 TOPOFDOP:
  ZCMD = ''
  "ISPEXEC TBTOP   TBLAPLDD"
  "ISPEXEC TBSKIP  TBLAPLDD NUMBER("ZTDTOP")"
  "ISPEXEC TBDISPL TBLAPLDD PANEL(AFORSPDA)"
  DSEMSG = ''
 ARND_DOP:
  XC = RC
  IF XC > 8 THEN DO
   MSGTXT ='SEVERE ERROR FROM TBDISPL FUNCTION.  ABORT.'
   CALL   SHOWMBOX
   XC = 20
   SIGNAL DO_TBL_CLOD
   END
  IF WORDPOS(MCMD,CANSTR) \=  0 THEN DO
   DSEMSG='COMMAND:'MCMD' SIGNALS ABORT'
   SIGNAL DO_CAND
   END
  IF MCMD = 'RESET' THEN DO
   SELELMS = ''
   XCLELMS=''
   "ISPEXEC TBTOP TBLAPLDA"
   DO I = 1 TO ZTDROWS
    "ISPEXEC TBSKIP  TBLAPLDA NUMBER(1)"
    ACTION = '-'
    FB = '-'
    "ISPEXEC TBPUT TBLAPLDD"
    END
   SIGNAL TOPOFDOP
   END
  IF MCMD = 'ALLCA' THEN DO
   MCMD = ''
   IF ALLCA_LST = '' THEN DO
    DSEMSG='ALLCA IS NOT VALID'
    SIGNAL TOPOFDOP
    END
   SELELMS = ALLCA_LST
   SIGNAL OKDOITD
   END
  IF MCMD = 'ALLCN' THEN DO
   MCMD = ''
   IF ALLCN_LST = '' THEN DO
    DSEMSG='ALLCN IS NOT VALID'
    SIGNAL TOPOFDOP
    END
   SELELMS = ALLCN_LST
   SIGNAL OKDOITD
   END
  NUD=ZTDSELS
  HR#=MDROW#
  HC#=MYCRP
  IF ZTDSELS > 0 THEN DO
   DO WHILE (ZTDSELS > 0)
    R#=MDROW#
    R#=MYCRP
    ACT_W#=WORDPOS(ACTION,PROCLST_WDS)
    SELECT
    WHEN ACTION = 'S' THEN DO
     IF FA = 'ALL' THEN DO
      XCLELMS = ''
      SELELMS=RSP_LST
      DO I = 2 TO ZTDROWS
       "ISPEXEC TBSKIP  TBLAPLDD NUMBER(1)"
       QQQ=FA
       ACTION = '-'
       FB = 'S'
       "ISPEXEC TBPUT TBLAPLDD"
       END
      SIGNAL TOPOFDOP
      END
      ELSE DO
      IF WORDPOS(FA,SELELMS) = 0 THEN SELELMS = SELELMS||' '||FA
      XP=WORDPOS(FA,XCLELMS)
      IF XP > 0 THEN XCLELMS=DELWORD(XCLELMS,XP,1)
      END
     END           /* END 'S' */
    WHEN ACTION = 'X' THEN DO
     IF FA = 'ALL' THEN DO
      SELELMS = ''
      XCLELMS=RSP_LST
      DO I = 1 TO ZTDROWS
       "ISPEXEC TBSKIP  TBLAPLDD NUMBER(1)"
       ACTION = '-'
       FB = 'X'
       "ISPEXEC TBPUT TBLAPLDD"
       END
      SIGNAL TOPOFDOP
      END
      ELSE DO
      IF WORDPOS(FA,XCLELMS) = 0 THEN XCLELMS = XCLELMS||' '||FA
      XP=WORDPOS(FA,SELELMS)
      IF XP > 0 THEN SELELMS=DELWORD(SELELMS,XP,1)
      END
     END
    WHEN ACTION = 'U' THEN DO
     IF FA = 'ALL' THEN DO
      SELELMS = ''
      XCLELMS=''
      DO I = 1 TO ZTDROWS
       "ISPEXEC TBSKIP  TBLAPLDD NUMBER(1)"
       ACTION = '-'
       FB = '-'
       "ISPEXEC TBPUT TBLAPLDD"
       END
      SIGNAL TOPOFDOP
      END
      ELSE DO
      XP=WORDPOS(FA,SELELMS)
      IF XP > 0 THEN SELELMS=DELWORD(SELELMS,XP,1)
      XP=WORDPOS(FA,XCLELMS)
      IF XP > 0 THEN XCLELMS=DELWORD(XCLELMS,XP,1)
      END
     END
    OTHERWISE NOP
    END                      /* END SELECT */
    FB = ACTION
    ACTION = '-'
    "ISPEXEC TBPUT TBLAPLDD"
    IF ZTDSELS > 1 THEN "ISPEXEC TBDISPL TBLAPLDD"
     ELSE LEAVE
 /* IF ZTDSELS < 1 THEN LEAVE */
    END
   END
  IF XC = 8 THEN DO
   IF MCMD = '' THEN MCMD = 'END'
   END
  IF MCMD = '?'THEN DO
   CALL DO_HELP
   MCMD = ''
   SIGNAL TOPOFDOP
   END
  IF WORDPOS(MCMD,CMDSTR) = 0 THEN SIGNAL TOPOFDOP
  IF WORDPOS(MCMD,DONSTR) \= 0 THEN SIGNAL OKDOITD
  SIGNAL TOPOFDOP
/*PROCESS COMMANDS */
/*LOOP TO TOPOFLOP UNTIL SAVE COMMAND */
 OKDOITD:
 /* TRACE I */
  IF SELELMS = '' THEN DO
   IF MCMD = 'DONE' THEN DO
    XC = 4
    SIGNAL DO_TBL_CLOD
    END
   XC = 0
   DSEMSG ='PF3/END: ZERO DATA; USE CANCEL/ABORT/DONE'
   SIGNAL TOPOFDOP
   END
   IF MCMD = 'DONE' THEN XC = 4
      ELSE XC = 0
  SIGNAL DO_TBL_CLOD
 DO_CAND:
  IF MCMD = 'ABORT' THEN XC = 20
   ELSE XC = 8
 DO_TBL_CLOD:
  "ISPEXEC TBCLOSE TBLAPLDD"
 DO_FIND:
  "ISPEXEC REMPOP"
   RETURN XC
  /*                                                                 *\
  |*                                                                 *|
  \*                                                                 */
 DSP_SEL_ELM:
 /* TRACE I */
  SECT=WORDS(SELELMS_LST)
  IF SECT < 1 THEN DO
   XC = 8
   RETURN
   END
  HAPLNM=WORD(SELRGNS,1)
  MYA=LEFT(HAPLNM,8)||'-->'||XFF||EXCIRSP.HAPLNM||XFF
  MYB=''
  GOT_BIT='N'
  DO I = 1 TO SECT
   RSPNM = WORD(SELELMS_LST,I)
   FP=POS('_',RSPNM)
   IF FP > 0 THEN DO
    PARSE VAR RSPNM APLNM '_' CACNNM
    IF WORDPOS(APLNM,SELRGNS) > 0 THEN DO
     IF APLNM \= HAPLNM THEN DO
      MYA=MYA||XFF||LEFT(APLNM,8)||'-->'||XFF||EXCIRSP.APLNM||XFF
      HAPLNM = APLNM
      END
     END
    END
    ELSE DO
    MYA=MYA||RSPNM||'-->'||XFF
    END
   INTERPRET 'TMP_NM = "'RSPNM'"'
   INTERPRET 'TMP_CN_MSG = 'TMP_NM
   DT_RSPNM = RSPNM||'_DATATYPE'
   INTERPRET 'Z_DT_RSPNM = 'DT_RSPNM
   IF Z_DT_RSPNM \= 'B' THEN TMP_TYP = 'CHAR'
    ELSE TMP_TYP = 'BIT'
   IF TMP_TYP = 'CHAR' THEN DO
    MYA=MYA||'CN:'||RSPNM||XFF
    TMP_L = LENGTH(TMP_CN_MSG)
    IF TMP_L > 0 THEN DO
     TMP=SUBSTR(TMP_CN_MSG,TMP_L,1)
     IF TMP > '39'X THEN TMP = '40'X
     TMP_CN_MSG = STRIP(TMP_CN_MSG,'T',TMP)
     TMP_CN_MSG = TRANSLATE(TMP_CN_MSG,XFF,X15)
     IF SUBSTR(TMP_CN_MSG,LENGTH(TMP_CN_MSG),1) \= XFF THEN,
      TMP_CN_MSG = TMP_CN_MSG||XFF
     MYA = MYA||TMP_CN_MSG
     END
     ELSE DO
     MYA = MYA||'<CONTAINER IS EMPTY>'||XFF
     END
    END
    ELSE DO
    GOT_BIT='Y'
    MYA = MYA||'BIT_CN:'||RSPNM||XFF
 MYB = MYB||'<'||LENGTH(TMP_CN_MSG)||' '||APLNM||':BIT_CN>'||TMP_CN_MSG
    END
 /* NEED TO ACCUMULATE BIT DATA TO A DIFFERENT MYA VAR */
 /*IF SUBSTR(TMP_CN_MSG,LENGTH(TMP_CN_MSG),1) \= XFF THEN, */
 /* TMP_CN_MSG = TMP_CN_MSG||XFF                           */
 /*MYA = MYA||TMP_CN_MSG||XFF                              */
   END
 /* BASED ON DSPLYA WITHOUT USING ISPF VARS FOR DATA                */
 /*  DATA EXISTS IN RX VARS MYA                                     */
 /* BIT  DATA DISPLAY */
  IF MYB \= '' THEN DO
   DSPHEXPN = 'EXHEXDMP'
   DSEMSG = 'HEX DATA DUMP FOR BIT CONTAINERS'
   "ISPEXEC VPUT (DSPHEXPN DSEMSG) ASIS"
   CALL EXHEXDMP MYB
   END
 /* CHAR DATA DISPLAY */
  CUTV = 'DSPC'
  CUTCNT=0
  MYVERB = ''
  XC = 0
  SEP=XFF
  I = 0
  MYAW=0
  MYDP=0
  MYLVLN = 0
  "ISPEXEC PQUERY PANEL(MYDSPAD1) AREANAME(MYAREA1) "||,
   "AREATYPE(MYAT) WIDTH(MYAW) DEPTH(MYDP)"
  DN = MYDP-2
  MYSCLN = DN
  SH = MYAW
  SV = MYDP
  MXLNG = 0
  DO WHILE(MYA \= '')
   FP = POS(SEP,MYA)
   IF FP = 0 THEN FP = MXLNG
   TMP = SUBSTR(MYA,1,FP)
   MYA = SUBSTR(MYA,FP + 1)
   TL = LENGTH(TMP)
   IF TL > MXLNG THEN MXLNG = TL
   I = I+1
   MYA.I = TMP
   END
  MYA.0 = I
  SVC = I
  TOPLN = 1
  BOTLN = 1
  MXLN = I
  NEWMX = 0
  MYSCLA=''
  MYSCLD='PAGE'
  MYSC = 'PAGE'
  MYA1 = ''
  MYAT = ''
  SUDT=DATE('U')
  CURLN=1
  CURCL=1
  /* TRACE ?I */
 DSPLOOP:
  TRACE OFF
  STIM=TIME()
  TOPLN=CURLN
  TOPCL=CURCL
  BOTLN = TOPLN + DN
  IF BOTLN > MXLN THEN BOTLN = MXLN
   MYAREA1 = ''
   I = TOPLN
   DO J = 1 TO MYDP
    IF I > MXLN THEN MYA.I = ' '
    MYAREA1 = MYAREA1||LEFT(SUBSTR(MYA.I,TOPCL),MYAW)
    I = I + 1
    END
 DSPLOOP1:
  IF MYVERB = '' & CMD = '' THEN DO
   ZEDSMSG = ""
   ZEDLMSG = ""
   "ISPEXEC SETMSG MSG(ISRZ001)"
   END
  CMD = ''
  ZCMD = ''
  MYVERB=''
  HLDSCLN = MYSCLN
  "ISPEXEC DISPLAY PANEL(MYDSPAD1)"
  XC=RC
/* TRACE I */
  AVERB = MYVERB
  ACMD = CMD
  PARSE VAR CMD CMD RESP
  GG='CMD='CMD'  MYVERB='MYVERB
  "ISPEXEC VPUT (GG) ASIS"
  IF MYSCLN=0 THEN MYSCLN = HLDSCLN
  MYSCLD = MYSCLA
  IF XC = 8 THEN SIGNAL EXITRC_END
  SELECT
   WHEN MYSCLD = 'HALF' THEN DO
    SV = MYSCLN/2
    SH = MYAW/2
    END
   WHEN MYSCLD = 'PAGE' THEN DO
    SV = MYSCLN
    SH = MYAW
    END
   WHEN MYSCLD = 'MAX' THEN DO
    SV = MXLN
    SH = MXLNG
    END
   OTHERWISE DO
    IF DATATYPE(MYSRCD) \= 'NUM' THEN MYSCLD = 'PAGE'
     ELSE DO
     SV = MYSCLD
     SH = MYSCLD
     END
    END
   END
   IF CMD='HELP' | CMD='?' THEN DO
    CALL CEMHELP 'DSPLYA'
    CMD = ''
    SIGNAL DONE_CMD1
    END
   IF CMD='SAVE' | CMD='MOD' | CMD='APPEND' THEN DO
/*  TRACE ?I  */
    CALL SET_ODSN
    IF RC \= 0 | ODSN = '' THEN DO
     ZEDSMSG = 'SAVE DSN ERROR'
     ZEDLMSG = 'ERROR OCCURRED SETTING SAVE TO DSN.NOTHING SAVED'
     END
     ELSE DO
     M# = MYA.0
     MYSTM='MYA.'
     EMBR=APLNM
     TDSN = ODSN
     CALL SAVIT
     IF RESULT = 0 THEN DO
      ZEDSMSG = 'DATA SAVED'
      ZEDLMSG = 'DATASET SAVED AS DIRECTED'
      END
      ELSE DO
      ZEDSMSG = 'DATA NOT SAVED'
      ZEDLMSG = 'ERROR OCCURRED, OR ABORT SELECTED. NOTHING SAVED'
      END
     END
    CMD = ''
    "ISPEXEC SETMSG MSG(ISRZ001)"
    SIGNAL REDSPLY
    END
   IF CMD = 'CUT' | CMD = 'CUTA' THEN DO
    IF RESP \= '' THEN CUTV=RESP
     ELSE CUTV='DSPA'
    IF CMD='CUT' THEN DO
     CUTCNT=0
     END
    CALL CUTIT
    IF RESULT = 0 THEN DO
     ZEDSMSG = 'DATA 'CMD
     ZEDLMSG = 'DATA 'CMD' AS DIRECTED'
     END
     ELSE DO
     ZEDSMSG = 'DATA NOT 'CMD
     ZEDLMSG = 'ERROR OCCURRED, DATA WAS NOT 'CMD
     END
    CMD = ''
    "ISPEXEC SETMSG MSG(ISRZ001)"
    SIGNAL REDSPLY
    END
   IF CMD='OS2PW' | ABBREV('OS2PNTN',CMD,4) = 1 |,
      CMD='PMBRW' | ABBREV('PMBRN',CMD,4) = 1 THEN DO
    CALL OS2PNT
    XC=RESULT
    IF XC=0 THEN DO
     IF CMD = 'OS2PW' | CMD='PMBRW' THEN DO
      CALL JRPPNT 'JRPPNTW'
      XC=RESULT
      END
      ELSE DO
      IF CMD='PMBRC' THEN CALL JRPPNT 'JRPPNTC'
       ELSE CALL JRPPNT 'JRPPNT'
      XC=RESULT
      END
     END
     IF XC = 0 | XC > 20 THEN DO
      ZEDSMSG = 'DATA PRINTED 'XC
      ZEDLMSG = 'DATASET PRINTED AS DIRECTED TO JRP'XC
      END
      ELSE DO
      ZEDSMSG = 'DATA NOT PRINTED'
      ZEDLMSG = 'ERROR OCCURRED, OR ABORT SELECTED. NOTHING PRINTED.'
      END
/*   END    */
    CMD = ''
    "ISPEXEC SETMSG MSG(ISRZ001)"
    SIGNAL REDSPLY
    END
   IF CMD = 'PFAPNT'| CMD='PFAEDIT'  THEN DO
    'ISPEXEC VGET (EXECSEL FAIDODSN) ASIS'
    IF EXECSEL = 'PFA' & FAIDODSN \= '' THEN DO
     IF FAIDODSN = '' | FAIDODSN = 'FAIDODSN' THEN RESULT=4
      ELSE DO
       IF CMD='PFAPNT' THEN JRPPNT 'JRPPNT' FAIDODSN
       IF CMD='PFAEDIT' THEN ,
        "ISPEXEC EDIT DATASET ('"FAIDODSN"')"
       END
      END
     IF RESULT = 0 THEN DO
      ZEDSMSG = 'FAID PRINTED'
      ZEDLMSG = 'DATASET PRINTED AS DIRECTED'
      END
      ELSE DO
      ZEDSMSG = 'DATASET NOT PRINTED'
      ZEDLMSG = 'FAID DATASET COULD NOT BE PRINTED.'
      END
    CMD = ''
    "ISPEXEC SETMSG MSG(ISRZ001)"
    SIGNAL REDSPLY
    END
DONE_CMD1:
   IF CMD \= '' & MYVERB = '' THEN MYVERB=CMD
  IF MYVERB = 'TOP' THEN DO
   MYVERB = 'UP'
   MYSCLD = 'MAX'
   END
  IF MYVERB = 'BOT' THEN DO
   MYVERB = 'DOWN'
   MYSCLD = 'MAX'
   END
  SELECT
   WHEN MYVERB = '' THEN SIGNAL DSPLOOP1
   WHEN MYVERB = 'END' THEN SIGNAL EXITRC_END
   WHEN MYVERB = 'ABORT' THEN SIGNAL EXITRC_ABORT
   WHEN MYVERB = 'BYPASS' THEN SIGNAL EXITRC_BYPASS
   WHEN MYVERB = 'CANCEL' THEN SIGNAL EXITRC_ABORT
   WHEN MYVERB = 'LEFT' THEN DO
    IF MYSCLD \= 'MAX' THEN DO
     CURCL = CURCL-SH
     IF CURCL < 1 THEN CURCL=1
     SIGNAL DSPLOOP
     END
     ELSE DO
     CURCL = 1
     SIGNAL DSPLOOP
     END
    END
   WHEN MYVERB = 'RIGHT' THEN DO
    IF MYSCLD \= 'MAX' THEN DO
     CURCL = CURCL+SH
     IF CURCL > MXLNG THEN DO
      CURCL=(MXLNG-SH)+1
      IF CURCL < 1 THEN CURCL = 1
      END
     SIGNAL DSPLOOP
     END
     ELSE DO
     CURCL = MXLNG-MYAW+1
     IF CURCL < 1 THEN CURCL = 1
     SIGNAL DSPLOOP
     END
    END
   WHEN MYVERB = 'UP' THEN DO
    IF MYSCLD \= 'MAX' THEN DO
     CURLN = TOPLN - MYSCLN
     IF CURLN < 1 THEN CURLN=1
     SIGNAL DSPLOOP
     END
     ELSE DO
     CURLN = 1
     SIGNAL DSPLOOP
     END
    END
   WHEN WORD(MYVERB,1)='L' THEN DO
    IF WORDS(MYVERB) \= 2 THEN LEAVE
    TMPLN=WORD(MYVERB,2)
    IF DATATYPE(TMPLN) \= 'NUM' THEN LEAVE
    IF TMPLN < 1 THEN TMPLN = 1
     ELSE IF TMPLN > MXLN THEN TMPLN = MXLN
    CURLN = TMPLN
    SIGNAL DSPLOOP
    END
   WHEN MYVERB = 'DOWN' THEN DO
    IF MYSCLD \= 'MAX' THEN DO
     CURLN = TOPLN + MYSCLN
     IF CURLN > MXLN THEN CURLN = MXLN - MYSCLN + 1
     IF CURLN < 1 THEN CURLN = 1
     SIGNAL DSPLOOP
     END
     ELSE DO
     CURLN = MXLN-MYSCLN+1
     IF CURLN < 1 THEN CURLN=1
     SIGNAL DSPLOOP
     END
    END
   OTHERWISE DO
    ZEDSMSG = MYVERB" INVALID"
    ZEDLMSG = "INVALID COMMAND ENTERED. NORMAL NAVIGATE CMD"
    "ISPEXEC SETMSG MSG(ISRZ001)"
    END
   END
 REDSPLY:
  CURCL=TOPCL
  CURLN=TOPLN
  SIGNAL DSPLOOP
 EXITRC_END:
  XC = 0
  ZEDSMSG = "DATA DISP OK"
  ZEDLMSG = "DATA DISPLAYED FINISHED NORMALLY"
  SIGNAL WRITIT
 EXITRC_BYPASS:
  XC = 4
  ZEDSMSG = "BYPASS REST"
  ZEDLMSG = "DATA DISPLAYED BYPASS REST OF DATA"
  SIGNAL WRITIT
 EXITRC_ABORT:
  XC = 8
  ZEDSMSG = "DATA DISP ABORT"
  ZEDLMSG = "DATA DISPLAY ABORTED BY COMMAND"
  SIGNAL WRITIT
 WRITIT:
  "ISPEXEC SETMSG MSG(ISRZ001)"
  RETURN XC
 XSAVIT: PROCEDURE EXPOSE MYA. MXLNG EXECSEL CMD AUTOSAVE
  /* TRACE ?I */
  SAY 'XSAVIT ROUTINE SHOULD NEVER BE INVOKED'
  PULL ANS
  "ISPEXEC VGET (DSPLYADS EMBR) ASIS"
  IF RC \= 0 THEN DO
   EDSN=SYSVAR(SYSUID)'.'EXECSEL'.DATA'
   EMBR=''
   END
   ELSE EDSN=DSPLYADS
  IF AUTOSAVE = 'Y' THEN DO
   EDSN=DSPLYADS
   EMBR='$'
   TDSN=EDSN
   SIGNAL DO_AS
   END
  DSEMSG='ENTER TARGET DSN (NO MBR)'
  MYAT='INPUT'
  "ISPEXEC VPUT (EDSN EMBR DSEMSG MYAT) ASIS"
  CALL GDSNNMBR
  IF RESULT = 8 THEN RETURN 8
  "ISPEXEC VGET (EDSN EMBR) ASIS"
  IF RC \= 0 THEN RETURN
  EMBR=STRIP(EMBR,'B')
  XMBR = ''
  /* DSN COULD HAVE BEEN SPECIFIED AS DSN(MBR)
     OR THE DSN AND MBR INPUT IN PANEL FIELDS,
     OR (CONFUSED) BOTH (IN WHICH CASE WE TAKE THE DSN(MBR)
     FORMATED BECAUSE WE FIGURE IT WAS INTENTIONAL).
  */
  PARSE VAR EDSN EDSN '(' XMBR ')'
  TDSN=EDSN
  IF XMBR \= '' THEN EMBR = XMBR
DO_AS:
  IF EMBR = '$' THEN EMBR = EXECSEL
  /* SIMPLE CHECK TO INSURE DSN NOT MIGRATED */
  CALL MALOC TDSN
  XC=RESULT
  IF XC = 0 THEN SIGNAL CHKORG
  IF EMBR = '' THEN MYDSO='PS)'
   ELSE MYDSO='PO) DSNTYPE(LIBRARY)'
  MODDSN = ''
  IF MXLNG < 128 THEN MXLNG = 128
  M=MXLNG+4
  DSEMSG = '(D) DEL/REALLOC,(A) ABORT'
  MODATTR="NEW BLKSIZE("M+4") DSORG("MYDSO" RECFM(V,B) SPACE(1,1)"||,
   "CYLINDER LRECL("M") CATALOG REUSE"
  EDSN = TDSN
  ADDRESS ISPEXEC "VPUT (EDSN EXECSEL DSEMSG MODATTR MODDSN) ASIS"
  IF RC \= 0 THEN SIGNAL EXITRC_END
  CALL ALOCDSN
  XC = RESULT
  "ISPEXEC VGET (EDSN) ASIS"
  IF RC \= 0 THEN RETURN 4
  SIGNAL DOWRITE
 XCHKORG:
  XC=LISTDSI("'"TDSN"'" DIRECTORY NORECALL)
  MYDSO=SYSDSORG
  IF EMBR \= '' THEN DO
   IF MYDSO = 'PS' THEN SIGNAL BADOPDSNORG
   END
   ELSE DO
   IF MYDSO = PO THEN SIGNAL BADOPDSNORG
   IF AUTOSAVE = 'Y' THEN DSPVAL='MOD'
   END
  DOWRITE:
  /* TRACE ?I */
  DSPLYADS=EDSN
  "ISPEXEC VPUT (DSPLYADS EMBR) ASIS"
  IF EMBR \= '' THEN EDSN=TDSN||'('||EMBR||')'
  IF XC = 0 THEN DO
   M# = MYA.0
   MSTM='MYA.'
   IF CMD = 'MOD' | CMD = 'APPEND' THEN DSPVAL='MOD'
    ELSE DSPVAL='SHR REUSE'
   IF EMBR \= '' THEN DO
    IF DSPVAL = 'MOD' THEN DO
     DSPVAL='SHR REUSE'
     ADDRESS TSO "ALLOC FI(I) DA('"EDSN"') "DSPVAL
     ADDRESS TSO "EXECIO * DISKR I (STEM MYB. FINIS"
     ADDRESS TSO "FREE FI(I)"
     MSTM='MYB.'
     MB#=MYB.0
     DO I = 1 TO M#
      MB#=MB# + 1
      MYB.MB#=MYA.I
      END
     M#=MB#
     END
    END
   ADDRESS TSO "ALLOC FI(O) DA('"EDSN"') "DSPVAL
   ADDRESS TSO "EXECIO "M#" DISKW O (STEM "MSTM" FINIS"
   ADDRESS TSO "FREE FI(O)"
   AUTOSAVE = 'N'
   CALL MSGBOX 'DATA SAVED TO 'EDSN
   RETURN 0
  END
  RETURN XC
BADOPDSNORG:
   CALL MSGBOX 'SAVE TO DSN DSORG INCONSISTENT WITH EXISTING DSN'
   RETURN 4
OS2PNT: PROCEDURE EXPOSE SVC MYA. XC
 IF SVC ^> 0 THEN RETURN 4
 DO I = 1 TO SVC
  INTERPRET 'OS2C'||I'= MYA.I'
  'ISPEXEC VPUT (OS2C'I') ASIS'
  END
 MYCN = 'OS2C'
 OS2CTOT = SVC
  ZEDSMSG = "DATA PRINTED"
  ZEDLMSG = "DATA SENT TO PRINTER"
 "ISPEXEC SETMSG MSG(ISRZ001)"
 "ISPEXEC VPUT (MYCN OS2CTOT) ASIS"
 RETURN 0
CUTIT: PROCEDURE EXPOSE SVC MYA. CUTV CUTCNT XC
 IF SVC ^> 0 THEN RETURN 4
 CVSTR=''
 DO I = 1 TO SVC
  CUTCNT=CUTCNT+1
  INTERPRET CUTV||CUTCNT'= MYA.I'
  'ISPEXEC VPUT ('CUTV||CUTCNT') ASIS'
  END
  INTERPRET CUTV'TOT = CUTCNT'
 'ISPEXEC VPUT ('CUTV'TOT) ASIS'
 RETURN 0
###END DSPAFOH
$$$BEG AFOCTGJL
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA AFOCTGJL - RETURN LIST OF CTG REGIONS ACTIVE            */
 /* CEMHELP AFOCTGJL - ISPF BASED. RETURNS LIST OF CTG REGIONS      */
 /* CEMHELP  JOBNAMES BY REGION TYPE AND THE RESPECTIVE CPU 4 EACH  */
 /* CEMHELP  NORMAL JOBNAMES LIST BEGIN WITH 'CTG'                  */
 /* CEMHELP  ATTLS  JOBNAMES LIST BEGIN WITH 'ATG'                  */
 /* CEMHELP   VPUT (CTGDEVJL CTGTSTJL CTGPRDJL CTGLIST) ASIS        */
 /* CEMHELP   VPUT (ATGTSTJL ATGPRDJL ATGLIST) ASIS                 */
 /* CEMHELP  RESPECTIVE CPU LISTS                                   */
 /* CEMHELP   VPUT (CTGDEVCP CTGTSTCP CTGPRDCP CTGLISTP) ASIS       */
 /* CEMHELP   VPUT (AGTSTCP ATGPRDCP ATGLISTP) ASIS                 */
 /* CEMHELP  WHICH ARE ACTIVE ON SYSPLEX                            */
 /* CEMHELP          -                                              */
 /* CEMHELP END                                                     */
  ADDRESS TSO
 /*  TRACE ?I */
   MYAREA=''
   CTGDEVJL=''
   CTGDEVCP=''
   CTGTSTJL=''
   ATGTSTJL=''
   CTGTSTCP=''
   ATGTSTCP=''
   CTGPRDJL=''
   ATGPRDJL=''
   CTGPRDCP=''
   ATGPRDCP=''
   CTGLIST=''
   ATGLIST=''
   CTGLISTP=''
   ATGLISTP=''
   FFX = 'FF'X
   ARGLST='JOB(ODTG*) DDNAME(-) SDSFPNL(ST) VQMODE(QUIET)'
   CALL SFISKIXA ARGLST
   XC = RC
   PULL MYAREA
   IF MYAREA = '' THEN SIGNAL DOTST
   DO WHILE (MYAREA \= '')
    PARSE VAR MYAREA LNE (FFX) MYAREA
    IF WORDPOS('EXECUTION',LNE) = 0 THEN ITERATE
    IF WORDS(LNE) < 4 THEN ITERATE
    CTGDEVJL=CTGDEVJL||' '||WORD(LNE,1)
    CTGDEVCP=CTGDEVCP||' '||SUBSTR(WORD(LNE,4),1,1)
    END
   IF LENGTH(CTGDEVJL) = 0 THEN DO
    /* SAY 'NO DEV  CTG IN EXECUTION' */
    SIGNAL DOTST
    END
   CTGDEVJL=STRIP(CTGDEVJL,'B')
   CTGDEVCP=STRIP(CTGDEVCP,'B')
   MYAREA=''
 DOTST:
   ARGLST='JOB(OTGG*) DDNAME(-) SDSFPNL(ST) VQMODE(QUIET)'
   CALL SFISKIXA ARGLST
   XC = RC
   PULL MYAREA
   IF MYAREA = '' THEN SIGNAL DOTSTH
   DO WHILE (MYAREA \= '')
    PARSE VAR MYAREA LNE (FFX) MYAREA
    IF WORDPOS('EXECUTION',LNE) = 0 THEN ITERATE
    IF WORDS(LNE) < 4 THEN ITERATE
    CTGTSTJL=CTGTSTJL||' '||WORD(LNE,1)
    CTGTSTCP=CTGTSTCP||' '||SUBSTR(WORD(LNE,4),1,1)
    END
   IF LENGTH(CTGTSTJL) = 0 THEN DO
    /* SAY 'NO TEST CTG IN EXECUTION' */
    SIGNAL DOTSTH
    END
   CTGTSTJL=STRIP(CTGTSTJL,'B')
   CTGTSTCP=STRIP(CTGTSTCP,'B')
   MYAREA=''
 DOTSTH:
   ARGLST='JOB(OTGH*) DDNAME(-) SDSFPNL(ST) VQMODE(QUIET)'
   CALL SFISKIXA ARGLST
   XC = RC
   PULL MYAREA
   IF MYAREA = '' THEN SIGNAL DOPRD
   DO WHILE (MYAREA \= '')
    PARSE VAR MYAREA LNE (FFX) MYAREA
    IF WORDPOS('EXECUTION',LNE) = 0 THEN ITERATE
    IF WORDS(LNE) < 4 THEN ITERATE
    ATGTSTJL=ATGTSTJL||' '||WORD(LNE,1)
    ATGTSTCP=ATGTSTCP||' '||SUBSTR(WORD(LNE,4),1,1)
    END
   IF LENGTH(CTGTSTJL) = 0 THEN DO
    /* SAY 'NO TEST CTG IN EXECUTION' */
    SIGNAL DOPRD
    END
   ATGTSTJL=STRIP(ATGTSTJL,'B')
   ATGTSTCP=STRIP(ATGTSTCP,'B')
   MYAREA=''
 DOPRD:
   ARGLST='JOB(OPGG*) DDNAME(-) SDSFPNL(ST) VQMODE(QUIET)'
   CALL SFISKIXA ARGLST
   XC = RC
   PULL MYAREA
   IF MYAREA = '' THEN SIGNAL DOPRDH
   DO WHILE (MYAREA \= '')
    PARSE VAR MYAREA LNE (FFX) MYAREA
    IF WORDPOS('EXECUTION',LNE) = 0 THEN ITERATE
    IF WORDS(LNE) < 4 THEN ITERATE
    CTGPRDJL=CTGPRDJL||' '||WORD(LNE,1)
    CTGPRDCP=CTGPRDCP||' '||SUBSTR(WORD(LNE,4),1,1)
    END
   IF LENGTH(CTGPRDJL) = 0 THEN DO
/*  SAY 'NO PROD CTG IN EXECUTION' */
    SIGNAL DOPRDH
    END
   CTGPRDJL=STRIP(CTGPRDJL,'B')
   CTGPRDCP=STRIP(CTGPRDCP,'B')
 DOPRDH:
   ARGLST='JOB(OPGH*) DDNAME(-) SDSFPNL(ST) VQMODE(QUIET)'
   CALL SFISKIXA ARGLST
   XC = RC
   PULL MYAREA
   IF MYAREA = '' THEN SIGNAL DONEIT
   DO WHILE (MYAREA \= '')
    PARSE VAR MYAREA LNE (FFX) MYAREA
    IF WORDPOS('EXECUTION',LNE) = 0 THEN ITERATE
    IF WORDS(LNE) < 4 THEN ITERATE
    ATGPRDJL=ATGPRDJL||' '||WORD(LNE,1)
    ATGPRDCP=ATGPRDCP||' '||SUBSTR(WORD(LNE,4),1,1)
    END
   IF LENGTH(CTGPRDJL) = 0 THEN DO
/*  SAY 'NO PROD CTG IN EXECUTION' */
    SIGNAL DONEIT
    END
   ATGPRDJL=STRIP(ATGPRDJL,'B')
   ATGPRDCP=STRIP(ATGPRDCP,'B')
 DONEIT:
   CTGLIST = CTGDEVJL||' '||CTGTSTJL||' '||CTGPRDJL
   ATGLIST = ATGTSTJL||' '||ATGPRDJL
   CTGLISTP = CTGDEVCP||' '||CTGTSTCP||' '||CTGPRDCP
   ATGLISTP = ATGTSTCP||' '||ATGPRDCP
   ADDRESS ISPEXEC 'VPUT (CTGDEVJL CTGTSTJL CTGPRDJL CTGLIST) ASIS'
   ADDRESS ISPEXEC 'VPUT (ATGTSTJL ATGPRDJL ATGLIST) ASIS'
   ADDRESS ISPEXEC 'VPUT (CTGDEVCP CTGTSTCP CTGPRDCP CTGLISTP) ASIS'
   ADDRESS ISPEXEC 'VPUT (ATGTSTCP ATGPRDCP ATGLISTP) ASIS'
   RETURN 0
###END AFOCTGJL
$$$BEG RDOPROC
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA RDOPROC  - PROCESS RDO OBJECTS.DIR,RECON,RESCOMP,GRPCOMP*/
 /* CEMHELP RDOPROC  - TSO BASE, EXEC WILL PRODUCE A SIDE BY SIDE   */
 /* CEMHELP          - REPORT ON 1 OR 2 RDO OBJECTS (SEE BELOW).    */
 /* CEMHELP          - VERSION 1.2                                  */
 /* CEMHELP          -  ADDED LOGIC TO IGNORE RDO CHANGE DATE....   */
 /* CEMHELP          - FUNTIONS AVAILABLE:                          */
 /* CEMHELP          - DIR IS ALWAYS PRODUCED AND IS A CONDENSED    */
 /* CEMHELP          -  LIST OF THE RDO OBJECT(S).                  */
 /* CEMHELP          - RECON LOOKS WITHIN EACH RDO OBJECT(S) AND    */
 /* CEMHELP          -  REPORTS ON DUPLICATE DEFINITIONS AND THEIR  */
 /* CEMHELP          -  RESPECTIVE GROUP.                           */
 /* CEMHELP          - RESCOMP REQUIRES 2 RDO OBJECTS AND WILL      */
 /* CEMHELP          -  MATCH UP RESOURCE DEFINITIONS BY TYPE AND   */
 /* CEMHELP          -  BY NAME, THEN DOING A PARAMETER BY PARAMETER*/
 /* CEMHELP          -  COMPARISON, REPORTING ONLY DIFFERENCES.     */
 /* CEMHELP          - GRPCOMP EXPECTS  2 RDO GROUP NAMES WHICH ARE */
 /* CEMHELP          -  APPENDED INSIDE BRACKETS TO EACH OF THE TOR */
 /* CEMHELP          -  AND TO THE AOR INPUT DSNAMES (PARM2 PARM3)  */
 /* CEMHELP          -  FOR EXAMPLE: GRPCOMP TOR.DSN<G1> AOR.DSN<G2>*/
 /* CEMHELP          -  USING RESSOURCE NAME, COMPARE EACH PARAMETER*/
 /* CEMHELP          -  G1 AGAINST G2, REPORTING ONLY DIFFERENCES.  */
 /* CEMHELP          - *SUFFIX ANY FUNCTIONS (EXCEPT 'DIR') WITH    */
 /* CEMHELP          -   'ONLY' TO ELIMINATE THE DIR REPORT.        */
 /* CEMHELP          -  RECONONLY RESCOMPONLY OR GRPCOMPONLY        */
 /* CEMHELP          -  THE APPEARENCE OF THE 'ONLY' SUFFIX WILL    */
 /* CEMHELP          -  INSURE THAT ONLY THAT REPORT IS PRODUCED.   */
 /* CEMHELP          -  FOR RECONONLY AND RESCOMPONLY, THE DIR      */
 /* CEMHELP          -  IS OMITTED.                                 */
 /* CEMHELP          -  FOR RESCOMPONLY AND RECONONLY, ONLY ERRORS  */
 /* CEMHELP          -  (DIFFERENCES) WILL BE REPORTED.             */
 /* CEMHELP          -  FOR THE DIRONLY REPORT, ONLY THOSE RESOURCES*/
 /* CEMHELP          -  PROVIDED FOR IN THE OPTIONAL SUBPARM WILL BE*/
 /* CEMHELP          -  PRODUCED, OR THE DEFAULT SUBPARM.           */
 /* CEMHELP          -  THE INTENTION IS TO REDUCE THE OUTPUT THAT  */
 /* CEMHELP          -  IS CREATED.                                 */
 /* CEMHELP          - EXEC REQUIRES FOUR PARMS                     */
 /* CEMHELP          - FIRST PARM DIRECTS THE FUNCTION AND OPTIONAL */
 /* CEMHELP          -  DIR PARAMETER LISTING.                      */
 /* CEMHELP          -  VALID FUNCTIONS ARE DIR RECON RESCOMP GRPCOMP*/
 /* CEMHELP          -  DIRONLY RECONONLY RESCOMPONLY GRPCOMPONLY   */
 /* CEMHELP          -  OPTIONAL VALUES ARE SPECIFIED IN BRACKETS <>*/
 /* CEMHELP          -  AND IMMEDIATELY FOLLOW THE FUNCTION(NOSPACE)*/
 /* CEMHELP          -  THE PARAMETER VALUES ARE SPECIFIC RDO TYPES */
 /* CEMHELP          -  (DFT:PROGRAM TRANSACTION PROFILE CONNECTION)*/
 /* CEMHELP          -  FOLLOWED BY A LIST OF SUBPARMS ENCLOSED IN  */
 /* CEMHELP          -  PARENTHESIS  FOR EXAMPLE                    */
 /* CEMHELP          -   DIR<PROGRAM(LANGUAGE) FILE(STRINGS)>       */
 /* CEMHELP          -   RECON<TRANSACTION(TCLASS PROGRAM)>         */
 /* CEMHELP          -   COMPARE<PROFILE(MSGINTEG SCRNSIZE)>        */
 /* CEMHELP          -  THE OPTIONAL PARMS WILL PRODUCE A LIST OF   */
 /* CEMHELP          -  SUBPARM VALUES FOR EACH RESOURCE ENCOUNTERED*/
 /* CEMHELP          -  AND THEY ARE INCLUDED IN THE DIR REPORT     */
 /* CEMHELP          -  (WHICH IS ALWAYS INCLUDED). IF OPTIONAL PARM*/
 /* CEMHELP          -  IS OMITTED, THEN DEFAULTS WILL REPORT.      */
 /* CEMHELP          -                                              */
 /* CEMHELP          - 2ND PARM, FIRST RDO GROUP DSN (KNOWN AS TOR) */
 /* CEMHELP          -                                              */
 /* CEMHELP          - 3RD PARM, SECOND RDO GROUP DSN (KNOWN AS AOR)*/
 /* CEMHELP          - (OPTIONAL) TO OMIT, CODE '()' E.G. EMPTY     */
 /* CEMHELP          -                                              */
 /* CEMHELP          - OPLOG DSN OR 'DISPLAY' TO SHOW RESULTS BACK  */
 /* CEMHELP          - TO THE SCREEN, OR 'RETURN' TO PUSH THE REPORT*/
 /* CEMHELP          - ONTO THE STACK, EACH LINE SEPARATED BY 'FF'X */
 /* CEMHELP          -  IF DSN PROVIDED, IT WILL BE ALOCATED OR     */
 /* CEMHELP          -  PROMPT FOR REUSE.  ALSO SUFFIX DSN WITH     */
 /* CEMHELP          -  OPTIONAL EDIT OR BROWSE COMMAND, ENCLOSED   */
 /* CEMHELP          -  IN '<..>'  E.G. MY.DSN<EDIT>                */
 /* CEMHELP          -                                              */
 /* CEMHELP          - NOTES                                        */
 /* CEMHELP          - V1.2 ADDED LOGIC TO IGNORE CICS 5.1          */
 /* CEMHELP          - DEFINETIME CHANGETIME CHANGEUSRID            */
 /* CEMHELP          - CHANGEAGENT CHANGEAGREL                      */
 /* CEMHELP          -  IF YOU WANT THIS DATA, APPEND 'RCD'         */
 /* CEMHELP          -   (REPORT CHANGE DATA) TO THE FUNC REQUEST   */
 /* CEMHELP          -   E.G. DIRRCD ...                            */
 /* CEMHELP          -        GRPCOMPONLYRCD ...                    */
 /* CEMHELP          - DIR FORMAT IS CONCISE LIST OF ONLY DEFINE    */
 /* CEMHELP          - TYPES AND ENTRY NAMES UNDER THE TYPE.        */
 /* CEMHELP          - ADDITIONAL ENTRY TYPE INFO IS ADDED FOR EACH */
 /* CEMHELP          - RESOURCE TYPE AS PROVIDED FOR IN THE OPTIONAL*/
 /* CEMHELP          - SUBPARM REQUEST (SEE ABOVE).                 */
 /* CEMHELP          - DIR IS ALWAYS PRODUCED UNLESS ONLY SUFFIX IS */
 /* CEMHELP          - ADDED TO THE 1ST PARM.  NOTE THAT DIRONLY IS */
 /* CEMHELP          - VALID AND IMPLIES THAT ONLY CRITERIA SELECTED*/
 /* CEMHELP          - VIA BRACKETS ARE REPORTED UPON.              */
 /* CEMHELP          - RESCOMP FORMAT IS A RESOURCE TYPE ENTRY      */
 /* CEMHELP          - COMPARE BY   EXACT ENTRY NAME, OF THE FIRST  */
 /* CEMHELP          - COMPARED TO THE SECOND.  DUPLICATE ENTRIES   */
 /* CEMHELP          - WILL COMPARE ON ONLY THE LAST OCCURANCE IN   */
 /* CEMHELP          - RDO OBJECT LIST. EACH ENTRY ACKNOWLEDGED. ANY*/
 /* CEMHELP          - PARMS WHICH COMPARE DIFFERENT WILL RESULT IN */
 /* CEMHELP          - ADDITIONL LOG ITEMS TO IDENTIFY THE DIFFERENC*/
 /* CEMHELP          - IN VALUES.  THEN DIR REPORT IS AUTOMATICALLY */
 /* CEMHELP          - INCLUDED.                                    */
 /* CEMHELP          - THE RECON FUNCTION IS A INTERNAL COMPARISON  */
 /* CEMHELP          - WITHIN EACH RDO OBJECT LIST. THE COMPARISON  */
 /* CEMHELP          - ATTEMPTS TO REPORT BACK GROUP NAMES WHERE    */
 /* CEMHELP          - DUPLICATE RESOURCE TYPE AND RESOURCE NAME IS */
 /* CEMHELP          - ENCOUNTERED. THE REPORT IS PRODUCED FOR EACH */
 /* CEMHELP          - RDO OBJECT FILE.                             */
 /* CEMHELP          -                                              */
 /* CEMHELP          - 'RDO OBJECTS' -                              */
 /* CEMHELP          - THE TWO RDO GROUP DSN MUST ACTUALLY BE IN A  */
 /* CEMHELP          - 'EXTENDED' FORMAT.  THIS FORMAT IS PRODUCED  */
 /* CEMHELP          - BY THE RDOXTND  CLIST.  GENERALLY, THIS MEANS*/
 /* CEMHELP          - THAT THE REAL RDO GROUP HAS BEEN EXTRACTED   */
 /* CEMHELP          - TO A LRECL(80) PDS, AND THEN RDOXTND  IS     */
 /* CEMHELP          - RUN TO 'EXTEND' EACH MULTI LINE EXTRACTED    */
 /* CEMHELP          - DEFINITION INTO A SINGLE LINE.  THE RDOXTND  */
 /* CEMHELP          - CLIST WRITES THE OUTPUT TO A VARIABLE BLOCK  */
 /* CEMHELP          - SEQUENTIAL DSN WITH DSN FINAL QUALIFIER IS   */
 /* CEMHELP          - THE MEMBER NAME OF THE PDS MEMBER HOLDING    */
 /* CEMHELP          - EXTRACTED RDO GROUP SOURCE.                  */
 /* CEMHELP          - THE SECOND DSN CAN BE OMITTED USING '()' AS  */
 /* CEMHELP          - THE PLACEHOLDER.                             */
 /* CEMHELP          - THE TOR OR AOR DSN CAN BE THE SAME DSN.  IN  */
 /* CEMHELP          - ORDER TO ABBREVIATE THE SECOND AOR DSN TO    */
 /* CEMHELP          - DEFAULT TO THE FIRST TOR, YOU CAN PROVIDE AN */
 /* CEMHELP          - '*' AS THE SECOND.  THIS DIFFERS FROM '()'   */
 /* CEMHELP          - AS THE AOR WHICH INDICATES NO SECOND DSN.    */
 /* CEMHELP          - IN ORDER TO LIMIT THE EXEC FROM PROCESSING   */
 /* CEMHELP          - AN ENTIRE DSN COMPARE, YOU CAN USE SOME ADD- */
 /* CEMHELP          - ITIONAL NOTATION, AS FOLLOWS. THE TOR AND AOR*/
 /* CEMHELP          - DSN CAN BE DELIMITED WITH A SUFFIX WHICH CAN */
 /* CEMHELP          - BE USED TO FORCE THE EXEC TO SEE ONLY CERTAIN*/
 /* CEMHELP          - RDO GROUPS.  THIS IS ACCOMPLISHED BY CODING A*/
 /* CEMHELP          - SUFFIX IN WHICH GROUP NAMES ARE ENCLOSED IN  */
 /* CEMHELP          - '<..>' EG: YOUR.TOR.DSN<TRDOG1 TRDOG2>       */
 /* CEMHELP          -         YOUR.AOR.DSN<ARDOG1 ARDOG2>          */
 /* CEMHELP          - THE ABOVE WILL PROCESS THE TOR GROUP AGAINST */
 /* CEMHELP          - THE AOR GROUPS IN THE ORDER OF SEQUENCE.  THE*/
 /* CEMHELP          - NUMBER OF GROUPS MUST BE EQUAL.  IF YOU WISH */
 /* CEMHELP          - TO ABBREVIATE A PROCESS WHERE THE GROUPS     */
 /* CEMHELP          - ARE WITHIN THE SAME RDO DSN, YOU CAN CODE:   */
 /* CEMHELP          -         YOUR.TOR.DSN<RDOG1 RDOG2 RDOG3>      */
 /* CEMHELP          -          <RDOG4 RDOG5 RDOG6>                 */
 /* CEMHELP          - IF THE RDO GROUP NAMES ARE THE SAME BETWEEN  */
 /* CEMHELP          - AN TOR AND AOR DSN PROCESS, CODE AS FOLLOWS: */
 /* CEMHELP          -         YOUR.TOR.DSN<RDOG1 RDOG2>            */
 /* CEMHELP          -         YOUR.AOR.DSN<*>                      */
 /* CEMHELP          - THE <*> COMMANDS THE PROCESS TO CONSIDER THE */
 /* CEMHELP          - LIKE NAMED GROUPS FROM THE TOR AND AOR.      */
 /* CEMHELP          - OBVIOUSLY, THE TOR AND AOR DSN WILL NOT BE   */
 /* CEMHELP          - THE SAME USING THIS FORMAT.                  */
 /* CEMHELP          - ONE LAST EXAMPLE:                            */
 /* CEMHELP          -         YOUR.AOR.DSN(SOMEMBR)<RDOG1>         */
 /* CEMHELP          -          *(OTHERMBR)<*>                      */
 /* CEMHELP          - THIS IS A VB PDS IN WHICH SOMEMBR IS PROCESSD*/
 /* CEMHELP          - AGAINST OTHERMBR FOR THE SAME RDO GROUP.     */
 /* CEMHELP          -                                              */
 /* CEMHELP          - THE OUTPUT FROM ANY    FUNCTIONS IS TESTED   */
 /* CEMHELP          - TO INSURE IT'S TOTAL LENGTH IS LESS THAN 32K.*/
 /* CEMHELP          - IF IT IS GREATER THAN 32K (409 OUTPUT LINES) */
 /* CEMHELP          - THE DISPLAY OPTION WILL NOT BE ALLOWED, AND  */
 /* CEMHELP          - YOU ARE PROMPTED FOR A DSN TO SAVE THE DATA. */
 /* CEMHELP          -                                              */
 /* CEMHELP END                                                     */
 /* %%% */
  ADDRESS TSO
CALL ON ERROR NAME ERRX
SIGNAL ON SYNTAX NAME SYNX
CALL ON FAILURE NAME FAIX
CALL ON HALT NAME HALX
  OPC=12    /* FIRST REPORT INFO STARTS AT LINE 12*/
  OP_1ST=OPC
  ARG FUNC TOR AOR OPLOG TFLG
  IF FUNC='' | FUNC = '?' THEN SIGNAL SHOWFRMT
  IF TOR='' THEN SIGNAL SHOWFRMT
  IF AOR='' THEN SIGNAL SHOWFRMT
  IF OPLOG='' THEN SIGNAL SHOWFRMT
  TFOPTS='TRACE TRACE(ON) TRON ON'
  IF TFLG ^= '' THEN DO
   IF WORDPOS(TFLG,TFOPTS) ^= 0 THEN TRACE I
   END
  IF FUNC = '' THEN SIGNAL SHOWFRMT
  EXECSEL='RDOPROC'
  ADDRESS ISPEXEC 'VPUT (EXECSEL) ASIS'
  OP.1='$$ START FUNC :'FUNC
  OP.2='   TOR DSN    :'TOR
  OP.3='   AOR DSN    :'AOR
  OP.4='   OPLOG      :'OPLOG
  OP.5='   TFLG       :'TFLG
  SUBFUNC=''
  /* RDO CHANGE DATA (RCD) */
  RCD='N'
  RCD_WDS='DEFINETIME CHANGETIME CHANGEUSRID '||,
         'CHANGEAGENT CHANGEAGREL'
  RCD_WDS_CT = WORDS(RCD_WDS)
  PARSE VAR FUNC FUNC '<' DIRPRMS '>' .
  RCDP = POS('RCD',FUNC)
  IF RCDP \= 0 THEN DO
   RCD='Y'
   OP.11 = 'RDO CHANGE DATA (RCD) FUNCTION SUFFIX SPECIFIES INCLUDE '||,
          'CHANGE DATA.'
   FUNC=SUBSTR(FUNC,1,RCDP-1)
   END
   ELSE DO
   OP.11 = 'RDO CHANGE DATA (RCD) FUNCTION SUFFIX OMITTED. CHANGE '||,
          'DATA REMOVED.'
   END
  ONLYP = POS('ONLY',FUNC)
  IF ONLYP ^= 0 THEN DO
   FUNC = SUBSTR(FUNC,1,ONLYP-1)
   SUBFUNC='ONLY'
   END
   ELSE DO
   ONLYP = POS('SUM',FUNC)
   IF ONLYP ^= 0 THEN DO
    FUNC = SUBSTR(FUNC,1,ONLYP-1)
    SUBFUNC='SUM'
    END
   END
 /*  TRACE I */
  IF FUNC^='DIR' & FUNC^='RESCOMP' & FUNC^='RECON' &,
     FUNC^='GRPCOMP' THEN SIGNAL SHOWFRMT
  PARSE VAR TOR TOR '<' TGLIST '>'
  PARSE VAR TOR TOR '(' TGN ')'
  XC=LISTDSI("'"TOR"'" NORECALL)
  IF XC ^= 0 THEN SIGNAL SHOWFRMT
  IF SYSBLKSIZE=80 | POS('V',SYSRECFM)=0  THEN SIGNAL SHOWFRMTDS
  IF AOR = '""' | AOR = "''" | AOR = '()' THEN DO
   AOR = ''
   AGLIST=''
   NAGLIST=0
 /*  SIGNAL BYGTST */
   END
  PARSE VAR AOR AOR '<' AGLIST '>'
  PARSE VAR AOR AOR '(' AGN ')'
  TGLIST=TRANSLATE(TGLIST,' ',',')
  AGLIST=TRANSLATE(AGLIST,' ',',')
  NTGLIST=WORDS(TGLIST)
  NAGLIST=WORDS(AGLIST)
  IF NTGLIST = 0 THEN DO
   OPC=OPC+1
   OP.OPC=' ALL TOR GROUPS REQUESTED.'
   SAY OP.OPC
   END
  IF AOR = '*' THEN DO
   AOR = TOR
   AGLIST = TGLIST
   NAGLIST=NTGLIST
   END
  IF NAGLIST = 0 THEN DO
   OPC=OPC+1
   OP.OPC=' ALL AOR GROUPS REQUESTED.'
   SAY OP.OPC
   END
   ELSE DO
   IF AOR ^= '' THEN DO
    XC=LISTDSI("'"AOR"'" NORECALL)
    IF XC ^= 0 THEN SIGNAL SHOWFRMT
    IF SYSBLKSIZE=80 | POS('V',SYSRECFM)=0 THEN SIGNAL SHOWFRMTDS
    END
   END
  IF AGLIST = '*' THEN DO
   END
  IF TOR ^= AOR THEN DSNSAME=0
   ELSE DO
    IF TGN = AGN & TGN ^= '' THEN SIGNAL DSNSAME8
    DSNSAME=1
    END
  OPC=OPC+1
  OP.OPC='* TOR DSN ='TOR
  OPC=OPC+1
  OP.OPC='* AOR DSN ='AOR
  OPC=OPC+1
  OP.OPC='* FUNCTION REQUEST:'FUNC' 'SUBFUNC
  IF FUNC ^= 'RESCOMP' & FUNC ^= 'GRPCOMP' THEN SIGNAL BYGTST
  IF NAGLIST > 0 THEN DO
   OPC=OPC+1
   TMPLIT = ' GROUPS REQUESTED = '
   OP.OPC='* NUMBER TOR'||TMPLIT||NTGLIST||', '||,
          ' NUMBER AOR'||TMPLIT||NAGLIST
   OPC=OPC+1
   OP.OPC='  TOR GROUP REQUESTS:'
   OPC=OPC+1
   OP.OPC='      '||TGLIST
   OPC=OPC+1
   OP.OPC='  AOR GROUP REQUESTS:'
   OPC=OPC+1
   OP.OPC='      '||AGLIST
   END
  IF DSNSAME=1 THEN DO
   IF NTGLIST = 0 | NAGLIST = 0 THEN SIGNAL DSNSAME8
   DO I = 1 TO NTGLIST
    TMPTWD=WORD(NTGLIST,I)
    DO J = 1 TO NAGLIST
     AMPTWD=WORD(NAGLIST,J)
     IF TMPTWD = AMPTWD THEN DO
      SAY ' ERROR. SAME TOR AND AOR DSN: SAME GROUP 'TMPTWD
      SIGNAL DSNSAME8
      END
     END
    END
   END
 BYGTST:
  SUDT=DATE('U')
  STTM=TIME()
  IF DSNSAME = 0 THEN SIGNAL NOMBRCK
  PARSE VAR TOR TDSN '(' TGN ')'
  PARSE VAR AOR ADSN '(' AGN ')'
  IF TGN = AGN & TGN ^= '' THEN SIGNAL DSNSAME8
 NOMBRCK:
  OP.6='FUNCTION REQUESTED:'FUNC' 'SUBFUNC
  OP.7='START RDOPROC ON 'SUDT' AT 'STTM' FOR FUNCTION 'FUNC' 'SUBFUNC
  OP.8='      TOR DSN:'TOR
  IF AOR = '' THEN OP.9='      AOR DSN:*AOR DSN* NOT PROVIDED'
   ELSE OP.9='      AOR DSN:'AOR
  PARSE VAR OPLOG OPLOG '<' DSNACTN '>'
  IF LENGTH(OPLOG) < 8 & LENGTH(DSNACTN) > 8 THEN DO
   TMP=OPLOG
   OPLOG=DSNACTN
   DSNACTN=TMP
   END
  OP.10='  OP LOG DEST:'OPLOG
  OP.12=' '  /* ERROR MESSAGE RECORD */
  DO O_I = 1 TO OP_1ST
  SAY OP.O_I
  END
  "ALLOC FI(I) DA('"TOR"') SHR"
  "EXECIO * DISKR I (STEM TL. FINIS"
  "FREE FI(I)"
  TCT=TL.0
  IF RCD = 'N' THEN DO
 /* LOOK FOR FIRST OCCURANCE OF DEFINETIME
    DELETE FROM THAT POS TO THE END TO REMOVE THE RCD_WDS */
   IGNR_WD = WORD(RCD_WDS,1)    /* DEFINETIME IS ALWAYS FIRST */
   DO I = 1 TO TCT
    TMP = TL.I
    IWPOS = 0
    DO II = 1 TO RCD_WDS_CT
     IWPOS=POS(WORD(RCD_WDS,II),TMP)
     IF IWPOS > 0 THEN LEAVE II
     END
    IF IWPOS = 0 THEN ITERATE
    TL.I = SUBSTR(TMP,1,IWPOS-1)
    END
   END
 /* REMOVE RCD_WDS FROM AOR RECORDS */
  AL.0=0
  IF AOR ^= '' THEN DO
   "ALLOC FI(I) DA('"AOR"') SHR"
   "EXECIO * DISKR I (STEM AL. FINIS"
   "FREE FI(I)"
   ACT=AL.0
   IF RCD = 'N' THEN DO
  /* LOOK FOR FIRST OCCURANCE OF DEFINETIME
     DELETE FROM THAT POS TO THE END TO REMOVE THE RCD_WDS */
    IGNR_WD = WORD(RCD_WDS,1)    /* DEFINETIME IS ALWAYS FIRST */
    DO I = 1 TO ACT
     TMP = AL.I
    IWPOS = 0
    DO II = 1 TO RCD_WDS_CT
     IWPOS=POS(WORD(RCD_WDS,II),TMP)
     IF IWPOS > 0 THEN LEAVE II
     END
     IF IWPOS = 0 THEN ITERATE
     AL.I = SUBSTR(TMP,1,IWPOS-1)
     END
    END
   END
  FFX='FF'X
  FEX='FE'X
  TRACE OFF
 /* TOR AOR AND GLOBAL WORD LISTS KEEP TRACK OF RESOURCE TYPES */
  TWL=''
  AWL=''
  GWL=''
 /* TOR AOR AND GLOBAL NUMBER WORDS KEEPS COUNT OF WORDS ON _WL */
  NTW=0
  NAW=0
  NGW=0
 /* TOR AOR AND GLOBAL WORD LISTS KEEP TRACK OF GROUP NAMES */
  TLL=''
  ALL=''
  GLL=''
 /* TOR AOR AND GLOBAL WORD LISTS KEEP TRACK OF GROUP NAMES */
  GNRT=''
  I=1
  PT='T'
  RTSS = ''
  IF DIRPRMS = '' THEN DO
   RTSS='TRANSACTION PROFILE TERMINAL CONNECTION FILE'
   NRTSW=WORDS(RTSS)
   RCSS.TRAN = 'PROGRAM PROFILE TCLASS'
   NRC.TRAN=WORDS(RCSS.TRAN)
   RCSS.PROF = 'SCRNSIZE'
   NRC.PROF=WORDS(RCSS.PROF)
   RCSS.TERM = 'NETNAME TYPETERM'
   NRC.TERM=WORDS(RCSS.TERM)
   RCSS.CONN = 'NETNAME ACCESSMETHOD'
   NRC.CONN=WORDS(RCSS.CONN)
   RCSS.FILE = 'LSRPOOLID STRINGS OPENTIME'
   NRC.FILE=WORDS(RCSS.FILE)
   SIGNAL STLOOP
   END
  HDIRPRMS=DIRPRMS
  IF POS('.',DIRPRMS) ^= 0 THEN DO
   IF SYSDSN("'"DIRPRMS"'") ^= 'OK' THEN SIGNAL SHOWFRMT
   "ALLOC FI(PRMS) DA('"DIRPRMS"') SHR REUSE"
   "EXECIO * DISKR PRMS (STEM PRM. FINIS"
   "FREE FI(PRMS)"
   DIRPRMS=''
   PCT=PRM.0
   DO I = 1 TO PCT
    DIRPRMS=DIRPRMS||PRM.I||' '
    END
   IF DIRPRMS = '' THEN RTSS='NONE'
   END
   ELSE DO
   DIRPRMS=TRANSLATE(DIRPRMS,' ',',')
   END
  IF DIRPRMS = '*' | DIRPRMS = 'ALL' THEN DO
   RTSS = 'ALL'
   RTSS_T=''
   RTSS_A=''
   RCSS.ALL = 'ALL'
   NCR.ALL = '0'
   SIGNAL STLOOP
   END
  DO WHILE(DIRPRMS^='')
   PARSE VAR DIRPRMS RTVAR '(' RTVAL ')' DIRPRMS
   RTVAR=STRIP(RTVAR,'L')
   IF WORDPOS(RTVAR,RTSS) = 0 THEN RTSS=RTSS||' '||RTVAR
   RTVAR=SUBSTR(RTVAR,1,4)
   RTVAL=STRIP(RTVAL,'B')
   INTERPRET 'RCSS.'RTVAR' = RTVAL'
   INTERPRET 'NRC.'RTVAR' = WORDS(RCSS.'RTVAR')'
   END
 STLOOP:
  TRACE OFF
  RTSS=STRIP(RTSS,'B')
  OPC=OPC+1
  OP.OPC=PT'OR DIR REPORTING ON>'||RTSS||'<'
  SAY OP.OPC
  HDIRPRMS=RTSS
  MXHL=125
  I=0
  INTERPRET 'LCT='PT'CT'
  OPC=OPC+1
  OP.OPC='DIRECTORY BUILD PROCESS FOR 'PT'OR IN PROGRESS...'
  SAY OP.OPC
  INTERPRET 'TGL = 'PT'GLIST'
  ICT=100
  P_WARN.T=''
  P_WARN.A=''
 TOPOFLOP:
  I=I+1
  IF I>ICT THEN DO
   SAY I
   ICT=ICT+100
   END
  IF I>LCT THEN SIGNAL OUTOFLOP
  INTERPRET "TMP="PT"L.I||' '"
  IF WORD(TMP,1) ^= 'DEFINE' THEN DO
   CALL UNKNREC
   SIGNAL TOPOFLOP
   END
  PARSE VAR TMP 'DEFINE' RT '(' RC# ') ' TMP
  RT=STRIP(RT,'B')
  IF SYMBOL(RC#) = 'BAD' THEN DO
   INTERPRET "P_W_WP=WORDPOS(RT,P_WARN."PT")"
   IF P_W_WP = 0 THEN DO
    INTERPRET "P_WARN."PT"."RT" = ''"
    INTERPRET "P_WARN."PT"=P_WARN."PT"||' '||RT"
    END
   RC#N=TRANSLATE(RC#,'_?__','-,/^')
   XCHG='('||RC#||'|'||RC#N||')'
   INTERPRET "P_WARN."PT"."RT" = P_WARN."PT"."RT"||' '||XCHG"
/* OPC=OPC+1
   OP.OPC='* PROCESS WARNING. ENCOUNTERED 'RT'('RC#') CHANGED TO 'RC#N
   */
   RC#=RC#N
   END
/* RT IS RESOURCE TYPE E.G. FILE TRANSACTION PROGRAM... */
/* RTA IS ABBREV 4 CHAR RESOURCE TYPE E.G. FILE TRAN PROG... */
/* RC# RECORDS THE ACTUAL RESOURCE NAME FOR THE INPUT RECORD */
/* RTSS_T AND RTSS_A WILL ACCUMULATE A LIST OF RESORURCE TYPE*/
/*  AND THE SET OF RDO ATTIBUTES ASSOCIATED WITH EACH RESTYPE*/
/* TRACE I */
  RT=STRIP(RT,'B')
  RTA=SUBSTR(RT,1,4)
  RC#=STRIP(RC#,'B')
  IF RT = '' | RC# = '' THEN DO
   CALL UNKNREC
   SIGNAL TOPOFLOP
   END
  IF RTSS = 'ALL' THEN DO
   INTERPRET 'RTSSTMP =  RTSS_'PT
   IF WORDPOS(RT,RTSSTMP) = 0 THEN DO
 /* TRACE I */
    CALL GET_RTSS_PAMS
    XX = RESULT
    END
   END
  /* PROCESS THE GROUP NAME */
  PARSE VAR TMP 'GROUP(' GNM ') ' .
  IF GNM = '' THEN DO
   GNM='GRPUNKN'
   END
  /* ADD TO THE GLOBAL LIST (AOR TOR LISTS) IF FIRST GROUP ENTRY */
  GNM=STRIP(GNM,'B')
  GNM=WORD(GNM,1)
  IF TGL ^= '' THEN DO
   IF WORDPOS(GNM,TGL) = 0 THEN SIGNAL TOPOFLOP
   END
  INTERPRET 'TMPWP=WORDPOS(GNM,'PT'LL)'
  IF TMPWP = 0 THEN DO
  /* INITIALIZE  AOR TOR LISTS  IF FIRST GROUP ENTRY */
  /* TLL AND ALL IS THE LIST OF GROUP NAMES BY FILE  */
  /* ..RCL IS THE LIST BY GROUP OF THE FULL RESOURCE TYPE */
   INTERPRET PT'.'GNM'.CT = 0'
   INTERPRET PT'.'GNM'.RCL = ""'
   INTERPRET PT"LL = "PT"LL||' '||GNM"
   END
  /* ADD RESOURCE TYPE TO AOR TOR GROUP LISTS */
  /* ADD FULL RESOURCE NAME TO THE GROUP NAME RCL */
  INTERPRET 'TMPRC='PT'.'GNM'.RCL'
  IF WORDPOS(RT,TMPRC) = 0 THEN DO
  /* INITIALIZE  AOR TOR RESOURCE GROUP ENTRY */
   TMPRC=TMPRC||' '||RT
   INTERPRET PT'.'GNM'.RCL = TMPRC'
   INTERPRET 'TMPCT='PT'.'GNM'.CT'
   TMPCT=TMPCT+1
   INTERPRET PT'.'GNM'.CT = TMPCT'
  /* THIS VAR KEEPS RESOURCE TYPE ABREV NAMES */
   INTERPRET PT'.'GNM'.'RTA' = ""'
   END
  /* PLACE EACH RESOURCE NAME(REC #) ONTO LIST */
  /* THIS LIST WILL KEEP TRACK OF RECOURCE NAME FOR EACH GROUP BY */
  /* RESOURCE TYPE.                                               */
  /* E.G. T.GRP.TRAN=ABCD(1)  THAT IS TRAN ABCD IN LINE 1 OF TOR */
  INTERPRET 'TMPRC='PT'.'GNM'.'RTA
  RC#I=RC#||'('||I||')'
  TMPRC=TMPRC||' '||RC#I
  INTERPRET PT'.'GNM'.'RTA' = TMPRC'
  /* ADD GROUP NAME TO GLOBAL LIST IF FIRST OCCURANCE */
  IF WORDPOS(GNM,GLL) = 0 THEN GLL = GLL||' '||GNM
  /* NOW CHECK OUT THE RESOURCE SIDE  */
  /* ADD THE RESOURCE NAME TO THE RESOURCE WORD LIST */
  /* TWL AND AWL KEEP THE TOTAL SET OF RESOURCE TYPES FOR TOR AOR */
  INTERPRET 'TMPWP=WORDPOS(RT,'PT'WL)'
  IF TMPWP = 0 THEN DO
  /* INITIALIZE THE RESOURCE WORD LIST WHEN FIRST RESOURCE TYPE */
  /* COUNT OF RESOURCE TYPES ON LIST */
   INTERPRET PT'.'RTA'.CT = 0'
  /* LIST OF RESOURCE NAMES FOR A RESOURCE TYPE */
   INTERPRET PT'.'RTA'.RCL = ""'
  /* LIST OF GROUP NAME(RECSOURCE LINE NUM) FOR A RESOURCE TYPE */
   INTERPRET PT'.'RTA'.RCGNM = ""'
  /* ADD NEW RESOURCE TYPE TO END OF LIST */
   INTERPRET PT"WL = "PT"WL||' '||RT"
   END
  INTERPRET 'TMPRC='PT'.'RTA'.RCL'
  NWRC# = WORDPOS(RC#,TMPRC)
  IF NWRC# = 0 THEN DO
   INTERPRET 'TMPCT='PT'.'RTA'.CT'
   TMPCT=TMPCT+1
   INTERPRET PT'.'RTA'.CT = TMPCT'
   TMPRC=TMPRC||' '||RC#
   INTERPRET PT'.'RTA'.RCL = TMPRC'
   INTERPRET PT"."RTA"."RC#" = GNM||'('||"I"||')'"
   END
   ELSE DO
   INTERPRET "XMPRC = "PT"."RTA"."RC#
   XMPRC=XMPRC||' '||GNM||'('||I||')'
   INTERPRET PT"."RTA"."RC#" = XMPRC"
   END
  INTERPRET 'TMPRC = 'PT'.'RTA'.RCGNM'
  TMPRC = TMPRC||' '||RC#||FFX||' '||GNM
  INTERPRET PT'.'RTA'.RCGNM = TMPRC'
  IF WORDPOS(RT,GWL) ^= 0 THEN SIGNAL TOPOFLOP
  GWL = GWL||' '||RT
  SIGNAL TOPOFLOP
 OUTOFLOP:
/* TRACE ?I */
  INTERPRET "P_W_CT=WORDS(P_WARN."PT")"
  IF P_W_CT > 0 THEN DO
   OPC=OPC+1
   OP.OPC='PROCESS WARNING. RESOURCE NAMES CHG FROM -,/^ TO _?__ '
   OPC=OPC+1
   OP.OPC=' FOR THE FOLLOWING RESOURCE TYPES:'
   OPC=OPC+1
   INTERPRET "OP.OPC=P_WARN."PT
   DO P_W_I = 1 TO P_W_CT
    OPC=OPC+1
    OP.OPC=' LIST FOR RESOURCE TYPE:'
    INTERPRET "P_WARN_WD = WORD(P_WARN."PT",P_W_I)"
    INTERPRET "P_WARN_LST = P_WARN."PT"."P_WARN_WD
    DO WHILE P_WARN_LST \= ''
     PARSE VAR P_WARN_LST RTSS_TMP P_WARN_LST
     IF (LENGTH(OP.OPC) + LENGTH(RTSS_TMP) + 1) > 120  THEN DO
      OPC=OPC+1
      OP.OPC=''
      END
     OP.OPC=OP.OPC||' '||RTSS_TMP
     END
    END
   END
  IF PT = 'T' THEN DO
   PT = 'A'
   SAY 'AOR='AOR
   IF AOR^='' THEN SIGNAL STLOOP
   END
  OPC=OPC+1
  OP.OPC=' -----------'
  NGW=WORDS(GWL)
  IF FUNC = 'RECON' THEN SIGNAL RECON
  IF FUNC ^= 'RESCOMP' & FUNC ^= 'GRPCOMP' THEN SIGNAL DODIR
  OPC=OPC+1
  OP.OPC= FUNC' FUNCTION IN PROGRESS. PLEASE BE PATIENT. 'TIME()
  IF ONLYP ^= 0 THEN DO
   OPC=OPC+1
   OP.OPC='.... 'FUNC'ONLY WAS COMMANDED, ONLY DIFFERENCES REPORTED'
   END
  IF AOR \= '' THEN DO
   COM_RT=''
   UNQ_RT=''
   RT_T_CT = WORDS(RTSS_T)
   DO RT_CT = 1 TO RT_T_CT
    RT_WD = WORD(RTSS_T,RT_CT)
    RA_WP = WORDPOS(RT_WD,RTSS_A)
    IF RA_WP \= 0 THEN DO
     COM_RT=COM_RT||' '||RT_WD
     RTSS_A = DELWORD(RTSS_A,RA_WP,1)
     END
     ELSE DO
     UNQ_RT=UNQ_RT||' '||RT_WD
     END
    END
   IF COM_RT \= '' THEN DO
    OPC=OPC+1
    OP.OPC='* COMMON RESOURCE TYPES:'
    OPC=OPC+1
    OP.OPC=''
    DO WHILE COM_RT \= ''
     PARSE VAR COM_RT RTSS_TMP COM_RT
     IF (LENGTH(OP.OPC) + LENGTH(RTSS_TMP) + 1) > 80  THEN DO
      OPC=OPC+1
      OP.OPC=''
      END
     OP.OPC=OP.OPC||' '||RTSS_TMP
     END
    END
   IF UNQ_RT \= '' THEN DO
    OPC=OPC+1
    OP.OPC='* UNIQUE TOR RESOURCE TYPES:'
    OPC=OPC+1
    OP.OPC=''
    DO WHILE UNQ_RT \= ''
     PARSE VAR UNQ_RT RTSS_TMP UNQ_RT
     IF (LENGTH(OP.OPC) + LENGTH(RTSS_TMP) + 1) > 80  THEN DO
      OPC=OPC+1
      OP.OPC=''
      END
     OP.OPC=OP.OPC||' '||RTSS_TMP
     END
    END
   IF RTSS_A \= '' THEN DO
    OPC=OPC+1
    OP.OPC='* UNIQUE AOR RESOURCE TYPES:'
    OPC=OPC+1
    OP.OPC=''
    DO WHILE UNQ_RT \= ''
     PARSE VAR UNQ_RT RTSS_TMP UNQ_RT
     IF (LENGTH(OP.OPC) + LENGTH(RTSS_TMP) + 1) > 80  THEN DO
      OPC=OPC+1
      OP.OPC=''
      END
     OP.OPC=OP.OPC||' '||RTSS_TMP
     END
    END
    ELSE DO
    OPC=OPC+1
    OP.OPC='* TOR RESOURCE TYPES FULLY MATCH AOR RESOURCE TYPES:'
    END
   END
   ELSE DO
   IF RTSS_T \= '' THEN DO
    OPC=OPC+1
    OP.OPC='  RESOURCE TYPES IN TOR:'
    RTSS_TMP = ''
    DO WHILE RTSS_T \= ''
     PARSE VAR RTSS_T RTSS_TMP RTSS_T
     IF (LENGTH(OP.OPC) + LENGTH(RTSS_TMP) + 1) > 80  THEN DO
      OPC=OPC+1
      OP.OPC=''
      END
     OP.OPC=OP.OPC||' '||RTSS_TMP
     END
    END
   END
  IF FUNC = 'GRPCOMP' THEN SIGNAL GRPCOMP
  IF TGLIST ^= '' THEN DO
   OPC=OPC+1
   OP.OPC='  RESCOMP SPECIFIC GROUP LIST REQUEST STARTING'
   END
  IF RTSS = 'ALL' THEN RTSS = GWL
  K = 1
 TOPGWLRT:
  RT=WORD(GWL,K)
  RTA=SUBSTR(RT,1,4)
  IF WORDPOS(RT,RTSS) = 0 THEN SIGNAL NXTGWL
  TWP=WORDPOS(RT,TWL)
  AWP=WORDPOS(RT,AWL)
  IF TWP = 0 THEN TMPMSG='* RESOURCE TYPE 'RT' NOT IN TOR DSN'
  ELSE IF AWP = 0 THEN TMPMSG='* RESOURCE TYPE 'RT' NOT IN AOR DSN'
  ELSE TMPMSG='  RESOURCE TYPE 'RT' FOUND IN BOTH TOR AND AOR DSN'
  OPC=OPC+1
  OP.OPC=TMPMSG
  /* .RCL IS THE LIST OF ALL ENTRIES OF TYPE RTA */
  INTERPRET 'TRWL=T.'RTA'.RCL'
  INTERPRET 'ARWL=A.'RTA'.RCL'
  INTERPRET 'NTRW=T.'RTA'.CT'
  INTERPRET 'NARW=A.'RTA'.CT'
  IF TWP = 0 | AWP = 0 THEN SIGNAL NXTGWL
  OPC=OPC+1
  IF NTRW > NARW THEN DO
   OP.OPC='* TOR COUNT OF RESOURCE 'RT' GREATER THAN AOR COUNT'
   END
  ELSE IF NTRW < NARW THEN DO
   OP.OPC='* TOR COUNT OF RESOURCE 'RT' LESS THAN AOR COUNT'
   END
  ELSE DO
   OP.OPC='  TOR COUNT OF RESOURCE 'RT' EQUAL TO AOR COUNT'
   END
  OPC=OPC+1
  OP.OPC='  TOR COUNT='NTRW', AOR COUNT='NARW
  AORFL=ARWL
  CWL=''
  DO J = 1 TO NTRW
   TWD = WORD(TRWL,J)
   AWP = POS(TWD,AORFL)
   IF AWP = 0 THEN DO
    OPC=OPC+1
    OP.OPC='* 'RT'('TWD') NOT FOUND ON AOR LIST'
    ITERATE
    END
   AWP=WORDS(SUBSTR(AORFL,1,AWP-1))+1
   AORFL=DELWORD(AORFL,AWP,1)
   CWL=CWL||' '||TWD
   END
  DO WHILE(AORFL ^= '')
   PARSE VAR AORFL AWD AORFL
   OPC=OPC+1
   OP.OPC='* 'RT'('AWD') NOT FOUND ON TOR LIST'
   AORFL=STRIP(AORFL,'B')
   END
  NCWL=WORDS(CWL)
  OPC=OPC+1
  OP.OPC='* TOR AND AOR TYPE 'RT' HAVE 'NCWL' COMMON RESOURCE NAMES.'
  IF CWL = '' THEN DO
   SIGNAL OUTGWLRT
   END
  CWL=STRIP(CWL,'B')
  IF ONLYP = 0 THEN DO
   OPC=OPC+1
   OP.OPC=' PROCESSING COMMON NAMES FOR RESOURCE 'RT
   END
  J = 1
 TOPCWL:
  TWD = WORD(CWL,J)
  HWD_CWL=TWD
  IF ONLYP = 0 THEN DO
   OPC=OPC+1
   OP.OPC='  PERFORM RESCOMP 'RT'('TWD')'
   END
  INTERPRET 'TRP=T.'RTA'.'TWD
  INTERPRET 'ARP=A.'RTA'.'TWD
  NTRP=WORDS(TRP)
  NARP=WORDS(ARP)
  IF NTRP > 1 | NARP > 1 THEN DO
   IF ONLYP = 0 THEN DO
    OPC=OPC+1
    OP.OPC=LEFT('  RES 'TWD' TOR COUNT='NTRP,MXHL)||FEX||,
     LEFT('  RES 'TWD' AOR COUNT='NARP,MXHL)
    END
   END
  IF NTRP>NARP THEN T#MAX=NTRP
   ELSE T#MAX = NARP
  R#=1
T#LOP:
  IF R# > NTRP THEN DO
   TMSG=' '
   END
   ELSE DO
   TGRC#=WORD(TRP,R#)
   PARSE VAR TGRC# TG#GNM '(' TRC# ')'
   TMSG=LEFT('  GROUP NAME 'TG#GNM,MXHL)
   END
  IF R# > NARP THEN DO
   AMSG=' '
   END
   ELSE DO
   AGRC#=WORD(ARP,R#)
   PARSE VAR AGRC# AG#GNM '(' ARC# ')'
   AMSG=LEFT('  GROUP NAME 'AG#GNM,MXHL)
   END
  IF ONLYP = 0 THEN DO
   OPC=OPC+1
   OP.OPC=LEFT(TMSG,MXHL)||FEX||,
          LEFT(AMSG,MXHL)
   END
  R#=R#+1
  IF R#^>T#MAX THEN SIGNAL T#LOP
 T#LOPX:
  TREC=TL.TRC#
  AREC=AL.ARC#
  PARSE VAR TREC 'DEFINE ' TRT '(' TRC ') ' TREC
  PARSE VAR AREC 'DEFINE ' ART '(' ARC ') ' AREC
  IF (TRT ^= ART) | (TRC ^= ARC) THEN SIGNAL RECERR
  FSTR=''
  PT=T
  SSTR='GROUP'
  CALL STRPIT
  PT=A
  CALL STRPIT
  PT=T
  SSTR='DESCRIPTION'
  CALL STRPIT
  PT=A
  CALL STRPIT
  DO WHILE(TREC ^= '')
   PARSE VAR TREC SSTR '(' TRC ') ' TREC
   LFSTR=LENGTH(TRC)
   IF LFSTR > 0 THEN DO
    LP=SUBSTR(TRC,LFSTR,1)
    DO WHILE(LP=')')
     TRC=SUBSTR(TRC,1,LFSTR-1)
     LFSTR=LENGTH(TRC)
     IF LFSTR > 0 THEN LEAVE
     LP=SUBSTR(TRC,LFSTR,1)
     END
    END
   FSTR=''
   CALL STRPIT
   IF FSTR = TRC THEN ITERATE
  /* TRACE ?I */
   OPC=OPC+1
   OP.OPC='*.TOR ENTRY<'TRP HWD_CWL'>PARM<'SSTR'('TRC||,
    ')> NOT EQ/NF OR DIFF LIST ORDER THAN AOR'
   OPC=OPC+1
   OP.OPC='*.AOR ENTRY<'ARP HWD_CWL'>PARM<'SSTR'('FSTR')>'
   END
  IF TREC ^= '' THEN DO
   DO WHILE(TREC ^= '')
    PARSE VAR TREC SSTR '(' TRC ') ' TREC
    OPC=OPC+1
    OP.OPC='*.TOR(GP(REC#)ENTRY)'TRP HWD_CWL' PARM 'SSTR'('TRC||,
    ') NOT FOUND IN AOR'
    END
   END
  IF AREC ^= '' THEN DO
   DO WHILE(AREC ^= '')
    PARSE VAR AREC SSTR '(' TRC ') ' AREC
    OPC=OPC+1
    OP.OPC='*.AOR(GP(REC#)ENTRY)'ARP HWD_CWL' PARM 'SSTR'('ARC||,
    ') NOT FOUND IN TOR'
    END
   END
  SIGNAL NXTCWL
 RECERR:
  OPC=OPC+1
  OP.OPC='* RECORDS NOT EQUAL' TRT ART TRC ARC
  SIGNAL NXTCWL
 NXTCWL:
  J = J+1
  IF J ^> NCWL THEN SIGNAL TOPCWL
 NXTGWL:
  K = K+1
  IF K ^> NGW THEN SIGNAL TOPGWLRT
 OUTGWLRT:
  OPC=OPC+1
  OP.OPC='RESCOMP FUNCTION REPORT COMPLETE. 'TIME()
  SAY OP.OPC
  IF ONLYP ^= 0 THEN DO
   SIGNAL OUTOFGWL
   END
  SIGNAL DODIR
GRPCOMP:
  IF TGLIST ^= '' THEN DO
   OPC=OPC+1
   OP.OPC='  GRPCOMP SPECIFIC GROUP LIST REQUEST STARTING'
   OPC=OPC+1
   OP.OPC='  TOR LIST:'TGLIST
   OPC=OPC+1
   OP.OPC='  AOR LIST:'AGLIST
   END
  NGW=WORDS(GLL)
  OPC=OPC+1
  OP.OPC='GRPCOMP FUNCTION REPORT STARTING. 'TIME()
  OPC=OPC+1
  OP.OPC='   GLOBAL GROUP NAMES COUNTED 'NGW
  OPC=OPC+1
  OP.OPC='----------------------------------'
  NTW=WORDS(TLL)
  NAW=WORDS(ALL)
  OPC=OPC+1
  OP.OPC=LEFT('NUMBER TOR GROUP NAMES 'NTW,MXHL)||FEX||,
         LEFT('NUMBER AOR GROUP NAMES 'NAW,MXHL)
  IF NTW > NAW THEN GN_CT=NTW
   ELSE GN_CT=NAW
  DO O_I = 1 TO GN_CT
   IF O_I > NTW THEN T_GN = '-'
    ELSE T_GN = WORD(TLL,O_I)
   IF O_I > NAW THEN A_GN = '-'
    ELSE A_GN = WORD(ALL,O_I)
   OPC=OPC+1
   OP.OPC=LEFT('     'T_GN,MXHL)||FEX||,
          LEFT('     'A_GN,MXHL)
   END
  G = 1
 TOPGGLRT:
  IF TGLIST ^= '' THEN DO
   TGNM=WORD(TGLIST,G)
   END
   ELSE DO
    TGNM=WORD(GLL,G)
    AGNM=TGNM
    SIGNAL NOAGLST
    END
  IF AGLIST ^= '' THEN DO
   AGNM=WORD(AGLIST,G)
   END
   ELSE AGNM=''
 NOAGLST:
  TWP=WORDPOS(TGNM,TLL)
  AWP=WORDPOS(AGNM,ALL)
  IF TWP = 0 THEN TMPMSG='* GROUP NAME 'TGNM' NOT IN TOR DSN'
  ELSE IF AWP = 0 THEN TMPMSG='* GROUP NAME 'AGNM' NOT IN AOR DSN'
  ELSE TMPMSG=LEFT(' TOR GROUP NAME 'TGNM,MXHL)||FEX||,
              LEFT(' AOR GROUP NAME 'AGNM,MXHL)
  OPC=OPC+1
  OP.OPC=TMPMSG
  IF TWP = 0 | AWP = 0 THEN SIGNAL NXTGGL
  INTERPRET 'GTRCL= T.'TGNM'.RCL'
  INTERPRET 'GARCL= A.'AGNM'.RCL'
  TGNMRL=GTRCL||' '||GARCL
  NGTL=WORDS(TGNMRL)
  GNMRL=''
  GNMRTA=''
  DO MI = 1 TO NGTL
   #WD=WORD(TGNMRL,MI)
   NTINA=WORDPOS(#WD,GNMRL)
   IF NTINA ^= 0 THEN ITERATE
   GNMRL=GNMRL||' '||#WD
   GNMRTA=GNMRTA||' '||SUBSTR(#WD,1,4)
   END
  NGNMRL=WORDS(GNMRL)
  H = 1
TOPCGL:
 TMPRL=WORD(GNMRL,H)
 TMPRLA=WORD(GNMRTA,H)
 TWP=WORDPOS(TMPRL,GTRCL)
 AWP=WORDPOS(TMPRL,GARCL)
 IF TWP = 0 THEN,
  TMPMSG='* RESOURCE TYPE 'TMPRL' NOT FOUND IN TOR GROUP'
  ELSE IF AWP = 0 THEN,
   TMPMSG='* RESOURCE TYPE 'TMPRL' NOT FOUND IN AOR GROUP'
   ELSE TMPMSG=LEFT('  RESOURCE TYPE 'TMPRL,MXHL)||FEX||,
               LEFT('RESOURCE TYPE 'TMPRL,MXHL)
 OPC=OPC+1
 OP.OPC=TMPMSG
 IF TWP = 0 | AWP = 0 THEN SIGNAL NXTCGL
 RTA=SUBSTR(WORD(GTRCL,TWP),1,4)
 RAA=SUBSTR(WORD(GARCL,AWP),1,4)
 INTERPRET 'TRTAL=T.'TGNM'.'RTA
 INTERPRET 'ARTAL=A.'AGNM'.'RAA
 NRTA#=WORDS(TRTAL)
 NRAA#=WORDS(ARTAL)
 OPC=OPC+1
 OP.OPC=LEFT('  NUMBER OF TOR 'RTA'='NRTA#,MXHL)||FEX||,
        LEFT('NUMBER OF AOR 'RAA'='NRAA#,MXHL)
 HTRCS=''
 DO NI = 1 TO NRTA#
  TTRC=WORD(TRTAL,NI)
  PARSE VAR TTRC TRC '(' TRP ')' .
  IF TRC = '' THEN SIGNAL RECERR
  TREC=TL.TRP
  HTRCS=HTRCS||' '||TRC
  INTERPRET 'T.HGNM.'TRC' = TREC'
  END
 UINT=0
 UINA=0
 COMRC=''
 DO NI = 1 TO NRAA#
  TTRC=WORD(ARTAL,NI)
  PARSE VAR TTRC TRC '(' TRP ')' .
  IF TRC = '' THEN SIGNAL RECERR
  TREC=AL.TRP
  NFANT=WORDPOS(TRC,HTRCS)
  IF NFANT=0 THEN DO
   OPC=OPC+1
   OP.OPC='  RESOURCE NAME 'TRC' FOUND IN AOR, NOT IN TOR '
   UINA=UINA+1
   END
   ELSE DO
   COMRC=COMRC||' '||TRC
   HTRCS=DELWORD(HTRCS,NFANT,1)
   INTERPRET 'A.HGNM.'TRC' = TREC'
   END
  END
 NUTRC=WORDS(HTRCS)
 DO NI = 1 TO NUTRC
  TRC=WORD(HTRCS,NI)
  OPC=OPC+1
  OP.OPC='  RESOURCE NAME 'TRC' FOUND IN TOR, NOT IN AOR '
  UINT=UINT+1
  END
 OPC=OPC+1
 OP.OPC=LEFT('  'UINT' UNIQUE DEFINITIONS IN TOR GROUP',MXHL)||FEX||,
        LEFT('  'UINA' UNIQUE DEFINITIONS IN AOR GROUP',MXHL)
 NCRC=WORDS(COMRC)
 OPC=OPC+1
 OP.OPC='  'NCRC' COMMON DEFINITONS FOUND IN GROUPS 'TGNM||,
   FEX||AGNM||' BEGIN COMMON DETAILED COMPARE.'
 TOTNUMDF=0
 HCOMRC=COMRC
 DO WHILE (HCOMRC ^= '')
  TCOMRC=SUBSTR(HCOMRC,1,70)
  LP=LASTPOS(' ',TCOMRC)
  IF LP = 0 THEN LP =LENGTH(TCOMRC)
  OPC=OPC+1
  OP.OPC=' '||SUBSTR(HCOMRC,1,LP)
  SAY OP.OPC
  HCOMRC=SUBSTR(HCOMRC,LP+1)
  END
 TSUMDIF=''
 OPCDF=0
 NI=1
TOPGCW:
 TSUMDIF=''
 OPCDF=0
 TRC=WORD(COMRC,NI)
 OPC=OPC+1
 OP.OPC="     COMPARE COMMON ENTRY "||TRC
 INTERPRET 'TREC=T.HGNM.'TRC
 INTERPRET 'AREC=A.HGNM.'TRC
 PARSE VAR TREC 'DEFINE ' TRT '(' TRC ') ' TREC
 PARSE VAR AREC 'DEFINE ' ART '(' ARC ') ' AREC
 IF (TRT ^= ART) | (TRC ^= ARC) THEN SIGNAL RECERR
 HTRC=TRT||'('||TRC||')'
 HARC=ART||'('||ARC||')'
  FSTR=''
  PT=T
  SSTR='GROUP'
  CALL STRPIT
  PT=A
  CALL STRPIT
  PT=T
  SSTR='DESCRIPTION'
  CALL STRPIT
  PT=A
  CALL STRPIT
  TOTRCDF=0
  DO WHILE(TREC ^= '')
   PARSE VAR TREC SSTR '(' TRC ') ' TREC
   LFSTR=LENGTH(TRC)
   IF LFSTR > 0 THEN DO
    LP=SUBSTR(TRC,LFSTR,1)
    DO WHILE(LP=')')
     TRC=SUBSTR(TRC,1,LFSTR-1)
     LFSTR=LENGTH(TRC)
     IF LFSTR > 0 THEN LEAVE
     LP=SUBSTR(TRC,LFSTR,1)
     END
    END
   FSTR=''
   CALL STRPIT
   IF FSTR = TRC THEN ITERATE
   IF OPCDF=0 THEN DO
    OPC=OPC+1
    OP.OPC='PLACEHOLDER'
    OPCDF=OPC
    END
   TSUMDIF=TSUMDIF||' '||SSTR||'('||TRC||')'
   TOTRCDF=TOTRCDF+1
   OPC=OPC+1
   OP.OPC='* TOR PARM 'SSTR'('TRC') NE/NF AOR PARM 'SSTR'('FSTR')'
   END
  IF AREC ^= '' THEN DO
   DO WHILE(AREC ^= '')
    PARSE VAR AREC SSTR '(' TRC ') ' AREC
    OPC=OPC+1
    OP.OPC='* AOR PARM 'SSTR'('TRC') NOT FOUND IN TOR'
    TOTRCDF=TOTRCDF+1
    END
   END
  SIGNAL BOTGCW
 RECGRR:
  OPC=OPC+1
  OP.OPC='* RECORDS NOT EQUAL' TRT ART TRC ARC
  SIGNAL BOTGCW
 BOTGCW:
  /* TRACE I */
  IF TOTRCDF^=0 THEN DO
   OP.OPCDF='*%ENTRY 'HTRC' CONTAINED 'TOTRCDF' PARM DIFFERENCES.'
   OPC=OPC+1
   OP.OPC='*%'||LEFT(TSUMDIF,77)
   TOTNUMDF=TOTNUMDF+1
   END
   ELSE DO
    OPC=OPC+1
    OP.OPC='  NO DIFFERENCES FOR ENTRY 'HTRC
   END
  OPC=OPC+1
  OP.OPC=' '
  NI = NI+1
  IF NI ^> NCRC THEN SIGNAL TOPGCW
 NXTCGL:
  IF TOTNUMDF^=0 THEN DO
   OPC=OPC+1
   OP.OPC='* RESOURCE TYPE 'TRT' CONTAINED 'TOTNUMDF' ENTRYS WITH '||,
    'DIFFERENCES.'
   END
  OPC=OPC+1
  OP.OPC='  COMMON 'TRT' DEFINITONS FOR GROUP 'TGNM' PROCESSED.'
  OPC=OPC+1
  OP.OPC='--------'
  H = H+1
  IF H ^> NGNMRL THEN SIGNAL TOPCGL
 NXTGGL:
  OPC=OPC+1
  OP.OPC=' '
  G = G+1
  IF G ^> NGW THEN SIGNAL TOPGGLRT
 OUTGGLRT:
  OPC=OPC+1
  OP.OPC='GRPCOMP FUNCTION REPORT COMPLETE. 'TIME()
  SAY OP.OPC
  IF ONLYP ^= 0 THEN DO
   SIGNAL OUTOFGWL
   END
  SIGNAL DODIR
 RECON:
  PT = 'T'
 TOPOFRCN:
  OPC=OPC+1
  OP.OPC='RECONCILE THE RDOFILES FOR DUPLICATE ENTRIES IN 'PT'OR'
  INTERPRET 'NRCNRT=WORDS('PT'WL)'
  IF NRCNRT = 0 THEN DO
   OPC=OPC+1
   OP.OPC=PT'OR RECONCILIATION OF DUPLICATES HAS NO RESOURCE TYPES.'
   IF PT = 'A' THEN SIGNAL DODIR
   PT = 'A'
   SIGNAL TOPOFRCN
   END
  I = 1
 TOPOFRCL:
  INTERPRET 'TMPRCN=WORD('PT'WL,I)'
  RTA=SUBSTR(TMPRCN,1,4)
  INTERPRET 'TMPRCG='PT'.'RTA'.RCGNM'
  NRCS = WORDS(TMPRCG)
  IF NRCS < 3 THEN DO
   OPC=OPC+1
 OP.OPC='* 'PT'OR HAS ONLY ONE RESOURCE DEFINITION FOR RESOURCE 'TMPRCN
   SIGNAL BOTOFRCN
   END
  IF ONLYP = 0 THEN DO
   OPC=OPC+1
   OP.OPC=PT'OR HAS 'NRCS/2' RESOURCES OF TYPE 'TMPRCN
   END
  NRCSM1 = NRCS - 1
  DO J = 1 TO NRCSM1 BY 2
   RCF=WORD(TMPRCG,J)
   PARSE VAR RCF RC# (FFX)
   NRRCS=J+1
   GNM = WORD(TMPRCG,NRRCS)
   GNMIND=0
   DO FOREVER
    NRRCS=WORDPOS(RCF,TMPRCG,NRRCS+1)
    IF NRRCS = 0 THEN LEAVE
    IF GNMIND = 0 THEN DO
     GNMIND=1
     OPC=OPC+1
   OP.OPC='* DEFINITION 'RC#' FOUND IN GROUP 'GNM', ALSO FOUND IN GROUP '
     END
    NRRCS=NRRCS+1
    GNM = WORD(TMPRCG,NRRCS)
    OPC=OPC+1
    OP.OPC='*                                'GNM
    END
   END
 BOTOFRCN:
   I = I + 1
   IF I ^> NRCNRT THEN SIGNAL TOPOFRCL
   IF PT = 'A' THEN SIGNAL DODIR
   PT = 'A'
   IF AOR ^= '' THEN SIGNAL TOPOFRCN
 DODIR:
  IF ONLYP ^= 0 & FUNC ^= 'DIR' THEN SIGNAL OUTOFGWL
  OPC=OPC+1
  OP.OPC=' DIR FUNCTION REPORT IN PROGRESS. PLEASE WAIT'
  SAY OP.OPC
  OPC=OPC+1
  OP.OPC=LEFT('NUMBER OF DEFINES 'TCT,MXHL)||FEX||,
         LEFT('NUMBER OF DEFINES 'ACT,MXHL)
  OPC=OPC+1
  OP.OPC='       GROUP NAMES DIRECTORY SECTION'
  NGLL=WORDS(GLL)
  OPC=OPC+1
  OP.OPC='GLOBAL GROUP NAMES COUNTED 'NGLL
  NTW=WORDS(TLL)
  NAW=WORDS(ALL)
  OPC=OPC+1
  OP.OPC=LEFT('NUMBER TOR GROUP NAMES 'NTW,MXHL)||FEX||,
         LEFT('NUMBER AOR GROUP NAMES 'NAW,MXHL)
  DO I = 1 TO NGLL
   TGWD=WORD(GLL,I)
   NTTL=WORDPOS(TGWD,TLL)
   NATL=WORDPOS(TGWD,ALL)
   IF NTTL > 0 THEN TWD=WORD(TLL,NTTL)
    ELSE DO
    TWD='NO'
    T.NO.RCL=''
    T.NO.CT=0
    END
   IF NATL > 0 THEN AWD=WORD(ALL,NATL)
    ELSE DO
    AWD='NO'
    A.NO.RCL=''
    A.NO.CT=0
    END
   OPC=OPC+1
   OP.OPC=LEFT('GROUP NAME 'TWD,MXHL)||FEX||,
          LEFT('GROUP NAME 'AWD,MXHL)
   INTERPRET 'GTWL= T.'TWD'.RCL'
   INTERPRET 'GAWL= A.'AWD'.RCL'
   INTERPRET 'NGTL= T.'TWD'.CT'
   INTERPRET 'NGAL= A.'AWD'.CT'
   OLDGAWL=GAWL
   NEWGAWL=''
   DO MI = 1 TO NGTL
    #WD=WORD(GTWL,MI)
    NTINA=WORDPOS(#WD,OLDGAWL)
    IF NTINA ^= 0 THEN DO
     NEWGAWL=NEWGAWL||' '||#WD
     OLDGAWL=DELWORD(OLDGAWL,NTINA,1)
     END
    ELSE NEWGAWL=NEWGAWL||' UNDE'
    END
   NOGAWL=WORDS(OLDGAWL)
   GAWL=STRIP(NEWGAWL||OLDGAWL,'B')
   GTWL=GTWL||' '||COPIES('UNDE ',NOGAWL)
   NGTL=WORDS(GTWL)
   NGAL=WORDS(GAWL)
   IF NGTL ^= NGAL THEN DO
    OPC=OPC+1
    OP.OPC='* RESOURCE COUNT FOR GROUPS UNEQUAL'
    END
   IF NGTL>NGAL THEN NGMX=NGTL
    ELSE NGMX=NGAL
   DO MI = 1 TO NGMX
    IF MI ^> NGTL THEN TGD = WORD(GTWL,MI)
     ELSE TGD='UNDE'
    IF TGD='UNDE' THEN DO
     INTERPRET 'T.'TWD'.UNDE=""'
     INTERPRET 'NRC.UNDE=0'
     END
    IF MI ^> NGAL THEN AGD = WORD(GAWL,MI)
     ELSE AGD='UNDE'
    IF AGD='UNDE' THEN DO
     INTERPRET 'A.'AWD'.UNDE=""'
     INTERPRET 'NRC.UNDE=0'
     END
    TTGD=SUBSTR(TGD,1,4)
    TAGD=SUBSTR(AGD,1,4)
    INTERPRET 'NCTL= WORDS(T.'TWD'.'TTGD')'
    INTERPRET 'NCAL= WORDS(A.'AWD'.'TAGD')'
    OPC=OPC+1
    OP.OPC=LEFT(' RESOURCE TYPE 'TGD'('NCTL')',MXHL)||FEX||,
           LEFT(' RESOURCE TYPE 'AGD'('NCAL')',MXHL)
    DODTLSW=0
    IF ONLYP ^= 0 THEN DO
     IF WORDPOS(TGD,HDIRPRMS) = 0 &,
        WORDPOS(AGD,HDIRPRMS) = 0 THEN DODTLSW=1
     END
    IF DODTLSW=0 THEN DO
    IF NCTL > NCAL THEN NCMX=NCTL
     ELSE NCMX=NCAL
    GGD=TGD
    IF TGD='UNDE' THEN DO
     GGD=AGD
     IF AGD='UNDE' THEN DO
      GGD='?????'
      END
     END
    DO NI = 1 TO NCMX
     IF NI ^> NCTL THEN INTERPRET 'TCD = WORD(T.'TWD'.'TTGD',NI)'
      ELSE TCD=''
     IF NI ^> NCAL THEN INTERPRET 'ACD = WORD(A.'AWD'.'TAGD',NI)'
      ELSE ACD=''
     HRTSS=WORDPOS(GGD,RTSS)
     PARSE VAR TCD TCD '(' TR# ')'
     PARSE VAR ACD ACD '(' AR# ')'
     IF HRTSS ^= 0 THEN DO
      TSTR=TTGD
      INTERPRET 'HRCSS=RCSS.'TSTR
      INTERPRET 'HNRC=NRC.'TSTR
      IF DATATYPE(HNRC) ^= 'NUM' THEN DO
       OPC=OPC+1
       OP.OPC='* TOR RESOURCE 'NRC.TSTR' WAS NOT INITIALIZED'
       INTERPRET 'NRC.'TSTR' = 0'
       HNRC=0
       END
      IF TCD ^= '' THEN DO
       HREC=TL.TR#
       DO JI = 1 TO HNRC
        TRCSS=' '||WORD(HRCSS,JI)||'('
        PTRCSS=POS(TRCSS,HREC)
        IF PTRCSS ^= 0 THEN DO
         PARSE VAR HREC . (TRCSS) RVSS ')' .
         RVSS=RVSS||')'
         END
         ELSE DO
         TRCSS=' <'||STRIP(TRCSS,'L')
         RVSS=')>'
         END
        TCD = TCD||TRCSS||RVSS
        END
       END
      ASTR=TAGD
      INTERPRET 'HRCSS=RCSS.'ASTR
      INTERPRET 'HNRC=NRC.'ASTR
      IF DATATYPE(HNRC) ^= 'NUM' THEN DO
       OPC=OPC+1
       OP.OPC='* TOR RESOURCE 'NRC.TSTR' AND AOR RESOURCE 'NRC.ASTR
       INTERPRET 'NRC.'ASTR' = 0'
       HNRC=0
       END
      IF ACD ^= '' THEN DO
       HREC=AL.AR#
       DO JI = 1 TO HNRC
        TRCSS=' '||WORD(HRCSS,JI)||'('
        PTRCSS=POS(TRCSS,HREC)
        IF PTRCSS ^= 0 THEN DO
         PARSE VAR HREC . (TRCSS) RVSS ')' .
         RVSS=RVSS||')'
         END
         ELSE DO
         TRCSS=' <'||STRIP(TRCSS,'L')
         RVSS=')>'
         END
        ACD = ACD||TRCSS||RVSS
        END
       END
      END
     OPC=OPC+1
/*   HTL=LENGTH(TCD)
     HAL=LENGTH(ACD)
     IF HAL > HTL THEN HTL = HAL
     IF HTL > MXHL THEN MXHL = HTL
     OP.OPC=LEFT(TCD,MXHL)||FEX||LEFT(ACD,MXHL) */
     OP.OPC=TCD||FEX||ACD
     END
    END
    END
   END
  OPC=OPC+1
  OP.OPC='     RESOURCE TYPES SECTION'
  OPC=OPC+1
  OP.OPC=LEFT('RESOURCES TYPES',MXHL)||FEX||,
         LEFT('RESOURCES TYPES',MXHL)
  NTW=WORDS(TWL)
  NAW=WORDS(AWL)
  OPC=OPC+1
  OP.OPC=LEFT('...'NTW,MXHL)||FEX||,
         LEFT('...'NAW,MXHL)
  IF NTW > NAW THEN NMX=NTW
   ELSE NMX=NAW
  DO I = 1 TO NMX
   IF I ^> NTW THEN TWD=WORD(TWL,I)
    ELSE TWD=''
   IF I ^> NAW THEN AWD=WORD(AWL,I)
    ELSE AWD=''
   OPC=OPC+1
 /*HTL=LENGTH(TWD)
   HAL=LENGTH(AWD)
   IF HAL > HTL THEN HTL = HAL
   IF HTL > MXHL THEN MXHL = HTL
   OP.OPC=LEFT(TWD,MXHL)||FEX||LEFT(AWD,MXHL) */
   OP.OPC=TWD||FEX||AWD
   END
  NGW=WORDS(GWL)
  J = 1
  ICT=100
 TOPGWL:
  RT=WORD(GWL,J)
  IF ONLYP ^= 0 THEN DO
   IF WORDPOS(RT,HDIRPRMS) = 0 THEN SIGNAL BOTGWL
   END
  RTA=STRIP(SUBSTR(RT,1,4),'B')
  IF RTA = '' THEN SIGNAL OUTOFGWL
  OPC=OPC+1
  OP.OPC=LEFT('LIST OF TOR 'RT,MXHL)||FEX||,
         LEFT('LIST OF AOR 'RT,MXHL)
  INTERPRET 'NTRW=T.'RTA'.CT'
  INTERPRET 'NARW=A.'RTA'.CT'
  INTERPRET 'TRWL=T.'RTA'.RCL'
  INTERPRET 'ARWL=A.'RTA'.RCL'
  IF NTRW > NARW THEN NMX=NTRW
   ELSE NMX=NARW
  DO I = 1 TO NMX
   OPC=OPC+1
   IF I ^> NTRW THEN TWD=WORD(TRWL,I)
    ELSE TWD=''
   IF I ^> NARW THEN AWD=WORD(ARWL,I)
    ELSE AWD=''
/* HTL=LENGTH(TWD)
   HAL=LENGTH(AWD)
   IF HAL > HTL THEN HTL = HAL
   IF HTL > MXHL THEN MXHL = HTL
   OP.OPC=LEFT(TWD,MXHL)||FEX||LEFT(AWD,MXHL) */
   OP.OPC=TWD||FEX||AWD
   END
 BOTGWL:
  J = J+1
  IF J > ICT THEN DO
 /*  SAY J */
  ICT=ICT+100
  END
  IF J ^> NGW THEN SIGNAL TOPGWL
 OUTOFGWL:
  OPC=OPC+1
  OP.OPC='...DIR REPORT FINISHED AT 'TIME()
  HOPLOG=OPLOG
  TMXL=(MXHL * 2) + 1
/*                       */
  TPC = 0
  DO I = 1 TO OPC
   OP.I =STRIP(OP.I,'T')
   TMP = OP.I
   IF TMP  = '' THEN DO
    TPC=TPC+1
    TP.TPC='*'
    ITERATE
    END
   PARSE VAR TMP P1 (FEX) P2
   P1L=LENGTH(P1)
   TCC=0
   DO WHILE P1L > MXHL
    TCC=TCC+1
    TC.TCC=SUBSTR(P1,1,MXHL)
    P1 = SUBSTR(P1,MXHL+1)
    P1L=LENGTH(P1)
    END
   TCC=TCC+1
   TC.TCC=LEFT(P1,MXHL)
   P2L=LENGTH(P2)
   ACC=0
   DO WHILE P2L > MXHL
    ACC=ACC+1
    AC.ACC=SUBSTR(P2,1,MXHL)
    P2 = SUBSTR(P2,MXHL+1)
    P2L=LENGTH(P2)
    END
   ACC=ACC+1
   AC.ACC=LEFT(P2,MXHL)
   EMP='-'||COPIES(' ',MXHL-1)
   DO WHILE ACC < TCC
    ACC=ACC+1
    AC.ACC = EMP
    END
   DO WHILE TCC < ACC
    TCC=TCC+1
    TC.TCC = EMP
    END
   DO YCC = 1 TO TCC
    TPC=TPC+1
    TP.TPC=TC.YCC||'|'||AC.YCC
    END
   END
/* NOW DROP THE OP. AND USE THE TP STEM QUEUE */
  IF OPLOG = 'DISPLAY' & TPC > 400 THEN DO
   TPC=TPC+1
   TP.TPC = '* DISPLAY OPTION CONVERSION. DISPLAY LINES EXCEEDED:'TPC
   GETUDSN EXECSEL
   PULL OPLOG
   DSNACTN='BROWSE'
   END
  IF OPLOG = 'DISPLAY' | OPLOG = 'RETURN' THEN SIGNAL ARNDOP
 ARNDALLI:
  IF OPLOG=HOPLOG THEN SIGNAL DSNPRVD
  ADDRESS ISPEXEC
   EDSN=OPLOG
   DSEMSG = 'ENTER TO ACCEPT, OVERTYPE, OR CANCEL'
   MYVERB = 'CANCEL'
   "ISPEXEC VPUT (EDSN DSEMSG MYVERB) ASIS"
   CALL DSNWIND
   XC = RESULT
   IF XC > 4 THEN SIGNAL BADDSN
   ADDRESS ISPEXEC "VGET (MYVERB EDSN) ASIS"
   IF RC ^= 0 THEN SIGNAL CANCEL8
   IF MYVERB ^= '' THEN DO
    IF MYVERB='ABORT' | MYVERB='CANCEL' THEN SIGNAL CANCEL8
    END
    ADDRESS TSO
  OPLOG=EDSN
 DSNPRVD:
  DSEMSG='ENTER DST DSN, LRECL='TMXL',RECFM(VB)'
 DSNPRVDA:
  EDSN = OPLOG
  BLKFM='V,B'
  HDSN=EDSN
  EXECSEL='RDOPROC'
  PARSE VAR EDSN EDSN '(' EMBR ')'
  TMBR=EMBR
  PDSXC=LISTDSI("'"EDSN"'" DIRECTORY NORECALL)
  IF PDSXC ^= 0 THEN DO
   SVDISP='REP'
   SIGNAL ALOCNEW
   END
  HSRECFM=SYSRECFM
  IF POS('V',HSRECFM) = 0 | POS('B',HSRECFM) = 0 THEN DO
   DSEMSG= '* TARGET MUST BE VARIABLE BLOCKED'
   SIGNAL TGTLOOP0
   END
  IF SYSDSORG='PO' THEN DO
   IF EMBR = '' THEN DO
    DSEMSG='TARGET IS PDS. MEMBER REQUIRED'
    EMBR='#MEMBER#'
    SIGNAL TGTLOOP0
    END
   IF SYSLRECL < TMXL THEN DO
    DSEMSG='TARGET IS PDS, BUT LRECL 'SYSLRECL' LT 'MXHL
    SIGNAL TGTLOOP0
    END
   TMBR = '('||STRIP(EMBR,'B')||')'
   SIGNAL OLDPDS
   END
  IF SYSDSORG ^= 'PS' THEN DO
   DSEMSG='TARGET DSORG 'SYSDSORG'. NEED PO OR PS.'
   SIGNAL TGTLOOP0
   END
 TGTLOOP0:
  IF EMBR = '' THEN EMBR = '#NOMBR#'
  "ISPEXEC VPUT (EDSN EMBR EXECSEL) ASIS"
  IF RC ^= 0 THEN RETURN 8
 TGTLOOP:
  HSVDISP = 'MOD REP DEL CAN'
 TGTLOOPA:
  SVDISP=HSVDISP
  "ISPEXEC VPUT (DSEMSG SVDISP) ASIS"
  IF RC ^= 0 THEN SIGNAL DSPOPX8
  CALL GDSNOMBR
  XC = RESULT
  IF XC ^= 0 & XC^=12 THEN SIGNAL CANCEL8
  "ISPEXEC VGET (EDSN EMBR SVDISP) ASIS"
  IF RC ^= 0 THEN SIGNAL EXITRC8
  IF EDSN ^= HDSN THEN DO
   OPLOG=EDSN
   SIGNAL DSNPRVDA
   END
  MYSVDISP=SVDISP
  IF WORDPOS(SVDISP,HSVDISP) = 0 THEN SIGNAL TGTLOOPA
  IF SVDISP = 'CAN' THEN SIGNAL CANCEL8
  IF SVDISP = 'MOD' THEN SIGNAL ALOCNEW
  IF XC = 0 THEN DO
   IF EMBR='' | EMBR='#NOMBR#' THEN DO
    IF SYSDSORG = 'PO' THEN MALOCSTR=EDSN
     ELSE MALOCSTR= '%NQA%('||EDSN||')'
    CALL MALOC MALOCSTR
    IF RESULT ^= 12 THEN SIGNAL EXITRC8
    END
   END
 ALOCNEW:
  IF EMBR = '' | EMBR = '#NOMBR#' THEN DO
   TMBR = ''
   DSO='DSORG(PS)'
   END
   ELSE DO
   TMBR = '('||STRIP(EMBR,'B')||')'
   IF PDSXC = 0 THEN SIGNAL OLDPDS
   DSO='DSORG(PO) DIR(1)'
   END
  TMXL=TMXL+4
  BLKSZ=TMXL+4
  MODATTR="NEW BLKSIZE("BLKSZ") "DSO||,
          " RECFM(V,B) SPACE("OPC",1)"||,
          "BLOCK("OPC") LRECL("TMXL") CATALOG REUSE"
  /* END OF INLINE VERSION */
  DSEMSG = '(R)REUSE,(D)DELETE/REALLOC,(C)CANCEL'
  MYVERB = 'ABORT BYPASS CANCEL REUSE DELETE'
  MODDSN=""
  "ISPEXEC VPUT (EDSN DSEMSG) ASIS"
  "ISPEXEC VPUT (EXECSEL MODDSN MODATTR MYVERB) ASIS"
  CALL ALOCDSN
  IF RESULT ^= 0 THEN SIGNAL CANCEL8
 OLDPDS:
  ADDRESS TSO
  EDSN=EDSN||TMBR
   OPTN = 0
   "ALLOC FI(M) DA('"EDSN"') SHR REUSE"
   TOTRECS=TPC
   IF SVDISP = 'MOD' THEN DO
    "EXECIO * DISKR M (STEM OPT. FINIS"
    OPTN=OPT.0
    OPO='OPT'
    J = OPTN
    DO I = 1 TO TPC
     J = J+1
     OPT.J = TP.I
     END
    TOTRECS=J
    END
    ELSE OPO='TP'
    INTERPRET OPO'.0 = TOTRECS'
    CALL OFF ERROR
   "EXECIO * DISKW M (STEM "OPO||". FINIS"
CALL ON ERROR NAME ERRX
   "FREE FI(M)"
   SIGNAL OFF ERROR
   IF DSNACTN = 'EDIT' | DSNACTN = 'BROWSE' THEN DO
    ADDRESS ISPEXEC DSNACTN" DATASET('"OPLOG"')"
    END
   RETURN 0
 ARNDDSN:
  IF OPLOG = 'RETURN' THEN DO
   DO I = 1 TO TPC
    PUSH TP.I
    END
   RETURN 0
   END
ARNDOP:
 MYAREA = ''
 MYAREA#=FFX
 DO I = 1 TO TPC
  MYAREA=MYAREA||TP.I||FFX
  END
 ADDRESS ISPEXEC "VPUT (MYAREA MYAREA#) ASIS"
 CALL DSPLYA
 RETURN 0
 CANCEL8:
  SAY 'CANCEL SELECTED'
  RETURN 8
 EXITRC8:
  SAY 'ERROR ENCOUNTERED'
  RETURN 8
 EXITRC0:
  SAY 'RDOPROC FINISHED'
  RETURN 0
 DSNSAME8:
  SAY '* SAME DSN(S) REQUESTED, AND'||,
          ' TOR GRP AND AOR GRP REQUESTS ARE SAME. ABORTING.'
  SIGNAL SHOWFRMT
 SHOWFRMTDS:
  SAY 'PARMS 2 AND OPTIONALLY 3, MUST BE CREATED BY RDOXTND '
  SAY ' (WHICH PRODUCES A VARIABLE BLOCKED DATASET)'
 SHOWFRMT:
  SAY 'RDOPROC REQUIRES 4 PARMS'
  SAY ' FIRST PARM IS DIR, RECON, RESCOMP, OR GRPCOMP'
  SAY '    (ALWAYS WILL GET A DIR REPORT, UNLESS     '
  SAY '    SUFFIX ABOVE WITH ONLY TO ELIMINATE DIR REPORT)'
  SAY '    SPECIFY REPORT SPECIFICS VIA THE FORMAT'
  SAY '     DIR<RESC-TYPE(RESC-PARM1,RESC-PARM2),...>'
  SAY 'EXPL:DIR<TRANSACTION(PRIORITY,PROGRAM),PROFILE(DPURGE)>'
  SAY ' SECOND PARM IS TOR RDO STRING FILE'
  SAY ' THIRD  PARM IS AOR RDO STRING FILE'
  SAY '             OF () TO OMIT THE AOR '
  SAY ' LAST   PARM IS OP LOG DSN OR THE WORD DISPLAY OR RETURN.'
  SAY '        IF OP DSN, THEN USE <EDIT> OR <BROWSE> FOR DISPLAY MODE'
  SAY 'CEMHELP RDOPROC WILL SHOW DETAILED DIRECTION FOR USAGE.'
  EXIT
 STRPIT: PROCEDURE EXPOSE PT TREC AREC SSTR FSTR
  INTERPRET 'XREC='PT'REC'
  PARSE VAR XREC XREC0 (SSTR) '(' FSTR ') ' XREC1
  LFSTR=LENGTH(FSTR)
  IF LFSTR > 0 THEN DO
   LP=SUBSTR(FSTR,LFSTR,1)
   DO WHILE(LP=')')
    FSTR=SUBSTR(FSTR,1,LFSTR-1)
    LFSTR=LENGTH(FSTR)
    IF LFSTR > 0 THEN LEAVE
    LP=SUBSTR(FSTR,LFSTR,1)
    END
   END
  INTERPRET PT"REC=STRIP(XREC0,'L')||XREC1"
  RETURN 0
 UNKNREC: PROCEDURE EXPOSE OPC OP. TMP
   OPC=OPC+1
   OP.OPC=PT' INPUT LOOP CONTAINS UNKNOWN RECORD'
   OPC=OPC+1
   OP.OPC=SUBSTR(TMP,1,78)
  RETURN 0
ERRX:
    XC=RC
    SVSIGL=SIGL
    SAY 'REXX ERROR 'XC' ON LINE 'SIGL':'
    SAY 'REXX:- APPLICATION RETURNED AN ERRORLEVEL' XC
    SIGNAL START
SYNX:
    XC=RC
    SVSIGL=SIGL
    SAY 'REXX ERROR 'XC' ON LINE 'SIGL':'ERRORTEXT(XC)
    SAY 'REXX:- ERROR' XC':' ERRORTEXT(XC)
    SIGNAL START
FAIX:
    XC=RC
    SVSIGL=SIGL
    SAY 'REXX ERROR 'XC' ON LINE 'SIGL':'
    IF XC = -3 THEN,
       SAY 'REXX:- PROGRAM NOT FOUND'
    ELSE IF XC = -8 THEN,
       SAY 'REXX:- INSUFFICIENT MEMORY FOR PROGRAM'
    ELSE,
       SAY 'REXX:- RETURN CODE' XC
    SIGNAL START
HALX:
    XC=RC
    SVSIGL=SIGL
    SAY 'REXX:- CTRL-BREAK INTEXCEPTED'
START:
  TRACE OFF
  XC=RC
SIGNAL ON HALT NAME XITIT
  SAY 'REXX ERROR 'XC' ON LINE 'SIGL':'ERRORTEXT(XC)
DO WHILE (1)
 SAY 'ENTER A VALID REXX COMMAND EXCEPT INTERPRET'
 PULL RESP
 IF WORD(RESP,1) = 'INTERPRET' THEN DO
  SAY 'DO NOT ENTER A INTERPRET COMMAND. RETRY'
  ITERATE
  END
 INTERPRET RESP
 END
 XITIT:
    PULL
    SIGNAL XITIT
 GET_RTSS_PAMS:
  RTSSTMP = RTSSTMP||' '||RT
  INTERPRET 'RTSS_'PT' = RTSSTMP'
  TMP2 = TMP
  RTSSLST = ''
  DO WHILE TMP2 \= ''
   PARSE VAR TMP2 VK '(' . ')' TMP2
   RTSSLST = RTSSLST||' '||VK
   END
  INTERPRET 'RTSS_'PT'.'RS' = RTSSLST'
  RETURN WORDS(RTSSLST)
###END RDOPROC
$$$BEG GETKREL
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA GETKREL  - PUSHES THE CICS REL INFO ONTO THE STACK 3.1  */
 /* CEMHELP GETKREL  - TSO REXX STACK BASED 3.1, TAKES ONE ARG      */
 /* CEMHELP          - KIXRELS VAR MUST BE ACCURATE LIST OF CURRENT */
 /* CEMHELP          -  SUPPORTED CICS 3 DIGIT RELEASE VALUES       */
 /* CEMHELP          - ARG MUST BE LENGTH OF 3 OR ERROR             */
 /* CEMHELP          - ARG: ??? WILL RETURN 2 VALUES                */
 /* CEMHELP          -       NUMBER OF RELEASES                     */
 /* CEMHELP          -       COMMA DELIMITED STRING, CODED WITH A   */
 /* CEMHELP          -       3 DIGIT RELEASE VALUE FOR EACH RELEASE */
 /* CEMHELP          - ARG: NNN IS THE RELEASE VALUE TO RETURN      */
 /* CEMHELP          -          SPECIFIC RELEASE DEPENDANT INFO     */
 /* CEMHELP          -      SUCH AS:                                */
 /* CEMHELP          -       KIXREL3  - THE 3 DIGIT REL NUMBER      */
 /* CEMHELP          -       KIXREL1  - THE 2 CHAR JCL VALUE        */
 /* CEMHELP          -                - USED TO RESOLVE SET INCLUDE */
 /* CEMHELP          -       KIXREL   - THE 4 CHAR RXXX JCL VALUE   */
 /* CEMHELP          - STACK RETURNS KIXREL1 KIXREL                 */
 /* CEMHELP          - NOTE - ADD LOGIC TO CIXXMAC EDITMAC          */
 /* CEMHELP          -      - SO THAT DFHPD, DFHTU, AND DFHDU       */
 /* CEMHELP          -      - WILL POINT AT THE CORRECT UTILITY MODS*/
 /* CEMHELP END                                                     */
 /*                                                                 *\
 |*                                                                 *|
 |* NOTE: EDIT AS A NEW RELEASE IS INTRODUCED TO THE ENVIRONMENT    *|
 |*  ELIMINATE DEFUNCT RELEASE.                                     *|
 |* NOTE: REMINDER TO CHANGE THE CIXXMAC EDITMAC WHICH  ALSO HAS    *|
 |*  CODE REQUIREMENTS DEPENDANT UPON THE REL VALUES                *|
 |*  AND EXCITSLB RX TO ESTABLISH TH PROPER EXCILIB ENVIR           *|
 |*                                                                 *|
 \*                                                                 */
 ADDRESS TSO
  /*                                                                 *\
  |* YOU MUST CHANGE THIS STRING AS NEW RELEASE BECOMES SUPPORTED    *|
  |* CURRENT (MOST PREVALENT) RELEASE SHOULD BE CODED FIRST          *|
  |* REMOVE SUNSET RELEASE VALUES FROM THE LIST                      *|
  \*                                                                 */
 /* TRACE ?I */
 KIXRELS='540 550'
 ARG KIXREL3
 IF LENGTH(KIXREL3) ^= 3 THEN DO
  PUSH "ERROR LENGTH"
  RETURN 12
  END
 IF KIXREL3 = '???' THEN DO
  KIXREL3 = KIXRELS
  KIXREL1= WORDS(TRANSLATE(KIXREL,' ',','))
  SIGNAL DONIT
  END
 KIXWD = WORDPOS(KIXREL3,KIXRELS)
 IF KIXWD = 0 THEN DO
  PUSH "ERROR REL_UNKNOWN"
  RETURN 12
  END
 KIXREL3 = WORD(KIXRELS,KIXWD)
 KIXREL1 = SUBSTR(KIXREL3,1,2)
 KIXREL  = 'R'||KIXREL3
DONIT:
 PUSH KIXREL1 KIXREL3
 EXIT
###END GETKREL
$$$BEG TST1
 /* REXX */
  TRACE ?I
  say 'enter Y or N or G(getkrel):'
  ans='test'
  parse upper external ans 2
  if ans = 'Y' then say 'Y'
   else say 'other:'ans':'
  if ans = 'G' then signal tst_getkrel
  astr='ab cfdefghij'
  cola=1;lena=4
  colb=3;lenb=5
  colc=2;lenc=5
  parse var astr =(colA) var1 +(lenA) .,
                   =(colB) var2 +(lenB) .,
                   =(colC) var3 +(lenC) .
  say var1;say var2;say var3
  q='test this'
  q.l=length(q)
  q.t='c'
  say q;say q.l;say q.t
  str1='this is a test'
  parse value str1 with a b c d e
  say a;say b;say c;say d;say e
  say str1
  str1='this is a test'
  parse var str1 a b c d e
  say a;say b;say c;say d;say e
  say str1
  str1='this is a test'
  do until(str1 = '')
  parse var str1 a str1
  say a;say str1
  end
  say str1
  count=2; year='1945'
  mystem.count.year=year
  say mystem.count.year
  year='1946'
  mystem.count.?year=year
  say mystem.count.year
  say mystem.count.?year
  year='1947'
  mystem.count.?year=?year
  say mystem.count.year
  say mystem.count.?year
  exit
  xxx.=8
  xxx.6=2
  do i = 0 to 10
   say '('||i||') ' xxx.i
   end
  exit
  mct = 0
  m.1.1='aaa'
  m.1.2='@'
  m.1.3='bbb'
  m.1.0=3
  mct = mct + 1
  m.2.1='xxx'
  m.2.2='$'
  m.2.3='yyy'
  m.2.4='!'
  m.2.5='zzz'
  m.2.0=5
  mct = mct + 1
  i=0
  j=0
  do k = 1 to mct
   l=m.k.0
   do h = 1 to l
    say k l h '>' m.k.h
    end
   end
ADDRESS ISPEXEC
 "ISPEXEC CONTROL ERRORS RETURN"
SIGNAL EXITBIGMSG
 EXITRC4:
  ZEDSMSG = 'DSN INVALID'
  ZEDLMSG = 'DSN PROVIDED IS INVALID'
  SIGNAL WRITIT
 EXITBIGMSG:
  ZEDSMSG = 'BIG INVALID'
  ZEDLMSG = 'THIS IS A TEST MESSAGE TO SEE HOW BIG THE LMSG CAN BE '||,
            'BEFORE IT COMPLAINS. E TO SEE HOW BIG THE LMSG CAN BE '||,
            'BEFORE IT COMPLAINS. E TO SEE HOW BIG THE LMSG CAN BE '||,
            'BEFORE IT COMPLAINS. E TO SEE HOW BIG THE LMSG CAN BE '||,
            'BEFORE IT COMPLAINS. E TO SEE HOW BIG THE LMSG CAN BE '||,
            'BEFORE IT COMPLAINS. as of this point, it works!!!!!! '
 WRITIT:
  'ISPEXEC SETMSG MSG(ISRZ000)'
  exit
 tst_getkrel:
  "GETKREL ???"
  PULL KIXRELLST
  IF KIXRELLST='' THEN DO
   KIXRELLST='0 320'
   END
  PARSE VAR KIXRELLST kixrelct KIXRELs
  KIXRELLST=TRANSLATE(KIXRELLST,' ',',')
  KIXCT=WORDS(KIXRELs)
  ktmp = '320'
 trykixagn:
  "GETKREL "ktmp
  PULL KIXRELLST
  PARSE VAR KIXRELLST kixrelct KIXRELs_too
  if kixrelct = 'ERROR' then do
   say kixrelct KIXRELLST
   if ktmp \= '320' then do
    say 'something weird in getkrel'
    leave
    end
   ktmp = word(kixrels,1)
   signal trykixagn
   end
  PARSE VAR KIXRELLST KIXREL1 KIXREL3
  KIXRELLST=TRANSLATE(KIXRELLST,' ',',')
  KIXCT=WORDS(KIXREL3)
 EXIT
 tst_true:
  MW='WORD '
  MWTOO='WORD'
  MW3='word'
  IF MW=MWTOO THEN SAY 'TRUE'
   ELSE SAY 'FALSE'
  IF MW==MWTOO THEN SAY 'TRUE'
   ELSE SAY 'FALSE'
  IF MW3=MWTOO THEN SAY 'TRUE'
   ELSE SAY 'FALSE'
  IF MW3==MWTOO THEN SAY 'TRUE'
   ELSE SAY 'FALSE'
ParsedString = "This is the String to be Parsed"
PARSE VAR ParsedString X1 X2 "be" X5 .
Say X1
Say X2
Say X5
x4='be'
PARSE VAR ParsedString y1 y2 (x4) y5 .
Say y1
Say y2
Say y5
PARSE VAR ParsedString z1 z2 =13 z5 .
Say z1
Say z2
Say z5
 Var1 = 'This'
 Var2 = 'is'
 Var3 = 'Passed'
 Call subrParseArg Var1 Var2 Var3
 Call subrArg Var1 Var2 var3
  EXIT
 SubrParseArg: Procedure
 Parse Arg s1 s2 s3
 Say s1 s2 s3
 Return
 SubrArg: Procedure
 Arg s1 s2 s3
 Say s1 s2 s3
 Return
  MYX=''
  SAY MYX
  MYD=X2D(C2X(MYX))
  SAY MYD
  MYX2=D2X(MYD,8)
  SAY MYX2
  EXIT
  SAY DATE('S') TIME()
  MYVAR='THIS'
  CALL P3
  MYVAR=MYVAR||' IS'
  CALL P2
  MYVAR=MYVAR||' A'
  CALL P1
  MYVAR=MYVAR||' TEST'
  CALL P2
  DO I = 1 TO 99
   INTERPRET "MYLBL"||I" = 'THIS IS LINE 'I"
   MYA.I = 'THIS IS LINE 'I
   END
 TRACE I
  TOPLN = 1
  BOTLN = 1
  MXLN = 99
  NEWMX = 0
  MYSCLN=0
  MYSCLA=''
  MYSCLD=''
  MYAREA = ''
  MYAT = ''
  MYAW=0
  MYDP=0
  MYROW = 0
  MYCOL = 0
  TRACE I
  MYLVLN = 0
  MYSC = 'PAGE'
  /*
  ADDRESS ISPEXEC "PQUERY PANEL(AFOFLDSD) AREANAME(MYAREA) "||,
   "AREATYPE(MYAT) WIDTH(MYAW) DEPTH(MYDP) ROW(MYROW) COLUMN(MYCOL)"
   */
  ADDRESS ISPEXEC "PQUERY PANEL(AFOFLDSD) AREANAME(MYAREA) "||,
   "AREATYPE(MYAT) WIDTH(MYAW) DEPTH(MYDP) ROW(MYROW) COLUMN(MYCOL)"
  DN = MYDP
 RETRYIT:
  BOTLN = TOPLN + DN - 1
  MYAREA = ''
  DO I = TOPLN TO BOTLN
   MYAREA = MYAREA||LEFT(MYA.I,MYAW)
   TRACE OFF
   END
  MYAREA1=MYAREA
  TRACE I
/*ADDRESS ISPEXEC "DISPLAY PANEL(AFOFLDSD)" */
  ADDRESS ISPEXEC "DISPLAY PANEL(MYTST1D)"
  XC = RC
  DN=MYSCLN
  DA=MYSCLA
  DD=MYSCLD
  LL=MYLVLN
  VCMD = CMD
  VVERB = MYVERB
  SELECT
   WHEN VVERB = 'UP' THEN DO
    TOPLN = TOPLN - DN
    IF TOPLN < 1 THEN TOPLN = 1
    END
   WHEN VVERB = 'DOWN' THEN DO
    TOPLN = TOPLN + DN
    NEWMX = MXLN - DN + 1
    IF TOPLN > NEWMX THEN TOPLN = NEWMX
    END
   WHEN VVERB = 'END' THEN DO
    SAY 'BYE BYE'
    RETURN 0
    END
   OTHERWISE NOP
   END
  SIGNAL RETRYIT
 P1:
  SAY "P1 CALLED WITH:"MYVAR
 P2:
  SAY "P2 CALLED WITH:"MYVAR
 P3:
  SAY "P3 CALLED WITH:"MYVAR
 RETURN
###END TST1
$$$BEG ALOCDSN
/* REXX */
/* CEMHELP BEGIN                                                     */
/* CEMHELA ALOCDSN  - ISPF SUBROUTINE TO ALLOCATE TARGET DSN         */
/* CEMHELP ALOCDSN  - ISPF BASED SUBROUTINE CALLED BY EXEC WHICH     */
/* CEMHELP          - REQUIRE A DSN BE VALDATED AND OR ALOCATED NEW. */
/* CEMHELP          - EXPECTS THAT THE CALLING ROUTINE PROVIDE ISPF  */
/* CEMHELP          - VARIABLES BELOW:                               */
/* CEMHELP          -   EDSN = 'THIS.IS.YOUR.DSN'                    */
/* CEMHELP          - MODDSN = 'THIS.IS.YOUR.MODEL.DSN'              */
/* CEMHELP          -  IF YOU PROVIDE A MODDSN, THEN THE ATTR FROM   */
/* CEMHELP          -   THE MODEL ARE USED AS THE SOURCE FOR ALLOC   */
/* CEMHELP          -   OTHERWISE MAKE MODDSN NULL. THIS WILL FORCE  */
/* CEMHELP          -   USE OF MODATTR.  IF YOU OMIT MODDSN AND THE  */
/* CEMHELP          -   THE VGET RC=8 THEN WE USE THE EDSN AS THE    */
/* CEMHELP          -   MODDSN IF IT EXISTS.                         */
/* CEMHELP          -  YOU CAN CHOOSE TO PROVIDE AN MODATTR WITH THE */
/* CEMHELP          -   EXPLICITE ATTRIBUTES FOR ALLOC.              */
/* CEMHELP          - MODATTR="NEW BLKSIZE(129) DSORG(PS) "||,       */
/* CEMHELP          -         "RECFM(V,B) SPACE(1,1)"||,             */
/* CEMHELP          -         "CYLINDER LRECL(125) CATALOG REUSE"    */
/* CEMHELP          - DSEMSG = 'THIS IS YOUR MESSAGE FOR POP WINDOW' */
/* CEMHELP          - EXECSEL = 'APPLID' YOUR CALLING EXEC,PANEL,ECT */
/* CEMHELP          - MYVERB = 'ABORT BYPASS CANCEL REUSE DELETE'    */
/* CEMHELP          -          'MOD'                                 */
/* CEMHELP          - MYVERB = '' THIS IS RETURNED TO YOU WITH THE   */
/* CEMHELP          -          SELECTED PROCESSING OPTION.           */
/* CEMHELP          - I.E. PROCESSING OPTIONS PROVIDED FOR ARE       */
/* CEMHELP          -  (ABBREVIATED BY FIRST CHARACTER TO FULL WORD) */
/* CEMHELP          -  CANCEL,BYPASS,HDEL,REUSE,DELETE,ABORT         */
/* CEMHELP          - VPUT THEN TO ISPF VARPOOL                      */
/* CEMHELP          - "ISPEXEC VPUT (EDSN DSEMSG) ASIS" REQUIRED     */
/* CEMHELP          - "ISPEXEC VPUT "||,                             */
/* CEMHELP          - "(EXECSEL MODDSN MODATTR MYVERB) ASIS"         */
/* CEMHELP          - CALL TO ALOCDSN WILL RETURN 0 IF SUCESSFUL     */
/* CEMHELP          -  OR 4 IF ABORT, OR GREATER THAN 4 IF ERROR.    */
/* CEMHELP          - EXEC ALSO RETURNS THE ISPF VARS                */
/* CEMHELP          - "ISPEXEC VPUT (EDSN MYVERB) ASIS" REQUIRED     */
/* CEMHELP          - EDSN IS NAME OF ALLOCATED DS (IT COULD HAVE CHG*/
/* CEMHELP          - MYVERB WAS TYPE OF ACTION REQUESTED FROM USER  */
/* CEMHELP          - NOTE - TO DELETE A DSN AND REALLOC WITH YOUR   */
/* CEMHELP          -      - CURRENT NEEDS, YOU SHOULD CODE THE DSN  */
/* CEMHELP          -      - VALUE PASSED IN EDSN AS FOLLOWS:        */
/* CEMHELP          -      - EDSN='%NQA%('DSNM')'                    */
/* CEMHELP          -      - INTERNAL EXEC WILL DELETE/HDEL ANY DSNM */
/* CEMHELP          -      - UNLESS IT BEGINS WITH TTEP,SYS1,SYS2,...*/
/* CEMHELP USE BELOW AS EXAMPLE CODE TO CALL THIS EXEC               */
/* CEMHELP SUID=SYSVAR(SYSUID)                                       */
/* CEMHELP ODSN='TTED.TSK.S.'SUID'.FAPRINT'                          */
/* CEMHELP EDSN = ODSN                                               */
/* CEMHELP EXECSEL = 'ALOCFAID'                                      */
/* CEMHELP DSEMSG = '(R) REUSE,(D) DEL/REALLOC,(A) ABORT'            */
/* CEMHELP MODATTR="NEW BLKSIZE(129) DSORG(PS) "||,                  */
/* CEMHELP  "RECFM(V,B) SPACE(1,1)"||,                               */
/* CEMHELP  "CYLINDER LRECL(125) CATALOG REUSE"                      */
/* CEMHELP ADDRESS ISPEXEC "VPUT (EDSN EXECSEL DSEMSG MODATTR) ASIS" */
/* CEMHELP IF RC ^= 0 THEN SIGNAL EXITRC8                            */
/* CEMHELP CALL ALOCDSN                                              */
/* CEMHELP XC = RESULT                                               */
/* CEMHELP IF XC = 8 THEN SIGNAL CANCEL8                             */
/* CEMHELP IF XC ^= 0 THEN SIGNAL EXITRC8                            */
/* CEMHELP DOALOC:                                                   */
/* CEMHELP "ALLOC FI(FAPRINT) DA('"ODSN"') SHR REUSE"                */
/* CEMHELP END                                                       */
 /* LOGIC ERROR - CHANGED CODE FOR MYVERB (DELETE)-LOOK FOR CEM      */
 /* LOGIC ERROR - CHANGED CODE FOR MYVERB (DELETE)-LOOK FOR CEM      */
 VALDSWDS='PROMPT NQA'
  ADDRESS ISPEXEC "VGET (EXECSEL) ASIS"
  ADDRESS ISPEXEC "VGET (EDSN DSEMSG) ASIS"
  IF RC ^= 0 THEN RETURN 8
  PARSE VAR EDSN DSACT '<' PDSN '>'
  IF PDSN='' THEN DO
   EDSN=DSACT
   DSACT=''
   END
   ELSE DO
   EDSN=PDSN
   IF WORD(DSACT,VALDSWDS) = 0 THEN RETURN 8
   END
  MODATTR = ''
  ADDRESS ISPEXEC "VGET (MODATTR) ASIS"
  HLDATTR = MODATTR
  SVVERB = 'ABORT BYPASS CANCEL REUSE DELETE HDEL MOD'
  #SVV=WORDS(SVVERB)
  ADDRESS ISPEXEC "VGET (MYVERB) ASIS"
  IF RC ^= 0 THEN DO
   MYVERB = SVVERB
   END
   ELSE HHVERB=MYVERB                        /* CEM CHG SVVERB=MYVERB*/
  MYVERB = ''                                /* CEM ADDED            */
  ADDRESS ISPEXEC "VPUT (MYVERB) ASIS"       /* CEM ADDED            */
 REDOVDT:
  IF DSACT = 'NQA' THEN DO
   EDSN='%NQA%('||EDSN||')'
   "ISPEXEC VPUT (EDSN) ASIS"
   END
  CALL VLDTTGT
  XC = RESULT
 /* VLDTTGT RETURNS                                                   */
 /*   0 IF THE DSN IS VALID AND EXISTS                                */
 /*   4 IF THE DSN IS VALID BUT IS UNAVAILABLE (HMIGR???)             */
 /*   8 IF DSN PASSED IS INVALID OR EXEC ERROR OR ABC                 */
 /*  12 IF DSN DOES NOT EXIST                                         */
 /*  16 IF ATTN RTN WAS ENTERED                                       */
  /* TRACE I */
  ADDRESS ISPEXEC
  ADDRESS ISPEXEC "VGET (EDSN MYVERB) ASIS"
  IF RC ^= 0 THEN RETURN 8
  ODSN = EDSN
  IF XC = 12 THEN SIGNAL NOTKNOWN
  IF XC ^= 0 THEN RETURN 8
 /* HERE WE KNOW DSN EXISTS, SO WE ASK MORE QUESTIONS */
 /* IF MYVERB CHGN FROM ALOCDSN TO REUSE THEN WE KNOW THAT HRESTORE */
 /*  SO WE DON'T ASK AGAIN                                          */
  IF MYVERB = 'REUSE' THEN RETURN 0
  IF MYVERB = 'MOD'   THEN RETURN 0
  IF MYVERB = 'DELETE' THEN SIGNAL DELIT
  IF MYVERB = 'HDEL' THEN SIGNAL DELIT
 REDOWIND:
   MYVERB = SVVERB
   "ISPEXEC VPUT (MYVERB) ASIS"
   CALL DSNWIND
   XC = RESULT
/*   0 IF WINDOW IS SUCESSFULLY DISPLAYED, NOT PF3 AND VARS VPUT     */
/*   4 IF ONE OF PREDEFINED VALUES NOT SELECTED                      */
/*   8 IF PF3 WAS STRUCK TO END WINDOW (CANCEL???)                   */
/*  12 UNUSED                                                        */
/*  16 IF ANY OF VGET VPUT FAILED OR WINDOW DISPLAY FAILED           */
   IF XC > 4 THEN SIGNAL EXITRC8
   ADDRESS ISPEXEC "VGET (MYVERB) ASIS"
   IF RC ^= 0 THEN SIGNAL EXITRC8
   SELECT
    WHEN MYVERB = 'ABORT' THEN SIGNAL EXITRC8
    WHEN MYVERB = 'BYPASS' THEN SIGNAL EXITRC8
    WHEN MYVERB = 'CANCEL' THEN SIGNAL EXITRC8
    WHEN MYVERB = 'REUSE' THEN RETURN 0
    WHEN MYVERB = 'MOD'   THEN RETURN 0
    WHEN MYVERB = 'DELETE' THEN NOP
    WHEN MYVERB = 'HDEL' THEN NOP
    WHEN MYVERB = 'DLTD' THEN NOP
    WHEN MYVERB = '' THEN NOP
    WHEN WORDPOS(MYVERB,SVVERB) ^= 0 THEN RETURN 0
    OTHERWISE SIGNAL REDOWIND
    END
  DELIT:
   ADDRESS ISPEXEC "VGET (EDSN) ASIS"
   IF RC ^= 0 THEN RETURN 8
   IF EDSN ^= ODSN THEN SIGNAL REDOVDT
   IF MYVERB = '' THEN SIGNAL REDOWIND
   "ISPEXEC VGET (MODDSN) ASIS"
   IF RC ^= 0 THEN SIGNAL USEEDSN
   IF MODDSN = '' THEN SIGNAL SETNEW
    ELSE SIGNAL DOGETAT
  USEEDSN:
   MODDSN = EDSN
   ADDRESS ISPEXEC "VPUT (MODDSN) ASIS"
   SIGNAL DOGETAT
   END
   RETURN 8
  NOTKNOWN:
  /* WE GET HERE BECAUSE VLDTTGT PASSED AN RC = 12.    WE HAVE A 12 */
  /* THEN WE KNOW THE DSN IS NOT ALLOCATED, AND WE TRY TO ALLOCATE. */
  /* OTHERWISE, WE ARE GOING TO RETURN A RC OF 8 TO INDICATE ERROR. */
  /* ALLOCATION OF DSN ACCORDING TO:                                */
  /*  CHECK IF MODDSN (MODEL DSN) PROVIDED. IF SO WE GO TO GET ATTR */
  /*  IF THE MODDSN IS NOT NULL.  IF NULL, ERROR.                   */
  /*  IF THE MODDSN IS NOT NULL.  IF NULL, THEN CHECK MODATTR.      */
   IF XC = 12 THEN DO
    ADDRESS ISPEXEC "VGET (MODDSN) ASIS"
    IF RC ^= 0 THEN SIGNAL SETNEW
    IF MODDSN ^= '' THEN SIGNAL DOGETAT
     ELSE SIGNAL SETNEW
    END
   RETURN 8
DOGETAT:
  CALL CLONEDS 'GETATTR'
  XC = RESULT
  IF RC ^= 0 THEN RETURN 4
SETNEW:
  ADDRESS ISPEXEC "VGET (MODATTR) ASIS"
  IF RC ^= 0 THEN RETURN 8
  IF MODATTR ^= '' THEN SIGNAL DOALOC
  IF HLDATTR = '' THEN RETURN 8
  MODATTR = HLDATTR
DOALOC:
  IF MYVERB = 'DELETE' THEN DO
   "DELETE '"ODSN"' SCRATCH"
    END
  IF MYVERB = 'HDEL' THEN DO
   "HDEL '"ODSN"'"
   OKCAN1='WAITING FOR HDEL'
   OKCAN2='4 OK OR CANCEL?'
   OKRET0='Y,O'
   OKRET4='N,C'
   OKWINTL='ALOCDSN'
   ADDRESS ISPEXEC 'VPUT (OKCAN1 OKCAN2 OKRET0 OKRET4 OKWINTL) ASIS'
   CALL CEMWAIT '<>'
   IF RESULT > 0 THEN EXIT
   END
  ADDRESS TSO
  SJDT = DATE('J')
  STIM = TIME('N')
  STIM = SUBSTR(STIM,1,2)||SUBSTR(STIM,4,2)
  SIGNAL ON ERROR NAME EXITRC8
  AF='#'||SUBSTR(SJDT,3,3)||SUBSTR(STIM,1,4)
  "ALLOC FI("AF") DA('"ODSN"') "MODATTR
  "FREE FI("AF")"
  RETURN 0
 EXITRC8:
  RETURN 8
###END ALOCDSN
$$$BEG RDOXTND
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA RDOXTND  - PRODUCE RDO EXTENDED FORMAT FROM EXTRACT MBR */
 /* CEMHELP RDOXTND  - TSO BASE, PRODUCED A 'EXTENDED RDO FORMAT'   */
 /* CEMHELP          - SEQUENTIAL DSN WHICH REPRESENTS THE DATA READ*/
 /* CEMHELP          - FROM AN EXTRACTED RDO SOURCE DATASET.  THIS  */
 /* CEMHELP          - SOURCE IS MANIPULATED SO THAT EACH ENTRY     */
 /* CEMHELP          - IS STRUNG OUT INTO A SINGLE RECORD.  THUS THE*/
 /* CEMHELP          - OUTPUT SEQUENTIAL DATASET WILL BE A VARIABLE */
 /* CEMHELP          - BLOCK, WHOSE BLOCKSIZE IS DEPENDENT ON THE   */
 /* CEMHELP          - LARGEST RESULTANT EXTENDED RECORD.           */
 /* CEMHELP          - PARM ONE IS REQUIRED AND IS THE SOURCE WHICH */
 /* CEMHELP          - HOLDS THE EXTRACTED RDO SOURCE. THE SOURCE   */
 /* CEMHELP          - PARM 1 DSN CAN BE A PDS(MBR), OR A SEQ DSN,  */
 /* CEMHELP          - OR A PDS WITH A MEMBER NAME WHICH IS         */
 /* CEMHELP          - HOLDING A LIST OF MEMBERS, TO   DIRECT  THE  */
 /* CEMHELP          - EXEC TO PROCESS SPECIFIC MEMBERS, THIS PDS.  */
 /* CEMHELP          - THE OUTPUT IS PLACED INTO NEW SEQ DSN. IF MBR*/
 /* CEMHELP          - ARE THE SAME AS THE INPUT PDS, EXCEPT WE LOOK*/
 /* CEMHELP          - FOR A '.P.' QUALIFIER, AND CHANGE IT TO '.S.'*/
 /* CEMHELP          - IF THE INPUT DSN DOESNOT HAVE A '.P.' QUALIFR*/
 /* CEMHELP          - THEN THE ENTIRE INPUT SOURCE DSNAME IS USED, */
 /* CEMHELP          - SUFFIXED WITH THE MEMBER NAME BEING PROCESSED*/
 /* CEMHELP          - IF THE DSN IS SEQUENTIAL, THEN THE EXEC WILL */
 /* CEMHELP          - SUFFIX THE OUTPUT NAME WITH THE VALUES THAT  */
 /* CEMHELP          - CAN BE PROVIDED AS THE SECOND PARM, OR       */
 /* CEMHELP          - DEFAULTED TO 'RDOXTND' SUFFIX.               */
 /* CEMHELP          - THE SECOND PARM IS USED TO DRIVE THE PROCESS,*/
 /* CEMHELP          - AND TO DERIVE THE DSN OF THE OUTPUT DS. PARM */
 /* CEMHELP          - TWO IS USED TO PRODUCE THE LAST QUALIFIER    */
 /* CEMHELP          - OF THE OUTPUT DSN, ACCORDING TO THE FOLLOWING*/
 /* CEMHELP          -  IF 2ND PARM OMITTED, THEN USED 'RDOXTND'    */
 /* CEMHELP          -  IF THE 2ND PARM IS A DSN, IT IS USED AS THE */
 /* CEMHELP          -   TARGET.                                    */
 /* CEMHELP          -  IF 2ND PARM IS MEMBER, USE LIST OF GROUPS   */
 /* CEMHELP          -   AS THE SOURCE OF DSN SUFFIX QUAL, 1 PER    */
 /* CEMHELP          - NOTE- EACH MEMBER IN THE INPUT PDS WILL BE   */
 /* CEMHELP          - SENT THROUGH THE PROCESS.  IF YOU NEED TO    */
 /* CEMHELP          - BE SELECTIVE, CREATE A SEPARATE MEMBER IN THE*/
 /* CEMHELP          - INPUT PDS WHICH IDENTIFIES THE SUBLIST OF    */
 /* CEMHELP          - MEMBERS TO PROCESS, EACH MEMBER NAME CODED   */
 /* CEMHELP          - 1 PER LINE, COLS 1 THROUGH 8.                */
 /* CEMHELP END                                                     */
  ADDRESS TSO
  EXECSEL='RDOXTND'
  ARG HDSN XDSN
  /* TRACE ?I */
  IF HDSN = '' THEN SIGNAL EXITRC12
  IF XDSN = '' THEN XDSN='RDOXTND'
  PARSE VAR HDSN HDSN '(' MBRLST ')'
  NWD=WORDS(MBRLST)
  XC=LISTDSI("'"HDSN"'" NODIRECTORY NORECALL)
  IF XC ^= 0 THEN SIGNAL EXITRC12
  HDSNDSO=SYSDSORG
  HXDSN=HDSN
  IF HDSNDSO = 'PO' THEN DO
   FP=POS('.P.',HXDSN)
   IF FP ^= 0 THEN HXDSN=OVERLAY('.S.',HXDSN,FP)
   END
  CHKMBR=''
  XMBRPFX='.'
  XMBRSFX=''
  IF LENGTH(XDSN) > 9 THEN SIGNAL DOCHKXD
  IF XDSN = '*' THEN DO
   CHKMBR = '*'
   XDSN=HXDSN
   SIGNAL DONEXDSN
   END
   IF XDSN = '(*)' THEN DO
    CHKMBR = '*'
    XMBRPFX='('
    XMBRSFX=')'
    XDSN=HXDSN
    END
    ELSE XDSN=HXDSN||'.'||XDSN
   SIGNAL DONEXDSN
DOCHKXD:
   IF POS('(',XDSN) ^= 0 THEN DO
    PARSE VAR XDSN XDSN '(' CHKMBR ')'
    IF CHKMBR = '' THEN SIGNAL BADTGT
    XMBRPFX='('
    XMBRSFX=')'
    END
DONEXDSN:
  EDSN=HDSN
  IF HDSNDSO = 'PS' THEN DO
   MBRLST=EXECSEL
   NWD=0
   SIGNAL GOTONE
   END
  IF NWD=0 THEN SIGNAL NEEDMBR
  IF NWD>1 THEN SIGNAL GOTMANY
  "ALLOC FI(I) DA('"HDSN||"("||MBRLST||")') SHR REUSE"
  "EXECIO * DISKR I (STEM CPY. FINIS"
  "FREE FI(I)"
  MBRCT=CPY.0
  MBRLST=''
  DO I = 1 TO MBRCT
   TMBR=STRIP(SUBSTR(CPY.I,1,8),'B')
   IF LENGTH(TMBR)>8 THEN SIGNAL GOTONE
   MBRLST=MBRLST||' '||TMBR
   END
  MBRLST=STRIP(MBRLST,'B')
  IF MBRLST = '' THEN SIGNAL EXITRC12
 NWD=WORDS(MBRLST)
 IF NWD = 0 THEN SIGNAL EXITRC4
GOTMANY:
 DROP CPY.
GOTONE:
 J=1
TOPOFLST:
 IF MBRLST='' THEN DO
  EMBR=EXECSEL
  SAY 'NON LIST PROCESSING 'EMBR
  SIGNAL BYPREAD
  END
 EMBR = WORD(MBRLST,J)
 SAY EMBR
 IF LENGTH(EMBR) > 8 THEN CBK=EMBR
  ELSE DO
  IF HDSNDSO='PO' THEN CBK=EDSN||'('||EMBR||')'
   ELSE CBK=HDSN
  END
 ADDRESS TSO
 IF SYSDSN("'"CBK"'") ^= 'OK' THEN DO
  SAY CBK' IS NOT FOUND'
  SIGNAL BOTOFLST
  END
 "ALLOC FI(I) DA('"CBK"') SHR REUSE"
 "EXECIO * DISKR I (STEM CPY. FINIS"
 "FREE FI(I)"
BYPREAD:
 I = 1
 OPC=0
 CCATSTR=''
 BYPWDS='ADD LIST DELETE COPY'
 MXLN=0
 INSTR=0
 CPYTOT=CPY.0
 LOPDETK=0
TOPOFLOP:
  IF I = LOPDETK THEN DO
   SAY 'LOOP DETECTED. ATTN TO HALT, ENTER TO TRACE I'
   PULL QUTNOW
   TRACE I
   END
  TMP=STRIP(CPY.I,'B')
  IF TMP='' THEN SIGNAL NXTLNE
  IF SUBSTR(TMP,1,1) = '*' THEN SIGNAL NXTLNE
  FWD=WORD(TMP,1)
  BYPWDIND=WORDPOS(FWD,BYPWDS)
  IF BYPWDIND ^= 0 THEN SIGNAL CHKINSTR
  IF FWD = 'DEFINE' THEN SIGNAL CHKINSTR
  IF INSTR=1 THEN DO
   CCATSTR=CCATSTR||' '||TMP
   SIGNAL NXTLNE
   END
  CCATSTR=TMP
  INSTR = 1
  SIGNAL NXTLNE
 CHKINSTR:
  IF INSTR = 1 THEN DO
   OPC=OPC+1
   OP.OPC=CCATSTR
   CCATSTRL=LENGTH(CCATSTR)
   IF CCATSTRL>MXLN THEN MXLN=CCATSTRL
   INSTR = 0
   END
  IF BYPWDIND=0 THEN DO
   INSTR=1
   CCATSTR=TMP
   END
NXTLNE:
  I = I+1
  IF I ^> CPYTOT THEN SIGNAL TOPOFLOP
  IF INSTR=1 THEN DO
   OPC=OPC+1
   OP.OPC=CCATSTR
   CCATSTRL=LENGTH(CCATSTR)
   IF CCATSTRL>MXLN THEN MXLN=CCATSTRL
   END
  IF CHKMBR = '' THEN SIGNAL NXTMBR
  IF CHKMBR ^= '*' THEN SIGNAL NXTMBR
  /* XDSN WAS EXAMINED UP TOP  FOR '*' OR  FOR SOME.DSN(*) */
  /* IF IT JUST CONTAINED AN '*' THEN WE WILL CREATE SEQ   */
  /*  OUTPUT DSN BASED ON THE SET XDSN AND MBRLST NAME     */
  /* IF XDSN CONTAINED A (*) THEN WE STILL USE MBRLST NAME */
  /*  BUT USE THE PDS NAME IN XDSN WITH MBRLST NAME        */
  /* * WHEN PDS AS XDSN AND * THEN WE MUST INSURE XDSN CAN */
  /* * HOLD THE SIZE OF OUTPUT DSN. ELSE WE REPROMPT.      */
  /* * IF NEW, THEN WE RECREATE.                           */
  /* * SET THE XMBRPFX TO '(' FOR PDS OR '.' FOR SEQ       */
  /* * SET THE XMBRSFX TO ')' FOR PDS OR ''  FOR SEQ       */
  /* WHEN XMBR WAS '' THEN WE TACK ON THE EXECSEL VALUE AND*/
  /*  WOULD ONLY OUTPUT ONCE AT END OF ALL MBRLST          */
  /* WHEN XMBR WAS DSN AND ALSO HAD (XMBR) THEN WE         */
  /*  WOULD ONLY OUTPUT ONCE AT END OF ALL MBRLST          */
  /* WHEN XMBR WAS DSN THEN WE                             */
  /*  WOULD ONLY OUTPUT ONCE AT END OF ALL MBRLST          */
  EDSN=XDSN||XMBRPFX||EMBR||XMBRSFX
ALOCXTGT:
  IF XMBRPFX = '(' THEN CKXDSN=XDSN
   ELSE CKXDSN=EDSN
  XC = LISTDSI("'"CKXDSN"'" NODIRECTORY NORECALL)
  IF RC ^= 0 THEN SIGNAL XDSNNEW
  IF XMBRPFX = '(' THEN DO
   IF SYSDSORG ^= 'PO' THEN DO
    CALL VALDTGT
    END
   END
ALOCNTGT:
  MODDSN = ''
  DSEMSG = '(R) REUSE,(D) DEL/REALLOC,(A) ABORT'
  MXLN=MXLN+4
  BS=MXLN+4
  MODATTR="NEW BLKSIZE("BS") DSORG(PS) RECFM(V,B) SPACE("OPC",1) "||,
   "BLOCK("BS") LRECL("MXLN") CATALOG REUSE"
  ADDRESS ISPEXEC "VPUT (EDSN EXECSEL DSEMSG MODATTR MODDSN) ASIS"
  IF RC ^= 0 THEN SIGNAL EXITRC8
  CALL ALOCDSN
  IF RESULT = 8 THEN SIGNAL CANCEL8
  IF RESULT ^= 0 THEN SIGNAL EXITRC8
  ADDRESS ISPEXEC "VGET (EDSN) ASIS"
  IF RC ^= 0 THEN SIGNAL EXITRC8
  "ALLOC FI(O) DA('"EDSN"') SHR REUSE"
  "EXECIO * DISKW O (STEM OP. FINIS"
  "FREE FI(O)"
 NXTMBR:
  IF CHKMBR='*' THEN DROP OP.
  DROP CPY.
 BOTOFLST:
  J=J+1
  IF J ^> NWD THEN SIGNAL TOPOFLST
  IF CHKMBR ^= '*' THEN DO
   CHKMBR='*'
   EDSN = XDSN
   SIGNAL ALOCXTGT
   END
  IF NWD > 1 THEN DO
   ADDRESS ISPEXEC
   EDSN=XDSN
   "ISPEXEC VPUT (EDSN MBRLST) ASIS"
   "ISPEXEC EDIT DATASET('TTED.TSK.P.TCEM.CNTL(TBS)') MACRO(TBSY3MAC)"
   END
  SAY EDSN
  SAY 'DONE ALL.....'
  EXIT
EXITRC4:
 SAY 'NO MEMBERS IN 'HDSN
 RETURN 4
EXITRC8:
 SAY 'ERROR OCCURRED. ENDING EXEC.'
 RETURN 4
CANCEL8:
 SAY 'CANCEL/ABORT/BYPASS OPTIONS SELECTED'
 RETURN 4
EXITRC12:
 SAY 'RETURN CODE 12 FROM SOME OPERATION'
 RETURN 4
###END RDOXTND
$$$BEG COPYSEL
/* REXX */
/* CEMHELP BEGIN                                                     */
/* CEMHELA COPYSEL   - TSO BASED, RETURNS CICS DATA  ACCDG TO SPECS  */
/* CEMHELP COPYSEL   - TSO BASED, PROMPTS YOU FOR SELECTION CRITERIA.*/
/* CEMHELP           - OR ALLOW ARGUMENT SELECTION FOR NO PROMPTS.   */
/* CEMHELP           - YOU CAN SELECT THE REGION TYPE (EXPR,TEST,ACCP*/
/* CEMHELP           - PROD OR ALL) AN THEN THE RELEASE TYPE (310,320*/
/* CEMHELP           - 420 510, OR 999 (ALL).   OPTIOANLLY PROVIDE A */
/* CEMHELP           - VALID CPU ID TO LIMIT SEL. EXEC READS THE AFO */
/* CEMHELP           - CTL FILE AND MAKES THE REQUESTED SELECTIONS.  */
/* CEMHELP           - THE EXEC ALSO PROVIDES FOR CURRENT CICS TABLE */
/* CEMHELP           - REPORTING USING A LIST OF DESIRED TABLES. YOU */
/* CEMHELP           - MUST EDIT THIS LIST. SEE VAL TBLS FOR DEFAULT */
/* CEMHELP           - LIST.  YOU CAN SPECIFY NO TABLE RESOLUTION BY */
/* CEMHELP           - CODING THE PROMPT FOR TABLE, JCL, PARM AS N.  */
/* CEMHELP           - IF ANY TBLS ARE DESIRED, YOU SHOULD INCLUDE   */
/* CEMHELP           - THE SIT AS ONE OF THEM. THE MAX REPORTING     */
/* CEMHELP           - CAPABILITY IS SET TO 17 TABLE SUFFIXES.  THE  */
/* CEMHELP           - EXEC WILL REPORT ON THE SELECTED COPIES, THEIR*/
/* CEMHELP           - APPLIDS, SELECTED TABLE SUFFIXES (IF ANY) AND */
/* CEMHELP           - THEN (STARTING AT COLUMN 68 IN EACH OUTPUT    */
/* CEMHELP           - REC) THE CPU THAT REGION RUNS ON,             */
/* CEMHELP           -      THE REGION TYPE (E,T,A,P), RELEASE, AND  */
/* CEMHELP           - FINALLY, THE 'COLD' JOB NAME.  YOU CAN OVER   */
/* CEMHELP           - RIDE THE REQUESTD COLD JOB  WITH ANOTHER COPY */
/* CEMHELP           - JCL MEMBER. WHEN ALL IS DONE,  THE EXEC WILL  */
/* CEMHELP           - PROMPT YOU FOR A MEMBER TO SAVE THE RESULT    */
/* CEMHELP           - LIST. WARNING, WHEN TABLES ARE BEING RESOLVED,*/
/* CEMHELP           - THE EXEC MANUFACTURES COS NAMES FOR PARMLIB,  */
/* CEMHELP           - TABLE.SOURCE. IF THESE DON'T EXIST THEN YOU   */
/* CEMHELP           - WILL BE PROMPTED FOR A SUBSTITUTE. IF YOU DO  */
/* CEMHELP           - NOT PROVIDE THE SUBSTITUTE, IT WILL NOT       */
/* CEMHELP           - REPORT ON TABLES FOR THE SPECIFIC COPY.       */
/* CEMHELP           - IF YOU WISH TO REPORT ON SIT/PARM SPECS THEN  */
/* CEMHELP           - CODE THE P FOR REQUEST TYPE AND CODE THE      */
/* CEMHELP           - VARIOUS EXACT SIT PARMS TO REPORT ON.  FINALLY*/
/* CEMHELP           - IF YOU WISH TO REPORT ON COMMON JCL SYMBOLIC  */
/* CEMHELP           - PARMS, THEN CODE THE J FOR REQUEST TYPE AND   */
/* CEMHELP           - FOLLOW WITH YOUR EXACT JCL SPECS TO SEARCH AND*/
/* CEMHELP           - REPORT ON.                                    */
/* CEMHELP           - YOU CAN INVOKE THIS AS A CALL BY PASSING A    */
/* CEMHELP           - PARM IN THE FOLLOWING FORMAT:                 */
/* CEMHELP           - CALL COPYSEL PARM1(KW2) PARM2(KW2) ...        */
/* CEMHELP           -  WHERE THE PARMS MUST BE ONE OR MORE OF THE FF*/
/* CEMHELP           -   MYAPLID(CICS APPLID)                        */
/* CEMHELP           -    OR                                         */
/* CEMHELP           -   TGT(CICS TYP) AS EXPR|DEV TEST ACCP PROD ALL*/
/* CEMHELP           -   CREL(CICS REL) 540 550 560 OR 999           */
/* CEMHELP           -   FREL(FORCE CICS REL N, 540, 550, ...)       */
/* CEMHELP           -   MYCPUID(X) WHERE X IS VALID CPU OR          */
/* CEMHELP           -              PLEX 1 2 3 V|T OR # FOR ALL      */
/* CEMHELP           -   TBLRESP(X) WHERE Y|T IS FOR TABLE SELECTION */
/* CEMHELP           -              J IS FOR JCL SYMBOLIC SELECTION  */
/* CEMHELP           -              P IS FOR PARM SELECTION          */
/* CEMHELP           -              N IS FOR NO SELECTIONS           */
/* CEMHELP           -   SELN(S1,S2,S3,..S16) WHERE S1 THRU S16 ARE  */
/* CEMHELP           -              EXACT, VALID TABLE,JCL OR PARM   */
/* CEMHELP           -               SYNTAX SELCTIONS                */
/* CEMHELP           -              (EG-FCT,SIT  REEGON,START  OSCOR)*/
/* CEMHELP           -   SJM(JCL MBR NAME)  IS THE JCL MEMBER NAME   */
/* CEMHELP           -              WILL BE REFLECTED IN THE REPORT  */
/* CEMHELP           -   MYDS(SPEC) IS REQUIRED PARM WHICH SPECIFIES*/
/* CEMHELP           -              WHERE YOU WISH THE OUTPUT TO BE */
/* CEMHELP           -              DIRECTED TO.  SPECIFY SPEC AS:   */
/* CEMHELP           -              DSN - AN OUTPUT DATASET          */
/* CEMHELP           -              DISPLAY - OUTPUT TO TERMINAL     */
/* CEMHELP           -              PUSH - OUTPUT PACKED AS A REXX   */
/* CEMHELP           -                     PUSHED RETURN STRING      */
/* CEMHELP           -              <VAR NAME> OUTPUT PACKED AS AN   */
/* CEMHELP           -                     ISPF VAR NAME AND VPUT    */
/* CEMHELP           - THE ENTIRE PARM LIST CAN BE PACKAGED AS A     */
/* CEMHELP           - ISPF PARM VAR, IN FORMAT SHOWN, AND THEN YOU  */
/* CEMHELP           - INVOKE THE EXEC AS: COPYSEL <VAR NAME>        */
/* CEMHELP           - AND THE EXEC WILL READ THE ISPF VAR NAME AND  */
/* CEMHELP           - PARSE THE VARS INTO INVOKATION PARMS.         */
/* CEMHELP           - WE WILL RETURN 0 OR 8 AS A RETURN CODE.       */
/* CEMHELP END                                                       */
/* %% TURN TRACE ON AT LINE 580 FOR A SPECIFIC REGION */
 TRACEREGN='NOTHING'
/* FIND '%%%' */
 /* TRACE I */
 SPCARGS='TGT CREL FREL MYAPLID MYCPUID TBLRESP'
 SPC.TGT='ALL'
 SPC.CREL='999'
 SPC.FREL='N'
 SPC.MYAPLID=''
 SPC.MYCPUID='#'
 SPC.TBLRESP='Y'
 SPC.SITRESP='ANY'
 VALTGT='DEV EXCP TEST ACCP PROD ALL'
 CALL GETKREL ???
 PULL VALREL
 VALREL=VALREL||' 999'
 VALCPU='ACXYZDEFHGIJSUV#'
 VALPLEX='12345'
 VALTBLR= 'TABLE PARAMETER PARM JCL NO YES'
 VALTBLP= 'Y P P J N Y'
 OPTARGS='SELN MYDS SJM'
 OPT.SELN='SIT'
 OPT.MYDS='DISPLAY'
 OPT.SJM='COLDM'
 VALSJM='UPJ COLDJ EMERJ DOWNJ UCC7J VERFJ JRNLJ BTCHJ '||,
         'UPM COLDM EMERM DOWNM UCC7M VERFM JRNLM BTCHM'
 VALMYDS='DISPLAY PUSH'
/* USE THIS STRING TO LIMIT THE TABLE SELECTIONS TO THIS LIST */
/* NOTE-SIT MUST PART OF THE LIST */
 STBLS='ALT DCT DDIR FCT JCT MCT NLT PDIR PLTPI PLTSD SIT '||,
  'SRT TCP TCT XLT ZCP'
 PECT=0
 ALIND = 0
 VRBOPT = 'ABORT BYPASS CANCEL'
 IF SYSVAR('SYSISPF') ^= 'ACTIVE' THEN DO
  SAY 'PROCEDURE MUST BE RUN FROM ISPF'
  EXIT
  END
 ADDRESS ISPEXEC "ISPEXEC VGET (SPCATI) SHARED"
 IF RC = 0 THEN SIGNAL DONEINIT
 A = 'TTED.TSK.P.TCEM'
 "ALLOC FI(SYSUPROC) DA('"A".EDITMAC' '"A".CLIST') SHR"
 "ALTLIB ACTIVATE USER(CLIST)"
 ALIND = 1
DONEINIT:
  MYPNLIB='TTED.TSK.D.TCEM.ISPPLIB'
  IF PNLLOADED > 0 THEN SIGNAL GOTMYPNLIB
  IDVAL_CT = 0
 TRYAGN:
  IDVAL=''
  'ISPEXEC QLIBDEF 'ISPPLIB' ID(IDVAL)'
  XC = RC
  IF IDVAL \= '' THEN DO
   IF IDVAL_CT > 1 THEN DO
    SAY 'COULD NOT LIBDEF ISPPLIB. LOOP??'
    RETURN 8
    END
   XDSN=TRANSLATE(IDVAL,"  ",",'")
   IF WORDPOS(MYPNLIB,XDSN) \= 0 THEN SIGNAL GOTMYPNLIB
   CALL EXPLLDEF 'ISPPLIB' MYPNLIB 'STACK' 'QUIET'
   XC=RESULT
   IDVAL_CT = IDVAL_CT + 1
   SIGNAL TRYAGN
   END
  IF IDVAL = '' THEN DO
   STKLIBS=MYPNLIB
   CALL EXPLLDEF 'ISPPLIB' STKLIBS 'STACK' 'QUIET'
   XC=RESULT
   IF RC > 4 THEN DO
    SAY 'COULD NOT LIBDEF ISPPLIB. RC WAS'RC
    RETURN 8
    END
   END
 GOTMYPNLIB:
 ADDRESS TSO
 DO I = 1 TO 16
  INTERPRET 'MT'I' = ""'
  END
 FFX ='FF'X
 ARG HOLDARG
 HOLDARG=STRIP(HOLDARG,'B')
 ONLYARG=HOLDARG
 IF ONLYARG='' THEN DO
  MYAPLID = ''
  MYCPUID='#'
  SJM = 'COLDM'
  SELTBL = 0
  TGT = ''
  CREL = ''
  FREL = 'N'
  TBLRESP = 'P'
  SITRESP='ANY'
  SIGNAL NOARGS
  END
 PARSE VAR ONLYARG ONLYARG '<' SPFVAR '>' REST
 IF SPFVAR ^= '' THEN DO
  ADDRESS ISPEXEC "VGET ("SPFVAR") ASIS"
  IF RC ^= 0 THEN RETURN 8
  INTERPRET "ONLYARG = "SPFVAR
  END
 ARGSTR=''
 CT=0
 DO WHILE(ONLYARG^='')
  PARSE VAR ONLYARG A '(' AVAL ')' ONLYARG
  IF AVAL = '' THEN RETURN 8
  IF LENGTH(A) > 8 THEN RETURN 8
  ARGSTR=ARGSTR||' '||A
  INTERPRET A" = '"AVAL"'"
  CT = CT+1
  IF ONLYARG = '' THEN LEAVE
  END
 IF ARGSTR='' THEN RETURN 8
 NAW=WORDS(ARGSTR)
 SPCOK=0
 DO I = 1 TO NAW
  TWD=WORD(ARGSTR,I)
  INTERPRET 'TSTR='TWD
  IF WORDPOS(TWD,OPTARGS) ^= 0 THEN DO
   INTERPRET 'OPT.'||TWD||' = "'TSTR'"'
   ITERATE
   END
  IF WORDPOS(TWD,SPCARGS) = 0 THEN RETURN 8
  INTERPRET 'SPC.'||TWD||' = "'TSTR'"'
  SPCOK=1
  END
 IF SPCOK = 0 THEN RETURN 8
 HARGSTR=ARGSTR
 NAW=WORDS(SPCARGS)
 I = 0
TOPARGLP:
 DO FOREVER
  I = I + 1
  IF I > NAW THEN SIGNAL CK4TBS
  TJMP = WORD(SPCARGS,I)
  INTERPRET 'SIGNAL 'TJMP
  END
FREL:
 FREL = SPC.FREL
 IF FREL \= 'Y' THEN RFEL = 'N'
 SIGNAL TOPARGLP
CREL:
 CREL = SPC.CREL
 IF WORDPOS(CREL,VALREL) = 0 THEN RETURN 8
 SIGNAL TOPARGLP
TGT:
 TGT=SPC.TGT
 IF WORDPOS(TGT,VALTGT) = 0 THEN RETURN 8
 SIGNAL TOPARGLP
MYAPLID:
 MYAPLID=SPC.MYAPLID
 IF MYAPLID = 'ALL' | MYAPLID='*' THEN MYAPLID = ''
 SIGNAL TOPARGLP
MYCPUID:
 MYCPUID = SPC.MYCPUID
 IF POS(MYCPUID,VALPLEX) ^= 0 THEN SIGNAL TOPARGLP
 IF POS(MYCPUID,VALCPU) = 0 THEN RETURN 8
 SIGNAL TOPARGLP
TBLRESP:
 TBLRESP = SPC.TBLRESP
 TBLP=WORDPOS(TBLRESP,VALTBLR)
 IF TBLP = 0 THEN RETURN 8
 TBLRESP=WORD(VALTBLP,TBLP)
 SIGNAL TOPARGLP
CK4TBS:
 NAW=WORDS(OPTARGS)
 SPCOK=0
 I = 0
TOPOPTLP:
 DO FOREVER
  I = I + 1
  IF I > NAW THEN SIGNAL FINARGS
  TJMP = WORD(OPTARGS,I)
  INTERPRET 'SIGNAL 'TJMP
  END
SELN:
 SELN = OPT.SELN
 SELN=TRANSLATE(SELN,' ',',')
 TBLSEL=SELN
 SELTAB=WORDS(TBLSEL)
 DO J = 1 TO SELTAB
  INTERPRET MT||J" = WORD(TBLSEL,J)"
  END
 SIGNAL TOPOPTLP
SJM:
 SJM = OPT.SJM
 IF POS(SJM,VALSJM) = 0 THEN DO
  DSEMSG='ERROR SPECIFYING JCL MEMBER'
  END
 SIGNAL TOPOPTLP
MYDS:
 MYDS= OPT.MYDS
 IF POS(MYDS,VALMYDS) ^= 0 THEN SIGNAL TOPOPTLP
 MYDS=STRIP(TRANSLATE(MYDS,'  ','"'||"'"),'B')
 IF LENGTH(MYDS) < 9 THEN RETURN 8
 HDS=TRANSLATE(MYDS,'   ','.()')
 NHDSW=WORDS(HDS)
 IF NHDSW<2 THEN RETURN 8
 DO K = 2 TO NHDSW
  TWD=WORD(HDS,K)
  IF LENGTH(TWD) > 8 THEN RETURN 8
  IF DATATYPE(SUBSTR(TWD,1,1)) ^= 'CHAR' THEN RETURN 8
  END
 SIGNAL TOPOPTLP
FINARGS:
 SIGNAL ARNDDOPT
NOARGS:
 DSEMSG = ''
 EXECSEL = 'COPYSEL'
 ADDRESS ISPEXEC
 'ISPEXEC VPUT (EXECSEL) ASIS'
ARNDDOPT:
 /* TRACE I */
 "ISPEXEC CONTROL ERRORS RETURN"
 "ISPEXEC VGET (CURCPU,CURGRP,CURCPUG) PROFILE"
 IF RC ^= 0 THEN DO
  CALL GETCPU1
 "ISPEXEC VGET (CURCPU,CURGRP,CURCPUG) PROFILE"
  IF RC ^= 0 THEN SIGNAL EXITRC8A
  END
 SITPOS = WORDPOS('SIT',STBLS)
 IF SITPOS = 0 THEN DO
  STBLS = STBLS||' SIT'
  SITPOS = WORDS(STBLS)
  END
 SORTTMPL = WORDS(STBLS)
 IF SORTTMPL > 16 THEN SIGNAL TOMNYTBL
 SORTTMP = SUBSTR(COPIES('0',25),1,SORTTMPL)
 NTBLS = 16  /* THIS INSURES THAT ALL TBLS FLDS ON DISPLY ARE SEEN */
/* */
/* THIS IS LIST OF ALL THINGS THAT CAN BE SUFFIXED. NOTE THAT THE */
/*  SORTTMP VAR HAS A 0 FOR EACH OF THE VALID TBLS IN LIST        */
/* NOTE-IF YOU ALTER THIS LIST, SIT MUST PART OF THE LIST */
 VALTBLS='ALT DBP DCT DDIR FCT JCT MCT NLT PDIR PLTPI PLTSD SIT '||,
  'SRT TCP TCT TLT TST XLT ZCP'
 VSITPOS = WORDPOS('SIT',VALTBLS)
 IF VSITPOS = 0 THEN DO
  VALTBLS = VALTBLS||' SIT'
  VSITPOS = WORDS(VALTBLS)
  END
 VTBLS = WORDS(VALTBLS)
 SIT.S='BYP'
 MYSIT = 'BYP'
 SSPOS = 25
 COMA = ','
 SP8 = '        '
 SP = ' '
 SP80 = COPIES(' ',80)
 N = 1
 IF HOLDARG^='' THEN SIGNAL PROSARG
 IF SYSVAR(SYSUID) = 'TCEM' THEN DO
  "ISPEXEC VGET (COPYSLDS) PROFILE"
  IF RC ^= 0 THEN DO
   COPYSLDS='TTEP.TSK.D.TCEM.NOTES(12345678)'
   "ISPEXEC VPUT (COPYSLDS) PROFILE"
   END
  MYDS = COPYSLDS
  END
  ELSE MYDS = 'YOUR.DSN(MBR)'
 SUDT = DATE('U')
 RSULST=''
REDO:
 IF HOLDARG^='' THEN RETURN 8
 STIM = TIME()
 MYVERB = ''
 SORTTBL=SORTTMP
 ADDRESS ISPEXEC "ISPEXEC DISPLAY PANEL(COPYSELD)"
 XC = RC
 IF XC = 8 THEN SIGNAL EXITRC0
 IF MYVERB = 'END'|MYVERB='CANCEL' THEN SIGNAL EXITRC0
PROSARG:
/* SAY 'CMD?'
 PULL CRESP
 IF CRESP='' THEN SIGNAL GOIT
 INTERPRET CRESP
 SIGNAL PROSARG
GOIT: */
 IF TGT ^='ALL' THEN TTP = SUBSTR(TGT,1,1)   /* TYPE OF REGION */
  ELSE TTP = '*'
 DSHLQ = 'TTE'||TTP
 MYCPUID=STRIP(MYCPUID,'T')
 HYCPUID=MYCPUID
 CVTDGRPC=CURCPUG
 CPUSCP='LOCAL'
 /* IF OPER DOES NOT ENTER A MYCPUID, THEN ASSUME, ALL CPU'S ON THE */
 /* CPU GRP FOR LOCAL COMPLEX.  IF X IS SELECTED, THEN ASSUME ALL   */
 /* CPU'S ARE OK BUT FORCE NON LOCAL (WE CAN'T EXPAND PARMS THE ARE */
 /* NOT ON THIS COMPLEX). IF OPER HAS SPECIFIES A COMPLEX, THEN WE  */
 /* SET MYCPUID TO ALL CPU'S ON COMPLEX AND MARK AS LOCAL IS LOCAL  */
 /* OR REMOTE IF NOT THIS COMPLEX.  IF SINGLE CPU SELECTED, THEN WE */
 /* USE THE CPU AS CRITERIA, AND SET LOCAL OR REMOTE ACCORDINGLY.   */
 IF MYCPUID ^= '' THEN DO
  IF MYCPUID = '#' THEN DO
   CPUSCP='ANY'
   MYCPUID=VALCPU
   SIGNAL ARNDBCPU
   END
  CALL GETCPU1 MYCPUID
  "ISPEXEC VGET (CVTDGRP CVTDGRPC) ASIS"
  IF RC ^= 0 THEN SIGNAL BADCPUS
 /*  TRACE I */
  CVTDGRP=CVTDGRP
  CVTDGRPC=CVTDGRPC
  IF CVTDGRP = '????' THEN SIGNAL BADCPUS
  IF POS(CURCPU,CVTDGRPC) = 0 THEN CPUSCP='REMOTE'
   ELSE CPUSCP='LOCAL'
  IF POS(MYCPUID,VALPLEX) ^= 0 THEN MYCPUID=CURCPUG
  END
  ELSE MYCPUID=CURCPUG
 SIGNAL ARNDBCPU
BADCPUS:
 DSEMSG='ERROR. CPU SELECTION NOT VALID FOR THIS COMPLEX.'
 SIGNAL REDO
ARNDBCPU:
 OP.1 = SUBSTR(DSHLQ||'  ',1,4)
 SELTBL = 0
 SRCHSTR = ''
 LTBLRESP=LENGTH(TBLRESP)
 IF LTBLRESP = 0 THEN DO
  TBLRESP = 'N'
  SIGNAL OUTOFLOP
  END
 IF CPUSCP = 'REMOTE' THEN DO
  TBLRESP = 'N'
  SIGNAL OUTOFLOP
  END
 IF LTBLRESP > 1 THEN SIGNAL CKPARM
 IF TBLRESP = 'N' THEN SIGNAL OUTOFLOP
 IF TBLRESP = 'P' | TBLRESP = 'J' THEN DO
  IF WORDPOS(SITRESP,'SYS PUT ANY') = 0 THEN DO
   DSEMSG='ERROR. SIT TYPE: ANY OR SYS OR PUT'
   SITRESP = 'ANY'
   SIGNAL REDO
   END
  SITLIST=''
  SITNFLIST=''
  TBLSLIST='SIT'
  J = 1
  TBLRESP='##'
  TBLS.1 = 'SIT'
  ST.1 = 'SIT'
  OP.1 = OP.1||' SIT '
  DO I = 1 TO 16
   INTERPRET "TMP = "MT||I
   IF LENGTH(TMP) < 1 THEN ITERATE
   IF WORDPOS(TMP,TBLSLIST) > 0 THEN ITERATE
   TBLSLIST = TBLSLIST||' '||TMP
   OP.1 = OP.1||' '||TMP
   J = J+1
   TBLS.J=TMP
   ST.J = TMP
   INTERPRET "SYMB."TMP" = J"
   END
  NTBLS = J
  SELTBL = J
  SYMB.SIT = 1
  STMB.SIT = 1
  SIGNAL ARNDTBLS
  END
 IF TBLRESP \= 'Y' THEN DO
  DSEMSG = 'INVALID SEARCH CRITERIA, RETRY'
  TBLRESP='N'
  SIGNAL REDO
  END
  ELSE SIGNAL CKTBL
CKPARM:
 SRCHSTR = TBLRESP
 OP.1 = OP.1||' SIT '||TBLRESP
 TBLS.1 = 'SIT'
 TBLS.2 = TBLRESP
 ST.1 = 'SIT'
 ST.2 = TBLRESP
 NTBLS = 2
 SELTBL = 2
 SYMB.SIT = 1
 STMB.SIT = 1
 INTERPRET "SYMB."TBLRESP" = 2"
 SIGNAL ARNDTBLS
CKTBL:
 SORTERR = 0
 IF NTBL=1 & MT1 = 'DFT' THEN DO
  SORTTBL=COPIES('1',16)
  SELTAB=16
  SIGNAL USEDDFT
  END
 DO I = 1 TO NTBLS
  INTERPRET 'TMP = MT'I
  IF TMP = '' THEN ITERATE
  J = WORDPOS(TMP,STBLS)
  IF J ^= 0 THEN SORTTBL = OVERLAY('1',SORTTBL,J)
   ELSE SORTERR = 1
  END
 IF SORTTBL = SORTTMP THEN DO
  DSEMSG = 'NO TABLES SPECIFIED. RETRY'
  SIGNAL REDO
  END
 IF SORTERR = 1 THEN DO
  DSEMSG = 'INVALID TABLE SPECIFIED. CHECK YOUR SELECTIONS.'
  SIGNAL REDO
  END
 SORTTBL = OVERLAY('1',SORTTBL,SITPOS)
 DO I = 1 TO SORTTMPL
  IF SUBSTR(SORTTBL,I,1) = '0' THEN ITERATE
  SELTBL = SELTBL + 1
  TBLS.SELTBL = WORD(STBLS,I)
  END
USEDDFT:
 NTBLS = SELTBL
 DO J = 1 TO SELTBL
  TMPWD = TBLS.J
  OP.1 = OP.1||' '||TMPWD
  ST.J = TMPWD
  INTERPRET "STMB."TMPWD" = "J
  END
OUTOFLOP:
 IF SELTBL = 0 THEN DO
  OP.1 = OP.1||' CRITERIA SELECTION BYPASSED'
  END
ARNDTBLS:
  MYSSTPOS = ''
  SJM= 'MY'||SJM
  MYSSTTYP = SJM
 "ISPEXEC VPUT (MYSSTPOS MYSSTTYP) ASIS"
  IF RC ^= 0 THEN SIGNAL EXITRC4
  CALL AFOPOS
  IF RESULT ^= 0 THEN SIGNAL EXITRC4
  "ISPEXEC VGET (MYSSTFLD MYSSTAFO MYSSTLNG MYSSTBGN MYSSTEND"||,
    " MYSSTLIT) ASIS"
  IF RC ^= 0 THEN SIGNAL EXITRC4
  ZZZ=MYSSTFLD MYSSTAFO MYSSTLNG MYSSTBGN MYSSTEND ,
    MYSSTLIT
    TRACE OFF
  SUID = SYSVAR(SYSUID)
CPUOK1:
 IF CREL = '999' THEN DO
  CREL = 'ALL'
  FREL = 'N'
  END
 "ISPEXEC VGET (MYAFOIND SVAFO0) SHARED"
 IF RC ^= 0 THEN DO
  CALL AFOLOAD1
  "ISPEXEC VGET (MYAFOIND SVAFO0) SHARED"
  IF RC ^= 0 THEN SIGNAL EXITRC4
  END
 MYAPLID = STRIP(MYAPLID,'B')
 APSPEC=0
 IF MYAPLID ^= '' THEN DO
  INTERPRET "ISPEXEC VGET ("MYAPLID") SHARED"
  IF RC = 0 THEN DO
   INTERPRET "I="MYAPLID
   INTERPRET "ISPEXEC VGET (SVAFO"I") SHARED"
   INTERPRET "TMP = STRIP(SUBSTR(SVAFO"I",1,254),'T')"
   SIGNAL GOTSPEC
   END
  CALL SAFO MYAPLID 'QUIET'
  "ISPEXEC VGET (SAFO) ASIS"
  TMP=SAFO
  SIGNAL GOTSPEC
  END
 DO I = 1 TO SVAFO0
  INTERPRET "ISPEXEC VGET (SVAFO"I") SHARED"
  INTERPRET "SAFOLST.I = STRIP(SUBSTR(SVAFO"I",1,254),'T')"
  END
 SAFOLST.0 = SVAFO0
 SIGNAL DONSPEC
GOTSPEC:
 APSPEC=1
 SAFOLST.1 =  TMP
 SAFOLST.0 = 1
 TGT = 'ALL'
 CREL = 'ALL'
 SIGNAL DONSPEC
DONSPEC:
 I = 0
 CPUSTR=''
 SRC = 0
  ZMP = 'MYTYP MYREL MYAPLID MYCOLDJ MYCPU'
  SJMFND= WORDPOS(SJM,ZMP)
  IF SJMFND = 0 THEN ZMP=ZMP||' '||SJM
  CALL AFOFLD ZMP
  PULL FLDX
  PARSE VAR FLDX MYTYPL MYTYPB MYTYPE MYTYPM '#',
                 MYRELL MYRELB MYRELE MYRELM '#',
                 MYAPLIDL MYAPLIDB MYAPLIDE MYAPLIDM '#',
                 MYCOLDJL MYCOLDJB MYCOLDJE MYCOLDJM '#',
                 MYCPUL MYCPUB MYCPUE MYCPUM '#' REST
 IF REST ^= '' THEN DO
  PARSE VAR REST ZREST '#' REST '#' .
  IF ZREST ^= '' THEN REST = ZREST
  PARSE VAR REST VL VB VE VM
  END
  ELSE SJMFND = 0
 TRACE OFF
 /* ALIAS APPLID PROCESSING FOR THE CRIS AND ADAB COPIES */
 ALIASLST = 'CRISD01 CRIST01 CRISM01 CRISP01 DELPHI INFOAG CICSMEDB'
 ALIASSUB = 'CICSCRID CICSCRIT CICSCRIM CICSCRIP CICSADAB CICSADA2 MEDB'
 /* ALIAS APPLID PROCESSING FOR THE CRIS AND ADAB COPIES */
 SIGNAL ON ERROR NAME ERRRTN
 SIGNAL ON SYNTAX NAME ERRRTN
  MSGLOCK='Y'
  MSGSTAT='CONTPOP'
  MSGBOXTX='STARTING COPY SELCTION PROCESSING...'
  ADDRESS ISPEXEC "VPUT (MSGBOXTX) ASIS"
  ADDRESS ISPEXEC "VPUT (MSGLOCK MSGSTAT) ASIS"
  CALL MSGBOX
  SACT = SAFOLST.0
TOPOFLP0:
  I = I + 1
  IF I > SAFOLST.0 THEN SIGNAL WRITLST
TOPOFLP:
  IF SUBSTR(SAFOLST.I,1,1) = '*' THEN SIGNAL TOPOFLP0
  MYTYP=STRIP(SUBSTR(SAFOLST.I,MYTYPB,MYTYPL),'B')
  MYREL=STRIP(SUBSTR(SAFOLST.I,MYRELB,MYRELL),'B')
  IF FREL = 'Y' THEN MYREL = CREL
  MYAPLID=STRIP(SUBSTR(SAFOLST.I,MYAPLIDB,MYAPLIDL),'B')
  IF MYAPLID = TRACEREGN THEN TRACE I
  MSGBOXTX='... PROCESSING >'||LEFT(MYAPLID,8)||'< # '||I||' OF '||SACT
  ADDRESS ISPEXEC "VPUT (MSGBOXTX) ASIS"
  CALL MSGBOX
  INTERPRET SJM "=STRIP(SUBSTR(SAFOLST.I,"VB","VL"),'B')"
  IF APSPEC=1 THEN OP.1='TTE'||MYTYP||' '||DELWORD(OP.1,1,1)
  IF TGT = 'TTED' & MYTYP = 'E' THEN SIGNAL ALLC
  IF TGT = 'ALL' THEN SIGNAL ALLC
  IF MYTYP ^= TTP THEN SIGNAL TOPOFLP0
 ALLC:
  MYCPU=STRIP(SUBSTR(SAFOLST.I,MYCPUB,MYCPUL),'B')
  IF POS(MYCPU,MYCPUID) = 0 THEN SIGNAL TOPOFLP0
 OKCPUID:
  IF CREL = 'ALL' THEN SIGNAL TAKEALL
  IF MYREL ^= CREL THEN SIGNAL TOPOFLP0
  /* TRACE I */
 TAKEALL:
  MYAPLID=STRIP(SUBSTR(SAFOLST.I,2,8),'T')
 /* ALIAS APPLID PROCESSING FOR THE CRIS AND ADAB COPIES */
  WPF = WORDPOS(MYAPLID,ALIASLST)
  IF WPF ^= 0 THEN MYAPLID = WORD(ALIASSUB,WPF)
  MYCOLDJ=STRIP(SUBSTR(SAFOLST.I,MYCOLDJB,MYCOLDJL),'B')
  IF MYTYP = 'E' THEN DSHLQ = 'TTED'
   ELSE DSHLQ = 'TTE'||MYTYP
  IF TBLRESP = 'N' THEN DO
   DSEMSG = '!NO TABLE SELECTION, BYPASSED '
   SIGNAL CANTPROC
   END
  IF CPUSCP = 'REMOTE' THEN DO
   DSEMSG = '!NON LOCAL CPU SELECTION, BYPASSED '
   SIGNAL CANTPROC
   END
  IF POS(MYCPU,CURCPUG) = 0 THEN DO
   DSEMSG = '!NON LOCAL CPU SELECTION, BYPASSED '
   SIGNAL CANTPROC
   END
  DSPFX = DSHLQ||'.TSK.F.R'||MYREL
  PRMLB=DSPFX||'.'||MYAPLID||'.PARMLIB'
 RETRYPL0:
 /* NEW CODE FOR FINDING SIT */
 /* CALL GET SIT RETURNS ISPF VARS LIST IN GETSITLS VAR */
 /* TRACE  I */
  GETSITLS = ''
  ADDRESS ISPEXEC "VPUT (GETSITLS) ASIS"
  CALL GETSIT MYAPLID  MYREL MYTYP
  IF RESULT \= 0 THEN SIGNAL GETSITERR
  ADDRESS ISPEXEC 'VGET (GETSITLS) ASIS'
  IF RC \= 0 THEN SIGNAL GETSITERR
  WDS = WORDS(GETSITLS)
  ADDRESS ISPEXEC 'VGET ('GETSITLS') ASIS'
  IF RC \= 0 THEN SIGNAL GETSITERR
  GETSITLS_VALS=''
 /* RETURNS 0 AND ISPF VAR GETSITLS WITH ALL            */
 /*  TABLES IN STARTUP AND ENVRSU AND STARTMBR          */
 /*  FOR EXAMPLE                                        */
 /*  SIT MCT SRT           S54D0809   STARTSYS          */
  DO I2 = 1 TO WDS
   TBLTMP = WORD(GETSITLS,I2)
   INTERPRET "GETSITLS_VALS = GETSITLS_VALS||' '||"TBLTMP
   END
  /* SAY 'SIT:' SIT */
  MYSIT = SIT
  SITFLG = 1
  SIT.S = MYSIT
  IF WORDPOS(ENVRSU,RSULST) = 0 THEN DO
   RSULST=RSULST||' '||ENVRSU
   INTERPRET "START_"ENVRSU" = '"STARTMBR"'"
   END
 /* END NEW CODE FOR FINDING SIT */
 /* CALL GET SIT RETURNS ISPF VARS LIST IN GETSITLS VAR */
 /* TRACE ?I */
  IF SITRESP = 'ANY' THEN PRMSTRT=STARTMBR
   ELSE PRMSTRT='START'||SITRESP
  PRMLIB=PRMLB||'('||PRMSTRT||')'
  IF SYSDSN("'"PRMLIB"'") ^= 'OK' THEN DO
   EDSN=PRMLB
   DSEMSG = 'PARMLIB('PRMLIB') NF. SPECIFY OTHER.'
   MYVERB = VRBOPT
   "ISPEXEC VPUT (EDSN DSEMSG MYVERB) ASIS"
   IF RC ^= 0 THEN SIGNAL EXITRC8B
   CALL DSNWIND
   XC = RESULT
   IF XC > 4 THEN SIGNAL CANCEL8
   ADDRESS ISPEXEC "VGET (MYVERB) ASIS"
   IF RC ^= 0 THEN SIGNAL EXITRC8C
   IF MYVERB='ABORT' | MYVERB='CANCEL' THEN SIGNAL CANCEL8
   IF MYVERB= 'BYPASS' THEN SIGNAL CANTPROC
   ADDRESS ISPEXEC "VGET (EDSN) ASIS"
   PRMLIB=STRIP(EDSN,'T')
   FP = POS('(',PRMLIB)
   IF FP ^= 0 THEN PRMLB = SUBSTR(PRMLIB,1,FP-1)
    ELSE PRMLB=PRMLIB
   SIGNAL RETRYPL0
   END
  SIGNAL ARND_OLD_SIT
 /* START OLD CODE IS NOT USED -                        */
  ADDRESS TSO
 "ALLOC FI(PLIB) DA('"PRMLIB"') SHR"
 "EXECIO * DISKR PLIB (STEM PRM. FINIS"
 "FREE FI(PLIB)"
  DO J = 1 TO PRM.0
   IF SUBSTR(PRM.J,1,3) = '//*' THEN ITERATE
   FP=POS('SIT=',PRM.J)
   IF FP = 0 THEN ITERATE
   MYSIT=SUBSTR(PRM.J,FP+4,2)
   SITFLG = 1
   SIT.S = MYSIT
   DROP PRM.
   SIGNAL SITFND
   END
   DSEMSG = 'PARMLIB(START'SITRESP') SIT WAS NOT FOUND.'
  SIGNAL CANTPROC
 /* END   OLD CODE IS NOT USED -                        */
 ARND_OLD_SIT:
  IF MYREL = '540' THEN DO
   IF MYTYP = 'D' THEN PRMLIB=PRMLB||'(STARTUP)'
    ELSE PRMLIB=PRMLB||'(STARTUPX)'
   END
   ELSE
   PRMLIB=PRMLB||'(STARTUP)'
   END
 SITFND:
 RETRYPL:
  IF SYSDSN("'"PRMLIB"'") ^= 'OK' THEN DO
   EDSN=PRMLB
   DSEMSG = 'PARMLIB(STARTUP(X)) NF. SPECIFY OTHER (STARTUP?)'
   MYVERB = VRBOPT
   "ISPEXEC VPUT (EDSN DSEMSG MYVERB) ASIS"
   IF RC ^= 0 THEN SIGNAL EXITRC8B
   CALL DSNWIND
   XC = RESULT
   IF XC > 4 THEN SIGNAL CANCEL8
   ADDRESS ISPEXEC "VGET (MYVERB) ASIS"
   IF RC ^= 0 THEN SIGNAL EXITRC8C
   IF MYVERB='ABORT' | MYVERB='CANCEL' THEN SIGNAL CANCEL8
   IF MYVERB= 'BYPASS' THEN SIGNAL CANTPROC
   ADDRESS ISPEXEC "VGET (EDSN) ASIS"
   PRMLIB=STRIP(EDSN,'T')
   FP = POS('(',PRMLIB)
   IF FP ^= 0 THEN PRMLB = SUBSTR(PRMLIB,1,FP-1)
    ELSE PRMLB=PRMLIB
   SIGNAL RETRYPL
   END
  ADDRESS TSO
 "ALLOC FI(PLIB) DA('"PRMLIB"') SHR"
 "EXECIO * DISKR PLIB (STEM XPRM. FINIS"
 "FREE FI(PLIB)"
  J = 0
  DROP PRM.
  DO K = 1 TO XPRM.0
   KMP = STRIP(XPRM.K,'T')
   IF SUBSTR(KMP,1,2) = '//' THEN ITERATE
   IF WORD(KMP,1)   = '.END' THEN LEAVE K
   J = J + 1
   PRM.J=KMP
   END
  /* TRACE ?I */
  IF J = 0 THEN DO
   DSEMSG='PARMLIB('PRMLIB') HAD ZERO PARAMETERS.'
   SIGNAL CANTPROC
   END
  PRM.0 = J
  IF LENGTH(MYSIT) ^= 2 THEN DO
   DSEMSG='PARMLIB('PRMLIB') SIT VALUE ('MYSIT') INVALID'
   SIGNAL CANTPROC
   END
/*  SSPOS = (VALUE("STMB."SIT)-1) * 3 */
  SITLB=DSPFX||'.'||MYAPLID||'.TABLE.SOURCE'
  IF MYTYP = 'E' THEN DO
   ASITIND=0
   END
   ELSE DO
   ASITIND=1
   END
  FNDIND='B{'
  IF WORDPOS(MYSIT,SITLIST) > 0 THEN SIGNAL SITISKNOWN
 /* TRACE ?I */
  ASITLB1='TTED.TSK.F.R'||MYREL||'.COMMON.TABLE.SOURCE'
  ASITLB2='TTEP.TSK.F.R'||MYREL||'.COMMON.TABLE.SOURCE'
 RETRYST:
  SITLIB=SITLB||'(DFHSIT'||MYSIT||')'
  IF SYSDSN("'"SITLIB"'") = 'OK' THEN SIGNAL SITDSNOK
  IF ASITIND < 2 THEN DO
   ASITIND = ASITIND + 1
   INTERPRET 'SITLB = ASITLB'ASITIND
   SIGNAL RETRYST
   END
  EDSN=SITLB
  DSEMSG = 'SIT LIB:'SITLIB': NF. SPECIFY OTHER.'
  MYVERB = VRBOPT
  "ISPEXEC VPUT (EDSN DSEMSG MYVERB) ASIS"
   IF RC ^= 0 THEN SIGNAL EXITRC8D
   CALL DSNWIND
   XC = RESULT
   IF XC > 4 THEN SIGNAL CANCEL8
   ADDRESS ISPEXEC "VGET (MYVERB) ASIS"
   IF RC ^= 0 THEN SIGNAL EXITRC8E
   IF MYVERB='ABORT' | MYVERB='CANCEL' THEN SIGNAL CANCEL8
   IF MYVERB='BYPASS' THEN SIGNAL CANTPROC
   ADDRESS ISPEXEC "VGET (EDSN) ASIS"
   SITLIB=STRIP(EDSN,'T')
   FP = POS('(',SITLIB)
   IF FP ^= 0 THEN SITLB = SUBSTR(SITLIB,1,FP-1)
    ELSE SITLB=SITLIB
  SIGNAL RETRYST
 SITDSNOK:
  "ALLOC FI(SLIB) DA('"SITLIB"') SHR"
  "EXECIO * DISKR SLIB (STEM ISIT. FINIS"
  "FREE FI(SLIB)"
  SV = 0
  TVARSTR=''
  STSIT = 0
  S=0
  DO SCT= 1 TO ISIT.0
   IF SUBSTR(ISIT.SCT,1,1) = '*' THEN ITERATE
   IF STSIT = 0 THEN DO
    IF SUBSTR(ISIT.SCT,9,6) = 'DFHSIT' |,
       SUBSTR(ISIT.SCT,10,6) = 'DFHSIT' THEN STSIT = SCT
    ELSE ITERATE
    END
   S=S+1
   SIT.S = STRIP(SUBSTR(ISIT.SCT,1,71),'B')
   END
  DROP ISIT.
  IF STSIT = 0 THEN DO
   DSEMSG='DFHSIT ('MYSIT') HAD NO MACRO VARIABLES.'
   SIGNAL CANTPROC
   END
  SITLIST=SITLIST||' '||MYSIT
 /* TRACE ?I */
  SMP = 'DFHSIT'MYSIT'.SYMBS'
  INTERPRET SMP' = ""'
  TRACE OFF
  MXS = S
  S = 1
  COMA = ','
  /* B{ INDICATES SIT VALUE */
  /* FNDIND='B{' */
 NEXTLNE:
   S = S+1
   IF S > MXS THEN SIGNAL DONESIT
   TMP1 = SIT.S
 NEXTPRM:
   FE = POS('=',TMP1)
/* IF FE > 9 THEN DO
    SIGNAL CANTPROC
    END                      */
   IF FE < 2 THEN DO
    IF SUBSTR(TMP1,1,3) = 'END' |,
        SUBSTR(TMP1,1,4) = '.END' THEN SIGNAL DONESIT
    SIGNAL NEXTLNE
    END
/* TRACE OFF */
   SYM = SUBSTR(TMP1,1,FE-1)
   IF WORDPOS(SYM,TBLSLIST) = 0 THEN SIGNAL NEXTLNE
/*TRACE I */
   SYM=SYM
   TMP = SUBSTR(TMP1,FE+1)
   SS = SUBSTR(TMP,1,1)
   IF SS = "(" THEN SS = ")"
    ELSE IF SS ^= "'" THEN SS = COMA
   IF SS = COMA THEN FSP = 1
    ELSE FSP = 2
   DLMS = POS(SS,TMP,FSP)
   IF DLMS = 0 THEN DO
    IF SS ^= COMA THEN DO
     DSEMSG='DFHSIT ('MYSIT') HAS A MACRO ERROR AT 'SYM
     SIGNAL CANTPROC
     END
    SUB = WORD(TMP,1)
    SIGNAL DONESIT
    END
   SUB = SUBSTR(TMP,FSP,DLMS-FSP)
   INTERPRET 'SYMB.'SYM'="'SUB'"'
   INTERPRET 'SYMN.'SYM'= FNDIND'
   SV = SV+1
   TVAR.SV = SYM
   TVARSTR=TVARSTR||SYM||' '
   INTERPRET SMP' = TVARSTR'
   SXP='DFHSIT'MYSIT'.'SYM
   INTERPRET SXP '= "'SUB'"'
 /* NTERPRET 'ZXP='SMP  */
 /*  SAY ZXP */
   TRACE OFF
   IF SUBSTR(TMP,DLMS+FSP-1,1) ^= ',' THEN SIGNAL DONESIT
   IF SUBSTR(TMP,DLMS+FSP,1) = ' ' THEN SIGNAL NEXTLNE
   TMP1 = SUBSTR(TMP,DLMS+FSP)
   IF TMP1 = '' THEN DO
     DSEMSG='DFHSIT ('MYSIT') HAS ENDED ABRUPTLY'
    SIGNAL CANTPROC
    END
   SIGNAL NEXTPRM
 SITISKNOWN:
 /*  TRACE ?I */
   SMP = 'DFHSIT'MYSIT'.SYMBS'
   INTERPRET 'TVARSTR = 'SMP
   WDS=WORDS(TVARSTR)
   DO SCT = 1 TO WDS
    SYM=WORD(TVARSTR,SCT)
    SXP='DFHSIT'MYSIT'.'SYM
    INTERPRET 'SUB='SXP
    INTERPRET 'SYMB.'SYM'="'SUB'"'
    INTERPRET 'SYMN.'SYM'= FNDIND'
    END
    TRACE OFF
 DONESIT:
  DROP SIT.
  T = 0
  DO S = 1 TO PRM.0
   IF SUBSTR(PRM.S,1,1) = '*' THEN ITERATE
   IF SUBSTR(PRM.S,1,1) = '-' THEN LEAVE
   T = T+1
   SIT.T = STRIP(SUBSTR(PRM.S,1,71),'B')
   END
  FNDIND='A{'
  S = 0
  MXS = T
  NTMP=''
  LONGPRMS='INITPARM JVMPROFILEDIR USSHOME'
/* TRACE I */
 NEXTLNE1:
  IF NTMP \= '' THEN DO
   TMP1=NTMP
   IF SUBSTR(TMP1,LENGTH(TMP1),1) \= COMA THEN TMP1 = TMP1||COMA
   NTMP = ''
   SIGNAL NEXTPRM1
   END
  S = S+1
  IF S > MXS THEN SIGNAL DONEPRM
  TMP1 = STRIP(SIT.S,'L')
 NEXTPRM1:
   TMP1L=LENGTH(TMP1)
   IF TMP1L < 2 THEN SIGNAL NEXTLNE1
   IF SUBSTR(TMP1,1,1) = COMA |,
      SUBSTR(TMP1,1,1) = SP   THEN DO
    TMP1=SUBSTR(TMP1,2)
    SIGNAL NEXTPRM1
    END
   FE = POS('=',TMP1)
   IF FE = 0 THEN DO
    IF SUBSTR(TMP1,1,3) = 'END' |,
        SUBSTR(TMP1,1,4) = '.END'THEN SIGNAL DONEPRM
     SIGNAL NEXTLNE1
     END
   FSP=1
   DLMS=0
   SYM = SUBSTR(TMP1,1,FE-1)
   TMP = SUBSTR(TMP1,FE+1)
   IF SUBSTR(TMP,1,1) = COMA THEN DO
    TMP=SUBSTR(TMP,2)
    SUB=''
    SIGNAL NULLPARM
    END
   IF TMP = '' THEN DO
    SUB=''
    SIGNAL NULLPARM
    END
   SS = SUBSTR(TMP,1,1)
   IF SS = "(" THEN SS = ")"
    ELSE IF SS ^= "'" THEN SS = COMA
   IF SS = COMA THEN FSP = 1
    ELSE FSP = 2
   DLMS = POS(SS,TMP,FSP)
   IF DLMS = 0 THEN DO
    /* TRACE I */
    IF WORDPOS(SYM,LONGPRMS) > 0 THEN
     NTMP=TMP
     HTMP = TMP
     HS=S
     DO LP# = 1 TO 3
      S=S+1
      IF S > MXS THEN DO
       LP#=4
       LEAVE LP#
       END
      TMP=STRIP(SIT.S,'B')
      NTMP=NTMP||TMP
      LP=LASTPOS(SS,NTMP)
      IF LP > 1 THEN LEAVE LP#
      END
     IF LP# < 4 THEN DO
      SUB=NTMP
      NTMP=SUBSTR(NTMP,2,LP - FSP)
      TMP = ''
      SIGNAL NULLPARM
      END
      ELSE DO
      S = HS
      TMP=HTMP
      END
    PECT=PECT+1
    PE.PECT='PARMLIB ERROR:'MYAPLID' LINE 'S':NO COMMA'
    DLMS = LENGTH(TMP) + 1
    FSP=1
    END        /* END OF IF DLMS=0 */
   SUB = SUBSTR(TMP,FSP,(DLMS-FSP))
NULLPARM:
   A='SYMB.'VALUE("SYM")
   IF WORDPOS(SYM,TBLSLIST) = 0 THEN SIGNAL NOPRMMATCH
   IF WORDPOS(SYM,TVARSTR) = 0 THEN DO
    SV = SV+1
    TVAR.SV = SYM
    TVARSTR=TVARSTR||SYM||' '
    END
   INTERPRET 'SYMB.'SYM'="'SUB'"'
   INTERPRET 'SYMN.'SYM'= FNDIND'
 NOPRMMATCH:
   TMP1 = SUBSTR(TMP,DLMS+FSP)
   IF TMP1 = '' THEN DO
     SIGNAL NEXTLNE1
     END
   SIGNAL NEXTPRM1
 DONEPRM:
  /* TRACE I */
  ES = MYSIT||' '
  DO J = 1 TO SELTBL
   SYM = ST.J
   IF SYM = 'SIT' THEN ITERATE
   SYMP=WORDPOS(SYM,TVARSTR)
   IF SYMP=0 THEN  RSLTSTR = '**'
   ELSE DO
    SYM=WORD(TVARSTR,SYMP)
    A='SYMB.'VALUE("SYM")
    Z='SYMN.'VALUE("SYM")
    IF SYMBOL(VALUE('A'))^="VAR" THEN RSLTSTR = '**'
     ELSE INTERPRET "RSLTSTR ="Z"||"A"||'}'"
    END
   ES = ES||' '||RSLTSTR
   END
 SIGNAL DONEALL
GETSITERR:
 DSEMSG='!!! ERROR GETSIT INFORMATION:'RESULT
CANTPROC:
 ADDRESS ISPEXEC
 N = N+1
/* IF N < 3 THEN TRACE I */
 SIT.S=DSEMSG
 INTERPRET "TJM="SJM
 OP.N = LEFT(LEFT(MYAPLID,24)||SIT.S,67)||,
  MYCPU||MYTYP||MYREL||TJM
 TRACE OFF
 SIGNAL NXTAFO
DONEALL:
 LES=LENGTH(ES)
 INTERPRET 'TJM = 'SJM
 DO WHILE(LES>0)
  TPP=LASTPOS(' ',SUBSTR(ES,1,57))
  IF TPP = 0  THEN TPP = 57
  TMPES=SUBSTR(ES,1,TPP)
  N = N+1
 /* IF N < 3 THEN TRACE I */
  OP.N=LEFT(LEFT(MYAPLID,9)||TMPES,67)||MYCPU||,
   MYTYP||MYREL||TJM
  TRACE OFF
  MYCPU=''
  MYTYP=''
  MYREL=''
  MYCOLDJ=''
  ES = SUBSTR(ES,TPP+1)
  LES=LENGTH(ES)
  TJM = ''
  END
NXTAFO:
 DROP SIT.
 DROP PRM.
 DROP SYMB.
 DROP TVAR.
 I = I+1
 IF I ^> SAFOLST.0 THEN SIGNAL TOPOFLP
WRITLST:
 MSGSTAT='REMPOP'
 MSGBOXTX= '< FINISHED PROCESSING SELECTION LIST. WRITING RESULTS'
 ADDRESS ISPEXEC "VPUT (MSGSTAT MSGBOXTX) ASIS"
 CALL MSGBOX
 OP.0 = N
GETMBRN:
 SIGNAL OFF ERROR
 IF ABBREV('DISPLAY',MYDS) > 0 THEN MYDS='DISPLAY'
 IF HOLDARG^='' | MYDS = 'DISPLAY' THEN DO
  MYAREA=FFX
  MYAREA#=FFX
  ADDRESS ISPEXEC
  DO I = 1 TO PECT
   MYAREA=MYAREA||PE.I||FFX
   END
  DO I = 1 TO N
   MYAREA=MYAREA||OP.I||FFX
   END
 NOTESVAR='**** A{__} A INDICATES FOUND IN APPLID.PARMLIB'||,
  FFX||'**** B{__} B INDICATES FOUND IN DFHSIT'
  IF FREL = 'Y' THEN TMP='!!!FORCE REPORT USING OVERRIDE REL:'||CREL
   ELSE TMP='***NORMAL REPORT USING AFOPER REL:'||CREL
  NOTESVAR=NOTESVAR||FFX||TMP
  IF MYDS = 'DISPLAY' THEN DO
   MYAREA=NOTESVAR||MYAREA
   "ISPEXEC VPUT (MYAREA MYAREA#) ASIS"
   CALL DSPLYA
   RETURN 0
   END
  IF SPFVAR ^= '' THEN DO
   INTERPRET SPFVAR" = MYAREA"
   "ISPEXEC VPUT ("SPFVAR") ASIS"
   END
   ELSE DO
   PUSH MYAREA
   END
  RETURN 0
  END
 FP = POS('(',MYDS)
 IF FP ^= 0 THEN TMYDS = SUBSTR(MYDS,1,FP-1)
  ELSE TMYDS = MYDS
 IF SYSDSN("'"TMYDS"'") = 'OK' THEN XC=0
  ELSE XC = 1
 IF XC > 0 THEN DO
  EDSN=MYDS
  DSEMSG = 'TARGET DSN FOR LIST NOT FOUND'
  MYVERV = 'ABORT BYPASS CANCEL'
  ADDRESS ISPEXEC "VPUT (EDSN DSEMSG MYVERB) ASIS"
  IF RC ^= 0 THEN SIGNAL EXITRC8F
  CALL DSNWIND
  XC = RESULT
  IF XC > 4 THEN SIGNAL CANCEL8
  ADDRESS ISPEXEC "VGET (MYVERB) ASIS"
  IF RC ^= 0 THEN SIGNAL EXITRC8G
  IF MYVERB='ABORT' | MYVERB='CANCEL' | MYVERB='BYPASS' THEN,
   SIGNAL CANCEL8
  ADDRESS ISPEXEC "VGET (EDSN) ASIS"
  IF RC ^= 0 THEN SIGNAL EXITRC8H
  MYDS=STRIP(EDSN,'T')
  SIGNAL GETMBRN
  END
OKMBR:
 IF SYSVAR(SYSUID) = 'TCEM' THEN DO
  IF COPYSLDS ^= MYDS THEN DO
   COPYSLDS=MYDS
   "ISPEXEC VPUT (COPYSLDS) PROFILE"
   END
  END
 ADDRESS TSO
 "ALLOC FI(I) DA('"MYDS"') SHR"
 "EXECIO * DISKW I (STEM OP. FINIS"
 "FREE FI(I)"
 ADDRESS ISPEXEC
  DO I = 1 TO PECT
   NOTESVAR=NOTESVAR||FFX||PE.I
   END
 "ISPEXEC VPUT (NOTESVAR) ASIS"
 "ISPEXEC EDIT DATASET('"MYDS"') MACRO(NOTESMAC)"
EXITRC0:
  RETURN 0
  END
TOMNYTBL:
 SAY 'TOO MANY TABLS SPECIFIED IN STBLS VARIABLE'
 RETURN 4
SPECNF:
 SAY 'SPECIFIC COPY NOT FOUND'
 RETURN 4
NOTCPU:
 SAY 'NOTCPU EXIT'
 RETURN 4
EXITRC2:
 SAY 'EXITRC2 EXIT'
 RETURN 2
EXITRC4:
 SAY 'EXITRC4 EXIT'
 RETURN 4
EXITRC8A:
 SAY 'EXITRC8A EXIT'
 RETURN 8
EXITRC8B:
 SAY 'EXITRC8B EXIT'
 RETURN 8
EXITRC8C:
 SAY 'EXITRC8C EXIT'
 RETURN 8
EXITRC8D:
 SAY 'EXITRC8D EXIT'
 RETURN 8
EXITRC8E:
 SAY 'EXITRC8E EXIT'
 RETURN 8
EXITRC8F:
 SAY 'EXITRC8F EXIT'
 RETURN 8
EXITRC8G:
 SAY 'EXITRC8G EXIT'
 RETURN 8
EXITRC8H:
 SAY 'EXITRC8H EXIT'
 RETURN 8
EXITRC12:
 SAY 'EXITRC12 EXIT'
 RETURN 8
CANCEL8:
 SAY 'CANCEL SELECTED'
 RETURN 8
ERRRTN:
XC=RC
 TRACE I;XC=XC
 LNO = SIGL
 IF LNO > 206 & LNO < 788 THEN SIGNAL CANTPROC
 SAY MYAPLID
 SAY SOURCELINE(LNO)
 SAY 'ENTER A RX CMD TO INTERPRET VALUES'
 SAY ' OR JUST ENTER TO QUIT'
ILOOP:
 PULL ANS
 IF ANS = '' THEN SIGNAL EXITRC12
 INTERPRET ANS
 SIGNAL ILOOP
S4TBL: PROCEDURE EXPOSE J PRM. SRCHSTR SRC RSTR
    S4X = ','
    SRC = 0
    RSTR = ''
    SP = 2
    PARSE VAR PRM.J G1 (SRCHSTR) G2
    G2 = STRIP(G2,'B')
    IF G2 ^= '' THEN DO
     G2A = SUBSTR(G2,1,1)
     IF G2A = '(' THEN S4X = ')'
      ELSE IF G2A = "'" THEN S4X = "'"
       ELSE SP = 1
     NC = POS(S4X,G2,SP)
     IF NC ^= 0 THEN DO
      RSTR = SUBSTR(G2,SP,NC-SP)
      SRC = 1
      END
      ELSE IF SP = 2 THEN SRC = 2
       ELSE DO
        SRC = 1
        RSTR = G2
        END
     END
    RETURN SRC
###END COPYSEL
$$$BEG MYTSO1
/* REXX */
/* CEMHELP BEGIN                                                     */
/* CEMHELA MYTSO1   - TSO BASE, RUNS TSO CMDS, COLLECTING OP TO DSN  */
/* CEMHELP MYTSO1   - TSO BASE, PROMPTS OR ACCEPTS AS PARMS   NATIVE */
/* CEMHELP          - TSO COMMANDS, WHERE THE OP OF THE COMMAND IS   */
/* CEMHELP          - CAPTURED TO A TEMP DS, POPING YOU INTO BROWSE  */
/* CEMHELP          - VALID FORMAT FOR CMD IS:                       */
/* CEMHELP          - MYTSO1               PROMPT FOR SINGLE COMMAND */
/* CEMHELP          - MYTSO1 NATIVE_CMD     NO SPACES IN CMD         */
/* CEMHELP          - MYTSO1 <NATIVE CMD>      SPACES IN CMD         */
/* CEMHELP          - MYTSO1 -<NATIVE CMD>  NO CAPS SPACES IN CMD    */
/* CEMHELP          - MYTSO1 ?             LAUNCH PANEL TO COLLECT   */
/* CEMHELP          - MYTSO1 <?>            MULTIPLE COMMANDS        */
/* CEMHELP          -                       (PANEL ALLOWS FOR COPY   */
/* CEMHELP          -                        PDS(MBR) HOLDING CMDS)  */
/* CEMHELP          - OPTIONAL PARMS FOLLOW ABOVE WITH <> FORMAT:    */
/* CEMHELP          - DSN=! OR DSN(!)   USE DEFAULT                  */
/* CEMHELP          - REPEAT(X) OR REPEAT=X  X IS 1-99 REPITIONS     */
/* CEMHELP          -      OF THE CMD(S)                             */
/* CEMHELP          - WAIT(Y) OR WAIT=Y      Y IS 1 - 60 SECONDS     */
/* CEMHELP          -      BETWEEN CMD(S)                            */
/* CEMHELP          -      WHERE CMDS IS THE SET OF COMMANDS         */
/* CEMHELP          - OUTPUT DSN MUST BE SEQUENTIAL (PO) AND DEFAULT */
/* CEMHELP          -      IS SUID.TEMPREX.SYSPRINT                  */
/* CEMHELP          -      YOU ARE PROMPTED TO CHANGE DSN IF YOU     */
/* CEMHELP          -      LIKE (IRRESPECTIVE OF OPT DSN PARM)       */
/* CEMHELP          -      AND CHOOSE TO REUSE (REPLACE CONTENTS)    */
/* CEMHELP          -         OR DEL/REALLOC TARGET DSN              */
/* CEMHELP          -         (CAUTION TO INSURE YOU KNOW WHAT       */
/* CEMHELP          -          TARGET IS)                            */
/* CEMHELP          -         OR MOD TO APPEND TO THE CURRENT DSN    */
/* CEMHELP          -      IF YOU CHOOSE REUSE, AND NEW DATA IS      */
/* CEMHELP          -         LONGER LRECL, YOU ARE ASKED IF THIS    */
/* CEMHELP          -         IS OK (Y/N). TRUNCATION WILL OCCUR IF  */
/* CEMHELP          -         YOU PROCEED.                           */
/* CEMHELP          -                                                */
/* CEMHELP          -                                                */
/* CEMHELP END                                                       */
 /* REXX */
 SIGNAL ON ERROR NAME ERROR
 SIGNAL ON SYNTAX NAME SYNTAX
 SIGNAL ON FAILURE NAME FAILURE
 SIGNAL START
 ERROR:
     XC=RC
     SIGLCODE='ERROR:'XC
     SAY SIGLCODE' ON LINE 'SIGL':'
     SAY 'MYTSO1 APPLICATION RETURNED AN ERRORLEVEL' XC
     SIGNAL ERREND
 SYNTAX:
     XC=RC
     SIGLCODE='SYNTAX:'XC
     SAY SIGLCODE' ON LINE 'SIGL':'
     SAY 'REXX:- ERROR' XC':' ERRORTEXT(XC)
     SIGNAL ERREND
 FAILURE:
     XC=RC
     SIGLCODE='FAILURE:'XC
     SAY SIGLCODE' ON LINE 'SIGL':'
     IF XC = -3 THEN,
        SAY 'REXX:- PROGRAM NOT FOUND'
     ELSE IF XC = -8 THEN,
        SAY 'REXX:- INSUFFICIENT MEMORY FOR PROGRAM'
     ELSE,
        SAY 'REXX:- RETURN CODE' XC
     SIGNAL ERREND
 START:
  /* TRACE ?I */
  PARSE ARG MTSOC
  IF SUBSTR(MTSOC,1,2) = '-<' THEN DO
   SET_CAPS = 'OFF'
   MTSOC = SUBSTR(MTSOC,2)
   END
   ELSE DO
   SET_CAPS = 'ON'
   PARSE UPPER ARG MTSOC
   END
  IF SUBSTR(MTSOC,1,1) = '<' THEN DO
   FP = POS('>',MTSOC,2)
   IF FP = 0 THEN SIGNAL BADPARM
   PARSE VAR MTSOC '<' MTSOC '>' PRMS
   END
   ELSE DO
   PARSE VAR MTSOC MTSOC PRMS
   END
  SUID=SYSVAR(SYSUID)
  MYVERB=''
  DFTDSN=SUID'.TEMPREX.SYSPRINT'
  VALPRMS='DSN REPEAT WAIT'
  DFTPVALS='! 0 0'
  VALDISP='SHR_REUSE DEL MOD'
  MAXRP  = 99
  MAXWT  = 60
  NPW=WORDS(VALPRMS)
  DO I = 1 TO NPW
   TMP = WORD(VALPRMS,I)
   TMPV = WORD(DFTPVALS,I)
   IF TMPV = '.' THEN TMPV = ''
    ELSE IF TMPV = '\.' THEN TMPV = '.'
   INTERPRET TMP"='"TMPV"'"
   END
 /* TRACE I */
  I=0
  PASSCT=0
  PRM_RC = 0
PRMLOOP:
  IF PRMS = '' THEN SIGNAL DONEPRMS
  PARSE VAR PRMS PRM PRMS
  IF PRM = '' THEN SIGNAL BADPARM
  PARSE VAR PRM PRM '=' PRMVAL
  IF WORDPOS(PRM,VALPRMS) ^= 0 THEN SIGNAL GOTEQ
  PARSE VAR PRM PRM '(' PRMVAL ')'
  IF WORDPOS(PRM,VALPRMS) = 0 THEN SIGNAL BADPARM
GOTEQ:
  IF PRMVAL = '' THEN SIGNAL GOT PRMVAL
  /* MYTSO NEVER EXPECTS COMPLEX PRMVAL. USUALLY GOT_PRMVAL-NO ( */
  IF SUBSTR(PRMVAL,1,1) ^= '(' THEN SIGNAL GOT_PRMVAL
  LP=POS(')',PRMVAL)
  IF LP = LENGTH(PRMVAL) THEN DO
   PARSE VAR PRMVAL '(' PRMVAL ')'
   SIGNAL GOT_PRMVAL
   END
  PRMVAL=SUBSTR(PRMVAL,2)
  IF SUBSTR(PRMS,1,1) = ')' THEN DO
   TMP = ''
   PRMS = SUBSTR(PRMS,2)
   SIGNAL ADD_TMP2PRMVAL
   END
  PARSE VAR PRMS TMP ')' PRMS
  IF TMP = '' THEN DO
   PRM_RC = 8
   SIGNAL BADPRMVAL
   END
ADD_TMP2PRMVAL:
  PRMVAL=PRMVAL||' '||TMP
  SIGNAL GOT_PRMVAL
GOT_PRMVAL:
  INTERPRET PRM "='"PRMVAL"'"
  PASSCT = PASSCT+1
NXTPRMS:
  SIGNAL PRMLOOP
BADPARM:
   SAY 'PARM>'PRM'< IS NOT A EXPECTED PARAMETER.'
   PRM_RC = 4
   SIGNAL NXTPRMS
   END
DONEPRMS:
  SAY 'USING PARMS:'
 /* TRACE I */
  DO I = 1 TO NPW
   TMP = WORD(VALPRMS,I)
   INTERPRET "TMPVAL = "TMP
   SAY 'PARM 'TMP' IS SET TO >'TMPVAL'<'
   SELECT
    WHEN TMP='DSN' THEN DO
     IF TMPVAL = '!' THEN DO
      TMPVAL = DFTDSN
      SAY ' WHICH IS THE DEFAULT:'TMPVAL
      END
     MDSN=TMPVAL
     END
    WHEN TMP='DSNDISP' THEN DO
     WP=WORDPOS(TMPVAL,VALDISP)
     IF WP = 0 THEN DO
      SAY 'DSNDISP VALUE IS INVALID>'TMPVAL'< USING SHR_REUSE'
      PRM_RC=4
      END
     END
    WHEN TMP='REPEAT' THEN DO
     IF (DATATYPE(TMPVAL) ^= 'NUM') THEN DO
      SAY 'REPEAT VALUE IS INVALID>'TMPVAL'< USING 0'
      PRM_RC=4
      ITERATE
      END
     IF TMPVAL < 0 THEN DO
      SAY 'REPEAT VALUE IS LT 0>'TMPVAL'< USING 0'
      PRM_RC=4
      ITERATE
      END
     IF TMPVAL > MAXRP THEN DO
      SAY 'REPEAT VALUE IS GT MAXRP>'TMPVAL'< USING 'MAXRP
      PRM_RC=4
      ITERATE
      END
     END
    WHEN TMP='WAIT' THEN DO
     IF (DATATYPE(TMPVAL) ^= 'NUM') THEN DO
      SAY 'WAIT VALUE IS INVALID>'TMPVAL'< USING 0'
      PRM_RC=4
      ITERATE
      END
     IF TMPVAL < 0 THEN DO
      SAY 'WAIT VALUE IS LT 0>'TMPVAL'< USING 0'
      PRM_RC=4
      ITERATE
      END
     IF TMPVAL > MAXWT THEN DO
      SAY 'WAIT VALUE IS GT MAXWT>'TMPVAL'< USING 'MAXWT
      PRM_RC=4
      ITERATE
      END
     END
    OTHERWISE DO
     SAY 'UNKNOWN PARAMETER>'TMP'< WITH VALUE>'TMPVAL'<'
     PRM_RC=4
     ITERATE
     END
    END  /* END SELECT */
   END
  IF PRM_RC ^= 0 THEN DO
   ANS = 'Y'
   SAY 'AT LEAST ONE OR MORE PARMS WERE INVALID. CONTINUE (Y/N)'
   PULL ANS
   UPPER ANS
   IF ANS ^= 'Y' THEN SIGNAL CANCEL8
   END
 /*TRACE I */
 IF SUBSTR(MTSOC,1,1) = '<' THEN DO
  FP = POS('>',MTSOC,2)
  IF FP = 0 THEN SIGNAL BADPARM
  PARSE VAR MTSOC '<' MTSOC '>'
  END
 SELECT
 WHEN MTSOC = '?' THEN DO
   ADDRESS TSO "NEWSTACK"
   ADDRESS ISPEXEC
   ACTN='PULL'         /* PULL MEANS DON'T LOOK FOR ISPVARS */
   EXECSEL = 'MYTSO1'
   DSEMSG = 'ENTER TSO COMMANDS (USE COPY TO READ FROM PDS)'
   ADDRESS ISPEXEC "VPUT (EXECSEL DSEMSG) ASIS"
   MYVARO = 'MSDSF'
   CALL REXXSRC ACTN"("MYVARO")"
   XC = RESULT
   IF XC ^= 0 THEN SIGNAL ERR_REXXSRC
   CC=QUEUED()
   IF CC = 0 THEN SIGNAL NO_CMDS
/*TRACE ?I   \*                                               */
   ACUMMSG=ACUMMSG||'....> PULLING REXX STATEMENTS <.....'||FFX
   MSGLOCK='Y'
   MSGSTAT='CONTPOP'
   MSGBOXTX=ACUMMSG
   ADDRESS ISPEXEC "VPUT (MSGBOXTX) ASIS"
   ADDRESS ISPEXEC "VPUT (MSGLOCK MSGSTAT) ASIS"
   CALL MSGBOX
   MYVARCT = QUEUED()
   SRC#=0
   DO K = 1 TO MYVARCT
    PULL SRC.K
    ACUMMSG=ACUMMSG||SRC.K||FFX
    SRC#=K
    END
   ADDRESS TSO
   "DELSTACK"
   IF SRC# < 1 THEN SIGNAL NO_CMDS
   IF SRC.1 = '' THEN SIGNAL NO_CMDS
   END
  WHEN MTSOC ^= '' THEN DO
   SRC.1 = MTSOC
   SRC#=1
   END
  OTHERWISE DO
   SAY 'ENTER TSO COMMAND WITH PARMS (IF ANY)'
   PULL MTSOC
   IF MTSOC = '' THEN EXIT
   SRC.1 = MTSOC
   SRC#=1
   END
  END  /* END SELECT */
 DOIT:
 /* TRACE ?I */
  EDSN=MDSN
  R_CT=1
  SAY 'EXECUTING TSO CMDS, REPEAT:'REPEAT' WAIT:'WAIT' TO DSN:'MDSN
  X=OUTTRAP('LINE.')
 REPEAT_LOOP:
  R_CT=R_CT+1
  DO I = 1 TO SRC#
   MTSOC = STRIP(SRC.I,'B')
   IF SUBSTR(MTSOC,1,1) = '*' THEN ITERATE
 /*TRACE I */
   MTSOC
   END
  IF WAIT>0 THEN DO
   JUNK = SYSCALLS('ON')
   ADDRESS SYSCALL "SLEEP" WAIT
   END
  IF R_CT>REPEAT THEN SIGNAL DONEIT
  SIGNAL REPEAT_LOOP
 DONEIT:
  X=OUTTRAP('OFF')
  MXLN=80
  LNCT=LINE.0
  IF LNCT < 1 THEN DO
   CALL MSGBOX 'TSO COMMAND RETURNED NULL OUTPUT. PRESS PF3 TO END'
   EXIT
   END
  DO I = 1 TO LNCT
   LL=LENGTH(LINE.I)
   IF LL > MXLN THEN MXLN = LL
   END
/* TRACE ?I   */
  MXLN=MXLN+4
  XC=LISTDSI("'"MDSN"'" DIRECTORY NORECALL)
  IF XC ^= 0 THEN SIGNAL ARNDLRECL
   IF MXLN > SYSLRECL THEN DO
   SAY 'WARNING:'MDSN
   SAY '         HAS LRECL OF 'SYSRECL
   SAY '   BUT YOU MAX LINE LENGTH IS 'MXLN
   SAY 'YOU MAY WANT A DIFFERENT DSN, OR DEL/REALC 'MDSN
   PULL
   END
   IF SYSDSORG ^= 'PS' THEN DO
   SAY 'WARNING: POSSIBLE DELETE OF NON SEQUENTIAL DATA'
   SAY 'WARNING:'EDSN
   SAY 'WARNING: THIS DS HAS 'SYSDSORG' DSTYPE'
   SAY '   AND CANNOT BE USED AS THE TARGET.'
   EDSN=DFTDSN
   SAY '   USING THE DEFAULT 'EDSN
   SAY 'YOU MAY WANT A DIFFERENT DSN, OR DEL/REALC '
   PULL
   END
 ARNDLRECL:
  BLKMXLN=MXLN+4
  EXECSEL = 'MYTSO'
  DSEMSG = '(R)REUSE,(D)DEL/REALC,(A)ABORT,(M)MOD'
  MODATTR="NEW DSORG(PS) "||,
   "RECFM(V,B) BLOCK("BLKMXLN") SPACE("LNCT",0) "||,
   "CATALOG REUSE"
  MYVERB = 'ABORT CANCEL REUSE DELETE MOD'
  MODDSN=''
  "ISPEXEC VPUT (MYVERB MODDSN) ASIS"
  "ISPEXEC VPUT (EDSN EXECSEL DSEMSG MODATTR) ASIS"
  IF RC ^= 0 THEN SIGNAL CANCEL8
  CALL ALOCDSN
  XC = RESULT
  IF XC = 8 THEN SIGNAL CANCEL8
  IF XC ^= 0 THEN SIGNAL CANCEL8
  "ISPEXEC VGET (EDSN MYVERB) ASIS"
  IF MYVERB ^= 'MOD' THEN MYVERB = 'SHR REUSE'
  "ALLOC FI(O) DA('"EDSN"') "MYVERB
  "EXECIO * DISKW O (STEM LINE. FINIS"
  "FREE FI(O)"
  "ISPEXEC VIEW DATASET('"EDSN"')"
  EXIT
BADPARM:
  SAY 'INVALID PARM:'PRM' SPECIFIED. VALID PARMS ARE:'VALPRMS
  RETURN 8
BADPRMVAL:
  SAY 'INVALID PARM SPECIFIED. VALID PARMS ARE:'VALPRMS
  RETURN PRM_RC
 CANCEL8:
  SAY 'ABORT OR CANCEL SELECTED'
  EXIT 8
ERREND:
  SAY 'ABORTING AFTER 'SIGLCODE'. BYE'
  RETURN 8
###END MYTSO1
$$$BEG DSNWIND
/* REXX */
/* CEMHELP BEGIN                                                     */
/* CEMHELP          - TSO BASE, RESTRICTED                           */
/* CEMHELP END                                                       */
/*                                                                   */
/* USE THIS EXEC TO POP A WINDOW TO DISPLAY THE EDSN VAR AN GET A    */
/*  RESPONSE. WE EXPECT ISPF VGET VAR EDSN DSEMSG AS REQUIRED AND    */
/*  VGET VAR MYVERB AND EXECSEL AS OPTIONAL. MYVERB SHOULD HOLD      */
/*  LIST OF ACCEPTABLE COMMANDS TO MATCH RESPONSE (NULL RESP IS OK   */
/*  BUT RETURNS RC 4).  IF MYVERB OMITTED, THEN WE USE A DEFUALT     */
/*  LIST.      THE EDSN VAR CAN BE CHANGED AND A MYVERB IS PASSED    */
/*  BACK FROM THE COMMAND LINE.  BOTH ARE RETURNED VIA VPUT.         */
/*  WE ALSO RETURN A VALUE                                           */
/*   0 IF WINDOW IS SUCESSFULLY DISPLAYED, NOT PF3 AND VARS VPUT     */
/*   4 IF ONE OF PREDEFINED VALUES NOT SELECTED                      */
/*   8 IF PF3 WAS STRUCK TO END WINDOW (CANCEL???)                   */
/*  12 UNUSED                                                        */
/*  16 IF ANY OF VGET VPUT FAILED OR WINDOW DISPLAY FAILED           */
 ADDRESS ISPEXEC
 "ISPEXEC VGET (EDSN DSEMSG) ASIS"
 IF RC ^= 0 THEN RETURN 16
 DFVERB = 'ABORT BYPASS CANCEL DELETE REUSE HDEL'
 "ISPEXEC VGET (MYVERB) ASIS"
 IF RC = 0 THEN DO
  IF MYVERB='' THEN MYVERB=DFVERB
   ELSE DFVERB=MYVERB
   END
  ELSE MYVERB=DFVERB
 DFVERB = TRANSLATE(DFVERB,' ',',')
 J = WORDS(DFVERB)
 TMPV=''
 TMPL=''
 DO I = 1 TO J
  WD.I = WORD(DFVERB,I)
  TMPC=SUBSTR(WD.I,1,1)
  TMPW=SUBSTR(WD.I,2)
  TMPV=TMPV||TMPC||' '
  TMPL=TMPL||'('||TMPC||')'||TMPW||' '
  END
 DIRMSG=TRANSLATE(STRIP(TMPL,'T'),',',' ')
 HDIRMSG=DIRMSG
 DFVERB=TRANSLATE(STRIP(TMPV,'T'),',',' ')
 "ISPEXEC VGET (EXECSEL) ASIS"
 IF RC ^= 0 THEN EXECSEL = ''
 "ISPEXEC ADDPOP ROW(1) COLUMN(2)"
REDSPLY:
 "ISPEXEC DISPLAY PANEL(COPYSELP)"
 XC = RC
 IF XC = 8 THEN DO
  MYVERB = 'CANCEL'
  END
  ELSE DO
   IF MYVERB = '' THEN SIGNAL VRBXIT
   DO I = 1 TO J
    IF ABBREV(WD.I,MYVERB,1) = 1 THEN DO
     MYVERB = WD.I
     SIGNAL VRBXIT
     END
    END
   XC = 4
   END
  DIRMSG="INVALID COMMAND."||HDIRMSG
  SIGNAL REDSPLY
VRBXIT:
 "ISPEXEC REMPOP"
 "ISPEXEC VPUT (EDSN MYVERB) ASIS"
 IF RC ^= 0 THEN XC = 16
 RETURN XC
###END DSNWIND
$$$BEG SPCAT
/* REXX */
/* CEMHELP BEGIN                                                     */
/* CEMHELA SPCAT   - CONCAT CEM EXEC AND EDITMAC DSN TO SYSPROC      */
/* CEMHELP SPCAT   - TSO BASED, INVOKE VIA 'TSO CEM SPCAT' IN ORDER  */
/* CEMHELP         - TO CONCATENATE THE CEM PROC AND MACRO LIBS TO   */
/* CEMHELP         - THE TOP OF YOUR TOS SYSPROC                     */
/* CEMHELP END                                                       */
 SPCATI = 'SPCAT ENVIRONMENT ESTABLISHED 'DATE('U') TIME('L')
 MIND = 1
 CIND = 1
 IF SYSVAR('SYSISPF') ^= 'ACTIVE' THEN SIGNAL DOKCAM
 ADDRESS ISPEXEC
 "ISPEXEC VGET (SPCATI) SHARED"
 IF RC ^= 0 THEN SIGNAL DOKCAM
 "ISPEXEC VPUT (SPCATI) SHARED"
 IF RC ^= 0 THEN SIGNAL EXITRC8
 ADDRESS TSO
 SIGNAL DOINIT
DOKCAM:
 ADDRESS TSO
 "EXECUTIL HT"
 ABC = MSG(OFF)
 '%KCAM'
 CIND = RC
 '%KCAMAC'
 MIND = RC
 "EXECUTIL RT"
 ABC = MSG(ABC)
 IF CIND = 0 & MIND = 0 THEN SIGNAL DONEINIT
DOINIT:
 CATDD = 'SYSPROC'
 CATLIB = ''
/* DLM = '' */
 DLM = ' '
/*
 IF MIND ^= 0 THEN DO
  CATLIB = 'TTED.TSK.D.TCEM.ISPPLIB'||DLM
  END
*/
 IF CIND ^= 0 THEN DO
  CATLIB = CATLIB||'TTED.TSK.P.TCEM.EDITMAC',
              ||DLM||'TTED.TSK.P.TCEM.CLIST'
  "EX 'TTED.TSK.P.TCEM.CLIST(CCAT)' '"CATDD CATLIB"'"
  IF RC ^= 0 THEN SIGNAL EXITRC8
  END
 CALL GETCPU1
 RETURN 0
DONEINIT:
 SAY 'SPCAT ENVIRONMENT ALREADY ESTABLISHED. ENDING EXEC.'
 RETURN 0
EXITRC8:
 SAY 'EXITRC 8 ROUTINE. CONCAT NOT DONE'
 RETURN 8
###END SPCAT
$$$BEG EXPLSIGL
/* REXX */
TRACE I
SIGNAL ON ERROR NAME ERROR
SIGNAL ON SYNTAX NAME SYNTAX
SIGNAL ON FAILURE NAME FAILURE
SIGNAL ON HALT NAME HALT
SIGNAL START
ERROR:
    XC=RC
    SAY 'REXX ERROR 'XC' ON LINE 'SIGL':'
    SAY 'REXX:- APPLICATION RETURNED AN ERRORLEVEL' XC
    SIGNAL START
SYNTAX:
    XC=RC
    SAY 'REXX ERROR 'XC' ON LINE 'SIGL':'ERRORTEXT(XC)
    SAY 'REXX:- ERROR' XC':' ERRORTEXT(XC)
    SIGNAL START
FAILURE:
    XC=RC
    SAY 'REXX ERROR 'XC' ON LINE 'SIGL':'
    IF XC = -3 THEN,
       SAY 'REXX:- PROGRAM NOT FOUND'
    ELSE IF XC = -8 THEN,
       SAY 'REXX:- INSUFFICIENT MEMORY FOR PROGRAM'
    ELSE,
       SAY 'REXX:- RETURN CODE' XC
    SIGNAL START
HALT:
    XC=RC
    SAY 'REXX:- CTRL-BREAK INTEXCEPTED'
START:
  XC=RC
SIGNAL ON HALT NAME XITIT
  SAY 'REXX ERROR 'XC' ON LINE 'SIGL':'ERRORTEXT(XC)
DO WHILE (1)
 SAY 'ENTER A VALID REXX COMMAND EXCEPT INTERPRET'
 PULL RESP
 IF WORD(RESP,1) = 'INTERPRET' THEN DO
  SAY 'DO NOT ENTER A INTERPRET COMMAND. RETRY'
  ITERATE
  END
 INTERPRET RESP
 END
 XITIT:
    PULL
    EXIT
###END EXPLSIGL
$$$BEG COPYINFO
/* REXX */
/* CEMHELP BEGIN                                                     */
/* CEMHELA COPYINFO - DISPLAYS AFOCNTL,SIT,PARM O/R,TABLE INFO/COPY  */
/* CEMHELP COPYINFO - TSO BASE, PROMPTS USER FOR CICS REGION NAME,   */
/* CEMHELP          - OR SOME IDENTIFYING STRING WHICH THIS EXEC USES*/
/* CEMHELP          - CREATE A ISPF DIALOGE PANEL.  RETURNS THE FIRST*/
/* CEMHELP          - OCCURANCE OF THE ENTERED STRING AND FORMATS THE*/
/* CEMHELP          - COPY AFOPER AND CURRENT SIT. ALLOWS VIEW OF    */
/* CEMHELP          - PARMLIB OVERRIDE AND/OR TABLE.SOURCE FOR COPY. */
/* CEMHELP END                                                       */
/* TRACE I */
 ALIND = 0
 IF SYSVAR('SYSISPF') ^= 'ACTIVE' THEN DO
  SAY 'PROCEDURE MUST BE RUN FROM ISPF'
  EXIT
  END
 EXECSEL = 'COPYINFO'
 DSEMSG=''
 ADDRESS ISPEXEC "ISPEXEC VPUT (DSEMSG EXECSEL) ASIS"
 ADDRESS ISPEXEC "ISPEXEC VGET (SPCATI) SHARED"
 IF RC = 0 THEN SIGNAL DONEINIT
 A = 'TTED.TSK.P.TCEM'
 "ALLOC FI(SYSUPROC) DA('"A".EDITMAC' '"A".CLIST') SHR"
 "ALTLIB ACTIVATE USER(CLIST)"
 ALIND = 1
DONEINIT:
  MYPNLIB='TTED.TSK.D.TCEM.ISPPLIB'
  IF PNLLOADED > 0 THEN SIGNAL GOTMYPNLIB
  IDVAL_CT = 0
 TRYAGN:
  IDVAL=''
  'ISPEXEC QLIBDEF 'ISPPLIB' ID(IDVAL)'
  XC = RC
  IF IDVAL \= '' THEN DO
   IF IDVAL_CT > 1 THEN DO
    SAY 'COULD NOT LIBDEF ISPPLIB. LOOP??'
    RETURN 8
    END
   XDSN=TRANSLATE(IDVAL,"  ",",'")
   IF WORDPOS(MYPNLIB,XDSN) \= 0 THEN SIGNAL GOTMYPNLIB
   CALL EXPLLDEF 'ISPPLIB' MYPNLIB 'STACK' 'QUIET'
   XC=RESULT
   IDVAL_CT = IDVAL_CT + 1
   SIGNAL TRYAGN
   END
  IF IDVAL = '' THEN DO
   STKLIBS=MYPNLIB
   CALL EXPLLDEF 'ISPPLIB' STKLIBS 'STACK' 'QUIET'
   XC=RESULT
   IF RC > 4 THEN DO
    SAY 'COULD NOT LIBDEF ISPPLIB. RC WAS'RC
    RETURN 8
    END
   END
 GOTMYPNLIB:
 /* TRACE I */
 ARG ARGAFO
 IF LENGTH(ARGAFO) > 10 THEN SIGNAL OK1
 CALL SAFO ARGAFO
 LR=RESULT
 IF LR = 0 THEN SIGNAL OK1
 IF LR > 4 THEN SIGNAL EXITRC2
 SIGNAL BADSEL
 OK1:
 ADDRESS ISPEXEC
 "ISPEXEC VGET (MYAFO MYSST MYSVAFO MYAFOVER "||,
  "MYCNTL MYBEEP MYAFOIND TEAM1BNO TEAM2BNO TEAMUBNO) SHARED"
 IF MYAFO = '' THEN SIGNAL NOTDON
 IF MYSVAFO < 1 THEN SIGNAL NOTDON
 "ISPEXEC VGET (SVAFO"MYSVAFO") ASIS"
 IF RC ^= 0 THEN SIGNAL NOTDON
 IF MYAFOVER = '1' THEN DO
  CALL COPYINV1
  EXIT
  END
 INTERPRET "MYAFO=SVAFO"MYSVAFO
 NOTCPUI = 1
 DOITANS='EYVB'  /* EDIT YES VIEW BROWSE */
 SJDT = DATE('J')
 SUDT = DATE('U')
 SWDT = DATE('W')
 SBDT = DATE('B')
 SCWD = SBDT//7
 YDT=SUBSTR(SJDT,1,2)
 SJDA=SUBSTR(SJDT,3,3)
 CURWK = 0
 CALL FDAY
 ODT=YDT||SUBSTR(CURWK+100,2,2)
 WDT=SUBSTR(SWDT,1,3)
 UPPER WDT
 CMD=''
  PS="#"
  "ISPEXEC VGET (AFOLISTV AFOLISTL) ASIS"
  IF RC ^= 0 THEN DO
   CALL AFOPOS
   "ISPEXEC VGET (AFOLISTV AFOLISTL) ASIS"
   IF RC ^= 0 THEN SIGNAL BADAFO
   END
  FLD#=AFOLISTL
  NWD=WORDS(AFOLISTV)
  DO I = 1 TO NWD
   CKVAR=STRIP(WORD(AFOLISTV,I),'B')
   IF LENGTH(CKVAR) > 7 THEN CKVAN=SUBSTR(CKVAR,1,7)
    ELSE CKVAN=CKVAR
   PARSE VAR FLD# TL TB TE TM (PS) FLD#
   IF TL = 0 THEN ITERATE
   INTERPRET CKVAN'L = TL'
   INTERPRET CKVAN'B = TB'
   INTERPRET CKVAN'E = TE'
   INTERPRET CKVAN'M = TM'
   INTERPRET CKVAR '= STRIP(SUBSTR(MYAFO,TB,TL),"B")'
   END
 JOBNM=STRIP(MYCOLDJ,'T')
 MYCTYPOR = MYTYP
 IF MYTYP = 'E' THEN MYTYP = 'D'
 IF MYCOMMNL > 60 THEN DO
  MYCMNT=SUBSTR(MYAFO,MYCOMMNB+61,MYCOMMNL-61)
  MYCOMMNT=SUBSTR(MYAFO,MYCOMMNB,60)
  END
 TMP = 'TEAM?NOT APPLICABLE NOT APPLICABLE'
 MYTNO = SUBSTR(TMP,1,5)
 MYDBNO = SUBSTR(TMP,6,15)
 MYNBNO = SUBSTR(TMP,21,15)
 MSNPP = POS('WD/',MYBEEP)
 IF MSNPP = 0 THEN DO
  MYSNP = 'START AND STOP TIMES UNKNOWN'
  END
  ELSE DO
  MYSNP = SUBSTR(MYBEEP,MSNPP)
  END
 SELECT
  WHEN MYAPLID = 'CICSMEDB' THEN  MYAPLIDX = 'MEDB'
  WHEN MYAPLID = 'CRISD01' THEN  MYAPLIDX = 'CICSCRID'
  WHEN MYAPLID = 'CRIST01' THEN  MYAPLIDX = 'CICSCRIT'
  WHEN MYAPLID = 'CRISM01' THEN  MYAPLIDX = 'CICSCRIM'
  WHEN MYAPLID = 'CRISP01' THEN  MYAPLIDX = 'CICSCRIP'
  WHEN MYAPLID = 'INFOAGY' THEN  MYAPLIDX = 'CICSADAB'
  WHEN MYAPLID = 'INFOAG' THEN  MYAPLIDX = 'CICSADA2'
  OTHERWISE MYAPLIDX = MYAPLID
  END
 MYCPYL=STRIP('TTE'||MYTYP||'.TSK.F.R'||MYREL||'.'||MYAPLIDX,'T')
 IF MYREL = '540' THEN DO
  IF MYTYP = 'D' THEN MYPRML=MYCPYL||'.PARMLIB(STARTUP)'
   ELSE MYPRML=MYCPYL||'.PARMLIB(STARTUPX)'
  END
  ELSE DO
  MYPRML=MYCPYL||'.PARMLIB(STARTUP)'
  END
 MYSITL=MYCPYL||'.TABLE.SOURCE'
 MYTABL=MYCPYL||'.TABLE.SOURCE'
 MYCTS='TTEP.TSK.F.R'||MYREL||'.COMMON.TABLE.SOURCE'
 MYSIT='N/A'
 TRACE OFF
 ADDRESS ISPEXEC "VGET (CURCPU CURGRP) PROFILE"
 IF RC ^= 0 THEN DO
  CALL GETCPU1
  ADDRESS ISPEXEC "VGET (CURCPU CURGRP) PROFILE"
  END
CPUOK1:
 GRP=MYCPU||'SYS'
 CALL GETCPU1 GRP
 ADDRESS ISPEXEC "VGET (CVTDGRP) SHARED"
 IF RC ^= 0 THEN GRP = '????'
  ELSE GRP = CVTDGRP
 IF GRP = '????' THEN SIGNAL NOTCPU
 IF GRP^=CURGRP THEN SIGNAL NOTCPU
 /* NEW CODE FOR FINDING SIT */
 /* CALL GET SIT RETURNS ISPF VARS LIST IN GETSITLS VAR */
 /* TRACE ?I */
 GETSITLS = ''
 ADDRESS ISPEXEC "VPUT (GETSITLS) ASIS"
 CALL GETSIT MYAPLIDX MYREL MYTYP
 IF RESULT \= 0 THEN SIGNAL GETSITERR
 ADDRESS ISPEXEC 'VGET (GETSITLS) ASIS'
 IF RC \= 0 THEN SIGNAL GETSITERR
 WDS = WORDS(GETSITLS)
 ADDRESS ISPEXEC 'VGET ('GETSITLS') ASIS'
 IF RC \= 0 THEN SIGNAL GETSITERR
 GETSITLS_VALS=''
 DO I = 1 TO WDS
  TBLTMP = WORD(GETSITLS,I)
  INTERPRET "GETSITLS_VALS = GETSITLS_VALS||' '||"TBLTMP
  END
 /* SAY 'SIT:' SIT */
 MYSIT = SIT
 SIGNAL ARND_OLD_SIT
 /* END NEW CODE FOR FINDING SIT */
 /* CALL GET SIT RETURNS ISPF VARS LIST IN GETSITLS VAR */
RETWPLOR:
 IF SYSDSN("'"MYPRML"'") ^= 'OK' THEN DO
   EDSN=MYPRML
   DSEMSG = 'PARMLIB(STARTUP) NOT FOUND'
   MYVERB = 'CANCEL ABORT BYPASS'
   ADDRESS ISPEXEC "VPUT (EDSN DSEMSG MYVERB) ASIS"
   CALL DSNWIND
   XC = RESULT
   IF XC > 4 THEN SIGNAL EXITRC2
   ADDRESS ISPEXEC "VGET (MYVERB) ASIS"
   IF RC ^= 0 THEN SIGNAL EXITRC8
   IF MYVERB ^= '' THEN DO
    IF MYVERB='ABORT' | MYVERB='CANCEL' THEN SIGNAL EXITRC2
    IF MYVERB = 'BYPASS' THEN SIGNAL BYPCPU
    END
   ADDRESS ISPEXEC "VGET (EDSN) ASIS"
   MYPRML= STRIP(EDSN,'T')
   SIGNAL RETWPLOR
   END
 ADDRESS TSO "ALLOC FI(SPRMI) DA('"MYPRML"') SHR"
 ADDRESS TSO "EXECIO * DISKR SPRMI (STEM SPRMLST. FINIS"
 ADDRESS TSO "FREE FI(SPRMI)"
 NOTCPUI = 0
 DO I = 1 TO SPRMLST.0
  IF SUBSTR(SPRMLST.I,1,1) = '*' THEN ITERATE
  POSSIT = POS('SIT=',SPRMLST.I)
  IF POSSIT ^= 0 THEN LEAVE
  END
 IF POSSIT ^= 0 THEN MYSIT=SUBSTR(SPRMLST.I,POSSIT+4,2)
ARND_OLD_SIT:
 ADDRESS TSO "ALLOC FI(SPRMI) DA('"MYPRML"') SHR"
 ADDRESS TSO "EXECIO * DISKR SPRMI (STEM SPRMLST. FINIS"
 ADDRESS TSO "FREE FI(SPRMI)"
 NOTCPUI = 0
 "ISPEXEC VPUT (MYSIT MYCPYL) SHARED"
 ZEDSMSG = MYAPLID MYCPU
 ZEDLMSG = 'COPY APPLID 'MYAPLID' FOUND FOR CPU 'MYCPU
 SIGNAL REDSPLYM

BYPCPU:
 ZEDSMSG = MYAPLID MYCPU
 ZEDLMSG = 'COPY APPLID 'MYAPLID' BYPASS SELECTED.'
 SIGNAL REDSPLYM
GETSITERR:
 ZEDSMSG = MYAPLID MYCPU
 ZEDLMSG = 'COPY APPLID 'MYAPLID' GETSITERR:'MAX(RC,RESULT)
 SIGNAL REDSPLYM
NOTCPU:
 ZEDSMSG = MYAPLID MYCPU
 ZEDLMSG = 'COPY APPLID 'MYAPLID' NOT FOUND FOR CPU 'MYCPU
REDSPLYM:
TRACE OFF
 "ISPEXEC SETMSG MSG(ISRZ001)"
REDSPLY:
 STIM = TIME()
 BPL='N'
 BTS='N'
 BSIT='N'
 DEXT='N'
 DTAB='N'
 DJCL='N'
 EJCL='N'
 XTNT='N'
 SRPL4MBR=''
 STBL='N'
 MYVERB = ''
 "ISPEXEC DISPLAY PANEL(AFOCNTLD)"
 LASTCC = RC
 IF LASTCC = 8 THEN SIGNAL EXITRC0
 IF MYVERB = 'END' THEN SIGNAL EXITRC0
 IF CMD = 'PING' | CMD= 'PINGQ' THEN DO
  MYCA='PING'
  IF CMD = 'PING' THEN  MYCAL=1024
   ELSE MYCAL=0
  MYPROG='UCEMPINN'
  "ISPEXEC VPUT (MYCA MYCAL MYPROG MYAPLID) ASIS"
  IF RC ^= 0 THEN SIGNAL PINGERR
  CALL EXCIS2 'MSGBOXONLY'
  CMD = ''
  END
 UPPER DEXT
 IF DEXT = 'Y' THEN DO
  IF MYCNTL = '' THEN SIGNAL NOEXTD
  MYJ1ASW=STRIP(SUBSTR(MYAFO,MYJ1ASWB,MYJ1ASWL),"B")
  MYJ1BSW=STRIP(SUBSTR(MYAFO,MYJ1BSWB,MYJ1BSWL),"B")
  MYJ1XSW=STRIP(SUBSTR(MYAFO,MYJ1XSWB,MYJ1XSWL),"B")
  MYJ10ASW=STRIP(SUBSTR(MYAFO,MYJ10ASB,MYJ10ASL),"B")
  MYJ10BSW=STRIP(SUBSTR(MYAFO,MYJ10BSB,MYJ10BSL),"B")
  MYJ21ASW=STRIP(SUBSTR(MYAFO,MYJ21ASB,MYJ21ASL),"B")
  MYJ21BSW=STRIP(SUBSTR(MYAFO,MYJ21BSB,MYJ21BSL),"B")
  MYRDRSW=STRIP(SUBSTR(MYAFO,MYRDRSWB,MYRDRSWL),"B")
  MYU1ASW=STRIP(SUBSTR(MYAFO,MYU1ASWB,MYU1ASWL),"B")
  MYU1BSW=STRIP(SUBSTR(MYAFO,MYU1BSWB,MYU1BSWL),"B")
  MYU2ASW=STRIP(SUBSTR(MYAFO,MYU2ASWB,MYU2ASWL),"B")
  MYU2BSW=STRIP(SUBSTR(MYAFO,MYU2BSWB,MYU2BSWL),"B")
  MYU3ASW=STRIP(SUBSTR(MYAFO,MYU3ASWB,MYU3ASWL),"B")
  MYU3BSW=STRIP(SUBSTR(MYAFO,MYU3BSWB,MYU3BSWL),"B")
  MYU4ASW=STRIP(SUBSTR(MYAFO,MYU4ASWB,MYU4ASWL),"B")
  MYU4BSW=STRIP(SUBSTR(MYAFO,MYU4BSWB,MYU4BSWL),"B")
  MYUJ=STRIP(SUBSTR(MYAFO,MYUJB,MYUJL),"B")
  MYCMISA=STRIP(SUBSTR(MYAFO,MYCMISAB,MYCMISAL),"B")
  MYCMISB=STRIP(SUBSTR(MYAFO,MYCMISBB,MYCMISBL),"B")
  MYEOD=STRIP(SUBSTR(MYAFO,MYEODB,MYEODL),"B")
 LASTCC = 0
 DO UNTIL (LASTCC ^= 0)
   "ISPEXEC DISPLAY PANEL(AFOCNTLE)"
   LASTCC = RC
   END
  END
NOEXTD:
 IF MYSIT='N/A' THEN SIGNAL NOSITOR
 UPPER BPL
 UPPER BSIT
 UPPER BTS
 IF POS(BPL,DOITANS) = 0 THEN SIGNAL SEESIT
 TDSN = MYPRML
RETPARM:
 IF SYSDSN("'"TDSN"'") = 'OK' THEN SIGNAL BROPARM
   EDSN=TDSN
   DSEMSG = 'PARMLIB(STARTUP) NOT FOUND'
   ADDRESS ISPEXEC "VPUT (EDSN DSEMSG) ASIS"
   CALL DSNWIND
   XC = RESULT
   IF XC > 4 THEN SIGNAL EXITRC2
   ADDRESS ISPEXEC "VGET (MYVERB) ASIS"
   IF RC ^= 0 THEN SIGNAL EXITRC8
   IF MYVERB ^= '' THEN DO
    IF MYVERB='ABORT' | MYVERB='CANCEL' THEN SIGNAL EXITRC2
    IF MYVERB = 'BYPASS' THEN SIGNAL SEESIT
    END
   ADDRESS ISPEXEC "VGET (EDSN) ASIS"
   TDSN=STRIP(EDSN,'T')
   SIGNAL RETPARM
   END
BROPARM:
 IF BPL = 'E' THEN "ISPEXEC EDIT DATASET('"TDSN"')"
  ELSE "ISPEXEC BROWSE DATASET('"TDSN"')"
SEESIT:
 IF POS(BSIT,DOITANS) = 0 THEN SIGNAL SEETBL
 TDSN = MYSITL||"(DFHSIT"MYSIT")"
 SITDSN=TDSN
RETSIT:
  IF SYSDSN("'"TDSN"'") = 'OK' THEN SIGNAL BROSIT
   IF SITDSN=TDSN THEN DO
    TDSN=MYCTS||'(DFHSIT'||MYSIT||')'
    SIGNAL RETSIT
    END
   EDSN=TDSN
   DSEMSG = TDSN' NOT FOUND'
   ADDRESS ISPEXEC "VPUT (EDSN DSEMSG) ASIS"
   CALL DSNWIND
   XC = RESULT
   IF XC > 4 THEN SIGNAL EXITRC2
   ADDRESS ISPEXEC "VGET (MYVERB) ASIS"
   IF RC ^= 0 THEN SIGNAL EXITRC8
   IF MYVERB ^= '' THEN DO
    IF MYVERB='ABORT' | MYVERB='CANCEL' THEN SIGNAL EXITRC2
    IF MYVERB = 'BYPASS' THEN SIGNAL SEETBL
    END
   ADDRESS ISPEXEC "VGET (EDSN) ASIS"
   TDSN=STRIP(EDSN,'T')
   FP = POS('(',TDSN)
   IF FP = 0 THEN FP = LENGTH(TDSN)
    ELSE FP = FP - 1
   MYSITL = SUBSTR(TDSN,1,FP)
   SIGNAL RETSIT
BROSIT:
 IF BSIT = 'E' THEN "ISPEXEC EDIT DATASET('"TDSN"')"
  ELSE "ISPEXEC VIEW DATASET('"TDSN"')"
SEETBL:
 BTSL=LENGTH(BTS)
 IF BTSL = 0 THEN SIGNAL TSTTAB
 IF BTS = 'N' THEN SIGNAL TSTTAB
 TDSN = MYTABL
RETTBL:
 IF SYSDSN("'"TDSN"'") = 'OK' THEN SIGNAL PROCTBL
 EDSN=TDSN
 DSEMSG = 'TABLE.SOURCE NOT FOUND'
 ADDRESS ISPEXEC "VPUT (EDSN DSEMSG) ASIS"
 CALL DSNWIND
 XC = RESULT
 IF XC > 4 THEN SIGNAL EXITRC2
 ADDRESS ISPEXEC "VGET (MYVERB) ASIS"
 IF RC ^= 0 THEN SIGNAL EXITRC8
 IF MYVERB ^= '' THEN DO
  IF MYVERB='ABORT' | MYVERB='CANCEL' THEN SIGNAL EXITRC2
  IF MYVERB = 'BYPASS' THEN SIGNAL TSTTAB
  END
 ADDRESS ISPEXEC "VGET (EDSN) ASIS"
 TDSN=STRIP(EDSN,'T')
 FP = POS('(',TDSN)
 IF FP = 0 THEN FP = LENGTH(TDSN)
  ELSE FP = FP - 1
 MYTABL = SUBSTR(TDSN,1,FP)
 SIGNAL RETTBL
PROCTBL:
 IF BTSL = 1 & POS(BTS,DOITANS) ^= 0 THEN DO
  IF BTS = 'E' THEN "ISPEXEC EDIT DATASET('"TDSN"')"
   ELSE "ISPEXEC VIEW DATASET('"TDSN"')"
  SIGNAL TSTTAB
  END
 MYTBLS = ''
 TP=WORDPOS(BTS,GETSITLS)
 IF TP > 0 THEN DO
  MYTBLS = WORD(GETSITLS_VALS,TP)
  BTSR=BTS
  END
  ELSE DO
  CALL CURRTBL BTS
  IF RESULT ^= 0 THEN SIGNAL NOTTBL
  BTSR=SUBSTR(BTS,1,3)
  END
 TBLDSN=MYTABL
CTSTBL:
 MYTBLL = TBLDSN||"(DFH"||BTSR||MYTBLS")"
  IF SYSDSN("'"MYTBLL"'") = 'OK' THEN SIGNAL BROTBL
   IF TBLDSN=TDSN THEN DO
    TBLDSN=MYCTS
    SIGNAL CTSTBL
    END
  SIGNAL NOTTBL
BROTBL:
"ISPEXEC VIEW DATASET('"MYTBLL"')"
 SIGNAL TSTTAB
PINGERR:
  ZEDSMSG = 'PING ERROR'
  ZEDLMSG = 'CAN NOT PING REGION: VARIABLES?'
  SIGNAL SETMSGO
NOSITOR:
  ZEDSMSG = 'SIT UNAVAILABLE'
  ZEDLMSG = 'NO SIT AVAILABLE (WRONG CPU?)'
  SIGNAL SETMSGO
NOTTBL:
  ZEDSMSG = 'TABLE 'BTS' NOT VALID'
  ZEDLMSG = 'NOT A VALID TABLE OR TABLE NOT IN LIBRARY'
SETMSGO:
  'ISPEXEC SETMSG MSG(ISRZ001)'
TSTTAB:
 IF DTAB = 'Y' THEN DO
  IF NOTCPUI = 1 THEN DO
   ZEDSMSG = 'DSN UNAVAILABLE'
   ZEDLMSG = 'NO DSN AVAILABLE (WRONG CPU?)'
  'ISPEXEC SETMSG MSG(ISRZ001)'
   END
   ELSE CALL COPYDS MYAPLID
  END
TSTJCL:
 IF DJCL = 'Y' THEN DO
  IF NOTCPUI = 1 THEN DO
   ZEDSMSG = 'JCL UNAVAILABLE'
   ZEDLMSG = 'NO JCL AVAILABLE (WRONG CPU?)'
  'ISPEXEC SETMSG MSG(ISRZ001)'
   END
   ELSE CALL COPYJCL MYAFO
  END
TSTEXPD:
 IF EJCL = 'Y' THEN DO
  IF NOTCPUI = 1 THEN DO
   ZEDSMSG = 'EXPANSION IMPOSSIBLE'
   ZEDLMSG = 'EXPANSION IMPOSSIBLE (WRONG CPU?)'
  'ISPEXEC SETMSG MSG(ISRZ001)'
   END
   ELSE CALL CICSEXPD JOBNM
  END
TSTSRPL:
 IF SRPL4MBR ^= '' THEN DO
  IF NOTCPUI = 1 THEN DO
   ZEDSMSG = 'RPL SEARCH IMPOSSIBLE'
   ZEDLMSG = 'RPL SEARCH IMPOSSIBLE (WRONG CPU?)'
  'ISPEXEC SETMSG MSG(ISRZ001)'
   END
   ELSE DO
    S4DDN = 'DFHRPL'
    CALL SRPL S4DDN JOBNM SRPL4MBR 'QUIET'
    END
  END
EXTNTLST:
 UPPER XTNT
 IF XTNT = 'Y' THEN DO
  IF NOTCPUI = 1 THEN DO
   ZEDSMSG = 'RPL SEARCH IMPOSSIBLE'
   ZEDLMSG = 'RPL SEARCH IMPOSSIBLE (WRONG CPU?)'
  'ISPEXEC SETMSG MSG(ISRZ001)'
   END
   ELSE DO
    S4DDN = 'DFHRPL'
    CALL SRPL S4DDN JOBNM ||' * VERBOSE EXTNTLST'
    END
  END
TSTSTBL:
 LSTBL = LENGTH(STBL)
 IF LSTBL = 0 THEN SIGNAL DONEALL
 IF STBL = 'N' THEN SIGNAL DONEALL
 IF NOTCPUI = 1 THEN DO
  ZEDSMSG = 'TBL SEARCH IMPOSSIBLE'
  ZEDLMSG = 'TBL SEARCH IMPOSSIBLE (WRONG CPU?)'
  'ISPEXEC SETMSG MSG(ISRZ001)'
  SIGNAL DONEALL
  END
 IF STBL = 'Y' THEN DO
  STBL = ''
  SIGNAL STBLDSN
  END
 IF LSTBL = 3 THEN DO
  TP=WORDPOS(STBL,GETSITLS)
  IF TP > 0 THEN DO
   MYTBLS = WORD(GETSITLS_VALS,TP)
   BTSR=STBL
   END
   ELSE DO
   CALL CURRTBL STBL
   IF RESULT ^= 0 THEN SIGNAL INVTBL
   END
  IF MYTBLS = 'NO' THEN SIGNAL INVTBL
  STBL = STBL||MYTBLS
  END
 STBL = 'DFH'||STBL
STBLDSN:
 CALL GETSRCHS MYTABL STBL
DONEALL:
 SIGNAL REDSPLY
         BADAFO:
          ZEDSMSG = 'AFOPOS FAILED'
          ZEDLMSG = 'AFOPER FEILD POSITIONS NOT ESTAB. ABORT.'
          SIGNAL WRITIT
         INVTBL:
          ZEDSMSG = 'INV TBL 'STBL||MYTBLS
          ZEDLMSG = 'TABLE 'STBL||MYTBLS' WAS INVALID OR NOT FOUND'
          SIGNAL REDSPLYM
         EXITRC0:
          ZEDSMSG = 'EXPANSION OK'
          ZEDLMSG = 'EXPANSION FOR 'MYSST' COMPLETED SUCCESSFULLY'
          SIGNAL WRITIT
         EXITRC2:
          ZEDSMSG = 'CANCEL SPECIFIED'
          ZEDLMSG = 'CANCEL WAS SPECIFIED. PROCESS ABORTED.'
          SIGNAL WRITIT
         EXITRC4:
          ZEDSMSG = 'NO HELP AVAIL'
          ZEDLMSG = 'NO HELP AVAILABLE FOR THIS PANEL'
          SIGNAL WRITIT
         EXITRC8:
         NOTDON:
          ZEDSMSG = 'NOT PROCESSED'
          ZEDLMSG = 'AFOPER EXPAND CICS REGION DEFN NOT DONE'
          SIGNAL WRITIT
         BADSEL:
          ZEDSMSG = ARGAFO' 'SELN INVALID'
      ZEDLMSG = 'AFOPER FILE DOES NOT CONTAIN INFORMATION FOR 'ARGAFO'
          SIGNAL WRITIT
         WRITIT:
          IF ALIND = 1 THEN DO
           ADDRESS TSO "ALTLIB DEACTIVATE USER(CLIST)"
           ADDRESS TSO "FREE FI(SYSUPROC)"
           END
          'ISPEXEC SETMSG MSG(ISRZ001)'
 EXIT
 * SJDA HOLDS TODAYS JUL DAY */
 * SCWD HOLDS TODAYS WEEK DAY NUMBER 0 I MON TO 6 IS FRI */
 * CURWK WILL RETURN TODAYS CURRENT WEEK BASED ON MON IS NEW WEEK */
FDAY: PROCEDURE EXPOSE SJDA SBDT CURWK
 RJDA=(SBDT-SJDA+1)//7
 CURWK=((SJDA+12)-RJDA)%7
 RETURN 0
CURRTBL: PROCEDURE EXPOSE MYSIT MYCTS SPRMLST. TDSN MYTBLS
 ARG BTS
 BTSL = LENGTH(BTS)
 IF BTSL ^= 3 & BTSL ^= 5 THEN SIGNAL BADTBL
 DO I = 1 TO SPRMLST.0
  POSTBL=POS(BTS||'=',SPRMLST.I)
  IF POSTBL^=0 THEN SIGNAL FNDPRM
  END
 TDSN = MYSITL||"(DFHSIT"MYSIT")"
 SITDSN=TDSN
CURSIT:
 IF SYSDSN("'"TDSN"'") = 'OK' THEN SIGNAL CURSITOK
 IF SITDSN=TDSN THEN DO
  TDSN=MYCTS||'(DFHSIT'||MYSIT||')'
  SIGNAL CURSIT
  END
 SIGNAL BADTBL
CURSITOK:
 MYTBLL= TDSN
 ADDRESS TSO "ALLOC FI(STBLI) DA('"MYTBLL"') SHR"
 ADDRESS TSO "EXECIO * DISKR STBLI (STEM STBLLST. FINIS"
 ADDRESS TSO "FREE FI(STBLI)"
 DO I = 1 TO STBLLST.0
  POSTBL=POS(BTS||'=',STBLLST.I)
  IF POSTBL^=0 THEN SIGNAL FNDTBL
  END
 SIGNAL BADTBL
FNDPRM:
 MYTBLS=SUBSTR(SPRMLST.I,POSTBL+BTSL+1,3)
 SIGNAL DOTBLBR
FNDTBL:
 MYTBLS=SUBSTR(STBLLST.I,POSTBL+BTSL+1,3)
DOTBLBR:
 IF SUBSTR(MYTBLS,1,1)='(' THEN MYTBLS=SUBSTR(MYTBLS,2,2)
  ELSE MYTBLS=SUBSTR(MYTBLS,1,2)
 RETURN 0
BADTBL:
 RETURN 4
###END COPYINFO
$$$BEG AFOLIST
/* REXX */
/* CEMHELP BEGIN                                                     */
/* CEMHELA AFOLIST  - LIST AFO CICS ONLINES ON THIS SYSPLEX V2.0     */
/* CEMHELP AFOLIST  - ISPF BASED, READS THE AFO FILE AND BUILDS A    */
/* CEMHELP          - ISPF SCREEN WHICH DISPLAYS ALL TEST, ACCP AND  */
/* CEMHELP          - PROD CICS APPLIDS FOR THIS SYSPLEX.            */
/* CEMHELP          - DATA DISPLAYED CAN BE SELECTED: USE AFOLIST ?  */
/* CEMHELP          - TO SELECT FIELDS FROM AFOPER FILE.             */
/* CEMHELP          - EACH CICS APPLID HAS AN INPUT FIELD IN WHICH   */
/* CEMHELP          - OTHER PROCESSING CAN BE DRIVEN (COPYINFO,ECT)  */
/* CEMHELP          - VERSION 2. UPDATED TO ALLOW FOR EXCI INTERFACE.*/
/* CEMHELP          - VERSION 2.1 ADDED ALLOC FOR ISPPLIB AT START   */
/* - THIS VERSION NOW ALLOWS THE FOLLOWING LINE COMMANDS:            */
/* - IT RUNS THE COPYINFO EXEC FOR THIS ONLINE                       */
/* - NOTE: FOR THE FOLLOWING, YOU NEED TO HAVE RUN THE FOLLOWING     */
/* - COMMAND FROM THE TSO 'READY' PROMPT:                            */
/* - EX 'TTED.TS.P.TCEM.CLIST(EXCITSLB)' '540'                       */
/* - WHICH ADDS TO THE TSO RUN ENVIR                                 */
/* - THEN RUN CICLOGON TO GET ISPF BACK                              */
/* - G RUNS THE EXCI PING                                            */
/* - D RUNS THE EXCI CEDA                                            */
/* - E RUNS THE EXCI CEMT                                            */
/* - L RUNS THE EXCI LINK                                            */
/* G,D,E, AND L PROCESSING:                                          */
/* ALL REQUIRE EXCITSLB EXEC TO BE RUN FROM TSO READY, TO ADD A      */
/* - TSOLIB EXECUTABLE TO THE TSO STEPLIB CONCATENATION              */
/* G DOES NOT PROMPT FOR A COMMAREA                                  */
/* - RUNS THE PING PROGRAM FOR THE SELECTED ONLINES                  */
/* D, E, AND L WILL PRESENT A PANEL TO CAPTURE THE INPUT DATA FOR    */
/* - THE REQUESTED COMMAND. THIS DATA IDENTIFIES THE COMMAREA AND THE*/
/* - COMMAREA LENGTH. THE COMMAREA MUST BE VALID FOR THE COMMAND     */
/* - REQUESTED (I.E. >CEMT INQUIRE TASK                              */
/* - IS VALID FOR A CEMT OR E LINE COMMAND) NO SYNTAX CHECKING IS    */
/* - PERFORMED.                                                      */
/* - IF L FOR LINK IS SELECTED, THEN ADDITIONAL FIELDS ON THE        */
/* - INPUT DATA PANEL IS REQUESTED. THAT IS, THE TARGET PROGRAM, AND */
/* - A REQUIRED TRANSACTION TO RUN UNDER. THE COMMAREA IS OPTIONAL   */
/* - FOR THE PROGRAM.                                                */
/* - ALL COMMAREA LENGTHS ARE IN RANGE 0 - 32400                     */
/* - THE DATA INPUT PANEL WILL ONLY ALLOW YOU TO ENTER INPUT COMMAREA*/
/* - DATA UP TO 20*60 CHARACTERS. HEX DATA IS NOT POSSIBLE (THIS IS  */
/* - A PLANNED ENHANCEMENT AS TIME PERMITS).                         */
/* -                                                                 */
/* - NOTE - FOR CEDA, TO DISPLAY DETAILS ON AN OBJECT, USE THE VIEW  */
/* -        COMMAND:                                                 */
/* -   CEDA VIEW   GROUP(IPICTCPS) TCPIPS(IPICCTGN)                  */
/* -   CEDA ALTER PROGRAM(KOCOME00) GROUP(OMEGAMON) CONCURRENCY(ANY) */
/* -   CEDA DISPLAY LIST(\@) - '\@' IS SYBOLIC SUB FOR APPLID        */
/* -   THE \@ AND \$ SYMBOLIC SUB FOR APPLID AND JOBNAME RESPECTIVLY */
/* -   THIS FEATURE IS AVAILABLE TO COMMAREA DATA CONTENT            */
/* -     (CEMT CEDA LINK PING)                                       */
/* -                                                                 */
/* PROCESSING INTERACTION IS CONTROLLED BY THE FOLLOWING:            */
/* - (Q)UIET MSGBOX(O)NLY MSGBOX(A)LL (V)ERBOSE                      */
/* - - BUT WILL COLLECT THE OUTPUT AND WRITE IT TO A NEW DSN         */
/* - (Q)UIET WILL RUN THE REQUEST(S) WITHOUT ANY PROGRESS INFORMATION*/
/* - MSGBOX(A)LL PROCESS THE SELECTION, SHOWING A PROGRESS BOX, AND  */
/* - - PRESENTING A FINAL DISPLAY WITH ALL RESULTS.                  */
/* - MSGBOX(O)NLY PRESENTS THE RESULTS FROM EACH INDIVIDUAL ONLINE   */
/* - - WHERE YOU CAN PF3 TO CONTINUE WITH THE NEXT ONLINE, OR CANCEL */
/* - (V)ERBOSE IS A TSO LINE BY LINE DISPLAY                         */
/* AFOLIST ALLOWS THE FOLLOWING PRIMARY COMMAND LINE ENTRIES:        */
/* - CEDA X, CEMT X LINK X PLAY X                                    */
/* - - WHERE X IS ONE OF TEST, ACCP OR PROD                          */
/* -                   @SYS WHICH IS LPAR SYSID ON SYSPLEX           */
/* -       X IS ONE OF OF YOUR SAVED REGION LISTS                    */
/* -       X IS 'CURRLIST' A DYNAMIC LIST CREATED BY MAKE AND APPEND */
/* -                   COMMANDS                                      */
/* - - WHICH SELECTS ALL ONLINES FROM THE RESPECTIVE LIST            */
/* - LISTS? SHOWS ALL OF THE KNOWN LISTS                             */
/* - SHOWLIST X WHERE X IS ONE THE (ABOVE ) KNOWN LISTS              */
/* - MAKE AND APPEND WILL CREATE|RESET/APPEND REGIONS SELECTIONS TO  */
/* -       THE DYNAMIC 'CURRLIST' REGIONS LIST.                      */
/* -       USE 'M' OR 'A' TO SELECT A REGION TO ADD TO CURRLIST      */
/* - PLAY - WILL INVOKE A MSGBOX TO COLLECT YOUR SCRIPT.             */
/* -      - SYNTAX IS NOT VERIFIED                                   */
/*         - IF YOU PLAY A LINK COMMAND, THEN YOU MUST HAVE          */
/*           INCLUDED A MYPROG(XXXXXXXX) VARIABLE  AND               */
/*           OPTIONALY A MYTRANID(YYYY)                              */
/*           OPTIONALY A MYCA(COMMAREA)                              */
/*           OPTIONALY A MYCAL(NNN)                                  */
/*           AFTER LINK PROGRAM(XXXX), THE OTHER VARIABLES IN ANY    */
/*           ORDER.                                                  */
/*   LINK MYPROG(UCEMPING) MYTRANID(UXXX) MYCAL(1016) MYCA(PING)     */
/* - CEMT AND CEDA - SYNTAX REQUIRES THAT YOU FULLY SPELL OUT THE    */
/* -       - SECOND PARAMETER (INQUIRE,SET,EXPAND,VIEW,DISPLAY...)   */
/* -       - SUBSEQUENT MUST BE VALID TO THE CICS COMMAND            */
/* -       - MYCAL IS CODED TO 4096 - PROGRAM CHANGE TO MAKE IT BIGER*/
/* -       - MYTRANID IS CODED AS THE DEFAULT CSMI                   */
/* - RELATED: THE FOLLOWING EXEC CAN BE EXECUTED AS A 'TSO CEM XXX'  */
/*         - AND UTILIZE THE VARIOUS AFOLIST REGIONS LIST VARIABLES  */
/* -       - (INCLUDING THE CURRLIST DYNAMIC LIST)                   */
/* -       - USE CEMHELP XXX FOR SPECIFIC INFORMATION                */
/* -         AFOSDSF - EXECUTE SDSF OPERATOR COMMANDS(S) FOR REGION(S)*/
/* -         AFORDOR - RUN DFHCSDUP COMMND(S) FOR REGION(S)          */
/* -         DSPSDSF - CAPTURE SDSF OUTPUT FOR REGION(S)             */
/* -                                                                 */
/* CEMHELP END                                                       */
 ADDRESS ISPEXEC
 AFOLSTNV='2.0'
 AFOLISNM='AFOLIST'
  "ISPEXEC VPUT (AFOLISNM AFOLSTNV) ASIS"
  PNLLOADED=0
  PLLLOADED=0
  MYPNLIB='TTED.TSK.D.TCEM.ISPPLIB'
  MYPLLIB='TTEP.TSK.E.TCEM.PDSE'
  IF PNLLOADED > 0 THEN SIGNAL GOTMYPNLIB
  IDVAL_CT = 0
 TRYAGN:
  IDVAL=''
  'ISPEXEC QLIBDEF 'ISPPLIB' ID(IDVAL)'
  XC = RC
  IF IDVAL \= '' THEN DO
   IF IDVAL_CT > 1 THEN DO
    SAY 'COULD NOT LIBDEF ISPPLIB. LOOP??'
    RETURN 8
    END
   XDSN=TRANSLATE(IDVAL,"  ",",'")
   IF WORDPOS(MYPNLIB,XDSN) \= 0 THEN SIGNAL GOTMYPNLIB
   CALL EXPLLDEF 'ISPPLIB' MYPNLIB 'STACK' 'QUIET'
   XC=RESULT
   IDVAL_CT = IDVAL_CT + 1
   SIGNAL TRYAGN
   END
  IF IDVAL = '' THEN DO
   STKLIBS=MYPNLIB
   CALL EXPLLDEF 'ISPPLIB' STKLIBS 'STACK' 'QUIET'
   XC=RESULT
   IF RC > 4 THEN DO
    SAY 'COULD NOT LIBDEF ISPPLIB. RC WAS'RC
    RETURN 8
    END
   END
 GOTMYPNLIB:
  PNLLOADED = 1
  IF PLLLOADED > 0 THEN SIGNAL GOTMYPLLIB
   IDVAL_CT = 0
 TRYAGN_ISPL:
   IDVAL=''
   'ISPEXEC QLIBDEF 'ISPLLIB' ID(IDVAL)'
   XC = RC
   IF IDVAL \= '' THEN DO
    IF IDVAL_CT > 1 THEN DO
     SAY 'COULD NOT LIBDEF ISPLLIB. LOOP??'
     RETURN 8
     END
    XDSN=TRANSLATE(IDVAL,"  ",",'")
    IF WORDPOS(MYPLLIB,XDSN) \= 0 THEN SIGNAL GOTMYPLLIB
    CALL EXPLLDEF 'ISPLLIB' MYPLLIB 'STACK' 'QUIET'
    XC=RESULT
    IDVAL_CT = IDVAL_CT + 1
    SIGNAL TRYAGN_ISPL
    END
   IF IDVAL = '' THEN DO
    CALL EXPLLDEF 'ISPLLIB' MYPLLIB 'STACK' 'QUIET'
    XC=RESULT
    IF XC > 4 THEN DO
     SAY 'COULD NOT LIBDEF ISPLLIB. RC WAS'RC
     RETURN 8
     END
    END
 GOTMYPLLIB:
    PLLLOADED = 1
 XC = 0
LGP1:
 CALL GETCPU1
 XC=RESULT
 IF XC ^= 0 THEN SIGNAL EXITRC8
 "ISPEXEC VGET (CURGRP CURCPUG) PROFILE"
 IF RC ^= 0 THEN SIGNAL EXITRC8
GOTCPUG:
 L_CPUG=LENGTH(CURCPUG)
 HOSTLIST=''
 DO I = 1 TO L_CPUG
  /* H = 'CPUHOST'SUBSTR(CURCPUG,I,1) */
  TH = SUBSTR(CURCPUG,I,1)||'SYS'
  INTERPRET TH'=""'
  HOSTLIST = HOSTLIST||" "TH
  END
 SELTYP=''
 /* CALL AFOFLD TO LOAD THE AFOFILE AND FIND THE REQUIRED VARIABLE */
 /*  META DATA : NAME OFFSET ANAD LENGTH. RETURN THIS INFO         */
 DFTVARS='MYAPLID MYCOLDJ MYCPU MYREL MYTYP'
 HLDVARS=DFTVARS
 THLDVARS=''
 HLDTMP=''
 CALL AFOFLD DFTVARS
 XC = RESULT
 PULL SRTVARS
 /* SAY SRTVARS */
 IF XC ^= 0 THEN SIGNAL EXITRC8
 /* SETLBL= 1     */   /* USED TO RETURN TO SETLBL1 */
 HLDLIT=''
 H_SRTVARS=SRTVARS
 CALL SETUPVAR
 H_HLDLIT=HLDLIT
SETRET1:
/* CHECK TO SEE IF AFOPER SELECTION VARIABLES WERE PROVIDED ON THE   */
/* COMMAND INVOKATION. IF SO, THEN FIND THE META DATA FOR THESE.     */
/* IF NONE, THEN USE THE DEFAULT LIST                                */
/* TRACE I */
 ARG SRTVARS
 I_SRTVARS=SRTVARS
 IF SRTVARS='' THEN SIGNAL USEDFT_VARS
/* GOT OVERRIDES. IF '?' OR 'INPUT' THEN PROMPT FOR SELECTION CRITRIA*/
 IF SRTVARS='?' | SRTVARS = 'INPUT' THEN DO
  SELTYP='INPUT'
  SELSTR = ''
  "ISPEXEC VPUT (SELSTR) ASIS"
  CALL AFOFLDS SELTYP
  XC=RESULT
/*IF XC ^= 0 THEN SIGNAL USEDFT_VARS */
  "ISPEXEC VGET (SELSTR) ASIS"
  PULL SRTVARS
  IF SELSTR = '' THEN SIGNAL USEDFT_VARS
  IF SRTVARS = '' THEN SIGNAL USEDFT_VARS
  END
  ELSE DO
  SELSTR = SRTVARS
  END
 THLDVARS=''
DOPARSE:
/* WE NEED 3 REQUIRED VARS: MYAPLID MYCPU AND MYTYP. INSURE THE LIST */
/* INCLUDES THESE IN THE SELECTION CRITERIA                      */
/* WARNING!!! MYAPLID HAS TO BE FIRST                            */
 SELSTR = 'MYAPLID '||SELSTR
 XC=WORDPOS('MYAPLID',SELSTR,2)
 IF XC \= 0 THEN SELSTR=DELWORD(SELSTR,XC,1)
 IF WORDPOS('MYCPU',SELSTR) = 0 THEN SELSTR=SELSTR||' MYCPU'
 IF WORDPOS('MYTYP',SELSTR) = 0 THEN SELSTR=SELSTR||' MYTYP'
 /* PULL */
 CALL AFOFLD SELSTR
 XC = RESULT
 PULL SRTVARS
 IF XC > 8 THEN SIGNAL EXITRC12
 IF XC = 8 THEN SIGNAL BAD_PARM
 IF SRTVARS = '' THEN SIGNAL USEDFT_VARS
 THLDVARS=''
DOSET2:
 /* SETLBL= 2     */   /* USED TO RETURN TO SETLBL2 */
 HLDLIT=''
 HLDVARS = SELSTR
 CALL SETUPVAR
 SIGNAL SETRET2
USEDFT_VARS:
 HLDVARS = DFTVARS
 HLDLIT=H_HLDLIT
 SRTVARS=H_SRTVARS
SETRET2:
 "ISPEXEC VGET (MYAFOIND SVAFO0) SHARED"
 IF RC = 0 THEN SIGNAL AFLD
 CALL AFOLOAD1
 "ISPEXEC VGET (MYAFOIND SVAFO0) SHARED"
 IF RC ^= 0 THEN SIGNAL EXITRC8
AFLD:
 "ISPEXEC VGET (GPAFO0) SHARED"
 IF RC ^= 0 THEN SIGNAL LGP
 IF GPAFO0 ^= 0 THEN SIGNAL GPLD
LGP:
 TLST=''
 ALST=''
 PLST=''
 J = 0
 T = 0
 A = 0
 P = 0
 MYCB=MYCPU.B
 MYCL=MYCPU.L
 MYTB=MYTYP.B
 MYTL=MYTYP.L
 J = 0
 DO I = 1 TO SVAFO0
  INTERPRET '"ISPEXEC VGET (SVAFO'||I') SHARED"'
  INTERPRET 'TMP=SVAFO'||I
  MYCPU=SUBSTR(TMP,MYCB,MYCL)
  IF POS(MYCPU,CURCPUG) = 0 THEN ITERATE
  MYTYP=SUBSTR(TMP,MYTB,MYTL)
  TA=SUBSTR(TMP,2,8)
  /* INTERPRET 'CPUHOST'MYCPU' = CPUHOST'MYCPU'||" "||STRIP(TA,"B")' */
  INTERPRET MYCPU'SYS = 'MYCPU'SYS||" "||STRIP(TA,"B")'
  ST = MYTYP
  IF POS(ST,'EDTAP') = 0 THEN ST='T'
  IF ST = 'E' | ST = 'D' THEN ST = 'T'
  INTERPRET ST '= 'ST' + 1'
  INTERPRET ST"LST = "ST"LST||STRIP(TA,'B')||' '"
  B = 'SRC'||ST||'.'
  INTERPRET 'TMP = 'HLDLIT
  INTERPRET B||ST' = LEFT(TMP,24)'
  J = J + 1
  TRACE OFF
  END
 TEST=TLST
 ACCP=ALST
 PROD=PLST
 DROP TLST ALST PLST
 'ISPEXEC VPUT (TEST ACCP PROD) ASIS'
 K = MAX(T,A,P)
 IF K = 0 THEN SIGNAL EXITRC12
/*  TRACE I */
  HOSTLIST = STRIP(HOSTLIST,'B')
  'ISPEXEC VPUT ('HOSTLIST') ASIS'
  CALL AFOCTGJL
  HOSTLIST=HOSTLIST||' CTGDEVJL CTGTSTJL CTGPRDJL'
  'ISPEXEC VPUT (HOSTLIST) ASIS'
/*  TRACE OFF */
 PUTSTR=''
 SP24=COPIES(' ',24)
 DO I = 1 TO K
  IF I > T THEN ST = SP24
   ELSE ST = SRCT.I
  IF I > A THEN SA = SP24
   ELSE SA = SRCA.I
  IF I > P THEN SP = SP24
   ELSE SP = SRCP.I
  INTERPRET 'AFOL'||I||'= ST SA SP'
  PUTSTR=PUTSTR||' AFOL'||I
  END
 PUTSTR=STRIP(PUTSTR,'L')
 MYTYP='AFOL'
 MYTYTOT=K
 DSEMSG = THLDVARS
 "ISPEXEC VPUT (MYTYP MYTYTOT DSEMSG) ASIS"
 "ISPEXEC VPUT ("PUTSTR") ASIS"
GPLD:
 AUTOSAVE='N'
 "ISPEXEC VPUT (AUTOSAVE) ASIS"
 CALL DSPAFODO
 XC = RESULT
 SIGNAL EXITIT
BAD_PARM:
  XC = 8
  SAY 'RC' XC 'INVALID PARAMETER NOT RECOGNISED.'I_SRTVARS
 SIGNAL EXITIT
EXITRC8:
  XC = 8
  SAY 'RC' XC 'COULD NOT ESTABLISH CPU VARIABLES. SORRY.'
 SIGNAL EXITIT
EXITRC12:
  SAY 'NO RECORDS ON AFOPER FILE MEET CRITERIA'
  XC = 12
 SIGNAL EXITIT
EXITRC4:
  XC = 4
  SAY 'RC' XC 'COULD NOT ESTABLISH CPU VARIABLES. SORRY.'
 SIGNAL EXITIT
EXITIT:
 RETURN XC
/* SUBROUTINE TO STRIP AND SETUP AFO VAR SELECTION */
SETUPVAR:
  MWD=WORDS(HLDVARS)
  K = 0
  DO WHILE(SRTVARS^='')
   K = K+1
   IF K > MWD THEN RETURN 4
   HLDSTR=WORD(HLDVARS,K)
   PARSE VAR SRTVARS TMPSTR '#' SRTVARS
   PARSE VAR TMPSTR TL TB TE TLIT
   IF WORDPOS(HLDSTR,THLDVARS) ^= 0 THEN ITERATE
    ELSE THLDVARS = THLDVARS||' '||HLDSTR
   INTERPRET HLDSTR'.L = 'TL
   INTERPRET HLDSTR'.B = 'TB
   LTL=TL+1
/* HLDLIT IS BEING SET UP TO BE EXECUTED IN A INTERPRET LATER */
/*  NOTICE THAT THE VAR 'TMP' IS ACTUALLY SET UP LATER. THEN THIS */
/*  HLDLIT MAKES SENSE                                        */
   HLDLIT=HLDLIT||'LEFT(SUBSTR(TMP,'TB','TL'),'LTL')'
   END
  RETURN 0
  EXIT
###END AFOLIST
$$$BEG GETSIT
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA GETSIT   - RETURNS ISPF VAR GETSITLS WITH SIT ENV INFO  */
 /* CEMHELP GETSIT   - ISPF BASED. RETURNS THE SIT SUFFIX AND       */
 /* CEMHELP          - ANY OTHER TABLES FROM START MEMBER           */
 /* CEMHELP          - REQUIRES 3 PARMS                             */
 /* CEMHELP          -  REGION APPLID                               */
 /* CEMHELP          -  REGION 3 DIGIT RELEASE                      */
 /* CEMHELP          -  REGION DTAP                                 */
 /* CEMHELP          - RETURNS 0 AND ISPF VAR GETSITLS WITH ALL     */
 /* CEMHELP          -  TABLES IN STARTUP AND ENVRSU AND STARTMBR   */
 /* CEMHELP          - OR RETURN NON ZERO FOR INVALID DATA          */
 /* CEMHELP          -                                              */
 /* CEMHELP END                                                     */
  ADDRESS TSO
 /* TRACE ?I */
  ARG MYAPLID MYREL MYTYP
  /* IF MYAPLID = 'CGAA' THEN TRACE I */
  XC = 0
  IF MYAPLID = '' | MYREL = '' | MYTYP = '' THEN SIGNAL BADARG
  IF MYTYP = 'E' THEN MYTYP = 'D'
  SRGNPML = 'TTE'||MYTYP||'.TSK.F.R'||MYREL||'.'||MYAPLID||'.PARMLIB('
  SPRCLIBD= 'TTED.TSK.G.PROCLIB('
  SPRCLIBP= 'TTEP.TSK.G.PROCLIB('
  MYSETPFX = 'S'||SUBSTR(MYREL,1,2)||MYTYP
  IF MYTYP = 'A' THEN MYSETPFZ = 'S'||SUBSTR(MYREL,1,2)||'T'
   ELSE MYSETPFZ = MYSETPFX
  IENVIN = MYSETPFX||'ENV)'
  SRGNENV=SRGNPML||IENVIN
  RS = SYSDSN("'"SRGNENV"'")
  IF RS = 'OK'  THEN SIGNAL READENV
  IF MYTYP \= 'D' THEN SIGNAL TRYTTEP
  SRGNENV=SPRCLIBD||IENVIN
  RS = SYSDSN("'"SRGNENV"'")
  IF RS = 'OK'  THEN SIGNAL READENV
 TRYTTEP:
  SRGNENV=SPRCLIBP||IENVIN
  RS = SYSDSN("'"SRGNENV"'")
  IF RS \= 'OK'  THEN SIGNAL BADENV
 READENV:
  "ALLOC FI(I) DA('"SRGNENV"') SHR"
  "EXECIO * DISKR I (STEM ENV. FINIS"
  "FREE FI(I)"
  ENVRSU = ''
  /* // INCLUDE MEMBER=S54D1809 */
  DO I = 1 TO ENV.0
   TMP = STRIP(ENV.I,'B')
   IF SUBSTR(TMP,1,3) = '//*' THEN ITERATE
   WP = WORDPOS('INCLUDE',TMP)
   IF WP = 0 THEN ITERATE
   PP = POS('MEMBER=',TMP)
   IF PP = 0 THEN ITERATE
   TMP = WORD(SUBSTR(TMP,PP+7),1)
   IF POS(MYSETPFX,TMP) = 0 THEN DO
    IF MYTYP = 'A' THEN DO
     IF POS(MYSETPFZ,TMP) = 0 THEN ITERATE
     END
    END
   RSUVAL=SUBSTR(TMP,5)
   IF DATATYPE(RSUVAL,'W') = 0 THEN ITERATE
    ELSE DO
    ENVRSU = TMP
    LEAVE I
    END
   END
  IF ENVRSU = '' THEN SIGNAL BADRSU
  DROP ENV.
 /* TRACE ?I */
  IENVIN  = ENVRSU||')'
  SRGNENV=SRGNPML||IENVIN
  RS = SYSDSN("'"SRGNENV"'")
  IF RS = 'OK'  THEN SIGNAL READRSU
  IF MYTYP \ = 'D' THEN SIGNAL RSUTTEP
  SRGNENV=SPRCLIBD||IENVIN
  RS = SYSDSN("'"SRGNENV"'")
  IF RS = 'OK'  THEN SIGNAL READRSU
 RSUTTEP:
  SRGNENV=SPRCLIBP||IENVIN
  RS = SYSDSN("'"SRGNENV"'")
  IF RS \= 'OK'  THEN SIGNAL BADRSU
 READRSU:
  "ALLOC FI(I) DA('"SRGNENV"') SHR"
  "EXECIO * DISKR I (STEM ENV. FINIS"
  "FREE FI(I)"
  /* // INCLUDE MEMBER=STARTSYS */
  STARTMBR = ''
  DO J = 1 TO ENV.0
   TMP = STRIP(ENV.J,'B')
   IF SUBSTR(TMP,1,3) = '//*' THEN ITERATE
   WP = WORDPOS('INCLUDE',TMP)
   IF WP = 0 THEN ITERATE
   PP = POS('MEMBER=',TMP)
   IF PP = 0 THEN ITERATE
   TMP = WORD(SUBSTR(TMP,PP+7),1)
   IF POS('START',TMP) = 0 THEN ITERATE
    ELSE DO
    STARTMBR=TMP
    LEAVE J
    END
   END
  IF STARTMBR = '' THEN SIGNAL BADSTART
  DROP ENV.
  IENVIN  = STARTMBR||')'
  SRGNENV=SRGNPML||IENVIN
  RS = SYSDSN("'"SRGNENV"'")
  IF RS \= 'OK'  THEN SIGNAL BADSTARTMBR
  "ALLOC FI(I) DA('"SRGNENV"') SHR"
  "EXECIO * DISKR I (STEM ENV. FINIS"
  "FREE FI(I)"
  /* // SET        SIT=DP       */
  /* // SET        MCT=DP       */
  /* // SET        SRT=EP       */
  TBLLST=''
  VALLST=''
  DO J = 1 TO ENV.0
   TMP = STRIP(ENV.J,'B')
   IF SUBSTR(TMP,1,3) = '//*' THEN ITERATE
   WP = WORDPOS('SET',TMP)
   IF WP = 0 THEN ITERATE
   TBL=WORD(TMP,WP+1)
   EP=POS('=',TBL)
   IF EP = 0 THEN ITERATE
   PARSE VAR TBL TBL '=' VAL
   TBLLST = TBLLST||' '||TBL
   VALLST = VALLST||' '||VAL
   END
  IF WORDPOS('SIT',TBLLST) = 0 THEN DO
   TBLLST = TBLLST||' SIT'
   VALLST = VALLST||' -'
   END
  WDS = WORDS(TBLLST)
  DO I = 1 TO WDS
   TMP = WORD(TBLLST,I)
   VAL = WORD(VALLST,I)
   INTERPRET TMP" = '"VAL"'"
   END
 /*TRACE ?I */
  GETSITLS=TBLLST||' STARTMBR ENVRSU'
  ADDRESS ISPEXEC 'VPUT (GETSITLS 'GETSITLS') ASIS'
  IF RC \= 0 THEN SIGNAL BADPUT
  ZEDSMSG = 'SIT FOUND'
  ZEDLMSG = 'SIT VAR LIST IN GETSITLS'
  SIGNAL WRITIT

 BADARG:
  ZEDSMSG = 'BAD ARGUMENT'
  ZEDLMSG = 'INVALID ARG WAS PROVIDED'
  XC = 4
  SIGNAL WRITIT
 BADENV:
  ZEDSMSG = 'BAD ENV MBR'
  ZEDLMSG = 'ENV MBR NOT FOUND OR INVALID'
  XC =  8
  SIGNAL WRITIT
 BADRSU:
  ZEDSMSG = 'BAD RSU MBR'
  ZEDLMSG = 'RSU MBR NOT FOUND OR INVALID'
  XC =  12
  SIGNAL WRITIT
 BADSTART:
  ZEDSMSG = 'BAD START MBR'
  ZEDLMSG = 'START MBR NOT FOUND OR INVALID'
  XC = 16
  SIGNAL WRITIT
 BADSTARTMBR:
  ZEDSMSG = 'NO TABLES FOUND'
  ZEDLMSG = 'START MBR DID NOT HAVE SIT'
  XC =  20
  SIGNAL WRITIT
 BADPUT:
  ZEDSMSG = 'ISPF VAR PUT FAILED'
  ZEDLMSG = 'ISPF VAR PUT FAILED'
  XC = 24
  SIGNAL WRITIT
 WRITIT:
  'ISPEXEC SETMSG MSG(ISRZ000)'
  RETURN  XC
###END GETSIT
$$$BEG DSPAFOH0
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA DSPAFOH  - SUBROUTINE TO AFOLIST. SEE AFOLIST           */
 /* CEMHELP DSPAFOH  - SUBROUTINE TO AFOLIST. SEE AFOLIST           */
 /* CEMHELP          - CALLED BY DSPAFOD                            */
 /* CEMHELP          - replaces  DSPAFOC                            */
 /* CEMHELP          - calls:address link "RXCNCLN2 RX_CNC_CH_NM"   */
 /* CEMHELP          - V3.0 - CNC ENABLED VERSION                   */
 /* CEMHELP          - V3.1 - FIXED SUBSYM PROBLEM                  */
 /* CEMHELP          - V3.2 - ADD LOGIC FOR CN DATATYPE             */
 /* CEMHELP END                                                     */
 /* this is the new interface to the exci function                  */
 /*    based on successful testing of trxcncl2                      */
 /* 001703     NEED TO ACCUMULATE BIT DATA TO A DIFFERENT MYA VAR   */
 /*                                                                 */
 /*  backed up to dspafoh# prior to adding excis0 logic             */
 /*                                                                 */
 /* TRACE I */
 /* ALWAYS RETURN THIS VAR WITH A QUICK NOTE SUCCESS/FAILURE */
 /* TRACE ?I */
  ADDRESS ISPEXEC
  'ISPEXEC CONTROL ERRORS RETURN'
  DSPAFOH_V='3.2'
  /*                                                                 *\
  |*  EXPECT THE FOLLOWING ISPF VARS TO BE SET                       *|
  |*   MYCMD - CEMT,CEDA,PING,PLAY,LINK                              *|
  |*         - BUT THIS IS NOT NECESSIARLY A DRIVER FOR THE CNC LOGIC*|
  |*         -  BECAUSE AS WE PROMPT FOR CN NAMES, EACH MAY BE DIFF  *|
  |*   MYAPLID - ONE TO MANY REGIONS                                 *|
  |*                                                                 *|
  \*                                                                 */
  'ISPEXEC VGET (MYCMD MYAPLID) ASIS'
  LASTCC=RC
  IF LASTCC  \= 0 THEN DO
   RETURN 20
   END
  /*                                                                 *\
  |* test tsolib for excilib allocation                              *|
  \*                                                                 */
  CALL EXPLTSOL 'EXCILIB'
  XC=RESULT
  IF XC  \= 0 THEN DO
   RETURN 18
   END
 /*   REMOVE THIS AT SOME TIME AFTER TESTING  */
/*CALL DO_TBL_CLO */
 /*                                           */
  MSGOUT_NOTE='INITIAL'
  /* ALWAYS RETURN THESE VARS: AS A STEM VARIABLE */
  /*  WITH THE APPLID AS THE PREFIX, AND THE FOLLOWING AS THE SUFFIX */
  TECCMDS='CEMT CEDA PING PLAY'
  RXCNCLN2_RSP_LOG='INITIAL'
  RETURN_CN_LIST=''
  /* REQUIRED RX VARS ON EACH CALL TO THE EXCI INTERFACE PROGRAM */
  PROGRAM_NM='UCEMPINR'
  APPLID_NM='CGE5'
  TRANID_NM='UXXX'
  /* AND THEN WE PROVIDE A SINGLE RX VAR AS THE SINGLE PARM TO       *\
  |*   THE PROGRAM IN WHICH WE ISSUE THE RX CMD:                     *|
  |* ADDRESS LINK 'RXCNCLN2 RXVARPARM'                               *|
  |* THE RXVARPARM IS EITHER                                         *|
  |*   COMMAREA  - YEP THE ACTUAL 'COMMAREA' LITERAL                 *|
  |*   OR                                                            *|
  |*   SOME_CHAN_NAME - A RX VAR WHICH DEFINES A CHANNEL NAME        *|
  |*             - AND WHO'S CONTENTS IS A COMMA SEPARATED LIST      *|
  |*             - OF CONTAINERS (WHICH ARE RX VARS WITH THE ACTUAL  *|
  |*             - CN DATA)                                          *|
  |*   FOR EACH, YOU CAN OPTIONALLY CODE ADDITIONAL RX STEM VARS     *|
  |*    WHICH HAVE THE 'COMMAREA' OR SOME_CONT_NAME WITH A '.L'      *|
  |*    SUFFIX. THIS IS USED TO CONVEY A LENGTH FOR THE CA OR CN     *|
  |*   AND FOR CN VARS, THE SAME SOME_CONT_NAME WITH A '.T' CAN      *|
  |*    OPTIONALLY CONVEY THE CN DATATYPE                            *|
  |*                                                                 *|
  |*                                                                 *|
  |*                                                                 *|
  \*                                                                 */
  /*  THE MYCMD AND MYAPLID ISPF PARMS PROVIDE SOME NECESSARY  INFO  *\
  |*  USE PANEL TO INDICATE COMMAREA OR CHANNEL                      *|
  \*                                                                 */
   RETRYCT = 0
   ZCMD=''
   MYSC='PAGE'
   EXECSEL = 'DSPAFOH'
   HYPROG = PROGRAM_NM
   HYDSRC = 'COMMAREA'
   HYFUNC1 = 'A'
   VALFUNC1='E A'
   VALFUNC = 'EACH ALL'
   AUTOSAVE = 'N'
   HYTRANID = TRANID_NM
   DSEMSG = 'INDICATE YOUR DATA SOURCE'
   "ISPEXEC ADDPOP ROW(1) COLUMN(10)"
GET_CA_OR_CHANNEL:
   'ISPEXEC DISPLAY PANEL (DSPAFOSL)'
   LASTCC=RC
  IF LASTCC  \= 0 THEN DO
   RETURN 20
   END
/*    TRACE I */
   CMD_1 = WORD(CMD,1)
   IF CMD = 'END' THEN SIGNAL GOT_DATA_SRC
   IF LASTCC = 8 THEN SIGNAL GOT_DATA_SRC
   IF CMD = 'CANCEL' | CMD = 'ABORT' THEN DO
    'ISPEXEC REMPOP'
    RETURN 8
    END
   ZCMD=''
   DSEMSG = 'PRESS PF3 TO CONTINUE'
GOT_DATA_SRC:
  TMP = HYDSRC
  PROGRAM_NM = HYPROG
  IF LENGTH(PROGRAM_NM) > 7 THEN DO
   IF WORDPOS(MYCMD,TECCMDS) > 0 THEN DO
   IF SUBSTR(PROGRAM_NM,1,7) = 'UCEMPIN' THEN HYTRANID = 'CSMI'
   END
   END
  TRANID_NM = HYTRANID
  IF AUTOSAVE \= 'Y' THEN AUTOSAVE = 'N'
   ELSE DO
   CALL SET_ODSN
   IF XC \= 0 THEN AUTOSAVE = 'N'
   END
  UPPER HYFUNC1
  MYFUNC1 = HYFUNC1
  IF MYFUNC1 \= 'E' THEN MYFUNC1 = 'A'
  RX_RQ_DATA = ''
  RX_RQ_DATA.L = '0'
  RX_RQ_DATA.T = 'CHAR'
  CNCCHNM = HYDSRC
  CN_CMD = CMD_1
  H_CNTO = ''
  H_CNTY = 'BIT'
  H_LR1LNG = '0'
  H_CNSTRIP = 'Y'
  LR1 = ''
  ZCMD = ''
  CALL DORESET HYDSRC
  /* TEST FOR COMMAREA OR anyname_CH CHANNEL NAME */
  IF HYDSRC = 'COMMAREA' THEN DO
   MAXRQL=32400
   CALL GET_COMMAREA
   IF XC \= 0 THEN DO
 MSGBOX 'ABORT OR CANCEL ENCOUNTERED GETTING THE COMMAREA DATA. BYE'
    'ISPEXEC REMPOP'
    RETURN XC
    END
 /* the RX var passed to the RXCNCLN2 program is either the word   *\
 |*  'COMMAREA' or a channel name. The RX var RX_CNC_CH_NM will    *|
 |*  contain one those two options.                                *|
 |*  address LINK 'RXCNCLN2 RX_CNC_CH_NM'                          *|
 |*  where RX_CNC_CH_NM contains the 'list' of request elements    *|
 |*   a list of CN names, or COMMAREA                              *|
 |*   each element is a RX var of that name, in which is the req   *|
 |*  so RX_CNC_CH_NM = 'COMMAREA'                                  *|
 |*  and RX var commarea=RX_RQ_DATA                                *|
 \*   which is the commearea data collected                        */
   RX_CNC_CH_NM = HYDSRC  /* SET THE RX PARM TO 'COMMAREA' AS THE  */
                          /*     RX var containing the list of req */
                          /*     variable names; in this case only */
                          /*     the one RX var named commarea     */
   CNLST = 'RX_RQ_DATA'   /* now put the 'list' of RX req var names*/
                          /*     into the RX var holding that list */
                          /* for commarea, ther is only one RX req */
   /* Later, the var named by RX_CNC_CH_NM will be set to 'CNLST'  */
   SIGNAL DONE_DATA_SRC
   END
 /* NOT COMMAREA                */
  /* HERE WE HAVE A CHANNEL NAME */
  /* HERE WE HAVE A CHANNEL NAME */
 GOT_CHANNEL_SRC:
 /* TRACE I */
   CNCCHNM = HYDSRC   /* was already set above - here to remind us */
/*RX_CNC_CH_NM = LEFT(HYDSRC,16,' ')    SET THE RX PARM TO THE     */
  RX_CNC_CH_NM = STRIP(HYDSRC,'T')   /* SET THE RX PARM TO THE     */
                                     /* CHANNEL NAME               */
  CN_CT = 0
  CNLST=''
  MAXRQL=2000000
  CALL GET_CN_SRC_DATA RX_CNC_CH_NM

 DONE_CN_LOOP:
  IF XC > 0 THEN SIGNAL DO_CANCEL
/*RX_RQ_DATA = CNLST
  CNLST = 'RX_RQ_DATA' */ /* now put the 'list' of RX req var names*/
  CN_CT = CNLSTCNT
  IF CNLSTCNT  < 1 THEN DO
   CALL GO_OR_NO  'YOU HAVE ENTERED ZERO CONTAINERS. OK (CONTINUE)  '||,
    ' OR CANCEL TO ABORT'
   IF RC > 0 THEN SIGNAL DO_CANCEL
   END
   ELSE DO
   CNLST=STRIP(CNLST,'B')
   END
 DONE_DATA_SRC:
    /*                                                              *\
    |* note: the RX_CNC_CH_NM is a var that we pass to pgm RXCNCLN2 *|
    |*  that var contents is either 'COMMAREA' or a channel name    *|
    |*  is either case: that value content is used as a name of the *|
    |*  RX var, in which a list of RX request var names define the  *|
    |*  set of RX reqest vars with data.                            *|
    |*  for commarea:                                               *|
    |*   RX_CNC_CH_NM = 'COMMAREA'                                  *|
    |*     and interpret resolves to COMMAREA='CNLST'               *|
    |*         for which CNLST='RX_RQ_DATA'                         *|
    |*  for CnC:                                                    *|
    |*   RX_CNC_CH_NM = 'Some_Channel__NM'                          *|
    |*     and interpret resolves to Some_Channel__NM='CNLST'       *|
    |*         for which CNLST='Cn_one,CN_2,CN_nn'                  *|
    |*   RX_RQ_DATA is the commarea data                            *|
    |*   and each CONTAINER NAME                                    *|
    |*   is utilized via an INTERPRET                               *|
    |*     INTERPRET rx_cnc_cn_nm' = rx_rq_data'                    *|
    |*       where the rx_cnc_cn_nm = 'Cn_one'    etc               *|
    |*             and rx_rq_data= 'is the cn data contents'        *|
    |*             as each new CN is created as a RX var            *|
    \*                                                              */
  APLCNT = WORDS(MYAPLID)
  APLCUR = 0
  APLID_BD  = 0
  APLID_GD  = 0
  /*                                                                 *\
  |* ACCUMULATE 3 RESPONSE STRINGS FOR PRESENTATION (OPTION)         *|
  \*                                                                 */
  EXCI_NOTE = 'ALL EXCI CALLS SUCCESSFUL'
  MSGNOTE_TEXT = ''
  RSPNOTE_TEXT = ''
  RETNOTE_TEXT = ''
  X15='15'X
  XFF='FF'X
  ERRMSG = ''
  I=0
  PRM_RC = 0
  DLM='(<{[='
  MDLM=')>}] '
  #DMM=LENGTH(DLM)
  REPWDS='\@ \$ \! \\'  /* SUBSTITUTE \ APPLID JOBNAME */
  RW_CT = WORDS(REPWDS)
  /*                                                                 *\
  |* HERE WE GO;                                                     *|
  |* EACH APPLID IS PROCESSED. THE COMMAREA OR CONTAINER REQUEST DATA*|
  |*  IS NEVER OVERWRITTEN BY THE EXCI CALL; THE COBOL PROGRAM WILL  *|
  |*  SEND RESPONSE DATA BACK WITH A APPLID_NM_ PREFIX VALUE         *|
  |* THIS ALLOWS THE REQUEST DATA TO REMAIN  UNALTERED AND           *|
  |*% THE RESPONSE DATA IS IN APPLID_NM SPECIFIC RESPONSE RX VARS    *|
  |* ADDRESS LINK 'RXCNCLN2 RXVARPARM'                               *|
  |* THE RXVARPARM IS EITHER                                         *|
  |*  'COMMAREA' - YEP THE ACTUAL 'COMMAREA' LITERAL                 *|
  |*   OR                                                            *|
  |*  'SOME_CHAN_NAME'- A RX VAR WHICH DEFINES A CHANNEL NAME        *|
  |*   USE AS A RX VAR WHO'S CONTENTS IS A COMMA SEPARATED LIST      *|
  |*             - OF CONTAINERS (WHICH ARE RX VARS WITH THE ACTUAL  *|
  |*             - CN DATA)                                          *|
  |*   FOR EACH, YOU CAN OPTIONALLY CODE ADDITIONAL RX STEM VARS     *|
  |*    WHICH HAVE THE 'COMMAREA' OR SOME_CONT_NAME WITH A '.L'      *|
  |*    SUFFIX. THIS IS USED TO CONVEY A LENGTH FOR THE CA OR CN     *|
  |*   AND FOR CN VARS, THE SAME SOME_CONT_NAME WITH A '.T' CAN      *|
  |*    OPTIONALLY CONVEY THE CN DATATYPE                            *|
  \*                                                                 */
  INTERPRET RX_CNC_CH_NM' = CNLST'
  JOBLS='N'
  "ISPEXEC VGET (AFOJOBLS AFOAPLLS) SHARED"
  IF RC = 0 THEN JOBLS='Y'
/* OK HERE WE GO */
  IF MYFUNC1 = 'A' | MYFUNC1 = 'Q' THEN DO
   /* trace i */
   MSGLOCK='Y'
   MSGSTAT='CONTPOP'
   MSGBOXTX='STARTING: PROCESSING ALL APPLIDS...'
   "ISPEXEC  VPUT (MSGBOXTX) ASIS"
   "ISPEXEC  VPUT (MSGLOCK MSGSTAT) ASIS"
   CALL MSGBOX
   END
   ELSE DO
   'ISPEXEC REMPOP'
   END
  GOT_SYMSUB = '?'
  J = 0
 TOPAPLLOP:
  APLCUR = APLCUR + 1
  IF APLCUR > APLCNT THEN DO
  /*   WHEN WE ARE DONE:                                             *\
  |* WHEN MYFUNC1=E THEN EACH RESPONSE HAS ALREADY BEEN PRESENTED    *|
  |* WHEN MYFUNC1\=E THEN PRESENT ALL ACCUM RESPONSE DATA            *|
  \*                                                                 */
   IF MYFUNC1 = 'E' THEN SIGNAL FINEXCI
   ELSE SIGNAL FINAPLLOP
   END
  /*                                                                 *\
  |* GET THE APPLID FOR EXCI CALL, AND SET UP THE PROGRAM PARM       *|
  |*  RX_CNC_CH_NM EQUAL TO THE LITERAL 'CNLST'                      *|
  |* THE RX VAR CNLST HOLDS COMMAREA OR A LIST OF CN NAMES           *|
  |* ACTUAL REQUEST DATA IS IN RX VARS: COMMAREA OR THE CN NAME      *|
  \*                                                                 */
  APPLID_NM = WORD(MYAPLID,APLCUR)
  APL_STM.APPLID_NM=APL_STM.APPLID_NM||':START:'||APPLID_NM||':'||XFF
  MSGOUT_NOTE = 'INITIAL'
  RXCNCLN2_RSP_LOG='INITIAL'
  RETURN_CN_LIST = ''
  /*                                                                 *\
  |* Perform the symbols substitution in the request data            *|
  |* If jobls is y, then we can do substitution                      *|
  |*     \@ WILL SUBSTITUTE APPLID                                   *|
  |*     \$ WILL SUBSTITUTE JOBNAME                                  *|
  |*     \! WILL SUBSTITUTE PARM NAMED S#PARM                        *|
  |*     \\ WILL SUBSTITUTE A SINGLE BACK SLASH                      *|
  |*        AND NOT INTERPRET THIS FURTHER                           *|
  |*  call sr: sr runs substitution logic, once                      *|
  |*  for each request data in the cnlst of commarea or cn           *|
  \*                                                                 */
  /* NEW CODE V3.1                                                   *\
  |*                                                                 *|
  |* GOT_SYMSUB INITIALLY SET TO '?', SO WE ALWAY ENTER ONCE         *|
  |* ON FIRST PASS, SET GOT_SYMSUB TO 'N'                            *|
  |* IF WE FIND A SUBSITUTION, THEN THE GOT_SYMSUB IS 'Y' AND        *|
  |*  WE ALWAYS PROCESS ADDITIONAL APPLID FROM THE BKUP_X DATA SRC   *|
  |*  OTHERWISE, WITHOUT ANY SUBSITUTIONS, THE GOT_SYMSUB IS 'N'     *|
  |*  AND WE NEVER ENTER THIS LOGIC AGAIN                            *|
  \*                                                                 */
  /* TRACE I */
  IF JOBLS = 'Y' THEN DO
   IF GOT_SYMSUB \= 'N' THEN DO
    APLPOS=WORDPOS(APPLID_NM,AFOAPLLS)
    IF APLPOS = 0 THEN SIGNAL NOSUB_CA
    JOBNM=WORD(AFOJOBLS,APLPOS)
    IF GOT_SYMSUB = '?' THEN GOT_SYMSUB = 'N'
  /* NEW CODE V2 */
  /* TRACE I */
    S#APLID = APPLID_NM
    IF LENGTH(S#APLID) < 7 THEN INTERPRET "T#PARM = 'S#"||S#APLID||"'"
     ELSE INTERPRET "T#PARM = 'S#"||SUBSTR(S#APLID,3)||"'"
    INTERPRET T#PARM " = S#VALUE"
    'ISPEXEC VGET ('T#PARM') ASIS'
    IF RC > 0 THEN S#PARM = APPLID_NM
     ELSE INTERPRET 'S#PARM = 'T#PARM
  /* NEW CODE V2                                                     */
    SUBWDS= APPLID_NM||' '||JOBNM||' '||S#PARM||' \'
  /* NEW CODE V3.1                                                   */
  /*                                                                 */
    CALL SUB_SYMS
    END     /* END GOT_SYMSUB */
   END      /* END JOBLS      */
  IF MYFUNC1 = 'A' | MYFUNC1 = 'Q' THEN DO
   MSGBOXTX='PROCESS ALL:'||MYCMD||'..CUR APPLID >'||APPLID_NM
   ADDRESS ISPEXEC "VPUT (MSGBOXTX) ASIS"
   CALL MSGBOX
   END
/* TRACE ?I */
/*    CALL COBOL PROGRAM   */
/*ADDRESS TSO */
/*ALLOC FI(SYSOUT) DA(*) SHR REUSE' */
/* "CALL 'TTED.TSK.P.TCEM.LOADLIB(EXPLPGM3)' 'TVAR1,TVAR2'" */
/* CALL DOES NOT INITIALIZE THE ENVIRONMENT BLOCK */
/*"CALL 'TTEP.TSK.E.TCEM.PDSE(RXVARS)' 'TVAR1,TVAR2'" */
/*  "CALL 'TTEP.TSK.E.TCEM.PDSE(RXCNCLNK)' 'PROGRAM_NM,"||,         *\
|*  "APPLID_NM,RX_CNC_CH_NM,RX_CNC_CN_REQ_LST,RX_CNC_CN_RSP_LST,"||,*|
\*  "TRANID_NM'"                                                    */
/*    CALL COBOL PROGRAM   */
/*    CALL COBOL PROGRAM   */
  address link "RXCNCLN2 RX_CNC_CH_NM"
  XC = RC
  /* TRACE ?I */
  /*                                                                 *\
  |* ON RETURN FROM EXCI CALL, FIRST CHECK RC. IF IT IS NOT ZERO     *|
  |*  THEN JUST USE THE MSGOUT_NOTE RX VAR TO INDICATE THE REASON    *|
  |*  FOR THE ERROR. OTHERWISE COLLECT THE RESPONSE DATA.            *|
  |* IF WE HAVE MYFUNC1 SET TO 'E' EVERY, THEN PRESENT THE RESONSE   *|
  |*  DATA VIA THE MYDSP                                             *|
  |*  response data is gathered                                      *|
  |*    APL_STM.APPLID_NM                                            *|
  |*    APPLID_NM||'_MN'                                             *|
  |*    APPLID_NM||'_RL'                                             *|
  |*    RETLST.APPLID_NM                                             *|
  |*  IF WE HAVE MUFUNC1 = 'A' OR 'Q' THEN WE JUST ITERATE TO NEXT   *|
  |*   APPLID_NM IN THE MYAPLID  LIST - PRESENT DATA AT END          *|
  |*  fOR MYFUNC1 = 'E' WE PRESENT THE DATA AS WE GET RESPONSES      *|
  |*                                                                 *|
  |* RETURN_CN_LIST                                                  *|
  |*  CGE5(CGE5_UCEMPINR_RESP_CN,CGE5_CEMT0001,CGE5_CEDA0001,        *|
  |*  CGE5(RX_RQ_DATA            <<<<<< COMMAREA DATA IN RX_RQ_DATA  *|
  |*                             SO WE NEED TO PRESERVE IT IN A      *|
  |*                             APL_CA.APLCUR STEM                  *|
  |*                                                                 *|
  \*                                                                 */
  /* TRACE I */
  EXCI_STR = 'EXCI SUCCESSFUL'
  IF XC > 4 THEN DO
   IF EXCI_MESSAGE \= 'INITIALIZE' THEN DO
    EXCI_STR = 'EXCI FIALURE:'||,
     'RESP1:'||EXCI_RESP1||,
     ':RESP2:'||EXCI_RESP2||,
     ':ABCODE:'||EXCI_ABCODE||,
     ':MESSAGE:'||EXCI_MESSAGE||':'
    END
   APLID_BD = APLID_BD + 1
   APL_STM.APPLID_NM=APL_STM.APPLID_NM||'FAILED:RC:'||XC||':'||,
    EXCI_STR||XFF
   EXCI_NOTE = 'ONE OR MORE EXCI CALLS IN ERROR'
   END
   ELSE DO
   APLID_GD = APLID_GD + 1
   APL_STM.APPLID_NM=APL_STM.APPLID_NM||'SUCCESS:'||XFF
   END
  /*TRACE OFF */
  /*  ACCUM RESPONSE TEXT                           */
  IF RETURN_CN_LIST = '' THEN DO
   ZMP='WARNING::RETURN_CN_LIST IS EMPTY. NO DATA TO DISPLAY:'||XFF
   APL_STM.APPLID_NM=APL_STM.APPLID_NM||ZMP
   MSGOUT_NOTE=MSGOUT_NOTE||XFF||ZMP
   APPLID_NM||'_NO_LIST' = APPLID_NM||':RETURN_CN_LIST NOT RETURNED'
   RETURN_CN_LIST=APPLID_NM||'('||APPLID_NM||'_NO_LIST'
   END
   ELSE DO
   FP = POS('(',RETURN_CN_LIST)
   IF FP > 0 THEN TMP_CN_LIST = SUBSTR(RETURN_CN_LIST,FP+1)
    ELSE TMP_CN_LIST = RETURN_CN_LIST
   ZMP_CN_LIST = ''
   TMP_CN_CT = WORDS(TMP_CN_LIST)
   TPPLID_NM = STRIP(APPLID_NM,'T')
   TPPLID_NM_L = LENGTH(TPPLID_NM)
   DO I = 1 TO TMP_CN_CT
    TMP_CN = WORD(TMP_CN_LIST,I)
    IF SUBSTR(TMP_CN,1,TPPLID_NM_L) \= TPPLID_NM THEN DO
     ZMP_CN=TPPLID_NM||'_'||TMP_CN
     INTERPRET 'WMP = 'TMP_CN
     IF EXCI_STR \= 'EXCI SUCCESSFUL' THEN DO
      WMP = EXCI_STR||XFF||WMP
      END
     INTERPRET ZMP_CN' = WMP'
     TMP_CN = ZMP_CN
     END
    ZMP_CN_LIST = ZMP_CN_LIST||' '||TMP_CN
    END
   ZMP_CN_LIST = STRIP(ZMP_CN_LIST,'B')
   RETURN_CN_LIST = TPPLID_NM||'('||ZMP_CN_LIST
   IF AUTOSAVE = 'Y' THEN CALL DO_AUTOSAVE
   END
  /*                                                                 *\
  |* PROCESS RETURNING DATA; FOR ALL, JUST ITERATE; FOR EACH SHOWDATA*|
  \*                                                                 */
  ZMP = APPLID_NM||'_MSGNOTE'
  INTERPRET ZMP" ="APPLID_NM||"':MSGNOTE:'||MSGOUT_NOTE"
  YMP = APPLID_NM||'_RSPLOG'
  INTERPRET YMP" ="APPLID_NM||"':RSPLOG:'||RXCNCLN2_RSP_LOG"
  EXCIRSP.APPLID_NM = EXCI_STR
  RETLST.APPLID_NM=RETURN_CN_LIST||' '||ZMP||' '||YMP
  IF MYFUNC1 = 'A' THEN DO
   SIGNAL TOPAPLLOP
   END
  NOT_DONE = 'FIN'
DSP_EVERY_RSP:
  SELRGNS = APPLID_NM
  CALL DSP_SEL_RGN_DATA
  IF XC = 20 THEN SIGNAL FINEXCI
  IF XC = 8 THEN SIGNAL TOPAPLLOP
  IF XC = 4 THEN DO
   SIGNAL TOPAPLLOP
   END
  NOT_DONE = 'MORE'
  SECT=WORDS(SELELMS)
  IF SECT < 1 THEN DO
   SIGNAL TOPAPLLOP
   END
  SELELMS_LST = SELELMS
  CALL DSP_SEL_ELM
  IF XC = 20 THEN SIGNAL FINEXCI
  IF XC = 8 THEN SIGNAL TOPAPLLOP
  IF XC = 4 THEN DO
   SIGNAL TOPAPLLOP
   END
  IF NOT_DONE = 'MORE' THEN SIGNAL DSP_EVERY_RSP
  SIGNAL TOPAPLLOP
FINAPLLOP:
  IF MYFUNC1 \= 'A' THEN DO
   SIGNAL FINEXCI
   END
  MSGSTAT='REMPOP'
  MSGBOXTX= '< FINISHED PROCESSING SELECTION LIST.'
  ADDRESS ISPEXEC "VPUT (MSGSTAT MSGBOXTX) ASIS"
  CALL MSGBOX
  NOT_DONE = 'FIN'
FINAPLNXT:
  CALL SEL_RSP_RGNS
  IF XC > 4 THEN DO
   MSGTXT = 'ABORT/CANCEL SELECTED'
   CALL SHOWMBOX
   RETURN 8
   END
  IF XC = 4 THEN SIGNAL FINEXCI
  IF WORDS(SELRGNS) < 1 THEN DO
   DSEMSG = 'DISPLAY FUNCTION ALL, BUT NO REGIONS SELECTED'
   SIGNAL FINAPLNXT
   END
 FINDATANXT:
  CALL DSP_SEL_RGN_DATA
  IF XC > 4 THEN DO
   MSGTXT = 'ABORT/CANCEL SELECTED'
   CALL SHOWMBOX
   RETURN 8
   END
  IF XC = 4 THEN SIGNAL FINAPLNXT
  SECT=WORDS(SELELMS)
  IF SECT < 1 THEN DO
   SIGNAL FINDATANXT
   END
  SELELMS_LST = SELELMS
  CALL DSP_SEL_ELM
  IF XC > 4 THEN DO
   MSGTXT = 'ABORT/CANCEL SELECTED'
   CALL SHOWMBOX
   RETURN 8
   END
  IF XC = 4 THEN SIGNAL FINAPLNXT
  SIGNAL FINDATANXT
 FINEXCI:
  RETURN 0
/* SUB ROUTINE TO DISPLAY RETURNED DATA */
SHOWRXDATA: PROCEDURE EXPOSE TMP_NM TMP_CN_MSG
  MSG_LF_DLM='15'X
  CPY_#=COPIES('-',60)
  RSPCT = 0
  DO WHILE TMP_CN_MSG \= ''
   PARSE VAR TMP_CN_MSG TMP (MSG_LF_DLM) TMP_CN_MSG
   IF TMP \= '' THEN DO
    RSPCT = RSPCT + 1
    RSP.RSPCT = TMP
    END
   END
  SAY 'FOUND<' RSPCT '> LINES IN RESP_CN_MSG'
  M0 = 1
  ANS = '>'
  DO WHILE ((POS(ANS,'<=>')) \= 0)
   CURLN = M0
   MXLN = RSPCT - CURLN
   IF MXLN > 60 THEN MXLN = CURLN + 60
    ELSE MXLN = CURLN + MXLN
   DO I = CURLN TO MXLN
     SAY RSP.I
     SAY CPY_#
     END
    SAY 'LAST DISPLAY: LINE:' CURLN ' THRU:' MXLN ' OF:' RSPCT
    SAY 'ENTER > TO CONTINUE FORWARD'
    SAY '      = TO RE DISPLAY CURRRENT SET'
    SAY '      < TO CONTINUE FORWARD'
    SAY ' OR ANY OTHER KEY STOP THIS MESSAGE DISPLAY'
    PULL ANS
    SELECT
     WHEN ANS = '>' THEN DO
                    M0 = CURLN + MXLN
                    IF M0 >= RSPCT THEN M0 = (RSPCT - MXLN) + 1
                    END
     WHEN ANS = '=' THEN M0 = CURLN
     WHEN ANS = '<' THEN DO
                    M0 = CURLN - MXLN
                    IF M0 <= 0 THEN M0 = 1
                    END
     OTHERWISE SAY 'SELECTED TO LEAVE:' ANS ':'
     END
   END
   RETURN
  /* GET THE COMMAREA */
  /* GET THE COMMAREA */
  /* GET THE COMMAREA */
 GET_COMMAREA:
   CNCMSG = 'ENTER COMMAREA DATA AND LENGTH; OPTIONS'
 GET_COMMAREA_AGN:
   RX_RQ_DATA = LR1
   BKUP_RX_RQ_DATA = LR1
   RX_RQ_DATA.L = '4096'
   CALL GET_CA_SRC_DATA 'COMMAREA'
   IF XC > 4  THEN RETURN 8
   cal = RX_RQ_DATA.L
   IF CAL = '' then signal get_cal_retry0
   IF DATATYPE(CAL,'W') = 0 then signal get_cal_retry1
   IF CAL = 0 THEN SIGNAL GET_CAL_RETRY4
   IF CAL < 0 | CAL > MAXRQL THEN SIGNAL GET_CAL_RETRY3
   return 0
  get_cal_retry0:
 DSEMSG='YOU SPECIFIED AN INVALID VALUE FOR THE COMMAREA LENGTH:'
   signal GET_COMMAREA_AGN
  get_cal_retry1:
 DSEMSG='YOU SPECIFIED AN NON NUMERIC VALUE FOR THE COMMAREA LENGTH:'
   signal GET_COMMAREA_AGN
  get_cal_retry2:
   CALL GO_OR_NO 'CA LNG IS ZERO. CONFIRM WITH (C)CONTINUE'
   IF RC > 0 THEN RETURN 0
 DSEMSG='YOUR COMMAREA LENGTH WAS ZERO. RETRY WITH ANOTHER VALUE'
   signal GET_COMMAREA_AGN
  GET_CAL_RETRY3:
 DSEMSG='YOUR COMMAREA LENGTH IS NOT IN A VALID RANGE 0 - 'MAXRQL':'
   signal GET_COMMAREA_AGN
 GET_COMMAREA_L_XIT:
    RETURN 16
/* TRACE  I */
  /*                                                                 *\
  |* DISPLAY CA OR CN PANEL TO GET SRC REQUEST DATA                  *|
  \*   EXPECTS ARG COMMAREA OR SOMEOTHERNAME                         */
 GET_CA_SRC_DATA:
/* trace ?i */
  XC = 0
  CA_OR_CN = ''
  ARG CA_OR_CN
  IF CA_OR_CN = '' THEN RETURN 8
  mysc = 'PAGE'
  LR1 = RX_RQ_DATA
  LR1LNG = RX_RQ_DATA.L
   EXECSEL='GETAFOCA'
   DSEMSG = 'ENTER TO UPDATE, PF3 TO CONTINUE'
   cnto='COMMAREA'
   cnty = ''
   cntystr=''
   cncchnm='COMMAREA'
   GET_PNL_NM = 'GETAFOCA'  cnlstcnt
  canstr='ABORT CANCEL'
  CMDSTR='END COPY RESET SETODSN '||CANSTR
  cnstrip='Y'
  h_cnto=cnto
  h_cnty=cnty
  h_LR1LNG=LR1LNG
  h_cnstrip=cnstrip
  xc = 0
  acmd = ''
  "ISPEXEC ADDPOP"
 TOPOFCALOP:
   zcmd = ''
   "ISPEXEC DISPLAY PANEL(GETAFOCA)"
   xc = rc
   acmd = zcmd
   IF WORDPOS(ACMD,CANSTR) > 0 THEN SIGNAL CAN_CA_SRC_DATA
   IF XC = 8 THEN DO
    IF ACMD = '' THEN ACMD = 'DONE'
    END
   IF ACMD = 'SETODSN' THEN DO
    CALL SET_ODSN
    SIGNAL topofcalop
    END
   IF ACMD = 'END' THEN SIGNAL FIN_CA_SRC_DATA
   IF ACMD = 'DONE' THEN SIGNAL FIN_CA_SRC_DATA
   if acmd = 'RESET' then do
    CALL DORESET HYDSRC
    signal topofcalop
    end
   if acmd = 'COPY' then do
    call docopy
    signal topofcalop
    end
   cncmsg='ENTER more COMMAREA DATA'
   signal topofcalop
 FIN_CA_SRC_DATA:
   XC = 0
   if cnstrip = 'Y' then do
    lr1 = strip(lr1,'T')
    IF CA_OR_CN \= 'COMMAREA' THEN LR1LNG = length(LR1)
    end
   RX_RQ_DATA = LR1
   BKUP_RX_RQ_DATA = LR1
   RX_RQ_DATA.L = LR1LNG
   CAL = LR1LNG
   RX_RQ_DATA.T = cnty
   SIGNAL RET_CA_SRC
 CAN_CA_SRC_DATA:
   XC = 8
 RET_CA_SRC:
   "ISPEXEC REMPOP"
   RETURN XC
/* sub routines */
/* sub routines */
/* sub routines */
 docopy:
  edsn = 'src.for.cn.dsn'
  embr = 'src_mbr'
  dsemsg = 'Enter DSN (opt MBR) for 'CA_OR_CN' data'
  "ISPEXEC VPUT (EDSN EMBR DSEMSG EXECSEL) ASIS"
  IF RC > 0 THEN DO
   cmcmsg = 'COPY failed to get 'CA_OR_CN' data (vput)'
   signal donecopy
   end
  call gdsnnmbr
  if rc > 4 then do
   cmcmsg = 'COPY failed to get 'CA_OR_CN' data (gdsn)'
   signal donecopy
   end
  "ISPEXEC Vget (EDSN EMBR) ASIS"
  IF RC > 0 THEN DO
   cmcmsg = 'COPY failed to get 'CA_OR_CN' data (vget_gdsn)'
   signal donecopy
   end
  if EDSN = '' THEN DO
   cmcmsg = 'COPY failed to get 'CA_OR_CN' data (vget_EDSN)'
   signal donecopy
   end
  if EMBR \= '' THEN DO
   EDSN = EDSN||'('||EMBR||')'
   "ISPEXEC VPUT (EDSN) ASIS"
   IF RC > 0 THEN DO
    cmcmsg = 'COPY failed to get CN DSN (VPUT)'
    signal donecopy
    end
   end
  if mcmd \= 'COPY' then return xc
  tgtdata = ''
  CALL CPDS2VAR "<EDSN> <TGTDATA>"
  if rc = 0 then do
   "ISPEXEC VGET (TGTDATA) ASIS"
   IF RC > 0 THEN DO
    cmcmsg = 'COPY failed to get CN data(VGET)'
    signal donecopy
    end
   LR1 = TGTDATA
   lr1lng = length(TGTDATA)
 donecopy:
  xc = rc
  return xc

 DORESET:
   CA_OR_CN = ''
   ARG CA_OR_CN
   IF CA_OR_CN = '' THEN RETURN 8
   CN_CMD=SUBSTR(MYCMD,1,4)
   IF CA_OR_CN = 'COMMAREA' THEN
    cncmsg='(reset)ENTER COMMAREA DATA'
    ELSE DO
    CNCMSG='(RESET)ENTER CONTAINER DATA'
    RX_CNC_CN_NM =CN_CMD||'0000'
    END
   cnto=h_cnto
   cnty=h_cnty
   LR1LNG=h_LR1LNG
   cnstrip=h_cnstrip
   SELECT
   WHEN CN_CMD = 'CEMT' THEN LR1 = 'CEMT INQUIRE SYSTEM'
   WHEN CN_CMD = 'CEDA' THEN LR1 = 'CEDA EXPAND GROUP(XXXXXXXX)'
   WHEN CN_CMD = 'PING' THEN LR1 = 'PINGThis is a PING test'
   WHEN CN_CMD = 'LINK' THEN LR1 = 'LINK,PROGRAM(UCEMPINQ)'
   OTHERWISE LR1 = 'ENTER REQUEST DATA'
   END
   return
  /*                                                                 *\
  |* OK CANCEL BOX - DETERMINES HOW TO CONTINUE WHEN WE NEED TO KNOW *|
  \*                                                                 */
 GO_OR_NO:
    ARG OKCAN1
    OKCAN2 = '(O)K TO CONTINUE, (C)ANCEL TO ABORT'
    OKCANX = 'C'
    ADDRESS ISPEXEC 'VPUT (OKCAN1 OKCAN2 OKCANX) ASIS'
    CALL OKCANBOX
    IF RESULT \= 0 THEN RETURN 8
    ADDRESS ISPEXEC 'VGET (OKCANX) ASIS'
    IF OKCANX \= 'O' THEN RETURN 4
    RETURN 0
  /*                                                                 *\
  |* GET THE OUTPUT DATASET FOR SAVING DATA                          *|
  \*                                                                 */
 SET_ODSN:
     XC = 0
     CALL GET_ODSN
     IF XC > 4 THEN SIGNAL RESET_SVDSN
     ADDRESS ISPEXEC "VGET (EDSN) ASIS"
     IF RC \= 0 THEN SIGNAL RESET_SVDSN
     ODSN = EDSN
     ADDRESS ISPEXEC "VGET (MYVERB) ASIS"
     IF RC \= 0 THEN SIGNAL RESET_SVDSN
     IF MYVERB \= '' THEN DO
      IF MYVERB='ABORT' | MYVERB='CANCEL' THEN SIGNAL RESET_SVDSN
      END
     DSPLYADS = ODSN
    "ISPEXEC VPUT (DSPLYADS) ASIS"
     RETURN
  RESET_SVDSN:
     XC = RC
     ODSN = ''
     RETURN
  /*                                                                 *\
  |* GET THE OUTPUT DATASET FOR SAVING DATA                          *|
  \*                                                                 */
 GET_ODSN:
    "ISPEXEC VGET (DSPLYADS) ASIS"
    IF RC \= 0 THEN DO
     CALL GETUDSN 'AFOLIST'
     PULL EDSN
     END
     ELSE EDSN=DSPLYADS
    TMP = EXECSEL
    EXECSEL = 'AUTOSAVE'
    DSEMSG = 'CHANGE AFOLIST SAVE TO PDS'
    MYVERB = 'CANCEL ABORT END'
    "ISPEXEC VPUT (EDSN) ASIS"
    "ISPEXEC VPUT (DSEMSG EXECSEL) ASIS"
    "ISPEXEC VPUT (MYVERB) ASIS"
    CALL DSNWIND
    EXECSEL = TMP
    XC = RESULT
    RETURN XC
  /*                                                                 *\
  |* logic to get containers for respective channel                   *|
  |* Expect arg to be the channel name, but it exists in CNCCHNM      *|
  |*  just want to be assured we are invoking for a CHANNEL NAME      *|
  \*                                                                 */
 GET_CN_SRC_DATA:
   get_ch_nm = ''
   arg get_ch_nm
   if get_ch_nm = '' then signal do_cn_cancel
   chnm_l = length(get_ch_nm)
   if chnm_l < 1 | chnm_l > 16 then signal do_cn_cancel
   CNOSTR='DONE ABORT CANCEL DELETE ?'
   CANSTR='ABORT CANCEL'
   CMDSTR='GO BACK CDSN BDSN '||CANSTR
   CNTYSTR='CHAR,BIT,CDSN,BDSN'
   CNTO=''
   CNTY='CHAR'
/* CNCCHNM = 'TEST_CH_NM' */
   GET_PNL_NM = 'GETAFOCN'
   CNLST=''
   CNLSTCNT=0
   LR1LSCRL='<'
   LR1RSCRL='>'
/* TRACE I */
/* "ISPEXEC ADDPOP ROW(1) COL(10)" */
   "ISPEXEC ADDPOP"
   LASTCC = RC
  /*                                                                 *\
  |* TOP: GET CONTAINER NAMES, OR DONE/CANCEL                        *|
  \*                                                                 */
 TOPOFCNLOP:
   IF CNOMSG = '' THEN CNOMSG='USE COMMAND OR ENTER NEW CN NM'
   EXECSEL='TSTAFONN'
   ZCMD = ''
   CNLSTL=LENGTH(CNLST)
   CNLSTCNT=WORDS(CNLST)
   CMDACTN='ADD'
   "ISPEXEC DISPLAY PANEL(GETAFONN)"
   LASTCC=RC
/* TRACE ?I */
   MCMD = WORD(ZCMD,1)
   IF MCMD = 'DONE' THEN SIGNAL GOT_ALL_CNTO
   IF MCMD = '?' THEN DO
    CALL SHOWHELP
    SIGNAL TOPOFCNLOP
    END
   IF MCMD = 'CANCEL' | MCMD = 'ABORT' THEN SIGNAL DO_CN_CANCEL
   IF LASTCC = 8 THEN SIGNAL GOT_ALL_CNTO
   IF MCMD = 'DELETE' THEN DO
    IF CNTO = '' THEN DO
     CNOMSG='DELETE:MISSING CN NAME'
     SIGNAL TOPOFCNLOP
     END
    WP = WORDPOS(CNTO,CNLST)
    IF WP = 0 THEN DO
     CNOMSG='DELETE:'CNTO' NOT ON CN LIST'
     SIGNAL TOPOFCNLOP
     END
    CNLST=DELWORD(CNLST,WP,1)
    CNOMSG='DELETED:'CNTO' FROM CN LIST'
    SIGNAL TOPOFCNLOP
    END
  /* PROCESS A CNTO */
   IF CNTO = '' THEN DO
    CNOMSG='MISSING A CONTAINER NAME. RETRY.'
    SIGNAL TOPOFCNLOP
    END
   WP = WORDPOS(CNTO,CNLST)
   IF WP > 0 THEN DO
    CMDACTN='EDIT'
    CNCMSG = 'EDIT THIS CONTAINER DATA'
    INTERPRET 'TMP = 'CNTO
    INTERPRET 'LR1 = "'TMP'"'
    INTERPRET 'LR1LNG  = 'CNTO'.L'
    INTERPRET 'CNTY    = 'CNTO'.T'
    SIGNAL GET_CN_DATA
    END
    ELSE DO
    IF WORDS(CNLST) > 98 THEN DO
     CNOMSG='MAX CN NAMES; DELETE, ABORT OR DONE'
     SIGNAL TOPOFCNLOP
     END
    IF LENGTH(CNTO) > 3 THEN CN_CMD=SUBSTR(CNTO,1,4)
     ELSE CN_CMD=CNTO
    SELECT
      WHEN CN_CMD = 'CEMT' THEN LR1 = 'CEMT INQUIRE SYSTEM'
      WHEN CN_CMD = 'CEDA' THEN LR1 = 'CEDA EXPAND GROUP(XXXXXXXX)'
      WHEN CN_CMD = 'PING' THEN LR1 = 'PINGTHIS IS A PING TEST'
      WHEN CN_CMD = 'LINK' THEN LR1 = 'LINK,PROGRAM(UCEMPINQ)'
      OTHERWISE LR1 = 'ENTER REQUEST DATA'
      END
    LR1LNG = LENGTH(LR1)
    CNTY = 'CHAR'
    END
 GET_CN_DATA:
   CNSTRIP = 'Y'
   CNCMSG='ENTER DATA FOR:'CNTO
   ZCMD = ''
   "ISPEXEC DISPLAY PANEL("GET_PNL_NM")"
   XC = RC
   ACMD = ZCMD
   IF ACMD = 'GO' THEN SIGNAL DON_AFO_SRC_DATA
   IF ACMD = 'BACK' THEN DO
    CNOMSG='BACK OFF LAST CN NAME'
    SIGNAL TOPOFCNLOP
    END
   IF ACMD = 'END' THEN SIGNAL DON_AFO_SRC_DATA
   IF ACMD = 'SETODSN' THEN DO
    CALL SET_ODSN
    SIGNAL GET_CN_DATA
    END
   IF WORDPOS(ACMD,CANSTR) > 0 THEN DO
    CNOMSG='CANCEL GETDATA FOR CN'
    SIGNAL TOPOFCNLOP
    END
   IF XC = 8 THEN SIGNAL DON_AFO_SRC_DATA
   IF ACMD = 'CDSN' | ACMD = 'BDSN' THEN DO
    IF SUBSTR(CNTY,1,1) \= SUBSTR(ACMD,1,1) THEN DO
     CNCMSG = ACMD':INCONSIST TYPE:'CNTY
     SIGNAL GET_CN_DATA
     END
     CALL DOCOPY
     IF RC \= 0 THEN DO
      CMCMSG = ACMD':FAILED:GDSN'
      SIGNAL GET_CN_DATA
      END
     LR1 = '<'||EDSN||'>'
    CNTY=ACMD
    SIGNAL GET_CN_DATA
    END
   CNCMSG='ENTER MORE CONTAINER DATA'
   SIGNAL GET_CN_DATA
DON_AFO_SRC_DATA:
   CNCMSG = 'ADDED THIS CONTAINER:'CNTO
   IF CNSTRIP = 'Y' THEN DO
    LR1=STRIP(LR1,'T')
    LR1LNG = LENGTH(LR1)
    END
   INTERPRET CNTO'.L = LR1LNG'
   INTERPRET CNTO'.T = CNTY'
   INTERPRET CNTO' = LR1'
   INTERPRET 'BKUP_'CNTO' = LR1'
   IF WORDPOS(CNTO,CNLST) = 0 THEN DO
    CNOMSG = 'CONT:'||CNTO||':ADDED. MORE OR DONE?'
    CNLST=CNLST||' '||CNTO
    END
    ELSE DO
    CNOMSG = 'CONT:'||CNTO||':EDITED. MORE OR DONE?'
    END
   SIGNAL TOPOFCNLOP
GOT_ALL_CNTO:
   CNLSTCNT = WORDS(CNLST)
  IF CNLSTCNT < 1 THEN DO
   CALL GO_OR_NO  'YOU HAVE ENTERED ZERO CONTAINERS. OK (CONTINUE)  '||,
    ' OR CANCEL TO ABORT'
   IF RESULT > 0 THEN SIGNAL DO_CN_CANCEL
   END
   ELSE DO
   CNLST=STRIP(CNLST,'B')
   END
   /*
   DO I = 1 TO CNLSTCNT
    TMP = WORD(CNLST,I)
    SAY 'CN:'TMP
    INTERPRET 'LR1 = 'TMP
    SAY LR1
    INTERPRET 'LR1LNG = 'TMP'.L'
    SAY 'LENGTH:'LR1LNG
    INTERPRET 'CNTY   = 'TMP'.T'
    SAY '  TYPE:'CNTY
    END
    */
   XC = 0
   SIGNAL DONE_CN
 DO_CN_CANCEL:
  DSEMSG = EXECSEL||' REQUESTED CANCEL'
  "ISPEXEC VPUT (DSEMSG) ASIS"
  XC = 8
 DONE_CN:
  "ISPEXEC REMPOP"
  RETURN XC
  /*                                                                 *\
  |* substitution sr for request data                                *|
  \*                                                                 */
 SUB_SYMS:
/*TRACE ?I */
  SSCT=WORDS(CNLST)
  SSCUR=0
  /*                                                                 *\
  |* DO SYMBOLS SUBSTITUTION                                         *|
  |* EVERY APPLID_NM HAS TO HAVE SYMBOLS SUBSTITUTED; SO WE USE THE  *|
  |*  BKUP_X VERSION TO RESEED THE REQUEST                           *|
  |* IF ON THE FIRST REGION, WE DO NOT FIND ANY SYMBOLS SUBSTITUTED  *|
  |*  WE CAN BYPASS SIMILAR PROCESSING SETTING   GOT_SYMSUB TO 'N'   *|
  |*  AND WE ARE NEVER CALLED AGAIN FROM MAIN LOGIC                  *|
  |* HOWEVER, IF WE DO FIND SYMBOLS, THEN SET GOT_SYMSUB TO 'Y'      *|
  \*                                                                 */

 TOPSUBSYMLOP:
  SSCUR = SSCUR + 1
  IF SSCUR > SSCT THEN RETURN 0
  SSTMP=WORD(CNLST,SSCUR)
  INTERPRET 'ZMP = BKUP_'SSTMP
  DOSUB = 0
  /*                                                                 *\
  |* REPWDS='\@ \$ \! \\'   APPLID JOBNAME SPECIFIC \\               *|
  |* RW_CT = WORDS(REPWDS)                                           *|
  \*                                                                 */
/* GOT THE REQUEST DATA IN ZMP - DO SUB FOR EACH VAR */
   DO K = 1 TO RW_CT     /* RW_CT IS NUMBER OF SYMS */
    TMPCAL=LENGTH(ZMP)
    SWD = WORD(REPWDS,K)
    RWD = WORD(SUBWDS,K)
    WP = 999             /* WE IMPOSE 999 MAX SUBS TO STOP LOOPER */
    DO UNTIL WP = 0
     WP = POS(SWD,ZMP)
     IF WP > 0 THEN DO
      IF WP = 1 THEN DO
       ZMP=RWD||SUBSTR(ZMP,WP+2)
       END
       ELSE DO
       IF WP = TMPCAL - 1 THEN ,
        ZMP=SUBSTR(ZMP,1,WP-1)||RWD
        ELSE ,
        ZMP=SUBSTR(ZMP,1,WP-1)||RWD||SUBSTR(ZMP,WP+2)
       END
      TMPCAL=LENGTH(ZMP)
      DOSUB = 1
      GOT_SYMSUB = 'Y'
      END
     END
    END
   IF DOSUB = 0 THEN SIGNAL TOPSUBSYMLOP
   INTERPRET SSTMP' = ZMP'
/* DOES NEW AREA EXCEED REQ TYPE MAX? */
   IF TMPCAL > MAXRQL THEN DO
    TMPCAL = MAXRQL
    ZMP=SUBST(ZMP,1,MAXRQL)
    END
   ZMPL = 0
/* DOES NEW AREA EXCEED REQ LNG .L STEM */
   INTERPRET 'ZMPL = 'SSTMP'.L'
   IF TMPCAL > ZMPL THEN DO
    ZMPL=TMPCAL
    INTERPRET SSTMP'.L = ZMPL'
    END
  SIGNAL TOPSUBSYMLOP
 BOTSUBSYMLOP:
  RETURN 0
/*       */
 SHOWHELP:
  IF HYDSRC = 'COMMAREA' THEN DO
   MSGBOX 'HELP INFO FOR CA REQUEST DATA SRC'
   END
   ELSE DO
   MSGBOX 'HELP INFO FOR CN REQUEST DATA SRC'
   END
  RETURN
  /*                                                                 *\
  |* AUTOSAVE FUNCTION - SAVE CURRENT RSP ELEMENT TO DSN             *|
  \*                                                                 */
 DO_AUTOSAVE:
  /*  TRACE ?I */
   "ISPEXEC VGET (DSPLYADS) ASIS"
   IF RC \= 0 THEN DO
    ZEDSMSG = 'AUTOSAVE VAR NF'
    ZEDLMSG = 'AUTOSAVE FOR REGION 'APPLID_NM' DSN VAR NOT FOUND'
    'ISPEXEC SETMSG MSG(ISRZ000)'
    APL_STM.APPLID_NM ='AUTOSAVE FAIL:DSN BAD:'APPLID_NM||XFF||,
                                                   APL_STM.APPLID_NM
    AUTOSAVE = 'N'
    RETURN 8
    END
   PARSE VAR DSPLYADS EDSN '(' EMBR ')'
   TDSN = EDSN
 /* DO THE AUTOSAVE ACTION FOR EACH RETURNED RSP DATA IN */
 /*  THE ZMP_CN_LIST (RETURN_CN_LIST)                    */
   RSPCT=WORDS(ZMP_CN_LIST)
   IF RSPCT < 1 THEN DO
    ZEDSMSG = 'AUTOSAVE:NO LIST'
    ZEDLMSG = 'AUTOSAVE:'APPLID_NM':EMPTY RETURN_CN_LIST'
    'ISPEXEC SETMSG MSG(ISRZ000)'
    APL_STM.APPLID_NM ='AUTOSAVE FAIL:LIST BAD:'APPLID_NM||XFF||,
                                                    APL_STM.APPLID_NM
    RETURN 8
    END
   RSPCUR=0
 TOPSAVITLOP:
   RSPCUR = RSPCUR + 1
   IF RSPCUR > RSPCT THEN RETURN 0
   RSPTMP=WORD(ZMP_CN_LIST,RSPCUR)
   INTERPRET 'ZMP = 'RSPTMP
   ZMP=TRANSLATE(ZMP,XFF,X15)
   TMP = SUBSTR(ZMP,LENGTH(ZMP),1)
   IF TMP > '39'X THEN TMP = '40'X
   ZMP = STRIP(ZMP,'T',TMP)
   L = 0
   DROP MYA.
   DO WHILE ZMP \= ''
     L = L + 1
     PARSE VAR ZMP MYA.L (XFF) ZMP
     WL=LENGTH(MYA.L)
     IF WL > MXLNG THEN MXLNG = WL
     TRACE OFF
     END
    /* TRACE ?I */
   MYA.0 = L
   M# = L
   EMBR=APPLID_NM
   MYSTM='MYA.'
   CALL SAVIT
   DROP MYA.
   IF XC \= 0 THEN DO
    ZEDSMSG = 'AUTOSAVE FAILED.'
    ZEDLMSG = 'AUTOSAVE:'APPLID_NM':'RSPTMP':FAILED.'
    'ISPEXEC SETMSG MSG(ISRZ000)'
    APL_STM.APPLID_NM ='AUTOSAVE FAIL:SAVIT:'APPLID_NM||XFF||,
                                                 APL_STM.APPLID_NM
    END
    ELSE DO
    ZEDSMSG = 'AUTOSAVE SUCCESS'
    ZEDLMSG = 'AUTOSAVE:'APPLID_NM':'RSPTMP':SUCCESSFUL'
    'ISPEXEC SETMSG MSG(ISRZ000)'
    APL_STM.APPLID_NM ='AUTOSAVE SUCCESSFUL:'APPLID_NM':'RSPTMP
    END
   SIGNAL TOPSAVITLOP
 DONE_AUTOSAVE:
   RETURN
  /*                                                                 *\
  |*  SAVIT SAVES STEM MYSTM VAR (M# RECORDS) TO DSN SELECTED        *|
  \*                                                                 */
 /* MYFUNC = QUIET : WRITE OP TO ODSN */
 SAVIT:
 /* TRACE ?I */
  EXECSEL='SAVIT'
  DSPVAL='SHR REUSE'
  CALL MALOC TDSN
  XC=RESULT
  IF XC = 0 THEN SIGNAL CHKORG
  IF EMBR = '' THEN MYDSO='PS)'
   ELSE DO
    MYDSO='PO) DSNTYPE(LIBRARY)'
   END
  MODDSN = ''
  M=MXLNG+4
  DSEMSG = '(D) DEL/REALLOC,(A) ABORT'
  MODATTR="NEW BLKSIZE("M+4") DSORG("MYDSO" RECFM(V,B) SPACE(1,1)"||,
   "CYLINDER LRECL("M") CATALOG REUSE"
  "ISPEXEC VPUT (EDSN EXECSEL DSEMSG MODATTR MODDSN) ASIS"
  IF RC \= 0 THEN SIGNAL EXITRC8
  CALL ALOCDSN
  XC = RESULT
  "ISPEXEC VGET (EDSN) ASIS"
  IF RC \= 0 THEN RETURN 4
  SIGNAL DOWRITEx
 CHKORG:
   XC=LISTDSI("'"TDSN"'" DIRECTORY NORECALL)
   MYDSO=SYSDSORG
   IF EMBR \= '' THEN DO
    IF MYDSO = 'PS' THEN SIGNAL BADOPDSNORG
    END
    ELSE DO
    IF MYDSO = PO THEN SIGNAL BADOPDSNORG
    IF AUTOSAVE = 'Y' THEN DSPVAL='MOD'
    END
   EDSN = TDSN
 DOWRITEx:
   /* TRACE ?I */
   DSPLYADS=EDSN
    IF EMBR \= '' THEN EDSN=EDSN||'('||EMBR||')'
   "ISPEXEC VPUT (DSPLYADS EMBR) ASIS"
   ADDRESS TSO "ALLOC FI(O) DA('"EDSN"') "DSPVAL
   ADDRESS TSO "EXECIO "M#" DISKW O (STEM "MYSTM" FINIS"
   ADDRESS TSO "FREE FI(O)"
   RETURN 0
BADOPDSNORG:
   CALL MSGBOX 'SAVE TO DSN DSORG INCONSISTENT WITH EXISTING DSN'
   RETURN 4
  END
 EXITRC8:
    ERR='NO VALID FUNCTION REQUESTED'
    SIGNAL DOERR
 EXITRC10:
    ERR='FUNCTION:QUIET, BUT NO OUTPUT DESTINATION PROVIDED.'
    SIGNAL DOERR
 EXITRC12:
 EXITRC16:
 EXITRC20:
 DOERR:
 RETURN XC
  /*                                                                 *\
  |*                                                                 *|
  \*                                                                 */
 SEL_RSP_RGNS:
  NOP
 HELPTOP:
 /*                                                                 *\
 |* MANAGE RESPONSE DATA FOR MYFUNC1 'E'                            *|
 |*  SELECT ONE OR MORE REGIONS                                     *|
 |*  OR                                                             *|
 |*  SELECT THE 'ALL' LINE ENTRY                                    *|
 |*                                                                 *|
 |*  BASED ON YOUR SELECTION, FOR EACH SELECTION (OR ALL)           *|
 |*   A SECOND PANELS ALLOWS YOU TO CHOOSE                          *|
 |*   WHICH RESPONSE DATA YOU WISH TO SEE                           *|
 |*                                                                 *|
 |*  PF3 OR END WILL PROCESS; CANCEL WILL ABORT CNC ACTION          *|
 |*  ? TO SEE THIS HELP DATA                                        *|
 \*                                                                 */
 HELPBOT:
  HELPTOP_SRCLN = 1189
  HELPBOT_SRCLN = 1199
 /*                                                                 *\
 |* THE ABOVE SRCLN VARS ARE USE IN THE HELP OPTION                 *|
 |*  IF YOU ADD OR DELETE LINES WITHIN THE HELPTOP:HELPBOT LABELS   *|
 |*   YOU MUST ADJUST THE SCRLN VARS ACCORDINGLY                    *|
 \*                                                                 */
  HELPDATA=XFF
 /* TRACE I */
  XC = 8
  CHNM_DFT=RX_CNC_CH_NM
  AMT='CSR'
  SIGNAL OFF ERROR
  "ISPEXEC ADDPOP ROW(2) COLUMN(20)"
  /* TBLAPLID HAS 2 COLS: ACTION APPLID */
  "ISPEXEC TBCREATE TBLAPLID "||,
    "NAMES(ACTION FA FB) NOWRITE REPLACE"
   IF RC > 4 THEN DO
   MSGTXT ='COULD NOT CREATE THE TBLAPLID LIST OF RESPONSE REGIONS.'||,
    'WILL DEFAULT TO ALL REGIONS.'
   CALL   SHOWMBOX
   SELRGNS=MYAPLID
   XC = 4
   SIGNAL DO_FIN
   END
  ACTION = '-'
  FA='ALL'
  FB='-'
  "ISPEXEC TBADD TBLAPLID"
  APLCT = WORDS(MYAPLID)
  DO I = 1 TO APLCT
   FA = WORD(MYAPLID,I)
   "ISPEXEC TBADD TBLAPLID"
   END
  /* TRACE I */
  EXECSEL='DSPAFOH$'
  "ISPEXEC TBTOP TBLAPLID"
  "ISPEXEC VPUT (EXECSEL) ASIS"
  CANSTR='CANCEL ABORT'
  DONSTR='DONE END'
  CMDSTR=CANSTR||' '||DONSTR||' RESET'
  PROCLST='-,S,U,X'
  PROCLST_WDS=TRANSLATE(PROCLST,' ',',')
  PROCLSTWD='- SELECT UNSELECT EXCLUDE'
  MCMD=''
  LSTHDR='RESPONSE REGION LIST'
  CHORCN=CHNM_DFT
  MYCRP = 0
  DSEMSG=''
  SELRGNS=''
  XCLRGNS=''
 /*  TRACE ?I */
  "ISPEXEC TBDISPL TBLAPLID PANEL(AFORSPAP) ROWID(MDROW#) POSITION(MYCRP)"
  SIGNAL ARND_TOP
 TOPOFLOP:
  ZCMD = ''
  "ISPEXEC TBTOP   TBLAPLID"
  "ISPEXEC TBSKIP  TBLAPLID NUMBER("ZTDTOP")"
  "ISPEXEC TBDISPL TBLAPLID PANEL(AFORSPAP)"
 ARND_TOP:
  XC = RC
  IF XC > 8 THEN DO
   MSGTXT ='SEVERE ERROR FROM TBDISPL FUNCTION.  ABORT.'
   CALL   SHOWMBOX
   XC = 20
   SIGNAL DO_TBL_CLO
   END
  IF WORDPOS(MCMD,CANSTR) \=  0 THEN DO
   DSEMSG='COMMAND:'MCMD' SIGNALS ABORT'
   SIGNAL DO_CAN
   END
  IF MCMD = 'RESET' THEN DO
   SELRGNS = ''
   XCLRGNS=''
   "ISPEXEC TBTOP TBLAPLID"
   DO I = 1 TO ZTDROWS
    "ISPEXEC TBSKIP  TBLAPLID NUMBER(1)"
    ACTION = '-'
    FB = '-'
    "ISPEXEC TBPUT TBLAPLID"
    END
   SIGNAL TOPOFLOP
   END
  NUD=ZTDSELS
  HR#=MDROW#
  HC#=MYCRP
  IF ZTDSELS > 0 THEN DO
   DO WHILE (ZTDSELS > 0)
    R#=MDROW#
    R#=MYCRP
    ACT_W#=WORDPOS(ACTION,PROCLST_WDS)
    SELECT
    WHEN ACTION = 'S' THEN DO
     IF FA = 'ALL' THEN DO
      XCLRGNS = ''
      SELRGNS=MYAPLID
      DO I = 2 TO ZTDROWS
       "ISPEXEC TBSKIP  TBLAPLID NUMBER(1)"
       QQQ=FA
       ACTION = '-'
       FB = 'S'
       "ISPEXEC TBPUT TBLAPLID"
       END
      SIGNAL TOPOFLOP
      END
      ELSE DO
      IF WORDPOS(FA,SELRGNS) = 0 THEN SELRGNS = SELRGNS||' '||FA
      XP=WORDPOS(FA,XCLRGNS)
      IF XP > 0 THEN XCLRGNS=DELWORD(XCLRGNS,XP,1)
      END
     END           /* END 'S' */
    WHEN ACTION = 'X' THEN DO
     IF FA = 'ALL' THEN DO
      SELRGNS = ''
      XCLRGNS=MYAPLID
      DO I = 1 TO ZTDROWS
       "ISPEXEC TBSKIP  TBLAPLID NUMBER(1)"
       ACTION = '-'
       FB = 'X'
       "ISPEXEC TBPUT TBLAPLID"
       END
      SIGNAL TOPOFLOP
      END
      ELSE DO
      IF WORDPOS(FA,XCLRGNS) = 0 THEN XCLRGNS = XCLRGNS||' '||FA
      XP=WORDPOS(FA,SELRGNS)
      IF XP > 0 THEN SELRGNS=DELWORD(SELRGNS,XP,1)
      END
     END
    WHEN ACTION = 'U' THEN DO
     IF FA = 'ALL' THEN DO
      SELRGNS = ''
      XCLRGNS=''
      DO I = 1 TO ZTDROWS
       "ISPEXEC TBSKIP  TBLAPLID NUMBER(1)"
       ACTION = '-'
       FB = '-'
       "ISPEXEC TBPUT TBLAPLID"
       END
      SIGNAL TOPOFLOP
      END
      ELSE DO
      XP=WORDPOS(FA,SELRGNS)
      IF XP > 0 THEN SELRGNS=DELWORD(SELRGNS,XP,1)
      XP=WORDPOS(FA,XCLRGNS)
      IF XP > 0 THEN XCLRGNS=DELWORD(XCLRGNS,XP,1)
      END
     END
    OTHERWISE NOP
    END                      /* END SELECT */
    FB = ACTION
    ACTION = '-'
    "ISPEXEC TBPUT TBLAPLID"
    IF ZTDSELS > 1 THEN "ISPEXEC TBDISPL TBLAPLID"
     ELSE LEAVE
 /* IF ZTDSELS < 1 THEN LEAVE */
    END
   END
 /*  TRACE I */
  IF XC = 8 THEN DO
   IF MCMD = '' THEN MCMD = 'END'
   END
  IF MCMD = '?'THEN DO
   CALL DO_HELP
   MCMD = ''
   SIGNAL TOPOFLOP
   END
  IF WORDPOS(MCMD,CMDSTR) = 0 THEN SIGNAL TOPOFLOP
  IF WORDPOS(MCMD,DONSTR) \= 0 THEN SIGNAL OKDOIT
  SIGNAL TOPOFLOP
/*PROCESS COMMANDS */
/*LOOP TO TOPOFLOP UNTIL SAVE COMMAND */
 OKDOIT:
 /* TRACE I */
  IF SELRGNS = '' THEN DO
   IF MCMD = 'DONE' THEN DO
    XC = 4
    SIGNAL DO_TBL_CLO
    END
   DSEMSG ='PF3/END: ZERO REGIONS; USE CANCEL/ABORT/DONE'
   SIGNAL TOPOFLOP
   END
  IF MCMD = 'DONE' THEN XC = 4
     ELSE XC = 0
  SIGNAL DO_TBL_CLO
 DO_CAN:
  IF MCMD = 'ABORT' THEN XC = 20
     ELSE XC = 8
 DO_TBL_CLO:
  "ISPEXEC TBCLOSE TBLAPLID"
 DO_FIN:
/*                                                                   *\
|* ADDPOP/REMPOP service in relation to CONTROL service              *|
|*                                                                   *|
|* The ADDPOP service performs the equivalent of a                   *|
|* CONTROL DISPLAY SAVE                                              *|
|* prior to creating the pop-up window and the REMPOP service        *|
|* performs the equivalent of a CONTROL DISPLAY RESTORE after        *|
|* removing the current  pop-up window.                              *|
|*  A dialog should not issue its own                                *|
|* CONTROL DISPLAY SAVE/RESTORE around an ADDPOP/REMPOP sequence     *|
|*                                                                   *|
|*                                                                   *|
\* A                                                                 */
  "ISPEXEC REMPOP"
   RETURN XC
  /*                                                                 *\
  |* UTILITY SUBROUTINES                                             *|
  \*                                                                 */
 SHOWMBOX:
   CALL MSGBOX MSGTXT
   RETURN
 DO_HELP:
  IF LENGTH(HELPDATA) < 2 THEN DO
   DO I = HELPTOP_SRCLN TO  HELPBOT_SRCLN
    TMP=STRIP(SOURCELINE(I),'B')
    TMP=TRANSLATE(TMP,'    ','/\|*')
    HELPDATA=HELPDATA||STRIP(TMP,'B')||XFF
    END
   END
  CALL MSGBOX HELPDATA
    RETURN XC
  /*                                                                 *\
  |*  DISPLAY THE RESPONSE DATA ELEMENTS FOR EACH REGION IN SELRGNS  *|
  \*                                                                 */
 DSP_SEL_RGN_DATA:
  IF WORDS(SELRGNS) < 1 THEN DO
   MSGTXT = 'ERROR: CALL TO DISPLAY DATA FOR SELETED REGIONS, BUT'||,
    ' THERE ARE NO REGIONS IN THE SELECT LIST.'
   CALL SHOWMBOX
   XC = 8
   RETURN
   END
 HELPTOP2:
 /*                                                                 *\
 |* MANAGE RESPONSE DATA FOR MYFUNC1 'E'                            *|
 |*  SELECT ONE OR MORE REGIONS                                     *|
 |*  OR                                                             *|
 |*  SELECT THE 'ALL' LINE ENTRY                                    *|
 |*                                                                 *|
 |*  BASED ON YOUR SELECTION, FOR EACH SELECTION (OR ALL)           *|
 |*   A SECOND PANELS ALLOWS YOU TO CHOOSE                          *|
 |*   WHICH RESPONSE DATA YOU WISH TO SEE                           *|
 |*                                                                 *|
 |*  PF3 OR END WILL PROCESS; CANCEL WILL ABORT CNC ACTION          *|
 |*  ? TO SEE THIS HELP DATA                                        *|
 \*                                                                 */
 HELPBOT2:
  HELPTOP_SRCLN = 1347
  HELPBOT_SRCLN = 1357
 /*                                                                 *\
 |* THE ABOVE SRCLN VARS ARE USE IN THE HELP OPTION                 *|
 |*  IF YOU ADD OR DELETE LINES WITHIN THE HELPTOP:HELPBOT LABELS   *|
 |*   YOU MUST ADJUST THE SCRLN VARS ACCORDINGLY                    *|
 \*                                                                 */
 /* TRACE I */
  XC = 8
  CHNM_DFT=RX_CNC_CH_NM
  AMT='CSR'
  IF RX_CNC_CH_NM \= 'COMMAREA' THEN SHOWYN='LOW'
   ELSE SHOWYN='NON'
  SELNMSG='List of Respnse Data Elements'
  SIGNAL OFF ERROR
  "ISPEXEC ADDPOP"
  /* TBLAPLID HAS 2 COLS: ACTION APPLID */
  "ISPEXEC TBCREATE TBLAPLDD "||,
    "NAMES(ACTION FA FB FC) NOWRITE REPLACE"
   IF RC > 4 THEN DO
   MSGTXT ='COULD NOT CREATE THE TBLAPLDD LIST OF RESPONSE DATA '||,
    'FOR SELECT REGIONS. WILL DEFAULT TO ALL DATA.'
   CALL   SHOWMBOX
   XC = 4
   SIGNAL DO_FIND
   END
  APLCT = WORDS(SELRGNS)
  ACTION = '-'
  FB='-'
  RSP_LST=''
  DO I = 1 TO APLCT
   APLNM = WORD(SELRGNS,I)
   RETURN_CN_LIST = RETLST.APLNM
   WP=POS('(',RETURN_CN_LIST)
   IF WP > 1 THEN DO
    RETURN_CN_LIST=SUBSTR(RETURN_CN_LIST,WP + 1)
    END
   RETURN_CN_LIST = TRANSLATE(RETURN_CN_LIST,' ',',')
   CN_CT = WORDS(RETURN_CN_LIST)
   IF CN_CT > 1 & I = 1 THEN DO
    FA='ALL'
    "ISPEXEC TBADD TBLAPLDD"
    END
   CN_WD_NUM=0
   CN_WD=''
   DO CN_WD_NUM = 1 TO CN_CT
    RSPNM=WORD(RETURN_CN_LIST,CN_WD_NUM)
    FA = RSPNM
    INTERPRET 'FC = 'RSPNM'_DATATYPE'
    IF FC \= 'B' THEN FC = 'C'
    "ISPEXEC TBADD TBLAPLDD"
    RSP_LST = RSP_LST||' '||RSPNM
    END
   END
  /* TRACE I */
  EXECSEL='DSPAFOH@'
  "ISPEXEC TBTOP TBLAPLDD"
  "ISPEXEC VPUT (EXECSEL) ASIS"
  CANSTR='CANCEL ABORT'
  DONSTR='DONE END'
  CMDSTR=CANSTR||' '||DONSTR||' RESET'
  PROCLST='-,S,U,X'
  PROCLST_WDS=TRANSLATE(PROCLST,' ',',')
  PROCLSTWD='- SELECT UNSELECT EXCLUDE'
  MCMD=''
  LSTHDR='RESPONSE REGION DATA LIST'
  CHORCN=CHNM_DFT
  MYCRP = 0
  DSEMSG=EXCI_NOTE
  SELNTYP='1'
  SELNMSG='DISPLAYING RESPONSE ELEMENTS'
  SELELMS = ''
  XCLELMS=''
 /*  TRACE ?I */
  "ISPEXEC TBDISPL TBLAPLDD PANEL(AFORSPDA) ROWID(MDROW#) POSITION(MYCRP)"
  SIGNAL ARND_DOP
 TOPOFDOP:
  ZCMD = ''
  "ISPEXEC TBTOP   TBLAPLDD"
  "ISPEXEC TBSKIP  TBLAPLDD NUMBER("ZTDTOP")"
  "ISPEXEC TBDISPL TBLAPLDD PANEL(AFORSPDA)"
 ARND_DOP:
  XC = RC
  IF XC > 8 THEN DO
   MSGTXT ='SEVERE ERROR FROM TBDISPL FUNCTION.  ABORT.'
   CALL   SHOWMBOX
   XC = 20
   SIGNAL DO_TBL_CLOD
   END
  IF WORDPOS(MCMD,CANSTR) \=  0 THEN DO
   DSEMSG='COMMAND:'MCMD' SIGNALS ABORT'
   SIGNAL DO_CAND
   END
  IF MCMD = 'RESET' THEN DO
   SELELMS = ''
   XCLELMS=''
   "ISPEXEC TBTOP TBLAPLDA"
   DO I = 1 TO ZTDROWS
    "ISPEXEC TBSKIP  TBLAPLDA NUMBER(1)"
    ACTION = '-'
    FB = '-'
    "ISPEXEC TBPUT TBLAPLDD"
    END
   SIGNAL TOPOFDOP
   END
  NUD=ZTDSELS
  HR#=MDROW#
  HC#=MYCRP
  IF ZTDSELS > 0 THEN DO
   DO WHILE (ZTDSELS > 0)
    R#=MDROW#
    R#=MYCRP
    ACT_W#=WORDPOS(ACTION,PROCLST_WDS)
    SELECT
    WHEN ACTION = 'S' THEN DO
     IF FA = 'ALL' THEN DO
      XCLELMS = ''
      SELELMS=RSP_LST
      DO I = 2 TO ZTDROWS
       "ISPEXEC TBSKIP  TBLAPLDD NUMBER(1)"
       QQQ=FA
       ACTION = '-'
       FB = 'S'
       "ISPEXEC TBPUT TBLAPLDD"
       END
      SIGNAL TOPOFDOP
      END
      ELSE DO
      IF WORDPOS(FA,SELELMS) = 0 THEN SELELMS = SELELMS||' '||FA
      XP=WORDPOS(FA,XCLELMS)
      IF XP > 0 THEN XCLELMS=DELWORD(XCLELMS,XP,1)
      END
     END           /* END 'S' */
    WHEN ACTION = 'X' THEN DO
     IF FA = 'ALL' THEN DO
      SELELMS = ''
      XCLELMS=RSP_LST
      DO I = 1 TO ZTDROWS
       "ISPEXEC TBSKIP  TBLAPLDD NUMBER(1)"
       ACTION = '-'
       FB = 'X'
       "ISPEXEC TBPUT TBLAPLDD"
       END
      SIGNAL TOPOFDOP
      END
      ELSE DO
      IF WORDPOS(FA,XCLELMS) = 0 THEN XCLELMS = XCLELMS||' '||FA
      XP=WORDPOS(FA,SELELMS)
      IF XP > 0 THEN SELELMS=DELWORD(SELELMS,XP,1)
      END
     END
    WHEN ACTION = 'U' THEN DO
     IF FA = 'ALL' THEN DO
      SELELMS = ''
      XCLELMS=''
      DO I = 1 TO ZTDROWS
       "ISPEXEC TBSKIP  TBLAPLDD NUMBER(1)"
       ACTION = '-'
       FB = '-'
       "ISPEXEC TBPUT TBLAPLDD"
       END
      SIGNAL TOPOFDOP
      END
      ELSE DO
      XP=WORDPOS(FA,SELELMS)
      IF XP > 0 THEN SELELMS=DELWORD(SELELMS,XP,1)
      XP=WORDPOS(FA,XCLELMS)
      IF XP > 0 THEN XCLELMS=DELWORD(XCLELMS,XP,1)
      END
     END
    OTHERWISE NOP
    END                      /* END SELECT */
    FB = ACTION
    ACTION = '-'
    "ISPEXEC TBPUT TBLAPLDD"
    IF ZTDSELS > 1 THEN "ISPEXEC TBDISPL TBLAPLDD"
     ELSE LEAVE
 /* IF ZTDSELS < 1 THEN LEAVE */
    END
   END
  IF XC = 8 THEN DO
   IF MCMD = '' THEN MCMD = 'END'
   END
  IF MCMD = '?'THEN DO
   CALL DO_HELP
   MCMD = ''
   SIGNAL TOPOFDOP
   END
  IF WORDPOS(MCMD,CMDSTR) = 0 THEN SIGNAL TOPOFDOP
  IF WORDPOS(MCMD,DONSTR) \= 0 THEN SIGNAL OKDOITD
  SIGNAL TOPOFDOP
/*PROCESS COMMANDS */
/*LOOP TO TOPOFLOP UNTIL SAVE COMMAND */
 OKDOITD:
 /* TRACE I */
  IF SELELMS = '' THEN DO
   IF MCMD = 'DONE' THEN DO
    XC = 4
    SIGNAL DO_TBL_CLOD
    END
   XC = 0
   DSEMSG ='PF3/END: ZERO DATA; USE CANCEL/ABORT/DONE'
   SIGNAL TOPOFDOP
   END
   IF MCMD = 'DONE' THEN XC = 4
      ELSE XC = 0
  SIGNAL DO_TBL_CLOD
 DO_CAND:
  IF MCMD = 'ABORT' THEN XC = 20
   ELSE XC = 8
 DO_TBL_CLOD:
  "ISPEXEC TBCLOSE TBLAPLDD"
 DO_FIND:
  "ISPEXEC REMPOP"
   RETURN XC
  /*                                                                 *\
  |*                                                                 *|
  \*                                                                 */
 DSP_SEL_ELM:
 /* TRACE I */
  SECT=WORDS(SELELMS_LST)
  IF SECT < 1 THEN DO
   XC = 8
   RETURN
   END
  HAPLNM=WORD(SELRGNS,1)
  MYA=LEFT(HAPLNM,8)||'-->'||XFF||EXCIRSP.HAPLNM||XFF
  MYB=''
  GOT_BIT='N'
  DO I = 1 TO SECT
   RSPNM = WORD(SELELMS_LST,I)
   FP=POS('_',RSPNM)
   IF FP > 0 THEN DO
    PARSE VAR RSPNM APLNM '_' CACNNM
    IF WORDPOS(APLNM,SELRGNS) > 0 THEN DO
     IF APLNM \= HAPLNM THEN DO
      MYA=MYA||XFF||LEFT(APLNM,8)||'-->'||XFF||EXCIRSP.APLNM||XFF
      HAPLNM = APLNM
      END
     END
    END
    ELSE DO
    MYA=MYA||RSPNM||'-->'||XFF
    END
   INTERPRET 'TMP_NM = "'RSPNM'"'
   INTERPRET 'TMP_CN_MSG = 'TMP_NM
   DT_RSPNM = RSPNM||'_DATATYPE'
   INTERPRET 'Z_DT_RSPNM = 'DT_RSPNM
   IF Z_DT_RSPNM \= 'B' THEN TMP_TYP = 'CHAR'
    ELSE TMP_TYP = 'BIT'
   IF TMP_TYP = 'CHAR' THEN DO
    MYA=MYA||'CN:'||RSPNM||XFF
    TMP_L = LENGTH(TMP_CN_MSG)
    IF TMP_L > 0 THEN DO
     TMP=SUBSTR(TMP_CN_MSG,TMP_L,1)
     IF TMP > '39'X THEN TMP = '40'X
     TMP_CN_MSG = STRIP(TMP_CN_MSG,'T',TMP)
     TMP_CN_MSG = TRANSLATE(TMP_CN_MSG,XFF,X15)
     IF SUBSTR(TMP_CN_MSG,LENGTH(TMP_CN_MSG),1) \= XFF THEN,
      TMP_CN_MSG = TMP_CN_MSG||XFF
     MYA = MYA||TMP_CN_MSG
     END
     ELSE DO
     MYA = MYA||'<CONTAINER IS EMPTY>'||XFF
     END
    END
    ELSE DO
    GOT_BIT='Y'
    MYA = MYA||'BIT_CN:'||RSPNM||XFF
 MYB = MYB||'<'||LENGTH(TMP_CN_MSG)||' '||APLNM||':BIT_CN>'||TMP_CN_MSG
    END
 /* NEED TO ACCUMULATE BIT DATA TO A DIFFERENT MYA VAR */
 /*IF SUBSTR(TMP_CN_MSG,LENGTH(TMP_CN_MSG),1) \= XFF THEN, */
 /* TMP_CN_MSG = TMP_CN_MSG||XFF                           */
 /*MYA = MYA||TMP_CN_MSG||XFF                              */
   END
 /* BASED ON DSPLYA WITHOUT USING ISPF VARS FOR DATA                */
 /*  DATA EXISTS IN RX VARS MYA                                     */
 /* BIT  DATA DISPLAY */
  IF MYB \= '' THEN DO
   DSPHEXPN = 'EXHEXDMP'
   DSEMSG = 'HEX DATA DUMP FOR BIT CONTAINERS'
   "ISPEXEC VPUT (DSPHEXPN DSEMSG) ASIS"
   CALL EXHEXDMP MYB
   END
 /* CHAR DATA DISPLAY */
  CUTV = 'DSPC'
  CUTCNT=0
  MYVERB = ''
  XC = 0
  SEP=XFF
  I = 0
  MYAW=0
  MYDP=0
  MYLVLN = 0
  "ISPEXEC PQUERY PANEL(MYDSPAD1) AREANAME(MYAREA1) "||,
   "AREATYPE(MYAT) WIDTH(MYAW) DEPTH(MYDP)"
  DN = MYDP-2
  MYSCLN = DN
  SH = MYAW
  SV = MYDP
  MXLNG = 0
  DO WHILE(MYA \= '')
   FP = POS(SEP,MYA)
   IF FP = 0 THEN FP = MXLNG
   TMP = SUBSTR(MYA,1,FP)
   MYA = SUBSTR(MYA,FP + 1)
   TL = LENGTH(TMP)
   IF TL > MXLNG THEN MXLNG = TL
   I = I+1
   MYA.I = TMP
   END
  MYA.0 = I
  SVC = I
  TOPLN = 1
  BOTLN = 1
  MXLN = I
  NEWMX = 0
  MYSCLA=''
  MYSCLD='PAGE'
  MYSC = 'PAGE'
  MYA1 = ''
  MYAT = ''
  SUDT=DATE('U')
  CURLN=1
  CURCL=1
  /* TRACE ?I */
 DSPLOOP:
  TRACE OFF
  STIM=TIME()
  TOPLN=CURLN
  TOPCL=CURCL
  BOTLN = TOPLN + DN
  IF BOTLN > MXLN THEN BOTLN = MXLN
   MYAREA1 = ''
   I = TOPLN
   DO J = 1 TO MYDP
    IF I > MXLN THEN MYA.I = ' '
    MYAREA1 = MYAREA1||LEFT(SUBSTR(MYA.I,TOPCL),MYAW)
    I = I + 1
    END
 DSPLOOP1:
  IF MYVERB = '' & CMD = '' THEN DO
   ZEDSMSG = ""
   ZEDLMSG = ""
   "ISPEXEC SETMSG MSG(ISRZ001)"
   END
  CMD = ''
  ZCMD = ''
  MYVERB=''
  HLDSCLN = MYSCLN
  "ISPEXEC DISPLAY PANEL(MYDSPAD1)"
  XC=RC
/* TRACE I */
  AVERB = MYVERB
  ACMD = CMD
  PARSE VAR CMD CMD RESP
  GG='CMD='CMD'  MYVERB='MYVERB
  "ISPEXEC VPUT (GG) ASIS"
  IF MYSCLN=0 THEN MYSCLN = HLDSCLN
  MYSCLD = MYSCLA
  IF XC = 8 THEN SIGNAL EXITRC_END
  SELECT
   WHEN MYSCLD = 'HALF' THEN DO
    SV = MYSCLN/2
    SH = MYAW/2
    END
   WHEN MYSCLD = 'PAGE' THEN DO
    SV = MYSCLN
    SH = MYAW
    END
   WHEN MYSCLD = 'MAX' THEN DO
    SV = MXLN
    SH = MXLNG
    END
   OTHERWISE DO
    IF DATATYPE(MYSRCD) \= 'NUM' THEN MYSCLD = 'PAGE'
     ELSE DO
     SV = MYSCLD
     SH = MYSCLD
     END
    END
   END
   IF CMD='HELP' | CMD='?' THEN DO
    CALL CEMHELP 'DSPLYA'
    CMD = ''
    SIGNAL DONE_CMD1
    END
   IF CMD='SAVE' | CMD='MOD' | CMD='APPEND' THEN DO
/*  TRACE ?I  */
    CALL SET_ODSN
    IF RC \= 0 | ODSN = '' THEN DO
     ZEDSMSG = 'SAVE DSN ERROR'
     ZEDLMSG = 'ERROR OCCURRED SETTING SAVE TO DSN.NOTHING SAVED'
     END
     ELSE DO
     M# = MYA.0
     MYSTM='MYA.'
     EMBR=APLNM
     TDSN = ODSN
     CALL SAVIT
     IF RESULT = 0 THEN DO
      ZEDSMSG = 'DATA SAVED'
      ZEDLMSG = 'DATASET SAVED AS DIRECTED'
      END
      ELSE DO
      ZEDSMSG = 'DATA NOT SAVED'
      ZEDLMSG = 'ERROR OCCURRED, OR ABORT SELECTED. NOTHING SAVED'
      END
     END
    CMD = ''
    "ISPEXEC SETMSG MSG(ISRZ001)"
    SIGNAL REDSPLY
    END
   IF CMD = 'CUT' | CMD = 'CUTA' THEN DO
    IF RESP \= '' THEN CUTV=RESP
     ELSE CUTV='DSPA'
    IF CMD='CUT' THEN DO
     CUTCNT=0
     END
    CALL CUTIT
    IF RESULT = 0 THEN DO
     ZEDSMSG = 'DATA 'CMD
     ZEDLMSG = 'DATA 'CMD' AS DIRECTED'
     END
     ELSE DO
     ZEDSMSG = 'DATA NOT 'CMD
     ZEDLMSG = 'ERROR OCCURRED, DATA WAS NOT 'CMD
     END
    CMD = ''
    "ISPEXEC SETMSG MSG(ISRZ001)"
    SIGNAL REDSPLY
    END
   IF CMD='OS2PW' | ABBREV('OS2PNTN',CMD,4) = 1 |,
      CMD='PMBRW' | ABBREV('PMBRN',CMD,4) = 1 THEN DO
    CALL OS2PNT
    XC=RESULT
    IF XC=0 THEN DO
     IF CMD = 'OS2PW' | CMD='PMBRW' THEN DO
      CALL JRPPNT 'JRPPNTW'
      XC=RESULT
      END
      ELSE DO
      IF CMD='PMBRC' THEN CALL JRPPNT 'JRPPNTC'
       ELSE CALL JRPPNT 'JRPPNT'
      XC=RESULT
      END
     END
     IF XC = 0 | XC > 20 THEN DO
      ZEDSMSG = 'DATA PRINTED 'XC
      ZEDLMSG = 'DATASET PRINTED AS DIRECTED TO JRP'XC
      END
      ELSE DO
      ZEDSMSG = 'DATA NOT PRINTED'
      ZEDLMSG = 'ERROR OCCURRED, OR ABORT SELECTED. NOTHING PRINTED.'
      END
/*   END    */
    CMD = ''
    "ISPEXEC SETMSG MSG(ISRZ001)"
    SIGNAL REDSPLY
    END
   IF CMD = 'PFAPNT'| CMD='PFAEDIT'  THEN DO
    'ISPEXEC VGET (EXECSEL FAIDODSN) ASIS'
    IF EXECSEL = 'PFA' & FAIDODSN \= '' THEN DO
     IF FAIDODSN = '' | FAIDODSN = 'FAIDODSN' THEN RESULT=4
      ELSE DO
       IF CMD='PFAPNT' THEN JRPPNT 'JRPPNT' FAIDODSN
       IF CMD='PFAEDIT' THEN ,
        "ISPEXEC EDIT DATASET ('"FAIDODSN"')"
       END
      END
     IF RESULT = 0 THEN DO
      ZEDSMSG = 'FAID PRINTED'
      ZEDLMSG = 'DATASET PRINTED AS DIRECTED'
      END
      ELSE DO
      ZEDSMSG = 'DATASET NOT PRINTED'
      ZEDLMSG = 'FAID DATASET COULD NOT BE PRINTED.'
      END
    CMD = ''
    "ISPEXEC SETMSG MSG(ISRZ001)"
    SIGNAL REDSPLY
    END
DONE_CMD1:
   IF CMD \= '' & MYVERB = '' THEN MYVERB=CMD
  IF MYVERB = 'TOP' THEN DO
   MYVERB = 'UP'
   MYSCLD = 'MAX'
   END
  IF MYVERB = 'BOT' THEN DO
   MYVERB = 'DOWN'
   MYSCLD = 'MAX'
   END
  SELECT
   WHEN MYVERB = '' THEN SIGNAL DSPLOOP1
   WHEN MYVERB = 'END' THEN SIGNAL EXITRC_END
   WHEN MYVERB = 'ABORT' THEN SIGNAL EXITRC_ABORT
   WHEN MYVERB = 'BYPASS' THEN SIGNAL EXITRC_BYPASS
   WHEN MYVERB = 'CANCEL' THEN SIGNAL EXITRC_ABORT
   WHEN MYVERB = 'LEFT' THEN DO
    IF MYSCLD \= 'MAX' THEN DO
     CURCL = CURCL-SH
     IF CURCL < 1 THEN CURCL=1
     SIGNAL DSPLOOP
     END
     ELSE DO
     CURCL = 1
     SIGNAL DSPLOOP
     END
    END
   WHEN MYVERB = 'RIGHT' THEN DO
    IF MYSCLD \= 'MAX' THEN DO
     CURCL = CURCL+SH
     IF CURCL > MXLNG THEN DO
      CURCL=(MXLNG-SH)+1
      IF CURCL < 1 THEN CURCL = 1
      END
     SIGNAL DSPLOOP
     END
     ELSE DO
     CURCL = MXLNG-MYAW+1
     IF CURCL < 1 THEN CURCL = 1
     SIGNAL DSPLOOP
     END
    END
   WHEN MYVERB = 'UP' THEN DO
    IF MYSCLD \= 'MAX' THEN DO
     CURLN = TOPLN - MYSCLN
     IF CURLN < 1 THEN CURLN=1
     SIGNAL DSPLOOP
     END
     ELSE DO
     CURLN = 1
     SIGNAL DSPLOOP
     END
    END
   WHEN WORD(MYVERB,1)='L' THEN DO
    IF WORDS(MYVERB) \= 2 THEN LEAVE
    TMPLN=WORD(MYVERB,2)
    IF DATATYPE(TMPLN) \= 'NUM' THEN LEAVE
    IF TMPLN < 1 THEN TMPLN = 1
     ELSE IF TMPLN > MXLN THEN TMPLN = MXLN
    CURLN = TMPLN
    SIGNAL DSPLOOP
    END
   WHEN MYVERB = 'DOWN' THEN DO
    IF MYSCLD \= 'MAX' THEN DO
     CURLN = TOPLN + MYSCLN
     IF CURLN > MXLN THEN CURLN = MXLN - MYSCLN + 1
     IF CURLN < 1 THEN CURLN = 1
     SIGNAL DSPLOOP
     END
     ELSE DO
     CURLN = MXLN-MYSCLN+1
     IF CURLN < 1 THEN CURLN=1
     SIGNAL DSPLOOP
     END
    END
   OTHERWISE DO
    ZEDSMSG = MYVERB" INVALID"
    ZEDLMSG = "INVALID COMMAND ENTERED. NORMAL NAVIGATE CMD"
    "ISPEXEC SETMSG MSG(ISRZ001)"
    END
   END
 REDSPLY:
  CURCL=TOPCL
  CURLN=TOPLN
  SIGNAL DSPLOOP
 EXITRC_END:
  XC = 0
  ZEDSMSG = "DATA DISP OK"
  ZEDLMSG = "DATA DISPLAYED FINISHED NORMALLY"
  SIGNAL WRITIT
 EXITRC_BYPASS:
  XC = 4
  ZEDSMSG = "BYPASS REST"
  ZEDLMSG = "DATA DISPLAYED BYPASS REST OF DATA"
  SIGNAL WRITIT
 EXITRC_ABORT:
  XC = 8
  ZEDSMSG = "DATA DISP ABORT"
  ZEDLMSG = "DATA DISPLAY ABORTED BY COMMAND"
  SIGNAL WRITIT
 WRITIT:
  "ISPEXEC SETMSG MSG(ISRZ001)"
  RETURN XC
 XSAVIT: PROCEDURE EXPOSE MYA. MXLNG EXECSEL CMD AUTOSAVE
  /* TRACE ?I */
  SAY 'XSAVIT ROUTINE SHOULD NEVER BE INVOKED'
  PULL ANS
  "ISPEXEC VGET (DSPLYADS EMBR) ASIS"
  IF RC \= 0 THEN DO
   EDSN=SYSVAR(SYSUID)'.'EXECSEL'.DATA'
   EMBR=''
   END
   ELSE EDSN=DSPLYADS
  IF AUTOSAVE = 'Y' THEN DO
   EDSN=DSPLYADS
   EMBR='$'
   TDSN=EDSN
   SIGNAL DO_AS
   END
  DSEMSG='ENTER TARGET DSN (NO MBR)'
  MYAT='INPUT'
  "ISPEXEC VPUT (EDSN EMBR DSEMSG MYAT) ASIS"
  CALL GDSNNMBR
  IF RESULT = 8 THEN RETURN 8
  "ISPEXEC VGET (EDSN EMBR) ASIS"
  IF RC \= 0 THEN RETURN
  EMBR=STRIP(EMBR,'B')
  XMBR = ''
  /* DSN COULD HAVE BEEN SPECIFIED AS DSN(MBR)
     OR THE DSN AND MBR INPUT IN PANEL FIELDS,
     OR (CONFUSED) BOTH (IN WHICH CASE WE TAKE THE DSN(MBR)
     FORMATED BECAUSE WE FIGURE IT WAS INTENTIONAL).
  */
  PARSE VAR EDSN EDSN '(' XMBR ')'
  TDSN=EDSN
  IF XMBR \= '' THEN EMBR = XMBR
DO_AS:
  IF EMBR = '$' THEN EMBR = EXECSEL
  /* SIMPLE CHECK TO INSURE DSN NOT MIGRATED */
  CALL MALOC TDSN
  XC=RESULT
  IF XC = 0 THEN SIGNAL CHKORG
  IF EMBR = '' THEN MYDSO='PS)'
   ELSE MYDSO='PO) DSNTYPE(LIBRARY)'
  MODDSN = ''
  IF MXLNG < 128 THEN MXLNG = 128
  M=MXLNG+4
  DSEMSG = '(D) DEL/REALLOC,(A) ABORT'
  MODATTR="NEW BLKSIZE("M+4") DSORG("MYDSO" RECFM(V,B) SPACE(1,1)"||,
   "CYLINDER LRECL("M") CATALOG REUSE"
  EDSN = TDSN
  ADDRESS ISPEXEC "VPUT (EDSN EXECSEL DSEMSG MODATTR MODDSN) ASIS"
  IF RC \= 0 THEN SIGNAL EXITRC_END
  CALL ALOCDSN
  XC = RESULT
  "ISPEXEC VGET (EDSN) ASIS"
  IF RC \= 0 THEN RETURN 4
  SIGNAL DOWRITE
 XCHKORG:
  XC=LISTDSI("'"TDSN"'" DIRECTORY NORECALL)
  MYDSO=SYSDSORG
  IF EMBR \= '' THEN DO
   IF MYDSO = 'PS' THEN SIGNAL BADOPDSNORG
   END
   ELSE DO
   IF MYDSO = PO THEN SIGNAL BADOPDSNORG
   IF AUTOSAVE = 'Y' THEN DSPVAL='MOD'
   END
  DOWRITE:
  /* TRACE ?I */
  DSPLYADS=EDSN
  "ISPEXEC VPUT (DSPLYADS EMBR) ASIS"
  IF EMBR \= '' THEN EDSN=TDSN||'('||EMBR||')'
  IF XC = 0 THEN DO
   M# = MYA.0
   MSTM='MYA.'
   IF CMD = 'MOD' | CMD = 'APPEND' THEN DSPVAL='MOD'
    ELSE DSPVAL='SHR REUSE'
   IF EMBR \= '' THEN DO
    IF DSPVAL = 'MOD' THEN DO
     DSPVAL='SHR REUSE'
     ADDRESS TSO "ALLOC FI(I) DA('"EDSN"') "DSPVAL
     ADDRESS TSO "EXECIO * DISKR I (STEM MYB. FINIS"
     ADDRESS TSO "FREE FI(I)"
     MSTM='MYB.'
     MB#=MYB.0
     DO I = 1 TO M#
      MB#=MB# + 1
      MYB.MB#=MYA.I
      END
     M#=MB#
     END
    END
   ADDRESS TSO "ALLOC FI(O) DA('"EDSN"') "DSPVAL
   ADDRESS TSO "EXECIO "M#" DISKW O (STEM "MSTM" FINIS"
   ADDRESS TSO "FREE FI(O)"
   AUTOSAVE = 'N'
   CALL MSGBOX 'DATA SAVED TO 'EDSN
   RETURN 0
  END
  RETURN XC
BADOPDSNORG:
   CALL MSGBOX 'SAVE TO DSN DSORG INCONSISTENT WITH EXISTING DSN'
   RETURN 4
OS2PNT: PROCEDURE EXPOSE SVC MYA. XC
 IF SVC ^> 0 THEN RETURN 4
 DO I = 1 TO SVC
  INTERPRET 'OS2C'||I'= MYA.I'
  'ISPEXEC VPUT (OS2C'I') ASIS'
  END
 MYCN = 'OS2C'
 OS2CTOT = SVC
  ZEDSMSG = "DATA PRINTED"
  ZEDLMSG = "DATA SENT TO PRINTER"
 "ISPEXEC SETMSG MSG(ISRZ001)"
 "ISPEXEC VPUT (MYCN OS2CTOT) ASIS"
 RETURN 0
CUTIT: PROCEDURE EXPOSE SVC MYA. CUTV CUTCNT XC
 IF SVC ^> 0 THEN RETURN 4
 CVSTR=''
 DO I = 1 TO SVC
  CUTCNT=CUTCNT+1
  INTERPRET CUTV||CUTCNT'= MYA.I'
  'ISPEXEC VPUT ('CUTV||CUTCNT') ASIS'
  END
  INTERPRET CUTV'TOT = CUTCNT'
 'ISPEXEC VPUT ('CUTV'TOT) ASIS'
 RETURN 0
###END DSPAFOH0
$$$BEG YZ
/* REXX */
TRACE ?I
SP = ' '
WDL='A B C'
WDV='1 2 3'
MYSIT = DS
SMP = 'SIT.'MYSIT'.SYMBS'
INTERPRET SMP' = ""'
DO I = 1 TO WORDS(WDL)
 INTERPRET SMP'='SMP'||SP||WORD(WDL,I)'
 SAY SMP
 INTERPRET 'ZMP ='SMP
 SAY ZMP
 END
INFO='D'
X=ABBREV('DISPLAY',INFO)
INFO='DIS'
X=ABBREV('DISPLAY',INFO)
INFO='DISPLAY'
X=ABBREV('DISPLAY',INFO)
INFO='DISPLAYX'
X=ABBREV('DISPLAY',INFO)
EXIT
ARG MYARG
SAY MYARG
MYARG='CDT'
PUSH MYARG
T='AAA BBB CCC'
U='ICN'||SUBSTR('0000'||WORDS(T),4,2)||'LST'
SAY U
RETURN MYARG
###END YZ
$$$BEG COPYSELD
)ATTR
  + TYPE(TEXT) INTENS(LOW) SKIP(ON)
  _ TYPE(INPUT) INTENS(HIGH) CAPS(ON)
   TYPE(INPUT) INTENS(low) CAPS(ON)
  ! TYPE(TEXT) INTENS(HIGH) SKIP(ON) COLOR(TURQ) HILITE(REVERSE)
  \ TYPE(TEXT) INTENS(HIGH) SKIP(ON) COLOR(RED)
  @ TYPE(OUTPUT) INTENS(LOW) CAPS(OFF)
  $ TYPE(OUTPUT) INTENS(HIGH) CAPS(OFF) COLOR(GREEN)
  { TYPE(OUTPUT) INTENS(LOW) CAPS(OFF) COLOR(TURQ)
)BODY
!Do NOT use this version:use TTED.TSK.D.TCEM.ISPPLIB(COPYSELD) +
!CICS Copy SElector+ Cmd:ZCMD    + Date>$SUDT    + Time>$STIM +
+ $dsemsg
+  Please Provide Required Selections:
+    CICS Region Type _Z   +     (valid is Expr Test Accp Prod ALL)
+    CICS Release Num _Z  +      (any valid 3 digits, or 999 for all)
+
+    OR Single APPLID _myaplid + (select one CICS Copy by APPLID)
+(opt.) Single CPU ID _Z+        (select one CPU to limit copy seln.)
+                             or (1,2,3,4,5 or # for all)
!OPTIONAL+ Enter n for List Only; Report on Copy Table Suffixes enter y,
+ Search JCL symbolics enter j, then  enter symb selection(s) in fields
+ Search SIT parms enter p, then enter parm selection(s) in fields
+ Default Criteria:\Tables;+ Make selection(s)Z      +
+  mt1     mt2     mt3     mt4     mt5     mt6     mt7     mt8     +
+  mt9     mt10    mt11    mt12    mt13    mt14    mt15    mt16    +
+ (overwite any, or all.  blank to remove specific selection)
+
+Sel JCL mbr info e.g.(UPx,COLDx,EMERx,DOWNx,UCC7x,VERFx,JRNLx,BTCHx)+
+ (x = j for a job name, or m for the SYSJCL COLD mbr name)_sjm  +
+Enter Target DSN specify where to Save Result List, or enter DISPLAY
+       >_myds                                        +<
+
)INIT
 .CURSOR=zcmd
 .ZVARS='(tgt,crel,mycpuid,tblresp)'
)PROC
 &CMD=&ZCMD
 &myverb=&zverb
 &myscln=&zscrolln
 VER (&tgt,NB,LIST,EXPR,TEST,ACCP,PROD,ALL)
 VER (&crel,NB,NUM)
 VER (&tblresp,NB)
 VER (&sjm,NB,LIST,UPJ,COLDJ,EMERJ,DOWNJ,UCC7J,VRFYJ,JRNLJ,BTCHJ, +
     UPM,COLDM,EMERM,DOWNM,UCC7M,VRFYM,JRNLM,BTCHM)
 ver (&myds,NB)
 if (&myds ^= DISPLAY)
     VER (&myds,DSNAME)
)END
###END COPYSELD
$$$BEG DSPAFODO
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA DSPAFOD  - SUBROUTINE TO AFOLIST. SEE AFOLIST           */
 /* CEMHELP DSPAFOD  - SUBROUTINE TO AFOLIST. SEE AFOLIST           */
 /* CEMHELP          - V2                                           */
 /* CEMHELP END                                                     */
 /* PRESERVED COPY OF DSPAFOD AS PRE CNC COPY 20190319 */
 /* PRESERVED COPY OF DSPAFOD AS PRE CNC COPY 20190319 */
 /* PRESERVED COPY OF DSPAFOD AS PRE CNC COPY 20190319 */
 /* PRESERVED COPY OF DSPAFOD AS PRE CNC COPY 20190319 */
 /* PRESERVED COPY OF DSPAFOD AS PRE CNC COPY 20190319 */
 /* PRESERVED COPY OF DSPAFOD AS PRE CNC COPY 20190319 */
 /* WHEN SELECTING INDIVIDUAL REGIONS, YOU CAN DEFER INDIVIDUAL     */
 /* BY ENTERING THE PRIMARY COMMAND (CEMT, CEDA,...) FOLLOWED BY    */
 /*  THE WORD LIST.                                                 */
 /* THE VAR D_STR  IS PREPENDED WITH '@ ' AND THEN THE CMD WORD     */
 /*  EACH RGN FLD SELECTED WILL BE CONCAT TO THE D_STR              */
 /*  FINALLY WHEN THE ALL FLDS ARE PROCESSED, INVOKE THE DSPAFOC    */
 /*  TO GET THE 'CMD' DATA REQUEST, AND THE RETURN HERE TO          */
 /*  CALL EXCI ONE AFTER ANOTHER                                    */
 /*                                                                 */
 ADDRESS ISPEXEC
 /*TRACE I */
 ARG MYTYP MYTYTOT
 AFOLISTV=''
 AFOLISNM=''
 "ISPEXEC VGET (AFOLISNM AFOLISTV) ASIS"
 FSAVSTR=''
 IF MYTYTOT = '' THEN DO
  ADDRESS ISPEXEC
  "ISPEXEC VGET (MYTYP MYTYTOT DSEMSG) ASIS"
  IF RC \= 0 THEN SIGNAL NOPOOL
  AFOLISTV = DSEMSG
  END
 DSEMSG=' '
 MYAREA=''
 IF MYTYTOT \> 0 THEN SIGNAL NOPOOL
 A = VALUE(MYTYP)
 MXLNG = 0
 APLP=WORDPOS('MYAPLID',AFOLISTV)
 DO I = 1 TO MYTYTOT
  VGETSTR=VGETSTR||' '||MYTYP||I
  END
 BKSLH = ' \'
 FNDWDS='\@ \$ \! \\'  /* SUBSTITUTE \ APPLID JOBNAME */
 RWCT=WORDS(FNDWDS)
 SUBWDS='MYAPLID JOBN S#PARM BKSLH'
 TECCMDS = 'CEMT CEDA PLAY'
 TC1='E D P'
 VALCMDS = 'PING LINK '||TECCMDS||' PING MAKE APPEND'
 VALCMD1 = 'G L '||TC1||' Q M A'
 DFT_UCEMPIN='UCEMPINQ'
 DFT_PING_CAL=1008
 MAX_CAL=32400
 DFT_CAL=4080
 TEST=''
 ACCP=''
 PROD=''
 MYCCPU = MVSVAR('SYSNAME')
 "ISPEXEC VGET ("VGETSTR") ASIS"
 DO I = 1 TO MYTYTOT
  INTERPRET 'TMP = 'A||I
  SRCT.I = SUBSTR(TMP,1,24)
  TEST=TEST||' '||WORD(SRCT.I,APLP)
  SRCA.I = SUBSTR(TMP,26,24)
  ACCP=ACCP||' '||WORD(SRCA.I,APLP)
  SRCP.I = SUBSTR(TMP,51,24)
  PROD=PROD||' '||WORD(SRCP.I,APLP)
  END
 TEST=STRIP(TEST,'B')
 ACCP=STRIP(ACCP,'B')
 PROD=STRIP(PROD,'B')
 APLLSTALL = TEST||' '||ACCP||' '||PROD
 VALLISTS='TEST ACCP PROD APLLSTALL '
  "ISPEXEC VGET (MYAFOIND CURGRP CURCPU CURCPUG) ASIS"
 VALCPU = ''
 L_CPUG=LENGTH(CURCPUG)
 VALCPU = ''
 DO I = 1 TO L_CPUG
  TH = SUBSTR(CURCPUG,I,1)
  INTERPRET 'VALCPU = VALCPU || " 'TH'SYS"'
  END
 VALCPU = STRIP(VALCPU,'B')
 'ISPEXEC VGET (HOSTLIST) ASIS'
 'ISPEXEC VGET ('HOSTLIST') ASIS'
 VALLISTS=VALLISTS||HOSTLIST
 CURRLIST = ''
 TMPLST='CURRLIST'
 MAFOLSTS=''
 CALL DSPAFOE
 'ISPEXEC VGET (MAFOLSTS) ASIS'
 'ISPEXEC VGET ('MAFOLSTS') ASIS'
 /* TRACE I
 NW=WORDS(MAFOLSTS)
 DO I = 1 TO NW
  INTERPRET 'XX='WORD(MAFOLSTS,I)
  END
 */
 MAFOLSTS='CURRLIST '||MAFOLSTS
 VALLISTS=VALLISTS||' '||MAFOLSTS
 /* TRACE I */
 MXLNG = 79
 SUDT=DATE('U')
 BOTLN=MYTYTOT
 CURLN=1
 CURCL=1
 SP78=COPIES(' ',78)
 DL78=SUBSTR('-'||SP78,1,78)
  "ISPEXEC VGET (ZSCREEND) ASIS"
  MYSCRD=ZSCREEND-4
  MYPNLD='AFOLTABD'
  IF MYSCRD > 20 THEN DO
   IF MYSCRD > 39 THEN MYSCRD = 39
   MYPNLD='AFOLTABE'
   END
  UP_PG=MYSCRD-1
  MYVERB1 = ''
  D_STR = ''
  ERRMSG=''
DSPLOOP:
  /* TRACE I */
 CMDIND=0
 "ISPEXEC VPUT (CMDIND) ASIS"
 STIM=TIME()
 TOPLN=CURLN
 TOPCL=CURCL
 DO I = 1 TO MYSCRD
  INTERPRET 'MITAT'I'= ""'
  INTERPRET 'MITAA'I'= ""'
  INTERPRET 'MITAP'I'= ""'
  IF CURLN > BOTLN THEN DO
   INTERPRET 'MYDST'I' = DL78'
   INTERPRET 'MYDSA'I' = DL78'
   INTERPRET 'MYDSP'I' = DL78'
   END
   ELSE DO
   TLNG = 80
   INTERPRET 'MYDST'I' = SRCT.CURLN'
   INTERPRET 'MYDSA'I' = SRCA.CURLN'
   INTERPRET 'MYDSP'I' = SRCP.CURLN'
   END
  CURLN = CURLN + 1
    TRACE OFF
  END
 /* TRACE I */
 CMD = ''
 CMD1 = ''
 MYVERB=''
 MYEND=''
 IF ERRMSG \= '' THEN DO
  DSEMSG=ERRMSG
  ERRMSG = ''
  END
  ELSE DO
  DSEMSG=D_STR
  END
 "ISPEXEC DISPLAY PANEL("MYPNLD")"
 LASTCC=RC
 IF LASTCC > 16 THEN DO
  SAY 'DISPLAY PANEL:'MYPNLD': RETURNED ERROR:'LASTCC':ABORT'
  RETURN 20
  END
 /* TRACE I */
 MYCMD = WORD(CMD,1)
 MYVERB1 = CMD
 IF CMD \= '' THEN "ISPEXEC VPUT (CMD) ASIS"
 IF CMD = 'END' THEN SIGNAL TRYEND
 IF LASTCC = 8 THEN RETURN 8
 IF CMD = 'CANCEL' THEN RETURN 8
 IF CMD = '' THEN SIGNAL DO_LOOP
 IF CMD = '?' THEN SIGNAL SHOWNLOOP
 IF CMD = 'LISTS?' THEN SIGNAL SHOWLISTS
 IF MYCMD = 'SHOWLIST' THEN SIGNAL SHOWONELIST
 /* TRACE I */
 WP=WORDPOS(MYCMD,VALCMDS)
 IF WP = 0 THEN SIGNAL DO_LOOP
 CMD1 = WORD(VALCMD1,WP)
 CMD_W2 = WORD(CMD,2)
 /* TRACE I */
 IF CMD1 = 'M' THEN DO
  /* TRACE ?I */
  IF CMD_W2 = '' THEN TMPLST='CURRLIST'
   ELSE DO
    IF LENGTH(CMD_W2) < 3 | LENGTH(CMD_W2) > 8 | ,
     (DATATYPE(SUBSTR(CMD_W2,1,1)) \= 'CHAR') THEN DO
     ERRMSG = 'MAKE VAR NAME INVALID (3-8 CHARS)'
     SIGNAL DO_LOOP
     END
    TMPLST=CMD_W2
   END
  IF WORDPOS(TMPLST,MAFOLSTS) = 0 THEN DO
   MAFOLSTS=MAFOLSTS||' '||TMPLST
   VALLISTS=VALLISTS||' '||TMPLST
   END
  INTERPRET TMPLST'=""'
  "ISPEXEC VPUT ("TMPLST") ASIS"
  D_STR = ''
  MYCMD='APPEND'
  ZCMD='APPEND'
  CMD1='A'
  SIGNAL DO_LOOP
  END
 IF CMD1 = 'A' THEN SIGNAL DO_LOOP
 CMD_W2 = WORD(CMD,2)
 IF CMD1 \= 'P' THEN SIGNAL ARNDPLAY
 /* TRACE I */
 IF CMD_W2 = '' THEN DO
  CMD1=''
  CALL MSGBOX 'ERROR:PLAY LIST SELECT MISSING.VALID LISTS:'MAFOLSTS
  SIGNAL ARND_LOOP
  END
 /*
 CALL GET_PLAY
 IF RC > 5 THEN SIGNAL ARND_LOOP
 DROP AFOSC.
 SCRPCMDI=0
 AFOSCTOT=0
 ADDRESS TSO "NEWSTACK"
 HDSEMSG = DSEMSG
 DSEMSG='ENTER VALID COMMANDS'
 "ISPEXEC VPUT (DSEMSG) ASIS"
 CALL REXXSRC "PULL(AFOSC)"
 XC = RESULT
 DSEMSG = HDSEMSG
 IF XC > 2 THEN DO
  CMD1=''
  CALL MSGBOX 'ERROR:PLAY LIST: COULD NOT CAPTURE SCRIPT.'
  SIGNAL ARND_LOOP
  END
 MY#VCT = QUEUED()
 IF MY#VCT > 99 THEN DO
  CMD1=''
  CALL MSGBOX 'ERROR:PLAY LIST: TOO MANY COMMANDS IN SCRIPT:'MY#VCT
  SIGNAL ARND_LOOP
  END
 K=0
 SCRPTLST=''
 DO J = 1 TO MY#VCT
  PULL AFOSC.J
  SCRPTMP=STRIP(AFOSC.J,'B')
  IF SCRPTMP  \= '' THEN DO
   IF SUBSTR(SCRPTMP,1,1) = '#' THEN ITERATE
   K=K+1
   INTERPRET 'AFOSC'K' = SCRPTMP'
   SCRPTLST=SCRPTLST||' AFOSC'||K
   END
  END
 ADDRESS TSO "DELSTACK"
 IF K < 1 THEN DO
  CMD1=''
  CALL MSGBOX 'ERROR:PLAY LIST: NO COMMANDS IN SCRIPT!'
  SIGNAL ARND_LOOP
  END
 AFOSCTOT=K
 "ISPEXEC VPUT (AFOSCTOT) ASIS"
 "ISPEXEC VPUT ("SCRPTLST") ASIS"
 IF RC \= 0 THEN DO
  CMD1=''
  CALL MSGBOX 'ERROR:PLAY LIST: COULD NOT SAVE COMMANDS'
  SIGNAL ARND_LOOP
  END
  */
ARNDPLAY:
 /* TRACE I */
 IF CMD_W2 = 'LIST' THEN DO
  IF D_STR = '' THEN  D_STR = '@ '||MYCMD||' '
  SIGNAL DO_LOOP
  END
 TX=WORDPOS(CMD_W2,VALCPU)
 IF TX \= 0 THEN DO
  TH = SUBSTR(WORD(VALCPU,TX),1,1)
  /* INTERPRET "D_STR = CPUHOST"TH */
  INTERPRET "D_STR = "TH"SYS"
  IF WORDS(D_STR) = 0 THEN SIGNAL DO_LOOP
  SIGNAL DO_INTGI
  END
 IF WORDPOS(CMD_W2,'TEST ACCP PROD') \= 0 THEN DO
  INTERPRET "D_STR = "CMD_W2
  SIGNAL DO_INTGI
  END
 TX=WORDPOS(CMD_W2,MAFOLSTS)
 IF TX = 0 THEN DO
  CALL MSGBOX 'ERROR:LIST('CMD_W2') IS NOT VALID'
  D_STR = ''
  SIGNAL ARND_LOOP
  END
 TH = CMD_W2
/* IF TH = 'CURRLIST' THEN D_STR=CURRLIST
  ELSE DO                                  */
 IF WORDPOS(TH,MAFOLSTS) > 0  THEN DO
  'ISPEXEC VGET ('TH') ASIS'
  IF RC \= 0 THEN DO
   CMD1=''
   CALL MSGBOX 'ERROR:INV LIST:'D_STR'<VALID LISTS:'MAFOLSTS
   SIGNAL ARND_LOOP
   END
  TMPLST = TH
  INTERPRET 'D_STR = 'TH
  END
 IF WORDS(D_STR) = 0 THEN DO
  CALL MSGBOX 'ERROR:EMPTY LIST:'D_STR'<'
  D_STR = ''
  SIGNAL ARND_LOOP
  END
/*  SIGNAL DO_INTGI
  END */
DO_INTGI:
 TMP=CMD1
 CALL INTGI
DO_INTGI_X:
 D_STR = ''
 MYCMD = ''
 CMD = ''
 ZCMD=''
    TRACE OFF
 SIGNAL ARND_LOOP
SHOWLISTS:
 CALL MSGBOX 'KNOWN LISTS:'||VALLISTS
 SIGNAL ARND_LOOP
SHOWONELIST:
  CMD_W2 = WORD(CMD,2)
  IF WORDPOS(CMD_W2,VALLISTS) \= 0 THEN DO
   INTERPRET 'XXX = 'CMD_W2
   IF XXX = CMD_W2 THEN 'ISPEXEC VGET ('XXX') ASIS'
   INTERPRET 'MSGBOXTX = 'XXX
   END
   ELSE MSGBOXTX = CMD_W2' IS NOT A VALID LIST'
 CALL MSGBOX 'LIST:'CMD_W2'='MSGBOXTX
 SIGNAL ARND_LOOP
SHOWNLOOP:
 CALL MSGBOX 'COMMANDS: '||VALCMDS||' LISTS? SHOWLIST END OR CANCEL'
 SIGNAL ARND_LOOP
DO_LOOP:
 /* TRACE I */
 CL=TOPLN
 HYCMD = ''
 DO I = 1 TO MYSCRD
  Q = I + TOPLN - 1
  DO T = 1 TO 1
   INTERPRET 'TMP = MITAT'I
   TP=WORDPOS(TMP,VALCMD1)
   IF TP \= 0 THEN DO
    IF TMP = 'M' | TMP = 'A' THEN DO
     "ISPEXEC VGET ("TMPLST") ASIS"
     IF RC > 0 THEN INTERPRET TMPLST" = ''"
     INTERPRET 'TMP = 'TMPLST
     TMP = TMP ||' '||WORD(SRCT.Q,1)
     D_STR=TMP
     INTERPRET TMPLST '= TMP'
     "ISPEXEC VPUT ("TMPLST") ASIS"
     LEAVE T
     END
     ELSE DO
     MYCMD=WORD(VALCMDS,TP)
     END
    END
   IF TMP = "I" THEN DO
    LNREST = SRCT.Q
    CALL INTCI
    LEAVE T
    END
   IF WORDPOS(TMP,VALCMD1) \= 0 THEN DO
    IF WORD(D_STR,1) = '@' THEN DO
     D_STR=D_STR||' '||WORD(SRCT.Q,1)
     LEAVE T
     END
    LNREST = SRCT.Q
    D_STR=WORD(SRCT.Q,1)
    CALL INTGI
    LEAVE T
    END
   IF TMP = "V" THEN DO
    LNREST = SRCT.Q
    CALL INTVI
    LEAVE T
    END
   END T
  DO A = 1 TO 1
   INTERPRET 'TMP = MITAA'I
   TP=WORDPOS(TMP,VALCMD1)
   IF TP \= 0 THEN DO
    IF TMP = 'M' | TMP = 'A' THEN DO
     "ISPEXEC VGET ("TMPLST") ASIS"
     IF RC > 0 THEN INTERPRET TMPLST" = ''"
     INTERPRET 'TMP = 'TMPLST
     TMP = TMP ||' '||WORD(SRCA.Q,1)
     D_STR=TMP
     INTERPRET TMPLST '= TMP'
     "ISPEXEC VPUT ("TMPLST") ASIS"
     LEAVE A
     END
     ELSE DO
     MYCMD=WORD(VALCMDS,TP)
     END
    END
   IF TMP = "I" THEN DO
    LNREST = SRCA.Q
    CALL INTCI
    LEAVE A
    END
   IF WORDPOS(TMP,VALCMD1) \= 0 THEN DO
    IF WORD(D_STR,1) = '@' THEN DO
     D_STR=D_STR||' '||WORD(SRCA.Q,1)
     LEAVE A
     END
    LNREST = SRCA.Q
    D_STR=WORD(SRCA.Q,1)
    CALL INTGI
    LEAVE A
    END
   IF TMP = "V" THEN DO
    LNREST = SRCA.Q
    CALL INTVI
    LEAVE A
    END
   END A
  DO P = 1 TO 1
   INTERPRET 'TMP = MITAP'I
   TP=WORDPOS(TMP,VALCMD1)
   IF TP \= 0 THEN DO
    IF TMP = 'M' | TMP = 'A' THEN DO
     "ISPEXEC VGET ("TMPLST") ASIS"
     IF RC > 0 THEN INTERPRET TMPLST" = ''"
     INTERPRET 'TMP = 'TMPLST
     TMP = TMP ||' '||WORD(SRCP.Q,1)
     D_STR=TMP
     INTERPRET TMPLST '= TMP'
     "ISPEXEC VPUT ("TMPLST") ASIS"
     LEAVE P
     END
     ELSE DO
     MYCMD=WORD(VALCMDS,TP)
     END
    END
   IF TMP = "I" THEN DO
    LNREST = SRCP.Q
    CALL INTCI
    LEAVE P
    END
   IF WORDPOS(TMP,VALCMD1) \= 0 THEN DO
    IF WORD(D_STR,1) = '@' THEN DO
     D_STR=D_STR||' '||WORD(SRCP.Q,1)
     LEAVE P
     END
    LNREST = SRCP.Q
    D_STR=WORD(SRCP.Q,1)
    CALL INTGI
    LEAVE P
    END
   IF TMP = "V" THEN DO
    LNREST = SRCP.Q
    CALL INTVI
    LEAVE P
    END
   END P
  IF I > 1 THEN TRACE OFF
  END
 /*TRACE I */
ARND_LOOP:
 IF MYVERB = 'LEFT' THEN DO
  CURCL = CURCL-78
  IF CURCL < 1 THEN CURCL=1
  SIGNAL REDSPLY
  END
 IF MYVERB = 'LEFT M' THEN DO
  CURCL = 1
  SIGNAL REDSPLY
  END
 IF MYVERB = 'RIGHT' THEN DO
  CURCL = CURCL+78
  IF CURCL > MXLNG THEN DO
   CURCL=MXLNG-77
   IF CURCL < 1 THEN CURCL = 1
   END
  SIGNAL REDSPLY
  END
 IF MYVERB = 'RIGHT M' THEN DO
  CURCL = MXLNG-77
  IF CURCL < 1 THEN CURCL = 1
  SIGNAL REDSPLY
  END
 IF MYVERB = 'UP' THEN DO
  CURLN = TOPLN-UP_PG
  IF CURLN < 1 THEN CURLN=1
  SIGNAL DSPLOOP
  END
 IF MYVERB = 'UP M' THEN DO
  CURLN = 1
  SIGNAL DSPLOOP
  END
 IF MYVERB = 'DOWN M' THEN DO
  CURLN = BOTLN-MYSCRD
  IF CURLN < 1 THEN CURLN=1
  SIGNAL DSPLOOP
  END
 IF MYVERB = 'DOWN' THEN DO
  IF CURLN > BOTLN THEN SIGNAL REDSPLY
  CURLN = CURLN - 1
  SIGNAL DSPLOOP
  END
 /* TRACE I */
  IF WORD(D_STR,1) = '@' THEN DO
   PARSE VAR D_STR '@' CMD  D_STR
   WP=WORDPOS(MYCMD,VALCMDS)
   TMP = WORD(VALCMD1,WP)
   IF D_STR \= '' THEN DO
    CALL INTGI
    D_STR = ''
    MYCMD = ''
    CMD = ''
    ZCMD=''
    END
    ELSE CMD = ''
   END
   TRACE OFF
 CURCL=TOPCL
REDSPLY:
 CURLN=TOPLN
 SIGNAL DSPLOOP
NOPOOL:
  ZEDSMSG = "NO POOLED DATA"
  ZEDLMSG = "NO DATA PREVIOUSLY POOLED FOR RECALL"
  XC = 4
 SIGNAL WRITIT
 WRITIT:
 IF FSAVSTR \= '' THEN SAY FSAVSTR
 "ISPEXEC SETMSG MSG(ISRZ001)"
 RETURN XC
 TRYEND:
 IF FSAVSTR \= '' THEN DO
  FSAVSTR = SUBSTR(FSASTR,2)
  MYTYRSP=FSAVSTR
  "ISPEXEC VPUT (MYTYRSP) ASIS"
  END
 RETURN 0
/* INTGI: PROCEDURE EXPOSE MYCMD HYCMD LNREST APLP TMP D_STR CMDIND */
INTGI:
 /* TRACE I */
  IF APLP = 0 THEN RETURN 8
  IF TMP = 'G' | TMP = 'Q' THEN DO
   MYCMD='PING'
   MYCA = 'PING DSPAFOD MSG FROM \@'
   MYPROG= DFT_UCEMPIN
   IF TMP = 'G' THEN DO
    MYCAL = DFT_PING_CAL
    MYFUNC = 'MSGBOXONLY'
    END
   IF TMP = 'Q' THEN DO
    MYCAL = 0
    MYFUNC = 'QUIET'
    END
   "ISPEXEC VPUT (MYCMD MYCA MYCAL MYPROG MYFUNC) ASIS"
   END
   IF TMP = 'P' THEN DO
    MYCMD='PLAY'
    MYCAL = MAX_CAL
    MYCA=''
    MYPROG=''
    MYFUNC = 'MSGBOXALL'
    CALL GET_PLAY
    IF RC > 4 THEN SIGNAL BYP_CMD
    IF SUBSTR(D_STR,1,1) = '@' THEN PARSE VAR D_STR '@' . D_STR
    MYAPLID=D_STR
    "ISPEXEC VPUT (MYAPLID MYCMD MYCA MYCAL MYPROG MYFUNC) ASIS"
    CALL AFOLPLAY
    XC = RESULT
    MYAREA = ''
   "ISPEXEC VPUT (MYAREA) ASIS"
    RETURN XC
    END
   IF TMP = 'E' | TMP = 'L' | TMP = 'D' THEN DO
 /* TRACE I */
    IF HYCMD \= MYCMD THEN CMDIND = 0
    IF CMDIND = 0 THEN DO
     MYFUNC1 = 'A'
     YYU2=MYCMD
     YYU2=MYFUNC1
     YYU2=CMDIND
     YYU2=MYAPLID
     YYU2=D_STR
    IF SUBSTR(D_STR,1,1) = '@' THEN PARSE VAR D_STR '@' . D_STR
    MYAPLID=D_STR
     "ISPEXEC VPUT (MYCMD MYFUNC1 CMDIND MYAPLID) ASIS"
     CALL DSPAFOC
     "ISPEXEC VGET (CMDIND MYFUNC1) ASIS"
     IF CMDIND > 1 THEN SIGNAL BYP_CMD
     VALFUNC='QUIET MSGBOXONLY MSGBOXALL VERBOSE'
     VALFUNC1='Q O A V'
     MYFUNC = WORD(VALFUNC,WORDPOS(MYFUNC1,VALFUNC1))
     "ISPEXEC VPUT (MYFUNC) ASIS"
     END
    END
DO_CALL:
   IF D_STR = '' THEN DO
    MYAPLID = WORD(LNREST,APLP)
    END
    ELSE DO
    MYAPLID = D_STR
    MYAPLID = TRANSLATE(MYAPLID,' ','@')
    END
   "ISPEXEC VPUT (MYAPLID) ASIS"
   IF RC \= 0 THEN SIGNAL BYP_CMD
   /* !@! */
   /* SUBSTITUTE SPECIFIC CHARACTER INDICATORS FOR JOBNAME OR *\
   \*  APPLID, TO CAUSE DYNAMIC CA DATA BASED ON JOB OR APPLID*/
/* CALL SUBJOBN                       *\
\* IF RESULT /= 0 THEN SIGNAL BYP_CMD */
   MYPRM= "MYCMD=<MYCMD> MYAPLID=<MYAPLID> MYCA=<MYCA> "|| ,
     "MYCAL=<MYCAL> MYPROG=<MYPROG> MYTRANID=<MYTRANID> ODSN=<MYODSN>"
   CALL EXCIS0 MYFUNC MYPRM
   XC = RESULT
   MYAREA = ''
   TRACE OFF
   "ISPEXEC VPUT (MYAREA) ASIS"
   IF D_STR = '' THEN RETURN XC
BYP_CMD:
   RETURN 8
/* INTCI: PROCEDURE EXPOSE LNREST */
INTCI:
   IF LNREST = '' THEN RETURN 4
   ARGAFO =STRIP(SUBSTR(LNREST,1,8),'T')
   CALL COPYINFO ARGAFO
   XC = RESULT
   RETURN XC
INTVI: PROCEDURE EXPOSE LNREST FSAVSTR
   IF LNREST = '' THEN RETURN 4
   ARGAFO =STRIP(SUBSTR(LNREST,1,8),'T')
   XC=POS(ARGAFO,FSAVSTR)
   IF XC = 0 THEN FSAVSTR=FSAVSTR||','||ARGAFO
   NOVAR:
   RETURN XC
GET_PLAY:
 DROP AFOSC.
 SCRPCMDI=0
 AFOSCTOT=0
 ADDRESS TSO "NEWSTACK"
 HDSEMSG = DSEMSG
 DSEMSG='ENTER VALID COMMANDS OR ? FOR HELP'
 "ISPEXEC VPUT (DSEMSG) ASIS"
 CALL REXXSRC "PULL(AFOSC)"
 XC = RESULT
 DSEMSG = HDSEMSG
 IF XC > 2 THEN DO
  CMD1=''
  CALL MSGBOX 'ERROR:PLAY LIST: COULD NOT CAPTURE SCRIPT.'
  RETURN 8
  END
 MY#VCT = QUEUED()
 IF MY#VCT > 99 THEN DO
  CMD1=''
  CALL MSGBOX 'ERROR:PLAY LIST: TOO MANY COMMANDS IN SCRIPT:'MY#VCT
  RETURN 4
  END
 K=0
 SCRPTLST=''
 DO J = 1 TO MY#VCT
  PULL AFOSC.J
  SCRPTMP=STRIP(AFOSC.J,'B')
  IF SCRPTMP  \= '' THEN DO
   IF SUBSTR(SCRPTMP,1,1) = '#' THEN ITERATE
   K=K+1
   INTERPRET 'AFOSC'K' = SCRPTMP'
   SCRPTLST=SCRPTLST||' AFOSC'||K
   END
  END
 ADDRESS TSO "DELSTACK"
 IF K < 1 THEN DO
  CMD1=''
  CALL MSGBOX 'ERROR:PLAY LIST: NO COMMANDS IN SCRIPT!'
  RETURN 8
  END
 AFOSCTOT=K
 "ISPEXEC VPUT (AFOSCTOT) ASIS"
 "ISPEXEC VPUT ("SCRPTLST") ASIS"
 IF RC \= 0 THEN DO
  CMD1=''
  CALL MSGBOX 'ERROR:PLAY LIST: COULD NOT SAVE COMMANDS'
  RETURN 8
  END
 RETURN 0
/* ROUTINE TO SUBSTITUTE JOB OR APPLID VALUE IN CA */
SUBJOBN:
/* JOB#PTR IS THE CURRENT JOBNAME FROM THE SUPPLIED LIST */
/* IF ZERO JOBNAMES WERE SUPPLIED, THEN WE CAN NOT PERFORM */
/*   THE $ SUBSTITUTION.                                 */
/* WE SHOULD NOT BE HERE IF THE JOB#PTR IS > NUMBER OF   */
/*   JOBNAMES PROVIDED IN THE JOBLIST ARGUMENT.          */
/* TRACE ?I */
  "ISPEXEC VGET (MYCA MYCAL) ASIS"
  IF RC \= 0 THEN RETURN 8
  IF LENGTH(MYCA) < 1 THEN RETURN 0
  LOOPCT=100
  V=1
  X = OUTTRAP('JNL.')
  CALL CVTJN2RG MYAPLID
  X = OUTTRAP('OFF')
  IF WORD(JNL.1,1) = '!!!!!!!!' THEN RETURN 8
  JOBN=WORD(JNL.1,2)
  SUBCMD=STRIP(MYCA,'T')
  CURL=LENGTH(SUBCMD)
  CURP=1
  CURS=0
  NEWCMD=''
  /* NEW CODE V2 */
  TRACE I
  S#APLID = MYAPLID
  IF LENGTH(S#APLID) < 7 THEN INTERPRET "T#PARM = 'S#"||S#APLID||"'"
    ELSE INTERPRET "T#PARM = 'S#"||SUBSTR(S#APLID,3)||"'"
  INTERPRET T#PARM " = S#VALUE"
  'ISPEXEC VGET ('T#PARM') ASIS'
  IF RC > 0 THEN S#PARM = MYAPLID
   ELSE INTERPRET 'S#PARM = 'T#PARM
  /* NEW CODE V2 */

TOPOFQLOP:
  JP = WORDPOS(SUBSTR(SUBCMD,CURP,1),FNDWDS)
  IF JP = 0 THEN SIGNAL NXT_POS
  /* TRACE ?I */

  SUBWD = WORD(SUBWDS,JP)
  INTERPRET 'REPWD = 'SUBWD
  IF CURP = 1 THEN DO
   NEWCMD = REPWD
   END
   ELSE DO
   IF CURS = 0 THEN NEWCMD = SUBSTR(SUBCMD,1,CURP - 1)
   NEWCMD=SUBSTR(NEWCMD,1)||REPWD
   END
  LOOPCT = LOOPCT - 1
  IF LOOPCT < 1 THEN RETURN 8
  CURS = CURP + 1
NXT_POS:
  CURP=CURP + 1
  IF CURP <= CURL THEN SIGNAL TOPOFQLOP
  IF CURS < CURP THEN DO
   IF CURS = 0 THEN NEWCMD = SUBCMD
   ELSE NEWCMD=SUBSTR(NEWCMD,1)||SUBSTR(SUBCMD,CURS)
   END
  IF LENGTH(NEWCMD) > MYCAL THEN MYCA = SUBSTR(NEWCMD,1,MYCAL)
   ELSE MYCA =  NEWCMD
  "ISPEXEC VPUT (MYCA MYCAL) ASIS"
  IF RC \= 0 THEN RETURN 8
   TRACE OFF
 RETURN 0
###END DSPAFODO
$$$BEG EXHEXDMP
/* REXX */
   ARG TMP_MSG
   X01 = '01'X
   APLNM = 'TESTAPLD'
   IF TMP_MSG = '' THEN DO
XSTR = '000102030405060708090A0B0C0D0EF1F2F3F4F5F6F7F8F9FAFBFCFDFEFF'X
    XSTR = COPIES(XSTR,20)
    XSTR_L = LENGTH(XSTR)
    TMP_MSG='<'||XSTR_L||' '||APLNM||'>'||XSTR
    END
/* TRACE ?I */
   ADDRESS ISPEXEC
   "ISPEXEC VGET (DSPHEXPN DSEMSG) ASIS"
   EXECSEL = DSPHEXPN
   "ISPEXEC PQUERY PANEL(MYDSPHEX) AREANAME(MYAREA1) "||,
    "AREATYPE(MYAT) WIDTH(MYAW) DEPTH(MYAD)"
   IF RC \= 0 THEN DO
    SAY 'DID YOU FORGET TO ALLOC THE ISPPLIB? RC = 'RC
    RETURN
    END
  LNCT = 0
  IF TMP_MSG = '' THEN DO
   LN.1   = LEFT(X01||APLNM||'--->',MYAW)
   LN.2   = LEFT(X01||'--- EMPTY CN DATA ---',MYAW)
   LNCT = 2
   SIGNAL FIN_HEXDMP
   END
  LNCT = 0
 TOPOFLOP:
  IF TMP_MSG = '' THEN SIGNAL FIN_HEXDMP
  IF SUBSTR(TMP_MSG,1,1) \= '<' THEN DO
    LNCT = LNCT + 1
    LN.LNCT = LEFT(X01||APLNM||'--->',MYAW)
    LNCT = LNCT + 1
    LN.LNCT = LEFT(X01||'--- NO HDR ON CN DATA ---',MYAW)
    CN_LNG = LENGTH(TMP_MSG)
    END
    ELSE DO
    PARSE VAR TMP_MSG . '<' CN_LNG HDRMSG '>' TMP_MSG
    HDRMSG  = TRANSLATE(HDRMSG,' ',X01)
    LNCT = LNCT + 1
    LN.LNCT = LEFT(X01||HDRMSG,MYAW)
    END
  CNMSG = SUBSTR(TMP_MSG,1,CN_LNG)
  TMP_MSG = SUBSTR(TMP_MSG,CN_LNG + 1)
  LNCHRL = 16
  LNCHRSL = 4
  CNOFFSET = -LNCHRL
  DO WHILE CNMSG \= ''
   LNCT = LNCT + 1
   IF LENGTH(CNMSG) < LNCHRL THEN DO
    SMP = CNMSG
    CNMSG = ''
    END
    ELSE DO
    SMP = SUBSTR(CNMSG,1,LNCHRL)
    CNMSG = SUBSTR(CNMSG,LNCHRL + 1)
    END
   HXSMP = LEFT(C2X(SMP),32,' ')
   SMP = LEFT(SMP,16,' ')
   CNOFFSET = CNOFFSET + LNCHRL
   CNHEXSET = RIGHT(D2X(CNOFFSET),6,'0')
   TMPLN=CNHEXSET||' | '||SUBSTR(HXSMP,1,8)||' '||,
    SUBSTR(HXSMP,9,8)||' '||SUBSTR(HXSMP,17,8)||' '||,
    SUBSTR(HXSMP,25,8)||' |'||SMP||'|'
   LN.LNCT = LEFT(X01||TMPLN,MYAW,' ')
   IF LNCT > 5 THEN TRACE OFF
   END
  IF TMPMSG \= '' THEN SIGNAL TOPOFLOP
 FIN_HEXDMP:
  /* TRACE I */
  MYAW = MYAW - 2
  DW = MYAW
  IF MYAD > LNCT THEN MYAD = LNCT
  DD = MYAD
  LASTLN=0
  MYSC='PAGE'
  ZSCROLLD = MYSC
  MYSCINC=MYAD        /* INCREMENT */
  MYSCCT = 1          /* TOP LN    */
  MYSCCB = MYAD       /* BOT LN    */
 DSPLOOP1:
  IF MYVERB = '' & ZCMD = '' THEN DO
   ZEDSMSG = ""
   ZEDLMSG = ""
   "ISPEXEC SETMSG MSG(ISRZ001)"
   END
  MCMD = ''
  ZCMD = ''
  MYVERB=''
  HLDSCLN=MYSCLN
  MYAREA1 = ''
  TRACE OFF
  DO I = MYSCCT TO MYSCCB
   MYAREA1 = MYAREA1||LN.I
   END
  "ISPEXEC DISPLAY PANEL(MYDSPHEX)"
  /* TRACE I */
  XC=RC
  XX = LASTLN
  IF MYSC = 'PAGE' | MYSC = 'HALF' | MYSC = 'CSR' | ,
   DATATYPE(MYSC,'W') \= 0 THEN DO
    ZSCROLLD = MYSC
    END
   ELSE MYSC = ZSCROLLD
  IF XC = 8 THEN SIGNAL EXITRC0
/* TRACE I */
  AVERB = MYVERB
/*  MCMD = ZCMD */
  PARSE VAR MCMD MCMD RESP
  GG='MCMD='MCMD'  MYVERB='MYVERB
   IF MCMD='HELP' | MCMD='?' THEN DO
    CALL CEMHELP 'DSPLYA'
    MCMD = ''
    SIGNAL DONE_CMD1
    END
/*  TRACE I */
DONE_CMD1:
  SELECT
   WHEN MYVERB = '' THEN SIGNAL DSPLOOP1
   WHEN MYVERB = 'END' THEN SIGNAL EXITRC0
   WHEN MYVERB = 'ABORT' THEN SIGNAL EXITRC4
   WHEN MYVERB = 'BYPASS' THEN SIGNAL EXITRC4
   WHEN MYVERB = 'CANCEL' THEN SIGNAL EXITRC4
   WHEN MYVERB = 'DOWN' THEN CALL DO_SCROLL
   WHEN MYVERB = 'UP' THEN CALL DO_SCROLL
   OTHERWISE MYVERB = ''
   END
 REDSPLY:
  SIGNAL DSPLOOP1
  /*                                                                 *\
  |*   MYSCINC=MYAD        /* INCREMENT */                           *|
  |*   MYSCCT = 1          /* TOP LN    */                           *|
  |*   MYSCCB = MYAD       /* BOT LN    */                           *|
  \*                                                                 */
 DO_SCROLL:
  SCDIR = 1
  QCP = QCP
  QLA = QLA
  QLN = QLN
  IF QLA = 'MAX' THEN QLN = LNCT
  QLN = QLN
  QNL = QNL
  MYSCINC = QLN
  IF MYVERB = 'DOWN' THEN DO
   SCDIR = 1
   END
  IF MYVERB = 'UP' THEN DO
   SCDIR = -1
   END
  TOPTMP = MYSCCT + (MYSCINC * SCDIR)
  IF TOPTMP > LNCT THEN TOPTMP = (LNCT - MYAD) + 1
  IF TOPTMP < 1 THEN TOPTMP = 1
  MYSCCT = TOPTMP
  MYSCCB = MYSCCT + MYAD
  IF MYSCCB > LNCT THEN MYSCCB = LNCT
  RETURN
/*            */
 EXITRC0:
  XC = 0
  ZEDSMSG = "DATA DISP OK"
  ZEDLMSG = "DATA DISPLAYED FINISHED NORMALLY"
  SIGNAL WRITIT
 EXITRC4:
  XC = 4
  ZEDSMSG = "DATA DISP ABORT"
  ZEDLMSG = "DATA DISPLAY ABORTED BY COMMAND"
  SIGNAL WRITIT
 NOPOOL:
  XC = 8
  ZEDSMSG = "NO POOLED DATA"
  ZEDLMSG = "NO DATA PREVIOUSLY POOLED FOR RECALL"
  SIGNAL WRITIT
  WRITIT:
  "ISPEXEC SETMSG MSG(ISRZ001)"
  RETURN XC
 SAVIT: PROCEDURE EXPOSE MYA. MXLNG EXECSEL MCMD AUTOSAVE
  /* TRACE ?I */
  "ISPEXEC VGET (DSPLYADS EMBR) ASIS"
  IF RC \= 0 THEN DO
   EDSN=SYSVAR(SYSUID)'.'EXECSEL'.DATA'
   EMBR=''
   END
   ELSE EDSN=DSPLYADS
  IF AUTOSAVE = 'Y' THEN DO
   EDSN=DSPLYADS
   EMBR='$'
   TDSN=EDSN
   SIGNAL DO_AS
   END
  DSEMSG='ENTER TARGET DSN (NO MBR)'
  MYAT='INPUT'
  "ISPEXEC VPUT (EDSN EMBR DSEMSG MYAT) ASIS"
  CALL GDSNNMBR
  IF RESULT = 8 THEN RETURN 8
  "ISPEXEC VGET (EDSN EMBR) ASIS"
  IF RC ^= 0 THEN RETURN
  EMBR=STRIP(EMBR,'B')
  XMBR = ''
  /* DSN COULD HAVE BEEN SPECIFIED AS DSN(MBR)
     OR THE DSN AND MBR INPUT IN PANEL FIELDS,
     OR (CONFUSED) BOTH (IN WHICH CASE WE TAKE THE DSN(MBR)
     FORMATED BECAUSE WE FIGURE IT WAS INTENTIONAL).
  */
  PARSE VAR EDSN EDSN '(' XMBR ')'
  TDSN=EDSN
  IF XMBR \= '' THEN EMBR = XMBR
DO_AS:
  IF EMBR = '$' THEN EMBR = EXECSEL
  /* SIMPLE CHECK TO INSURE DSN NOT MIGRATED */
  CALL MALOC TDSN
  XC=RESULT
  IF XC = 0 THEN SIGNAL CHKORG
  IF EMBR = '' THEN MYDSO='PS)'
   ELSE MYDSO='PO) DSNTYPE(LIBRARY)'
  MODDSN = ''
  IF MXLNG < 128 THEN MXLNG = 128
  M=MXLNG+4
  DSEMSG = '(D) DEL/REALLOC,(A) ABORT'
  MODATTR="NEW BLKSIZE("M+4") DSORG("MYDSO" RECFM(V,B) SPACE(1,1)"||,
   "CYLINDER LRECL("M") CATALOG REUSE"
  EDSN = TDSN
  ADDRESS ISPEXEC "VPUT (EDSN EXECSEL DSEMSG MODATTR MODDSN) ASIS"
  IF RC ^= 0 THEN SIGNAL EXITRC8
  CALL ALOCDSN
  XC = RESULT
  "ISPEXEC VGET (EDSN) ASIS"
  IF RC ^= 0 THEN RETURN 4
  SIGNAL DOWRITE
 CHKORG:
  XC=LISTDSI("'"TDSN"'" DIRECTORY NORECALL)
  MYDSO=SYSDSORG
  IF EMBR \= '' THEN DO
   IF MYDSO = 'PS' THEN SIGNAL BADOPDSNORG
   END
   ELSE DO
   IF MYDSO = PO THEN SIGNAL BADOPDSNORG
   IF AUTOSAVE = 'Y' THEN DSPVAL='MOD'
   END
 DOWRITE:
  /* TRACE ?I */
  DSPLYADS=EDSN
  "ISPEXEC VPUT (DSPLYADS EMBR) ASIS"
  IF EMBR \= '' THEN EDSN=TDSN||'('||EMBR||')'
  IF XC = 0 THEN DO
   M# = MYA.0
   MSTM='MYA.'
   IF MCMD = 'MOD' | MCMD = 'APPEND' THEN DSPVAL='MOD'
    ELSE DSPVAL='SHR REUSE'
   IF EMBR \= '' THEN DO
    IF DSPVAL = 'MOD' THEN DO
     DSPVAL='SHR REUSE'
     ADDRESS TSO "ALLOC FI(I) DA('"EDSN"') "DSPVAL
     ADDRESS TSO "EXECIO * DISKR I (STEM MYB. FINIS"
     ADDRESS TSO "FREE FI(I)"
     MSTM='MYB.'
     MB#=MYB.0
     DO I = 1 TO M#
      MB#=MB# + 1
      MYB.MB#=MYA.I
      END
     M#=MB#
     END
    END
   ADDRESS TSO "ALLOC FI(O) DA('"EDSN"') "DSPVAL
   ADDRESS TSO "EXECIO "M#" DISKW O (STEM "MSTM" FINIS"
   ADDRESS TSO "FREE FI(O)"
   AUTOSAVE = 'N'
   CALL MSGBOX 'DATA SAVED TO 'EDSN
   RETURN 0
  END
  RETURN XC
BADOPDSNORG:
   CALL MSGBOX 'SAVE TO DSN DSORG INCONSISTENT WITH EXISTING DSN'
   RETURN 4
OS2PNT: PROCEDURE EXPOSE SVC MYA. XC
 IF SVC ^> 0 THEN RETURN 4
 DO I = 1 TO SVC
  INTERPRET 'OS2C'||I'= MYA.I'
  'ISPEXEC VPUT (OS2C'I') ASIS'
  END
 MYCN = 'OS2C'
 OS2CTOT = SVC
  ZEDSMSG = "DATA PRINTED"
  ZEDLMSG = "DATA SENT TO PRINTER"
 "ISPEXEC SETMSG MSG(ISRZ001)"
 "ISPEXEC VPUT (MYCN OS2CTOT) ASIS"
 RETURN 0
CUTIT: PROCEDURE EXPOSE SVC MYA. CUTV CUTCNT XC
 IF SVC ^> 0 THEN RETURN 4
 CVSTR=''
 DO I = 1 TO SVC
  CUTCNT=CUTCNT+1
  INTERPRET CUTV||CUTCNT'= MYA.I'
  'ISPEXEC VPUT ('CUTV||CUTCNT') ASIS'
  END
  INTERPRET CUTV'TOT = CUTCNT'
 'ISPEXEC VPUT ('CUTV'TOT) ASIS'
 RETURN 0



###END EXHEXDMP
$$$BEG TSTDYNAR
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA          - RESTRICTED                                   */
 /* CEMHELP          - ISPF BASED - SUBROUTINE                      */
 /* CEMHELP          -                                              */
 /* CEMHELP END                                                     */
 /* TRACE I */
   ADDRESS ISPEXEC
   EXECSEL = 'TESTME'
   MPNL = 'EXDYNAR1'
   MPNL = 'MYDSPDYN'
   "ISPEXEC PQUERY PANEL("MPNL") AREANAME(MYAREA1) "||,
    "AREATYPE(MYAT) WIDTH(MYAW) DEPTH(MYAD)"
   IF RC \= 0 THEN DO
    SAY 'DID YOU FORGET TO ALLOC THE ISPPLIB? RC = 'RC
    RETURN
    END
   X15 = '15'X
   X01 = '01'X
   X02 = '02'X
   XX = RANDOM(0,99999,12345)
   X =
'----+----1----+----2----+----3----+----4----+----5----+----6----+----7'
   LNCT = 67
  DW = MYAW - 2
   DO I = 1 TO LNCT
    LN.I = LEFT(X01||(I * 1000),DW)||X02||'O'
    END
  TRACE I
  MYLNG=LENGTH(MYAREA1)
  IF MYAD > LNCT THEN MYAD = LNCT
  DD = MYAD
  LASTLN=0
  MYSC='PAGE'
  ZSCROLLD = MYSC
  MYSCINC=MYAD        /* INCREMENT */
  MYSCCT = 1          /* TOP LN    */
  MYSCCB = MYAD       /* BOT LN    */
 DSPLOOP1:
  IF MYVERB = '' & ZCMD = '' THEN DO
   ZEDSMSG = ""
   ZEDLMSG = ""
   "ISPEXEC SETMSG MSG(ISRZ001)"
   END
  MCMD = ''
  ZCMD = ''
  MYVERB=''
  HLDSCLN=MYSCLN
  MYAREA1 = ''
  TRACE OFF
  DO I = MYSCCT TO MYSCCB
   MYAREA1 = MYAREA1||LN.I
   END
  TRACE I
  "ISPEXEC DISPLAY PANEL("MPNL")"
  XC=RC
  XX = LASTLN
  IF MYSC = 'PAGE' | MYSC = 'HALF' | MYSC = 'CSR' | ,
   DATATYPE(MYSC,'W') \= 0 THEN DO
    ZSCROLLD = MYSC
    END
   ELSE MYSC = ZSCROLLD
  IF XC = 8 THEN SIGNAL EXITRC0
/* TRACE I */
  AVERB = MYVERB
/*  MCMD = ZCMD */
  PARSE VAR MCMD MCMD RESP
  GG='MCMD='MCMD'  MYVERB='MYVERB
   IF MCMD='HELP' | MCMD='?' THEN DO
    CALL CEMHELP 'DSPLYA'
    MCMD = ''
    SIGNAL DONE_CMD1
    END
  TRACE OFF
  CHGED=''
  MYAREA1 = STRIP(MYAREA1,'T')
  DO WHILE MYAREA1 \= ''
   PARSE VAR MYAREA1 V (X02) SLN (X01) MYAREA1
   S = SLN
   IF S \= 'O' THEN DO
    CHGED = CHGED||' '||STRIP(V,'T')||'='||S
    END
   END
  TRACE I
  IF CHGED = '' THEN DSEMSG = 'NO CHANGES'
   ELSE DSEMSG = 'FOUND:'WORDS(CHGED)': CHANGED'
DONE_CMD1:
  SELECT
   WHEN MYVERB = '' THEN SIGNAL DSPLOOP1
   WHEN MYVERB = 'END' THEN SIGNAL EXITRC0
   WHEN MYVERB = 'ABORT' THEN SIGNAL EXITRC4
   WHEN MYVERB = 'BYPASS' THEN SIGNAL EXITRC4
   WHEN MYVERB = 'CANCEL' THEN SIGNAL EXITRC4
   WHEN MYVERB = 'DOWN' THEN CALL DO_SCROLL
   WHEN MYVERB = 'UP' THEN CALL DO_SCROLL
   OTHERWISE MYVERB = ''
   END
 REDSPLY:
  SIGNAL DSPLOOP1
  /*                                                                 *\
  |*   MYSCINC=MYAD        /* INCREMENT */                           *|
  |*   MYSCCT = 1          /* TOP LN    */                           *|
  |*   MYSCCB = MYAD       /* BOT LN    */                           *|
  \*                                                                 */
 DO_SCROLL:
  SCDIR = 1
  QCP = QCP
  QLA = QLA
  QLN = QLN
  IF QLA = 'MAX' THEN QLN = LNCT
  QLN = QLN
  QNL = QNL
  MYSCINC = QLN
  IF MYVERB = 'DOWN' THEN DO
   SCDIR = 1
   END
  IF MYVERB = 'UP' THEN DO
   SCDIR = -1
   END
  TOPTMP = MYSCCT + (MYSCINC * SCDIR)
  IF TOPTMP > LNCT THEN TOPTMP = (LNCT - MYAD) + 1
  IF TOPTMP < 1 THEN TOPTMP = 1
  MYSCCT = TOPTMP
  MYSCCB = MYSCCT + MYAD
  IF MYSCCB > LNCT THEN MYSCCB = LNCT
  RETURN
/*            */
 EXITRC0:
  XC = 0
  ZEDSMSG = "DATA DISP OK"
  ZEDLMSG = "DATA DISPLAYED FINISHED NORMALLY"
  SIGNAL WRITIT
 EXITRC4:
  XC = 4
  ZEDSMSG = "DATA DISP ABORT"
  ZEDLMSG = "DATA DISPLAY ABORTED BY COMMAND"
  SIGNAL WRITIT
 NOPOOL:
  XC = 8
  ZEDSMSG = "NO POOLED DATA"
  ZEDLMSG = "NO DATA PREVIOUSLY POOLED FOR RECALL"
  SIGNAL WRITIT
  WRITIT:
  "ISPEXEC SETMSG MSG(ISRZ001)"
  RETURN XC
 SAVIT: PROCEDURE EXPOSE MYA. MXLNG EXECSEL MCMD AUTOSAVE
  /* TRACE ?I */
  "ISPEXEC VGET (DSPLYADS EMBR) ASIS"
  IF RC \= 0 THEN DO
   EDSN=SYSVAR(SYSUID)'.'EXECSEL'.DATA'
   EMBR=''
   END
   ELSE EDSN=DSPLYADS
  IF AUTOSAVE = 'Y' THEN DO
   EDSN=DSPLYADS
   EMBR='$'
   TDSN=EDSN
   SIGNAL DO_AS
   END
  DSEMSG='ENTER TARGET DSN (NO MBR)'
  MYAT='INPUT'
  "ISPEXEC VPUT (EDSN EMBR DSEMSG MYAT) ASIS"
  CALL GDSNNMBR
  IF RESULT = 8 THEN RETURN 8
  "ISPEXEC VGET (EDSN EMBR) ASIS"
  IF RC ^= 0 THEN RETURN
  EMBR=STRIP(EMBR,'B')
  XMBR = ''
  /* DSN COULD HAVE BEEN SPECIFIED AS DSN(MBR)
     OR THE DSN AND MBR INPUT IN PANEL FIELDS,
     OR (CONFUSED) BOTH (IN WHICH CASE WE TAKE THE DSN(MBR)
     FORMATED BECAUSE WE FIGURE IT WAS INTENTIONAL).
  */
  PARSE VAR EDSN EDSN '(' XMBR ')'
  TDSN=EDSN
  IF XMBR \= '' THEN EMBR = XMBR
DO_AS:
  IF EMBR = '$' THEN EMBR = EXECSEL
  /* SIMPLE CHECK TO INSURE DSN NOT MIGRATED */
  CALL MALOC TDSN
  XC=RESULT
  IF XC = 0 THEN SIGNAL CHKORG
  IF EMBR = '' THEN MYDSO='PS)'
   ELSE MYDSO='PO) DSNTYPE(LIBRARY)'
  MODDSN = ''
  IF MXLNG < 128 THEN MXLNG = 128
  M=MXLNG+4
  DSEMSG = '(D) DEL/REALLOC,(A) ABORT'
  MODATTR="NEW BLKSIZE("M+4") DSORG("MYDSO" RECFM(V,B) SPACE(1,1)"||,
   "CYLINDER LRECL("M") CATALOG REUSE"
  EDSN = TDSN
  ADDRESS ISPEXEC "VPUT (EDSN EXECSEL DSEMSG MODATTR MODDSN) ASIS"
  IF RC ^= 0 THEN SIGNAL EXITRC8
  CALL ALOCDSN
  XC = RESULT
  "ISPEXEC VGET (EDSN) ASIS"
  IF RC ^= 0 THEN RETURN 4
  SIGNAL DOWRITE
 CHKORG:
  XC=LISTDSI("'"TDSN"'" DIRECTORY NORECALL)
  MYDSO=SYSDSORG
  IF EMBR \= '' THEN DO
   IF MYDSO = 'PS' THEN SIGNAL BADOPDSNORG
   END
   ELSE DO
   IF MYDSO = PO THEN SIGNAL BADOPDSNORG
   IF AUTOSAVE = 'Y' THEN DSPVAL='MOD'
   END
 DOWRITE:
  /* TRACE ?I */
  DSPLYADS=EDSN
  "ISPEXEC VPUT (DSPLYADS EMBR) ASIS"
  IF EMBR \= '' THEN EDSN=TDSN||'('||EMBR||')'
  IF XC = 0 THEN DO
   M# = MYA.0
   MSTM='MYA.'
   IF MCMD = 'MOD' | MCMD = 'APPEND' THEN DSPVAL='MOD'
    ELSE DSPVAL='SHR REUSE'
   IF EMBR \= '' THEN DO
    IF DSPVAL = 'MOD' THEN DO
     DSPVAL='SHR REUSE'
     ADDRESS TSO "ALLOC FI(I) DA('"EDSN"') "DSPVAL
     ADDRESS TSO "EXECIO * DISKR I (STEM MYB. FINIS"
     ADDRESS TSO "FREE FI(I)"
     MSTM='MYB.'
     MB#=MYB.0
     DO I = 1 TO M#
      MB#=MB# + 1
      MYB.MB#=MYA.I
      END
     M#=MB#
     END
    END
   ADDRESS TSO "ALLOC FI(O) DA('"EDSN"') "DSPVAL
   ADDRESS TSO "EXECIO "M#" DISKW O (STEM "MSTM" FINIS"
   ADDRESS TSO "FREE FI(O)"
   AUTOSAVE = 'N'
   CALL MSGBOX 'DATA SAVED TO 'EDSN
   RETURN 0
  END
  RETURN XC
BADOPDSNORG:
   CALL MSGBOX 'SAVE TO DSN DSORG INCONSISTENT WITH EXISTING DSN'
   RETURN 4
OS2PNT: PROCEDURE EXPOSE SVC MYA. XC
 IF SVC ^> 0 THEN RETURN 4
 DO I = 1 TO SVC
  INTERPRET 'OS2C'||I'= MYA.I'
  'ISPEXEC VPUT (OS2C'I') ASIS'
  END
 MYCN = 'OS2C'
 OS2CTOT = SVC
  ZEDSMSG = "DATA PRINTED"
  ZEDLMSG = "DATA SENT TO PRINTER"
 "ISPEXEC SETMSG MSG(ISRZ001)"
 "ISPEXEC VPUT (MYCN OS2CTOT) ASIS"
 RETURN 0
CUTIT: PROCEDURE EXPOSE SVC MYA. CUTV CUTCNT XC
 IF SVC ^> 0 THEN RETURN 4
 CVSTR=''
 DO I = 1 TO SVC
  CUTCNT=CUTCNT+1
  INTERPRET CUTV||CUTCNT'= MYA.I'
  'ISPEXEC VPUT ('CUTV||CUTCNT') ASIS'
  END
  INTERPRET CUTV'TOT = CUTCNT'
 'ISPEXEC VPUT ('CUTV'TOT) ASIS'
 RETURN 0
###END TSTDYNAR
$$$BEG TESTPRM
/* REXX */
 TRACE I
/* "ALLOC FI(PRINTER) DA(*) LRECL(80) BLKSIZE(80) REUSE" */
 X = '01F988C3'X
 Y = C2X(X)
 SAY X
 X = TRANSLATE(X,' ','01'X)
 EXIT
 MYPARM = 'I HOPE THIS IS A TEST PARM'
 IF SYSVAR('SYSISPF') = 'ACTIVE' THEN SIGNAL TRYRUN
 "TEST 'TTED.TSK.P.TCEM.LOADLIB(TESTRECB)' 'PUT(MYPARM)THIS IS NOT IT'"
  SIGNAL ARNDISPF
 TRYRUN:
 "CALL 'TTED.TSK.P.TCEM.LOADLIB(TESTRECB)' 'PUT(MYPARM)THIS IS NOT IT'"
ARNDISPF:
 SAY MYPARM
/* "FREE FI(PRINTER)" */
 B=MYPARM
###END TESTPRM
$$$BEG GETKREL0
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA GETKREL  - PUSHES THE CICS REL INFO ONTO THE STACK 3.1  */
 /* CEMHELP GETKREL  - TSO REXX STACK BASED 3.1, TAKES ONE ARG      */
 /* CEMHELP          - ARG MUST BE LENGTH OF 3 OR ERROR             */
 /* CEMHELP          - ARG: ??? WILL RETURN 2 VALUES                */
 /* CEMHELP          -       NUMBER OF RELEASES                     */
 /* CEMHELP          -       COMMA DELIMITED STRING, CODED WITH A   */
 /* CEMHELP          -       3 DIGIT RELEASE VALUE FOR EACH RELEASE */
 /* CEMHELP          - ARG: NNN IS THE RELEASE VALUE TO RETURN      */
 /* CEMHELP          -          SPECIFIC RELEASE DEPENDANT INFO     */
 /* CEMHELP          -      SUCH AS:                                */
 /* CEMHELP          -       KIXREL3  - THE 3 DIGIT REL NUMBER      */
 /* CEMHELP          -       KIXREL1  - THE 2 CHAR JCL VALUE        */
 /* CEMHELP          -                - USED TO RESOLVE SET INCLUDE */
 /* CEMHELP          -       KIXREL   - THE 4 CHAR RXXX JCL VALUE   */
 /* CEMHELP          - STACK RETURNS KIXREL1 KIXREL                 */
 /* CEMHELP          - NOTE - ADD LOGIC TO CIXXMAC EDITMAC          */
 /* CEMHELP          -      - SO THAT DFHPD, DFHTU, AND DFHDU       */
 /* CEMHELP          -      - WILL POINT AT THE CORRECT UTILITY MODS*/
 /* CEMHELP END                                                     */
 /*                                                                 *\
 |*                                                                 *|
 |* NOTE: EDIT AS A NEW RELEASE IS INTRODUCED TO THE ENVIRONMENT    *|
 |*  ELIMINATE DEFUNCT RELEASE.                                     *|
 |*                                                                 *|
 \*                                                                 */
 ADDRESS TSO
 ARG KIXREL3
 IF LENGTH(KIXREL3) ^= 3 THEN DO
  PUSH "ERROR LENGTH"
  RETURN 12
  END
 IF KIXREL3 = '???' THEN DO
  KIXREL ='540,550'
  KIXREL1= WORDS(TRANSLATE(KIXREL,' ',','))
  SIGNAL DONIT
  END
 IF DATATYPE(KIXREL3) ^= 'NUM' THEN DO
  KIXREL3= '540'
  KIXREL1='52'
  KIXREL = 'R540'
  SIGNAL DONIT
  END
  WHEN KIXREL3 = '540' THEN DO
   KIXREL3= '540'
   KIXREL1='52'
   KIXREL = 'R540'
   END
 SELECT
  WHEN KIXREL3 = '550' THEN DO
   KIXREL3= '550'
   KIXREL1='54'
   KIXREL = 'R550'
   END
   OTHERWISE DO
   KIXREL1=SUBSTR(KIXREL3,1,2)
   KIXREL = 'R'||KIXREL3
   END
  END
DONIT:
 PUSH KIXREL1 KIXREL
 EXIT
###END GETKREL0
$$$BEG EXPLTSOL
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA          -                                              */
 /* CEMHELP          - TSO BASE, RESTRICTED                         */
 /* CEMHELP          -                                              */
 /* CEMHELP END                                                     */
 /*                                            *\
 |*    CALL EXPLTSOL 'EXCILIB'
 |*    IF RESULT \= '0' THEN SIGNAL NO_TSOLIB   |
 \*                                            */
 /* TRACE ?I */
 ADDRESS TSO
 TGTAPPL=''
 MYFUNC=''
 ARG TGTAPPL MYFUNC
 IF TGTAPPL = '' THEN TGTAPPL='EXCILIB'
  X=OUTTRAP('LINE.', 10, NOCONCAT)
  ADDRESS TSO "TSOLIB DISPLAY"
  X=OUTTRAP('OFF')
  LNCT=LINE.0
  TMP = LINE.1
  IF LNCT < 1 THEN DO
   IF MYFUNC = 'QUIET' THEN DO
    DROP LINE.
    RETURN 20
    END
   C_A = 'TSO COMMAND RETURNED NULL OUTPUT. PRESS PF3 TO END'
   SIGNAL NO_TSOLIB
   END
  ERRLST='IDY00029I'
  IF WORDPOS(ERRLST,TMP) > 0 THEN SIGNAL NO_TSOLIB
  ERRLST='IDY00023I'
  DO I = 1 TO LNCT
   IF WORDPOS(ERRLST,LINE.I) > 0 THEN SIGNAL DO_LA
   END
  SIGNAL NO_TSOLIB
 DO_LA:
  PARSE VAR LINE.I . '=' DDN
  DROP LINE.
  X=OUTTRAP('LINE.')
  ADDRESS TSO "LA "DDN
  X=OUTTRAP('OFF')
  LNCT=LINE.0
  DO I = 1 TO LNCT
   IF POS(TGTAPPL,LINE.I) > 0 THEN SIGNAL OK_TSOLIB
   END
 NO_TSOLIB:
  XFF='FF'X
  DROP LINE.
  MYAREA#=XFF
  X15='15'X
 C_A = XFF||TMP||'::MISSING 'TGTAPPL' LIBRARY, REQUIRED FOR TSO'||,
 ' ENVIRONMENT. (GO BACK TO READY)'||XFF||"EX 'TTED.TSK.P.TCEM.CLIS"||,
 "T(EXCITSLB)' 'REL', WHERE REL IS 3 DIGIT CICS RELEASE"||XFF||,
 '(NOW RUN FROM READY) CICLOGON'
 H_MYCA = 'ERROR!'
 EXCI_RESP=0
 MSGBOXTX = C_A
 CALL MSGBOX MSGBOXTX
 RETURN 20
OK_TSOLIB:
 DROP LINE.
 RETURN 0
###END EXPLTSOL
$$$BEG TSTSCRLA
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA          - RESTRICTED                                   */
 /* CEMHELP          - ISPF BASED - SUBROUTINE                      */
 /* CEMHELP          -                                              */
 /* CEMHELP END                                                     */
  ADDRESS ISPEXEC
  EXECSEL = 'TESTME'
  DW = 52
  X15 = '15'X
  MYAREA1 = RANDOM(0,99999,12345)||X15
  DO 50
   MYAREA1 = MYAREA1||RANDOM(0,99999)||X15
  END
 TRACE I
 DSPLOOP1:
  IF MYVERB = '' & ZCMD = '' THEN DO
   ZEDSMSG = ""
   ZEDLMSG = ""
   "ISPEXEC SETMSG MSG(ISRZ001)"
   END
  CMD = ''
  ZCMD = ''
  MYVERB=''
  HLDSCLN=MYSCLN
  "ISPEXEC DISPLAY PANEL(EXSCRLA1)"
  XC=RC
/* TRACE I */
  AVERB = MYVERB
  CMD = ZCMD
  PARSE VAR CMD CMD RESP
  GG='CMD='CMD'  MYVERB='MYVERB
   IF CMD='HELP' | CMD='?' THEN DO
    CALL CEMHELP 'DSPLYA'
    CMD = ''
    SIGNAL DONE_CMD1
    END
DONE_CMD1:
   IF CMD \= '' & MYVERB = '' THEN MYVERB=CMD
  SELECT
   WHEN MYVERB = '' THEN SIGNAL DSPLOOP1
   WHEN MYVERB = 'END' THEN SIGNAL EXITRC0
   WHEN MYVERB = 'ABORT' THEN SIGNAL EXITRC4
   WHEN MYVERB = 'BYPASS' THEN SIGNAL EXITRC4
   WHEN MYVERB = 'CANCEL' THEN SIGNAL EXITRC4
   END
 REDSPLY:
  CURCL=TOPCL
  CURLN=TOPLN
  SIGNAL DSPLOOP
 EXITRC0:
  XC = 0
  ZEDSMSG = "DATA DISP OK"
  ZEDLMSG = "DATA DISPLAYED FINISHED NORMALLY"
  SIGNAL WRITIT
 EXITRC4:
  XC = 4
  ZEDSMSG = "DATA DISP ABORT"
  ZEDLMSG = "DATA DISPLAY ABORTED BY COMMAND"
  SIGNAL WRITIT
 NOPOOL:
  XC = 8
  ZEDSMSG = "NO POOLED DATA"
  ZEDLMSG = "NO DATA PREVIOUSLY POOLED FOR RECALL"
  SIGNAL WRITIT
  WRITIT:
  "ISPEXEC SETMSG MSG(ISRZ001)"
  RETURN XC
 SAVIT: PROCEDURE EXPOSE MYA. MXLNG EXECSEL CMD AUTOSAVE
  /* TRACE ?I */
  "ISPEXEC VGET (DSPLYADS EMBR) ASIS"
  IF RC \= 0 THEN DO
   EDSN=SYSVAR(SYSUID)'.'EXECSEL'.DATA'
   EMBR=''
   END
   ELSE EDSN=DSPLYADS
  IF AUTOSAVE = 'Y' THEN DO
   EDSN=DSPLYADS
   EMBR='$'
   TDSN=EDSN
   SIGNAL DO_AS
   END
  DSEMSG='ENTER TARGET DSN (NO MBR)'
  MYAT='INPUT'
  "ISPEXEC VPUT (EDSN EMBR DSEMSG MYAT) ASIS"
  CALL GDSNNMBR
  IF RESULT = 8 THEN RETURN 8
  "ISPEXEC VGET (EDSN EMBR) ASIS"
  IF RC ^= 0 THEN RETURN
  EMBR=STRIP(EMBR,'B')
  XMBR = ''
  /* DSN COULD HAVE BEEN SPECIFIED AS DSN(MBR)
     OR THE DSN AND MBR INPUT IN PANEL FIELDS,
     OR (CONFUSED) BOTH (IN WHICH CASE WE TAKE THE DSN(MBR)
     FORMATED BECAUSE WE FIGURE IT WAS INTENTIONAL).
  */
  PARSE VAR EDSN EDSN '(' XMBR ')'
  TDSN=EDSN
  IF XMBR \= '' THEN EMBR = XMBR
DO_AS:
  IF EMBR = '$' THEN EMBR = EXECSEL
  /* SIMPLE CHECK TO INSURE DSN NOT MIGRATED */
  CALL MALOC TDSN
  XC=RESULT
  IF XC = 0 THEN SIGNAL CHKORG
  IF EMBR = '' THEN MYDSO='PS)'
   ELSE MYDSO='PO) DSNTYPE(LIBRARY)'
  MODDSN = ''
  IF MXLNG < 128 THEN MXLNG = 128
  M=MXLNG+4
  DSEMSG = '(D) DEL/REALLOC,(A) ABORT'
  MODATTR="NEW BLKSIZE("M+4") DSORG("MYDSO" RECFM(V,B) SPACE(1,1)"||,
   "CYLINDER LRECL("M") CATALOG REUSE"
  EDSN = TDSN
  ADDRESS ISPEXEC "VPUT (EDSN EXECSEL DSEMSG MODATTR MODDSN) ASIS"
  IF RC ^= 0 THEN SIGNAL EXITRC8
  CALL ALOCDSN
  XC = RESULT
  "ISPEXEC VGET (EDSN) ASIS"
  IF RC ^= 0 THEN RETURN 4
  SIGNAL DOWRITE
 CHKORG:
  XC=LISTDSI("'"TDSN"'" DIRECTORY NORECALL)
  MYDSO=SYSDSORG
  IF EMBR \= '' THEN DO
   IF MYDSO = 'PS' THEN SIGNAL BADOPDSNORG
   END
   ELSE DO
   IF MYDSO = PO THEN SIGNAL BADOPDSNORG
   IF AUTOSAVE = 'Y' THEN DSPVAL='MOD'
   END
 DOWRITE:
  /* TRACE ?I */
  DSPLYADS=EDSN
  "ISPEXEC VPUT (DSPLYADS EMBR) ASIS"
  IF EMBR \= '' THEN EDSN=TDSN||'('||EMBR||')'
  IF XC = 0 THEN DO
   M# = MYA.0
   MSTM='MYA.'
   IF CMD = 'MOD' | CMD = 'APPEND' THEN DSPVAL='MOD'
    ELSE DSPVAL='SHR REUSE'
   IF EMBR \= '' THEN DO
    IF DSPVAL = 'MOD' THEN DO
     DSPVAL='SHR REUSE'
     ADDRESS TSO "ALLOC FI(I) DA('"EDSN"') "DSPVAL
     ADDRESS TSO "EXECIO * DISKR I (STEM MYB. FINIS"
     ADDRESS TSO "FREE FI(I)"
     MSTM='MYB.'
     MB#=MYB.0
     DO I = 1 TO M#
      MB#=MB# + 1
      MYB.MB#=MYA.I
      END
     M#=MB#
     END
    END
   ADDRESS TSO "ALLOC FI(O) DA('"EDSN"') "DSPVAL
   ADDRESS TSO "EXECIO "M#" DISKW O (STEM "MSTM" FINIS"
   ADDRESS TSO "FREE FI(O)"
   AUTOSAVE = 'N'
   CALL MSGBOX 'DATA SAVED TO 'EDSN
   RETURN 0
  END
  RETURN XC
BADOPDSNORG:
   CALL MSGBOX 'SAVE TO DSN DSORG INCONSISTENT WITH EXISTING DSN'
   RETURN 4
OS2PNT: PROCEDURE EXPOSE SVC MYA. XC
 IF SVC ^> 0 THEN RETURN 4
 DO I = 1 TO SVC
  INTERPRET 'OS2C'||I'= MYA.I'
  'ISPEXEC VPUT (OS2C'I') ASIS'
  END
 MYCN = 'OS2C'
 OS2CTOT = SVC
  ZEDSMSG = "DATA PRINTED"
  ZEDLMSG = "DATA SENT TO PRINTER"
 "ISPEXEC SETMSG MSG(ISRZ001)"
 "ISPEXEC VPUT (MYCN OS2CTOT) ASIS"
 RETURN 0
CUTIT: PROCEDURE EXPOSE SVC MYA. CUTV CUTCNT XC
 IF SVC ^> 0 THEN RETURN 4
 CVSTR=''
 DO I = 1 TO SVC
  CUTCNT=CUTCNT+1
  INTERPRET CUTV||CUTCNT'= MYA.I'
  'ISPEXEC VPUT ('CUTV||CUTCNT') ASIS'
  END
  INTERPRET CUTV'TOT = CUTCNT'
 'ISPEXEC VPUT ('CUTV'TOT) ASIS'
 RETURN 0
###END TSTSCRLA
$$$BEG EXPLRAND
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA          -                                              */
 /* CEMHELP          - TSO BASE, RESTRICTED                         */
 /* CEMHELP          -                                              */
 /* CEMHELP END                                                     */
 TRACE ?I
 ADDRESS TSO
 SEQUENCE = RANDOM(0,99999,12345)
 /* ANY NUMBER WOULD */
 /* DO FOR A SEED */
 DO 5561           /* 5560 GIVE LENGHT 32764 WHICH IS MAX */
  SEQUENCE = SEQUENCE RANDOM(0,99999)
 END
 SAY LENGTH(SEQUENCE)
 TRACE ?I
 ADDRESS ISPEXEC "VPUT (SEQUENCE) ASIS"
 XC=RC
 IF RC \= 0 THEN DO
  SAY 'ERROR - 'RC
  EXIT
  END
 DROP SEQUENCE
 ADDRESS ISPEXEC "VGET (SEQUENCE) ASIS"
 XC=RC
 IF RC \= 0 THEN DO
  SAY 'ERROR - 'RC
  EXIT
  END
 SAY LENGTH(SEQUENCE)
###END EXPLRAND
$$$BEG EXCIS0
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA EXCIS0   - SUBROUTINE TO AFOLIST. SEE AFOLIST           */
 /* CEMHELP EXCIS0   - SUBROUTINE TO AFOLIST. SEE AFOLIST           */
 /* CEMHELP          -                                              */
 /* CEMHELP END                                                     */
 /*                                                                 */
 /* REQUIRED PARAMETERS:                                            */
 /*  MYFUNC - FIRST PARM IDENTIFIES THE OUTPUT PROCESS              */
 /*         - SEE VAR VALFUNC                                       */
 /*  MYCMD  - DESIRED COMMAND PROCESSING OPTION                     */
 /*           SEE VAR VALPRMS                                       */
 /*  MYAPLID() - TARGET APPLID(S) EXPECTED AS COMMA DELM LIST       */
 /*  ODSN   - IF QUIET, IDENTIFIES THE TARGET DSN TO COLLECT THE    */
 /*           RESULTS                                               */
 /*                                                                 */
 /*  PARMS MUST BE IN THE FORMAT                                    */
 /*   ACTUAL LITERAL (SEE VALPRMS FOR LIST) EXPL: MYAPLID           */
 /*     MYAPLID=XXXX   SINGLE CHOICE                                */
 /*            =(XXXX YYYY ....) MULTIPLE CHOICES                   */
 /*            (XXXX YYYY ....) MULTIPLE CHOICES                    */
 /*            =<IIII> IDENTIFIES AN ISPFVAR NAME                   */
 /*            <IIII>                                               */
 /*    IIII ISPFVAR NAME - IS THE ACTUAL NAME OF AN ISPFVAR         */
 /*            WHICH WILL BE VGET. THE CONTENTS OF THAT VAR         */
 /*            WILL BE USED AS A LIST                               */
 /*                                                                 */
 /*  MYCMD   CAN NOT BE A LIST. IT IS USED TO DEFINE A SINGLE       */
 /*          COMMAND, TO BE USED WITH THE APPLID LIST               */
 /*          IF MYCMD IS LIST, CEMT, OR CEDA THEN YOU MUST          */
 /*          PROVIDE A MYCA AND MYCAL VARIABLE                      */
 /*                                                                 */
 /*  MYTRANID(T) THE NAME OF THE TRANS ID TO USE  IF MYCMD IS LINK  */
 /*          PASSED IN AN ISPF VAR AND THE T IS THE VARIABLE NAME   */
 /*                                                                 */
 /*  MYPROG(P) THE NAME OF THE PROGRAM TO LINK TO IF MYCMD IS LINK  */
 /*          PASSED IN AN ISPF VAR AND THE P IS THE VARIABLE NAME   */
 /*                                                                 */
 /*  MYCA<X> THE COMMAREA  ASSOCIATED WITH THE COMMAND MUST BE      */
 /*          PASSED IN AN ISPF VAR AND THE X IS THE VARIABLE NAME   */
 /*          (NOTE SYMBOLIC SUBSTITUTION VARS ARE AS FOLLOW:        */
 /*          \@ WILL SUBSTITUTE APPLID                              */
 /*          \$ WILL SUBSTITUTE JOBNAME                             */
 /*          \! WILL SUBSTITUTE PARM NAMED S#PARM  (SEE BELOW)      */
 /*          \\ WILL SUBSTITUTE A SINGLE BACK SLASH                 */
 /*             AND NOT INTERPRET THIS FURTHER                      */
 /*                                                                 */
 /*                                                                 */
 /*  MYCAL<Y> SPEFICIES THE NAME OF THE ISPF VAR, WHICH DEFINES THE */
 /*          DESIRED COMMAREA LENGTH (0 - 32400)                    */
 /*          PASSED IN AN ISPF VAR AND THE Y IS THE VARIABLE NAME   */
 /*                                                                 */
 /*  ODSN - CAN BE 'DISPLAY' WHICH WILL DISPLAY UP TO 99 LINES      */
 /*       - A DATASET (NEW OR EXISTING) IF EXISTING, YOU ARE        */
 /*         PROMPTED TO ACCEPT REUSE. IT CAN BE A PDS(E) WITH MBR   */
 /*                                                                 */
 /*  NOTE: S#PARM                                                   */
 /* SPECIAL SUBSTITUTION PARM \! IS DESIGNED TO LET YOU SUPPLY A    */
 /*         SET OF VARIABLE TO BE SUBSTITUTED BASED ON THE APPLID   */
 /*         SEE RX AFOS#PRM   FOR SPECIFIC INFORMATION              */
 /* ACCUMSG = EXECSEL||' CREATE S#PARMS FROM LIST:'||FFX            */
 /*  DSEMSG = 'CREATE S#PARM (TWO COLS OF APPLID PARMV. PF3 END'    */
 /*  USE AFOS#PRM RX TO CREATE THIS APPLID SPECIFIC SPECIAL PARM    */
 /*   WHERE FOR EACH APPLID THAT NEEDS A SPECIAL PARM SUBSTITUTION  */
 /*   IS ACCESSED IN ISPF VAR 'S#'APLID AND THE VALUE IS UNIQUE     */
 /*   FOR THAT REGION.                                              */
 /*                                                                 */
  ADDRESS ISPEXEC
  /* TRACE I */
  "ISPEXEC CONTROL ERRORS RETURN"
  ARG MYFUNC PRMS
  IF MYFUNC = '' THEN SIGNAL BADFUNC
  VALFUNC='QUIET MSGBOXONLY MSGBOXALL VERBOSE'
  VALPRMS='MYCMD MYAPLID ODSN MYCA MYCAL MYPROG MYTRANID'
  VALCMDS = 'PING CEMT CEDA LINK'
  DFTPVALS='PING . .'
  IF PRMS ^= '' THEN DO
   NPW=WORDS(VALPRMS)
   DO I = 1 TO NPW
    TMP = WORD(VALPRMS,I)
    TMPV = WORD(DFTPVALS,I)
    IF TMPV = '.' THEN TMPV = ''
     ELSE IF TMPV = '\.' THEN TMPV = '.'
    INTERPRET TMP"='"TMPV"'"
    END
   END
   X15='15'X
   XFF='FF'X
   ERRMSG = ''
   I=0
   PRM_RC = 0
   DLM='(<{[='
   MDLM=')>}] '
   #DMM=LENGTH(DLM)
   REPWDS='\@ \$ \! \\'  /* SUBSTITUTE \ APPLID JOBNAME */
   RW_CT = WORDS(REPWDS)
   DFT_PING_CAL=1008
   MAX_CAL=32000
   DFT_CAL=4080
   DFT_UCEMPIN='UCEMPINR'
PRMLOOP:
   IF PRMS = '' THEN SIGNAL DONEPRMS
   PRMX = ''
   PARSE VAR PRMS PRM PRMS
   IF PRM = '' THEN SIGNAL EXITRC8
   PRM=PRM||' ' /* TACK ON A SPACE TO HELP FIND '=' END */
   L_PRM=LENGTH(PRM)
   FDLM = ''
   EDLM = ''
   DO I = 2 TO L_PRM
    PP=SUBSTR(PRM,I,1)
    CKPP=POS(PP,DLM)
    IF CKPP ^= 0 THEN DO
     FDLM=SUBSTR(DLM,CKPP,1)
     EDLM=SUBSTR(MDLM,CKPP,1)
     LEAVE
     END
    END
   IF FDLM = '' THEN SIGNAL BADPARM
   IF I >= L_PRM THEN SIGNAL BADPARM
   LP = LASTPOS(EDLM,PRM)
   IF LP = 0 THEN LP=L_PRM
    ELSE LP = LP - 1
   PRMVAL = SUBSTR(PRM,I+1,LP-I)
   PRM = SUBSTR(PRM,1,I-1)
   IF PP = '=' THEN SIGNAL GOTEQ
   IF PP = '<' THEN SIGNAL GOTBRKT
   SIGNAL GOTPARNT
GOTEQ:
   IF PRMVAL = '' THEN SIGNAL BADPARM
   L_PRM=LENGTH(PRMVAL)
   PP = SUBSTR(PRMVAL,1,1)
   CKPP=POS(PP,DLM)
   IF CKPP = 0 THEN DO
    SIGNAL GOT_PRMVAL
    END
   I = 1
   FDLM=SUBSTR(DLM,CKPP,1)
   EDLM=SUBSTR(MDLM,CKPP,1)
   LP = LASTPOS(EDLM,PRMVAL)
   IF LP = 0 THEN LP=L_PRM
    ELSE LP = LP - 1
   PRMVAL = SUBSTR(PRMVAL,I+1,LP-I)
   IF PP = '<' THEN SIGNAL GOTBRKT
   SIGNAL GOTPARNT
GOTPARNT:
   PARSE VAR PRMVAL . '<' TMPVAL '>'
   IF TMPVAL ^= '' THEN DO
    PRMVAL = TMPVAL
    SIGNAL GOTBRKT
    END
   SIGNAL GOT_SIMPLE
GOTBRKT:
   IF LENGTH(PRMVAL) > 8 THEN SIGNAL BADPARM
   "ISPEXEC VGET ("PRMVAL") ASIS"
   INTERPRET "PRMVAL = "PRMVAL
/* IF PRMVAL = '' THEN SIGNAL BADPARM */
   SIGNAL NXTPRMS
BADPARM:
    ERRMSG = ERRMSG||XFF||,
       'PARM:'PRM' IS NOT A EXPECTED PARAMETER. BYPASSING.'
    PRM_RC = 4
    SIGNAL      NXTPRMS
GOT_SIMPLE:
GOT_PRMVAL:
   INTERPRET PRM "='"||PRMVAL||"'"
NXTPRMS:
/* TRACE OFF */
   SIGNAL PRMLOOP
DONEPRMS:
/* TRACE I */
   IF PRM_RC > 4 THEN SIGNAL EXITRC4
   IF MYFUNC = '' THEN SIGNAL EXITRC8
   IF MYFUNC = 'QUIET' THEN DO
    IF ODSN = '' | ODSN = 'ODSN' THEN DO
     CALL GETUDSN 'AFOLIST'
     PULL ODSN
     END
    IF ODSN = '' THEN SIGNAL EXITRC10
    SIGNAL GOTFUNC
    END
   IF MYFUNC = 'MSGBOXONLY' THEN SIGNAL GOTFUNC
   IF MYFUNC = 'MSGBOXALL' THEN SIGNAL GOTFUNC
   IF MYFUNC = 'VERBOSE' THEN SIGNAL GOTFUNC
   SIGNAL EXITRC8
 GOTFUNC:
/*TRACE I */
   IF WORDPOS(MYCMD,VALCMDS) = 0 THEN SIGNAL EXITRC12
   "ISPEXEC VGET (AUTOSAVE) ASIS"
   IF RC \= 0 THEN AUTOSAVE = 'N'
   IF MYCMD = 'PING' THEN DO
    MYCA = 'PING EXCIS0 MSG FROM \@'
    MYCAL = DFT_PING_CAL
    SIGNAL SETPROG
    END
   IF MYCA = '' & MYCMD \= 'LINK' THEN SIGNAL BADCA
   IF MYCAL = '' THEN MYCAL = LENGTH(MYCA)
   IF DATATYPE(MYCAL) ^= 'NUM' THEN SIGNAL BADCA
   IF MYCAL < 0 | MYCAL > MAX_CAL THEN SIGNAL BADCA
   IF MYCMD = 'LINK' THEN DO
    IF MYPROG = '' THEN SIGNAL BADLINK
    IF MYTRANID = '' THEN MYTRANID = 'CSMI'
     ELSE DO
     LTRID = LENGTH(MYTRANID)
     IF LTRID < 1 | LTRID > 4 THEN SIGNAL BADLINK
     END
    SIGNAL SET_H_VARS
    END
SETPROG:
   IF MYTRANID = '' THEN MYTRANID = 'CSMI'
   MYPROG=DFT_UCEMPIN
SET_H_VARS:
   L_CA = LENGTH(MYCA)
   IF MYCAL < L_CA THEN MYCAL = L_CA
   H_MYCA = MYCA
   H_MYCAL = MYCAL
   H_MYPROG = MYPROG
   H_MYTRANID = MYTRANID
   TOTLNG=0
TSTAPLIDS:
   I = 0
   IF MYAPLID = '' THEN SIGNAL EXITRC16
   DO WHILE(MYAPLID ^= '')
    I = I + 1
    PARSE VAR MYAPLID APL_STM.I MYAPLID
 /* TRACE OFF */
    END
   APL_STM.0 = I
   H_I = I
   JOBLS='N'
   "ISPEXEC VGET (AFOJOBLS AFOAPLLS) SHARED"
   IF RC = 0 THEN JOBLS='Y'
 /* OK HERE WE GO */
   IF MYFUNC = 'MSGBOXALL' | MYFUNC = 'QUIET' THEN DO
    MSGLOCK='Y'
    MSGSTAT='CONTPOP'
    MSGBOXTX='STARTING: PROCESSING ALL APPLIDS...'
    ADDRESS ISPEXEC "VPUT (MSGBOXTX) ASIS"
    ADDRESS ISPEXEC "VPUT (MSGLOCK MSGSTAT) ASIS"
 /* "ISPEXEC CONTROL DISPLAY REFRESH"  */
    CALL MSGBOX
    END
   J = 0
   MXLNG = 132
TOPOFLOP:
   /* TRACE I */
   J = J + 1
   IF J > I THEN SIGNAL DONEIT
   MYAPLID = APL_STM.J
   MYCA = H_MYCA
   MYCAL = H_MYCAL
   IF JOBLS = 'Y' THEN DO
    APLPOS=WORDPOS(MYAPLID,AFOAPLLS)
    IF APLPOS = 0 THEN SIGNAL NOSUB_CA
    JOBNM=WORD(AFOJOBLS,APLPOS)
   /* NEW CODE V2 */
   /* TRACE I */
   S#APLID = MYAPLID
    IF LENGTH(S#APLID) < 7 THEN INTERPRET "T#PARM = 'S#"||S#APLID||"'"
     ELSE INTERPRET "T#PARM = 'S#"||SUBSTR(S#APLID,3)||"'"
    INTERPRET T#PARM " = S#VALUE"
    'ISPEXEC VGET ('T#PARM') ASIS'
    IF RC > 0 THEN S#PARM = MYAPLID
     ELSE INTERPRET 'S#PARM = 'T#PARM
    TRACE OFF
   /* NEW CODE V2 */
    SUBWDS= MYAPLID||' '||JOBNM||' '||S#PARM||' \'
    DO K = 1 TO RW_CT
     TMPCAL=LENGTH(MYCA)
     SWD = WORD(REPWDS,K)
     RWD = WORD(SUBWDS,K)
     WP = 999
     DO UNTIL WP = 0
      WP = POS(SWD,MYCA)
      IF WP > 0 THEN DO
       IF WP = 1 THEN DO
        MYCA=RWD||SUBSTR(MYCA,WP+2)
        END
        ELSE DO
        IF WP = TMPCAL - 1 THEN ,
         MYCA=SUBSTR(MYCA,1,WP-1)||RWD
         ELSE ,
         MYCA=SUBSTR(MYCA,1,WP-1)||RWD||SUBSTR(MYCA,WP+2)
        END
       TMPCAL=LENGTH(MYCA)
       END
      END
     END
    IF TMPCAL > MAX_CAL THEN DO
     TMPCAL = MAX_CAL
     MYCA=SUBST(MYCA,1,MAX_CAL)
     END
    IF TMPCAL > H_MYCAL THEN DO
     MYCAL=TMPCAL
     END
    END
NOSUB_CA:
   MYPROG = H_MYPROG
   MYTRANID = H_MYTRANID
  "ISPEXEC VPUT (MYAPLID MYPROG MYCA MYCAL MYTRANID) ASIS"
   IF RC ^= 0 THEN SIGNAL CHK_ERR
   IF MYFUNC = 'MSGBOXALL' | MYFUNC = 'QUIET' THEN DO
    MSGBOXTX=MYFUNC||' '||MYCMD||'... PROCESSING >'||MYAPLID            T
    ADDRESS ISPEXEC "VPUT (MSGBOXTX) ASIS"
    "ISPEXEC CONTROL DISPLAY REFRESH"
    CALL MSGBOX
    END
   CALL EXCIS2 MYFUNC
   XC = RESULT
   IF XC = 20 THEN SIGNAL EXITRC20
   IF XC = 4 THEN SIGNAL DONEIT
   IF MYFUNC = 'MSGBOXALL' | MYFUNC = 'QUIET' THEN DO
    /* TRACE ?I */
    TMP=XFF||LEFT(MYAPLID,8)||'-->'||XFF
    IF XC ^= 0 THEN TMP = TMP||'WARNING - CALL RETURNED 'XC||XFF
    "ISPEXEC VGET (MYCA) ASIS"
    MYCA = STRIP(MYCA,'B')
    APL_STM.J = TMP||TRANSLATE(MYCA,XFF,X15)
    IF AUTOSAVE = 'N' THEN SIGNAL CHK_CAL
    "ISPEXEC VGET (DSPLYADS) ASIS"
    IF RC \= 0 THEN DO
     ZEDSMSG = 'AUTOSAVE DSN BAD'
     ZEDLMSG = 'AUTOSAVE FOR REGION 'MYAPLID' DSN BAD'
     'ISPEXEC SETMSG MSG(ISRZ000)'
     APL_STM.J ='AUTOSAVE FAIL:DSN BAD:'MYAPLID||XFF||APL_STM.J
     SIGNAL CHK_CAL
     END
    PARSE VAR DSPLYADS EDSN '(' EMBR ')'
    TDSN = EDSN
   /* DO THE AUTOSAVE ACTION */
    H_MYAREA=APL_STM.J
    L = 0
    DO WHILE H_MYAREA \= ''
     L = L + 1
     PARSE VAR H_MYAREA MYA.L (XFF) H_MYAREA
     WL=LENGTH(MYA.L)
     IF WL > MXLNG THEN MXLNG = WL
     TRACE OFF
     END
    /* TRACE ?I */
    MYA.0 = L
    EMBR=MYAPLID
    M# = MYA.0
    MYSTM='MYA.'
    CALL SAVIT
    DROP MYA.
    IF XC \= 0 THEN DO
     ZEDSMSG = 'AUTOSAVE FAILED.'
     ZEDLMSG = 'AUTOSAVE FOR REGION 'MYAPLID' FAILED.'
     'ISPEXEC SETMSG MSG(ISRZ000)'
     APL_STM.J ='AUTOSAVE FAIL:SAVIT:'MYAPLID||XFF||APL_STM.J
     END
     ELSE DO
     ZEDSMSG = 'AUTOSAVE SUCCESS'
     ZEDLMSG = 'AUTOSAVE FOR REGION 'MYAPLID' SUCCESSFUL.'
     'ISPEXEC SETMSG MSG(ISRZ000)'
     APL_STM.J ='AUTOSAVE SUCCESSFUL:'MYAPLID
     END
    END
 CHK_CAL:
    L_CA=LENGTH(APL_STM.J)
    TOTLNG=TOTLNG+L_CA
    IF L_CA > MAX_CAL THEN SIGNAL TOOMUCH
 GO_NEXT:
    SIGNAL TOPOFLOP
 DONEIT:
   IF MYFUNC = 'VERBOSE' | MYFUNC = 'MSGBOXONLY' THEN SIGNAL EXITRC0
   J = H_I
   IF MYFUNC = 'MSGBOXALL' THEN DO
    MSGSTAT='REMPOP'
    MSGBOXTX= '< FINISHED PROCESSING SELECTION LIST. WRITING RESULTS'
    ADDRESS ISPEXEC "VPUT (MSGSTAT MSGBOXTX) ASIS"
    "ISPEXEC CONTROL DISPLAY REFRESH"
    CALL MSGBOX
    EXECSEL = 'MSGBOXAL'
    "ISPEXEC VPUT (EXECSEL) ASIS"
    MYAREA=''
    DO I = 1 TO J
     MYAREA=MYAREA||XFF||APL_STM.I
     END
    MYCA = H_MYCA
    MYAREA#=XFF
    MYAREA='PROCESSED 'J' REGIONS. FINISHED AT 'DATE('U')||' '||,
           TIME()||XFF||'TO:'||DSPLYADS||XFF||MYAREA
    M$L=LENGTH(MYAREA)
    IF M$L > MAX_CAL THEN DO
     M$CT=0
     MAVAR=''
     M$L_MX=MAX_CAL
     DO WHILE (M$L > 0)
      M$CT=M$CT +1
      DVAL=MYARE||M$CT
      INTERPRET DVAL||' = SUBSTR(MYAREA,1,'M$L_MX')'
      MAVAR = MAVAR||DVAL||' '
      MYAREA=SUBSTR(MYAREA,M$L_MX+1)
      M$L=LENGTH(MYAREA)
      IF M$L < M$L_MX THEN M$L_MX = M$L
      END
/*   MYAREA='!!OVERFLOW: PARTIAL RESULT RETURNED!!'||,
      SUBSTR(MYAREA,1,MAX_CAL - 38) */
     MAVAR=STRIP(MAVAR,'B')
     "ISPEXEC VPUT ("MAVAR") ASIS"
     MYAREA#=XFF||'<'||M$CT||'>'
     END
    "ISPEXEC VPUT (MYAREA MYAREA#) ASIS"
    "ISPEXEC CONTROL DISPLAY REFRESH"
    CALL DSPLYA
    RETURN 0
    END
/* MYFUNC = QUIET : WRITE OP TO ODSN */
DO_ODSN:
  IF MYFUNC ^= 'QUIET' THEN SAY MUFUNC 'IS NOT EXPECTED:EXPECT:QUIET'
  IF ODSN = '' THEN SIGNAL EXITRC10
  MYSTM='APL_STM.'
  PARSE VAR ODSN TDSN '(' EMBR ')'
  EDSN = ODSN
SAVIT:
  EXECSEL='EXCIS0'
  DSPVAL='SHR REUSE'
  CALL MALOC TDSN
  XC=RESULT
  IF XC = 0 THEN SIGNAL CHKORG
  IF EMBR = '' THEN MYDSO='PS)'
   ELSE DO
    MYDSO='PO) DSNTYPE(LIBRARY)'
   END
  MODDSN = ''
  M=MXLNG+4
  DSEMSG = '(D) DEL/REALLOC,(A) ABORT'
  MODATTR="NEW BLKSIZE("M+4") DSORG("MYDSO" RECFM(V,B) SPACE(1,1)"||,
   "CYLINDER LRECL("M") CATALOG REUSE"
  "ISPEXEC VPUT (EDSN EXECSEL DSEMSG MODATTR MODDSN) ASIS"
  IF RC ^= 0 THEN SIGNAL EXITRC8
  CALL ALOCDSN
  XC = RESULT
  "ISPEXEC VGET (EDSN) ASIS"
  IF RC ^= 0 THEN RETURN 4
  SIGNAL DOWRITE
 CHKORG:
   XC=LISTDSI("'"TDSN"'" DIRECTORY NORECALL)
   MYDSO=SYSDSORG
   IF EMBR \= '' THEN DO
    IF MYDSO = 'PS' THEN SIGNAL BADOPDSNORG
    END
    ELSE DO
    IF MYDSO = PO THEN SIGNAL BADOPDSNORG
    IF AUTOSAVE = 'Y' THEN DSPVAL='MOD'
    END
  DOWRITE:
   /* TRACE ?I */
   DSPLYADS=EDSN
    IF EMBR \= '' THEN EDSN=EDSN||'('||EMBR||')'
   "ISPEXEC VPUT (DSPLYADS EMBR) ASIS"
   ADDRESS TSO "ALLOC FI(O) DA('"EDSN"') "DSPVAL
   ADDRESS TSO "EXECIO "M#" DISKW O (STEM "MYSTM" FINIS"
   ADDRESS TSO "FREE FI(O)"
   RETURN 0
BADOPDSNORG:
   CALL MSGBOX 'SAVE TO DSN DSORG INCONSISTENT WITH EXISTING DSN'
   RETURN 4
  END
 BADCA:
    ERR=MYCMD' COMMAND: MISSING COMMAREA'
    SIGNAL DOERR
 BADLINK::
    ERR='LINK  COMMAND: INVALID PROGRAM, COMMAREA OR TRANSID'
    SIGNAL DOERR
 BADPARM:
    ERR=TMP
    SIGNAL DOERR
 EXITRC4:
    ERR='PARAMETER ERROR:'||PRM_RC
    SIGNAL DOERR
 EXITRC8:
    ERR='NO VALID FUNCTION REQUESTED'
    SIGNAL DOERR
 EXITRC10:
    ERR='FUNCTION:QUIET, BUT NO OUTPUT DESTINATION PROVIDED.'
    SIGNAL DOERR
 EXITRC12:
 EXITRC16:
 EXITRC20:
 EXITRC0:
 DOERR:
 RETURN XC
###END EXCIS0
$$$BEG EXCIS2
/* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA EXCIS2   - SUBROUTINE TO AFOLIST. SEE AFOLIST           */
 /* CEMHELP EXCIS2   - SUBROUTINE TO AFOLIST. SEE AFOLIST           */
 /* CEMHELP          -                                              */
 /* CEMHELP END                                                     */
/*  USED BY AFOLPLAY - DIFFERENT FROM EXCIS0 ???? */
/*  CALLED BY EXCIS0 - COMMAREA BASED EXCI CALL   */
/*  TRACE I */
   ADDRESS ISPEXEC 'VGET (MYAPLID) ASIS'
   ADDRESS TSO
   ARG MYFUNC
   XC = 0
   XFF='FF'X
   MYAREA#=XFF
   X15='15'X
   VALWDS = 'VERBOSE MSGBOXONLY MSGBOXALL QUIET MSGBOXSAVE'
   IF WORDPOS(MYFUNC,VALWDS) = 0 THEN ,
       MYFUNC='VERBOSE'
 /*                                                                 *\
 |* TEST TSOLIB FOR EXCILIB ALLOCATION                              *|
 \*                                                                 */
 CALL EXPLTSOL 'EXCILIB' MYFUNC
 XC=RESULT
 IF XC  \= 0 THEN DO
  RETURN 20
  END
/* X=OUTTRAP('LINE.')
   ADDRESS TSO "TSOLIB DISPLAY"
   X=OUTTRAP('OFF')
   LNCT=LINE.0
   TMP = LINE.1
   IF LNCT < 1 THEN DO
    IF MYFUNC = 'QUIET' THEN RETURN 12
    C_A = 'TSO COMMAND RETURNED NULL OUTPUT. PRESS PF3 TO END'
    XC = 12
    SIGNAL PROCIT
    END
   TMP = WORD(LINE.1,1)
ERRLST='IDY00029I'
IF WORDPOS(TMP,ERRLST) ^ = 0 THEN DO
 C_A    = XFF||TMP||'::MISSING SDFHEXCI LIBRARY, REQUIRED FOR TSO'||,
 ' ENVIRONMENT'||XFF||'PLEASE RUN THE TSOLIB COMMAND FROM NATIVE '||,
 'TSO'||XFF||'(GO BACK TO READY)'||XFF||"EX 'TTED.TSK.P.TCEM.CLIS"||,
 "T(EXCITSLB)' 'REL'"||XFF||'WHERE REL IS CICS RELEASE'||XFF||,
 '(NOW RUN FROM READY)> CICLOGON'
 H_MYCA = 'ERROR!'
 EXCI_RESP=0
 XC = 8
 SIGNAL PROCIT
 END */
/*----------------- COPYINFO INTERFACE FOR EXCI CALLS ---------------*\
|* PLEASE RUN THE TSOLIB COMMAND FROM NATIVE TSO                     *|
|*  (GO BACK TO READY)> CEM EXCITSLB
|*  (NOW RUN...)      > CICLOGON
|*                                                                   *|
|* THIS EXEC USES THE EXCI LINK INTERFACE TO EXECUTE A CICS PROGRAM  *|
|*                                                                   *|
|* "CA1DCALL "PROGRAM("PROGRAM_NAME")" ,                              *|
|*              "APPLID("VTAM_APPLID")" ,                            *|
|*              "USERID("USER_ID")" ,                                *|
|*              "COMMAREA(CA_NAME)" ,           /* OPTIONAL */       *|
|*              "LENGTH("CA_LENGTH")" ,         /* OPTIONAL */       *|
|*              "DATALENGTH("COMMAREA_DLEN")" , /* OPTIONAL */       *|
|*              "TRANSID("TRANS_ID")"           /* OPTIONAL */       *|
|* PROGRAM_NAME  - CONTAINS THE NAME OF THE CICS PROGRAM TO EXECUT   *|
|*                 FOLLOWING THE NAMING CONVENTIONS FOR CICS PROGR   *|
|*                                                                   *|
|* VTAM_APPLID   - CONTAINS THE VTAM APPLID FOR THE CICS REGION WH   *|
|*                 IS TO RECEIVE THE REQUEST.                        *|
|*                                                                   *|
|* USER_ID       - CONTAINS THE CICS USERID UNDER WHICH THE CICS     *|
|*                 PROGRAM WILL EXECUTE.  THIS USERID MUST BE        *|
|*                 VALIDATED PRIOR TO CALLING THE CICS PROGRAM BEC   *|
|*                 THERE IS NO ABILITY TO PASS A PASSWORD TO CICS.   *|
|*                                                                   *|
|* COMMAREA_NAME - IS THE NAME OF THE REXX VARIABLE THAT CONTAINS    *|
|*                 COMMAREA CONTENTS.  (BE SURE TO WATCH THE '"' T   *|
SUBSTR= 'UCEMPINQ' THEN DO
|*                 NOT SPECIFIED, THEN LENGTH AND DATALENGTH ARE     *|
|*                 IGNORED IF SPECIFIED. DEFAULT IS C_A.             *|
|*                                                                   *|
|* COMMAREA_LEN  - CONTAINS THE LENGTH OF THE COMMAREA TO BE USED    *|
|*                 THE EXCI.  THIS LENGTH CANNOT EXCEED 32768. IF    *|
|*                 VALUE IS NOT SUPPLIED BUT THE CA_NAME IS SPECIF   *|
|*                 THEN THE LENGTH OF THE REXX VARIABLE IS USED.     *|
|*                                                                   *|
|* COMMAREA_DLEN - CONTAINS THE LENGTH OF THE DATA TO BE PASSED IN   *|
|*                 COMMAREA.  THIS LENGTH MUST NOT BE LARGER THAN    *|
|*                 LENGTH OF THE COMMAREA. IF THIS VALUE IS NOT      *|
|*                 SUPPLIED BUT LENGTH IS SPECIFIED, THEN LENGTH I   *|
|*                 USED.  IF LENGTH IS NOT SPECIFIED THEN THE LENG   *|
|*                 THE CA_NAME REXX VARIABLE CONTENTS IS USED.       *|
|*                                                                   *|
|* TRANS_ID      - CONTAINS THE NAME OF A TRANSACTION TO BE USED F   *|
|*                 THE MIRROR FUNCTION.  IF NOT ENTERED THE DEFAUL   *|
|*                 MIRROR TRANSACTION, CSMI IS USED.                 *|
\*-------------------------------------------------------------------*/
ARND_IDY:
/* TRACE I  */
      UU='EXCIS2'
   ADDRESS ISPEXEC
   'ISPEXEC VGET (MYAPLID MYPROG MYCA MYCAL) ASIS'
   IF RC ^= 0 THEN DO
    C_A = 'ISPEXEC VGET VARIABLES FAILED. PRESS PF3 TO END'
    XC = 8
    SIGNAL PROCIT
    END
   H_CA = MYCA
   IF MYAPLID = '' THEN SIGNAL BADPARM
   APPLID_NAME = MYAPLID
   IF MYPROG = '' THEN SIGNAL BADPARM
   PROGRAM_NAME=MYPROG
   CAL = LENGTH(MYCA)
   MYTRANID = ''
   'ISPEXEC VGET (MYTRANID) ASIS'
   IF SUBSTR(MYPROG,1,7) = 'UCEMPIN' THEN DO
    IF MYTRANID = '' THEN TR_ID='CSMI'
     ELSE TR_ID=MYTRANID
     IF CAL < 4 | MYCAL < 4 THEN DO
      MYCA = ''
      CAL = 0
      MYCA=''
      MYCAL = 0
      COMMAREA_DLEN = 0
      MYCMD = 'PING'
      H_MYCA = 'PING TO CSSL'
      SIGNAL DO_CSSL
      END
     IF SUBSTR(MYCA,1,5) = 'SYSID' THEN DO
      MYCMD=TRANSLATE(MYCA,' ',',')
      MYCMD = WORD(MYCMD,2)
      IF LENGTH(MYCMD) \= 4 THEN SIGNAL BADPARM
      END
      ELSE MYCMD = WORD(MYCA,1)
     IF  WORDPOS(MYCMD,'PING CEMT CEDA LINK') = 0 THEN SIGNAL BADPARM
     END
    ELSE DO     /* NOT UCEMPIN. */
    IF MYTRANID = 'CSMI' THEN SIGNAL BADPARM
    IF MYTRANID = '$SMI' THEN MYTRANID='CSMI'
    TR_ID=MYTRANID
    MYCMD=''
    END
   H_MYCA=MYCA
   IF MYCMD = 'CEDA' THEN DO
    FP = POS('!',MYCA)
    IF FP > 0 THEN DO
     TMP=SUBSTR(MYCA,1,FP-1)||MYAPLID||SUBSTR(MYCA,FP+1)
     TMP_L = LENGTH(TMP)
     IF TMP_L > MYCAL THEN SIGNAL BADSUBST
     MYCA=TMP
     END
    END
   COMMAREA_DLEN = LENGTH(STRIP(MYCA,'T'))
DO_CSSL:
   COMMAREA_NAME= 'C_A'
   C_A=''
   IF MYCAL < COMMAREA_DLEN THEN SIGNAL BADPARM
   C_A = MYCA||COPIES(' ',MYCAL-COMMAREA_DLEN)
   COMMAREA_LEN = LENGTH(C_A)
   ADDRESS TSO
   USER_ID=SYSVAR(SYSUID)
   PARM = "'PROGRAM("PROGRAM_NAME")','COMMAREA(C_A)',"||,
          "'TRANSID("TR_ID")',"||,
          "'LENGTH("COMMAREA_LEN")','APPLID("APPLID_NAME")'"
   P1 = "PROGRAM("PROGRAM_NAME")"
   P2 = "COMMAREA(C_A)"
   P3 = "LENGTH("COMMAREA_LEN")"
   P4 = "APPLID("APPLID_NAME")"
   P5 = "TRANSID("TR_ID")"
   P6 = "DATALENGTH("MYCAL")"
   P7 = "USERID("USER_ID")"
   EXCI_RESP='--'
   EXCI_RESP2='##'
   EXCI_ABCODE='____'
   EXCI_MESSAGE='-'
 IF MYFUNC ^= 'VERBOSE' THEN SIGNAL ARNDPRE
   SAY 'COMMAREA LENTH BEFORE LINK IS:' COMMAREA_LEN
   SAY
   SAY 'CALLING CICSLINK WITH PARAMETERS:'
   PARM1 = PARM
   DO UNTIL PARM1 = ''
     PARSE VAR PARM1 PART ',' PARM1
     SAY '   ' PART
     END
   SAY 'PRESS Y TO CONTINUE OR ANOTHER KEY TP BYPASS'
   PULL ANS
   IF ANS ^= 'Y' THEN SIGNAL EXITRC4
ARNDPRE:
 /* MDDN = 'ISPLLIB'
    MDSN = "'TTEP.TSK.E.TCEM.PDSE'"
    "ISPEXEC LIBDEF "MDDN" DATASET ID("MDSN") UNCOND"
    IF RC ^= 0 THEN SIGNAL DONIT */
    /* "ISPEXEC SELECT PGM(ISPLLS) SCRNAME(LIBDEF)" */
   /* NEXT 2 WORK - ALL ARGS ARE COMBINED INTO ONE RX ARG */
   /* RXVARS_RESULT = CA1DLINK('P1','P2','P3','P4','P5') */
   /* CALL CA1DLINK 'P1','P2','P3','P4','P5' */
   /* THIS WORKS - EACH ARG IS SEPARATE IN RX ARG TABLE */
    INTERPRET "CALL CA1DLINK '"P1"','"P2"','"P3"','"P4"','"P5"'"
   /* XX=CA1DLINK('PROGRAM' ,
                'APPLID' ,
                'COMMAREA' ,
                'LENGTH' ,
                'DATALENGTH' ,
                'TRANSID'      ) */
   /* XX=CA1DLINK('PROGRAM(UCEMPINN)' ,
                'APPLID(CGE5)' ,
                'COMMAREA(COMMAREA)' ,
                'LENGTH(1080)' ,
                'DATALENGTH(4)' ,
                'TRANSID(UTST)') */
  SIGNAL PROCIT
BADSUBST:
  XC = 16
  C_A='INVALID SUBSTITUTION PARAMETER FOR APPLID. CANNOT PROCESS'
  SIGNAL PROCIT
BADPARM:
  XC = 16
  C_A='INVALID PARM RECEIVED. CANNOT PROCESS REQUEST'
PROCIT:
 /* TRACE I*/
 IF MYFUNC = 'QUIET' | MYFUNC = 'MSGBOXALL' THEN DO
  MYCA=C_A
  ADDRESS ISPEXEC 'VPUT (MYCA) ASIS'
  XC = EXCI_RESP
  RETURN XC
  END
 IF MYFUNC = 'MSGBOXONLY' THEN DO
  EXECSEL=MYAPLID
  "ISPEXEC VPUT (EXECSEL) ASIS"
  MYAREA =  XFF||H_MYCA||' REGION:'||MYAPLID
  IF EXCI_RESP = 0 THEN DO
   C_A=STRIP(C_A,'B')
   MYAREA=MYAREA||XFF||TRANSLATE(C_A,XFF,X15)
   END
   ELSE DO
   MYAREA = MYAREA||XFF||'EXCI_RESP IS:' EXCI_RESP||XFF||,
       'EXCI_RESP2 IS:' EXCI_RESP2||XFF||,
       'EXCI_ABCODE IS:' EXCI_ABCODE||XFF||,
       'EXCI_MESSAGE LENGTH IS:' LENGTH(EXCI_MESSAGE)||XFF||,
       'EXCI_MESSAGE IS:' EXCI_MESSAGE
    END
   ADDRESS ISPEXEC "VPUT (MYAREA MYAREA#) ASIS"
   IF MYFUNC = 'MSGBOXALL' THEN RETURN 0
   "ISPEXEC CONTROL DISPLAY REFRESH"
   CALL DSPLYA
   XC = RESULT
   RETURN XC
   END
  IF MYFUNC ^= 'VERBOSE' THEN SIGNAL ARNDPOST
  O_C_A_LEN=LENGTH(C_A)
  C_A=STRIP(C_A,'T')
  N_C_A_LEN=LENGTH(C_A)
  SAY 'MAIN EXEC - RESULT VARIABLE CONTENTS:' RESULT
  SAY
  SAY 'EXCI_RESP IS:' EXCI_RESP
  SAY 'EXCI_RESP2 IS:' EXCI_RESP2
  SAY 'EXCI_ABCODE IS:' EXCI_ABCODE
  SAY 'EXCI_MESSAGE LENGTH IS:' LENGTH(EXCI_MESSAGE)
  SAY 'EXCI_MESSAGE IS:' EXCI_MESSAGE
  SAY
  SAY 'COMMAREA CONTENTS AFTER LINK ARE:'
  SAY 'LENGTH IS:' O_C_A_LEN
  SAY ' STRIPPED 'O_C_A_LEN-N_C_A_LEN' SPACES AT END OF COMMAREA'
  SAY 'COMMAREA WAS:>'H_MYCA
  MCT = 0
  DO WHILE(C_A ^= '')
   PARSE VAR C_A TMP (X15) C_A
   MCT=MCT+1
   MSG.MCT = TMP
   SAY TMP
   END
  IF MCT = 0 '' THEN MSG.1 = 'WARNING - NO OUTPUT RETURNED IN C_A'
 ARNDPOST:
DONIT:
  RETURN XC
###END EXCIS2
$$$BEG DSPAFOCO
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA          -                                              */
 /* CEMHELP          - TSO BASE, RESTRICTED                         */
 /* CEMHELP          -                                              */
 /* CEMHELP END                                                     */
 /* OLD VERSION:DSPAFOC WAS COPIED HERE            */
 /* OLD VERSION:THIS IS THE ONLY CHANGE ADDED HERE */
 /* OLD VERSION:TCEM 20190319                      */
   ADDRESS ISPEXEC
/* TRACE I */
/* TRACE ?I */
/* SAY 'DSPAFOC' */
   TRCCMD='TRACE OFF'
   "ISPEXEC CONTROL ERRORS RETURN"
   AFOLISTV=''
   AFOLISNM=''
   "ISPEXEC VGET (AFOLISNM AFOLISTV) ASIS"
   "ISPEXEC ADDPOP ROW(1) COLUMN(10)"
   IF RC ^= 0 THEN SIGNAL EXITRC24
   EXECSEL='DSPAFOC'
   DFLTM='ENTER ASSOCIATED DATA VALUES. PF3/END CANCEL RESET'
   DSEMSG=DFLTM
   VLL=''
   SP9 = '         '
   FFX='FF'X
   JCLSFMT=''
   ONCEIND=0
   HYCA=''
   VALFUNC='QUIET MSGBOXONLY MSGBOXALL VERBOSE'
   VALFUNC1='Q O A V'
   VALPRMS='MYCMD MYCA MYCAL MYPROG MYTRANID'
   TECCMDS = 'CEMT CEDA'
   VALCMDS = 'PING LINK '||TECCMDS
   'ISPEXEC VGET (CMDIND MYFUNC1 AUTOSAVE) ASIS'
   IF CMDIND ^= 0 THEN CMDIND = 0
   AUTOSAVE='N'
   IF WORDPOS(MYFUNC1,VALFUNC1) = 0 THEN MYFUNC1 = 'O'
   HYFUNC1 = MYFUNC1
   'ISPEXEC VGET (MYCMD) ASIS'
   IF RC ^= 0 THEN SIGNAL EXIITRC8
   IF MYCMD = '' THEN SIGNAL EXITRC8
   IF WORDPOS(MYCMD,VALCMDS) = 0 THEN SIGNAL EXITRC8
   IF WORDPOS(MYCMD,TECCMDS) = 0 THEN DO
    MYICA = ''
    SIGNAL NOT_TECCMD
    END
   IF MYCMD='CEMT' THEN DFTCA='CEMT INQUIRE SYSTEM'
   IF MYCMD='CEDA' THEN DFTCA= 'CEDA EXPAND GROUP(XXXXXXXX)'
   'ISPEXEC VGET (MYICA) ASIS'
   IF RC \= 0 THEN DO
    MYICA=DFTCA
    END
    ELSE DO
    W1 = WORD(MYICA,1)
    IF W1 \= MYCMD THEN MYICA = DFTCA
    END
NOT_TECCMD:
   'ISPEXEC VPUT (MYICA) ASIS'
   'ISPEXEC VGET (MYCA MYCAL) ASIS'
   IF RC ^= 0 THEN DO
    MYCA = MYICA
    MYCAL=4080
   'ISPEXEC VPUT (MYCA MYCAL) ASIS'
    END
    ELSE DO
    MYCA = MYICA
    MYCAL=4080
    'ISPEXEC VPUT (MYCA MYCAL) ASIS'
    END
   IF MYCMD = 'LINK' THEN DO
    'ISPEXEC VGET (MYPROG MYTRANID) ASIS'
    IF RC ^= 0 THEN DO
     MYPROG= ''
     MYTRANID=''
     END
    SELN='INPUT'
    LINKPMSG='ENTER LINK-TO PROGRAM'
    LINKTMSG='ENTER TRANSID TO INVOKE'
    IF MYPROG='' THEN HYPROG='--------'
     ELSE HYPROG=MYPROG
    IF MYTRANID = '' THEN HYTRANID='----'
     ELSE HYTRANID = MYTRANID
    END
    ELSE DO
    SELN='OUTPUT'
    LINKPMSG=''
    LINKTMSG=''
    HYPROG='--------'
    HYTRANID='----'
    END
  /* TRACE I */
   H_CAL=MYCAL
   H_PROG = HYPROG
   H_TRANID=HYTRANID
   MDSN='TTED.TSK.P.TCEM.CLIST'
   "ISPEXEC LIBDEF ISPPLIB DATASET ID('"MDSN"') UNCOND"
   IF RC ^= 0 THEN SIGNAL EXITRC8
RES_CA:
   HYFUNC1=MYFUNC1
   HYCAL=MYCAL
   HYCA=MYCA
   SIGNAL ARND_CLR_CA
CLR_CA:
   HYCA=''
ARND_CLR_CA:
   L_CA=LENGTH(HYCA)
   MX_L_CA = (20*59)
   IF L_CA > MX_L_CA THEN DO
     L_CA_RM = MX_L_CA
     HYCA = SUBSTR(HYCA,1,MX_L_CA - 1)||'+'
     END
    ELSE L_CA_RM = L_CA
   J = 1
   DO I = 1 TO 20
    IF L_CA_RM < 1 THEN H.I = ''
     ELSE DO
     IF L_CA_RM > 59 THEN L_CA_SP = 59
      ELSE L_CA_SP = L_CA_RM
     H.I = SUBSTR(HYCA,J,L_CA_SP)
     J = J + L_CA_SP
     L_CA_RM = L_CA_RM - L_CA_SP
     END
     TRACE OFF
    END
  /* TRACE I */
RESET:
   DO I = 1 TO 20
    INTERPRET "F"I" = H.I"
    TRACE OFF
    END
  /* TRACE I */
   HYPROG = H_PROG
   HYTRANID = H_TRANID
DISPP:
    INTERPRET TRCCMD
   "ISPEXEC DISPLAY PANEL(DSPAFOCD)"
   IF RC = 8 THEN SIGNAL DONEIT
   IF RC ^= 0 THEN SIGNAL EXITRC8
   IF ZCMD = 'HELP' | ZCMD = '?' THEN SIGNAL SHOWFMT
   IF ZCMD = 'RESET' THEN SIGNAL RESET
   IF ZCMD = 'RESCA' THEN SIGNAL RES_CA
   IF ZCMD = 'CLRCA' THEN SIGNAL CLR_CA
   IF ZCMD = 'SETODSN' THEN SIGNAL SET_ODSN
   IF ZCMD = 'CANCEL' THEN SIGNAL EXITRC8
   IF ZCMD = 'CANALL' THEN SIGNAL EXITRC20
   IF ZCMD = 'END' THEN SIGNAL DONEIT
   MCMD=ZCMD
   IF MCMD ^= '' THEN DO
    PARSE VAR MCMD FCMD RCMD
    IF FCMD = 'TRACE' THEN TRCCMD=MCMD
     ELSE "TSO MCMD"
    END
   INTERPRET TRCCMD
   IF RC = 0 THEN SIGNAL DISPP
   SIGNAL DISPP
SHOWFMT:
 MSGBOXTX=FFX||'THE CLRCA WILL RESET THE COMMAREA TO NULLS'||FFX||,
 'THE CLRCA WILL RESET THE COMMAREA TO NULLS'||FFX||,
 'THE RESCA WILL RESE THE CA BACK TO VALUE SHOWN AT FIRST ENTRY'||FFX||,
 'CANCEL WILL END ANY FRUTHER EXECUTION'||FFX||,
 'THE RESET REFRESHES THE CA BACK TO THE LAST ENTER KEY'||FFX||,
 'SETODSN IS USEFUL IF YOU WANT A SPECIFIC DSN NAME FOR QUIET'||FFX||,
 'CANCEL CANCEL THIS SINGLE SELECTION PROCESS'||FFX||,
 'CANALL CANCEL OUT OF A COMMAND PROCESS'||FFX||,
 'END AND '||FFX||,
 'PF3 PROCESSES THE REQUEST. NOTE, I DO NOT DO ANY SYNTAX CHECKING.'
 CALL MSGBOX MSGBOXTX
   SIGNAL DISPP
SET_ODSN:
   XC = 0
   CALL GET_ODSN
   IF XC > 4 THEN SIGNAL RESET
   ADDRESS ISPEXEC "VGET (EDSN) ASIS"
   IF RC ^= 0 THEN SIGNAL RESET
   ODSN = EDSN
   ADDRESS ISPEXEC "VGET (MYVERB) ASIS"
   IF RC ^= 0 THEN SIGNAL RESET
   IF MYVERB ^= '' THEN DO
    IF MYVERB='ABORT' | MYVERB='CANCEL' THEN SIGNAL RESET
    END
DONEIT:
   HYCA=''
   DO J = 1 TO 20
    INTERPRET 'TMP = F'J
    IF TMP = '' THEN ITERATE
    HYCA=HYCA||TMP
    END
/* TRACE ?I */
   IF WORDPOS(MYCMD,TECCMDS) ^= 0 THEN DO
    FW_HYCA=WORD(HYCA,1)
    IF WORDPOS(FW_HYCA,TECCMDS) = 0 THEN HYCA=MYCMD||' '||HYCA
     ELSE IF FW_HYCA ^= MYCMD THEN HYCA=MYCMD||' '||DELWORD(HYCA,1,1)
    END
   L_HCA = LENGTH(HYCA)
   IF L_HCA > HYCAL THEN DO
    IF HYCAL = 0 THEN HYCA = ''
     ELSE HYCA=SUBSTR(HYCA,1,HYCAL)
    END
   MYFUNC1=HYFUNC1
   UPPER AUTOSAVE
   IF AUTOSAVE = 'Y' THEN DO
    CALL GET_ODSN
    IF XC > 4 THEN SIGNAL RESET
    ADDRESS ISPEXEC "VGET (EDSN) ASIS"
    IF RC ^= 0 THEN SIGNAL RESET
    DSPLYADS = EDSN
    ADDRESS ISPEXEC "VPUT (DSPLYADS) ASIS"
    ADDRESS ISPEXEC "VGET (MYVERB) ASIS"
    IF RC ^= 0 THEN SIGNAL RESET
    IF MYVERB ^= '' THEN DO
     IF MYVERB='ABORT' | MYVERB='CANCEL' THEN SIGNAL RESET
     END
    END
   MYCA = HYCA
   MYCAL =HYCAL
   MYICA=MYCA
   "ISPEXEC VPUT (MYCA MYICA MYCAL MYFUNC1 AUTOSAVE) ASIS"
   IF MYCMD = 'LINK' THEN DO
    MYPROG = HYPROG
    MYTRANID = HYTRANID
    "ISPEXEC VPUT (MYPROG MYTRANID) ASIS"
    END
JSTRET0:
 CMDIND = 0
 SIGNAL EXITIT
EXITRC8:
 CMDIND = 8
 SIGNAL EXITIT
EXITRC20:
 CMDIND = 20
 SIGNAL EXITIT
EXITRC24:
 CMDIND = 24
 SIGNAL EXITIT_
EXITIT:
 "ISPEXEC REMPOP"
EXITIT_:
 "ISPEXEC VPUT (CMDIND) ASIS"
 RETURN CMDIND
GET_ODSN:
   "ISPEXEC VGET (DSPLYADS EMBR) ASIS"
   IF RC \= 0 THEN DO
    CALL GETUDSN 'AFOLIST'
    PULL EDSN
    END
    ELSE EDSN=DSPLYADS
   EXECSEL = 'DSPAFOC'
   DSEMSG = 'CHANGE OUTPUT DSN TARGET'
   MYVERB = 'CANCEL ABORT END'
   "ISPEXEC VPUT (EDSN) ASIS"
   "ISPEXEC VPUT (DSEMSG EXECSEL) ASIS"
   "ISPEXEC VPUT (MYVERB) ASIS"
   CALL DSNWIND
   XC = RESULT
   RETURN XC
###END DSPAFOCO
$$$BEG EXCITSLA
PROC 1 KIXREL KIXCTYP(D) KIXENV(SYS)
CONTROL NOCONLIST NOSYMLIST
IF &KIXREL = ? THEN GOTO SHOWMSG
IF &LENGTH(&KIXREL) LT 3 THEN GOTO BADPARM
IF &LENGTH(&KIXREL) GT 3 THEN GOTO BADPARM
IF (&KIXCTYP NE D) AND +
   (&KIXCTYP NE T) AND +
   (&KIXCTYP NE P) THEN GOTO BADPARM
IF (&KIXENV NE SYS) AND +
   (&KIXENV NE PUT) THEN GOTO BADPARM
IF &SUBSTR(1:1,&KIXREL) EQ R THEN GOTO BADPARM
RETRYIT: -
SET &EDSN0='TTE&KIXCTYP..TSK.G.R&KIXREL..&KIXENV..SEYUAUTH'
SET &EDSN1='TTE&KIXCTYP..TSK.G.R&KIXREL..&KIXENV..EXCILIB'
SET &EDSN2='TTE&KIXCTYP..TSK.F.R&KIXREL..LOADLIB'
LISTDSI &EDSN0 NORECALL
DO WHILE &LASTCC > 3
 IF &KIXCTYP = D THEN GOTO BADPARM
 SET &KIXCTYP = D
 GOTO RETRYIT
 END
LISTDSI &EDSN1 NORECALL
DO WHILE &LASTCC > 3
 IF &KIXCTYP = D THEN GOTO BADPARM
 SET &KIXCTYP = D
 GOTO RETRYIT
 END
LISTDSI &EDSN2 NORECALL
DO WHILE &LASTCC > 3
 IF &KIXCTYP = D THEN GOTO BADPARM
 SET &KIXCTYP = D
 GOTO RETRYIT
 END
TSOLIB ACTIVATE DATASET(&EDSN0 &EDSN1 &EDSN2)
TSOLIB DISPLAY
EXIT
BADPARM: -
WRITE INVALID PARM:
WRITE CICS 3 DIGIT RELEASE: &KIXREL
WRITE KIXCTYP : &KIXCTYP
WRITE KIXENV  : &KIXENV
WRITE OR THE LIBRARY &EDSN0 DOES NOT EXIST
WRITE OR THE LIBRARY &EDSN1 DOES NOT EXIST
WRITE OR THE LIBRARY &EDSN2 DOES NOT EXIST
SHOWMSG: -
WRITE PROVIDE A 3 DIGIT CICS RELEASE NUMBER (540, 550, ...)
WRITE AND SPECIFY AN OVERRIDE VARIABLE
WRITE     KIXCTYP(D)
WRITE OR  KIXCTYP(T)
WRITE OR  KIXCTYP(P)
WRITE     KIXENV(SYS)
WRITE OR  KIXENV(PUT)
EXIT
###END EXCITSLA
$$$BEG DSPAFOC
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA          -                                              */
 /* CEMHELP          - TSO BASE, RESTRICTED                         */
 /* CEMHELP          -                                              */
 /* CEMHELP END                                                     */
 /* OLD VERSION:THIS VERSION WAS COPIED TO       */
 /* TTED.TSK.P.TCEM.CLIST(DSPAFOCO)              */
 /*  PRIOR TO ADDING CNC CODE CHANGES            */
 /* AFOLIST NOW LIBDEF ISPN ANBD ISPL LIBS       */
 /*   SO THIS CODE DOES NOT NEED TO              */
 /*                                              */
   ADDRESS ISPEXEC
/* TRACE  I */
/* TRACE ?I */
/* SAY 'DSPAFOC' */
   DSPAFOC_V='3.0'
   TRCCMD='TRACE OFF'
/* TRCCMD='TRACE I' */
   "ISPEXEC CONTROL ERRORS RETURN"
   "ISPEXEC ADDPOP ROW(1) COLUMN(10)"
   IF RC ^= 0 THEN SIGNAL EXITRC24
   EXECSEL='DSPAFOC'
   DFLTM='ENTER ASSOCIATED DATA VALUES. PF3/END CANCEL RESET'
   DSEMSG=DFLTM
   VLL=''
   SP9 = '         '
   FFX='FF'X
   JCLSFMT=''
   ONCEIND=0
   HYCA=''
   VALFUNC='QUIET MSGBOXONLY MSGBOXALL VERBOSE'
   VALFUNC1='Q O A V'
   VALPRMS='MYCMD MYCA MYCAL MYPROG MYTRANID'
   TECCMDS = 'CEMT CEDA'
   VALCMDS = 'PING LINK '||TECCMDS
   'ISPEXEC VGET (CMDIND MYFUNC1 AUTOSAVE) ASIS'
   IF CMDIND ^= 0 THEN CMDIND = 0
   AUTOSAVE='N'
   IF WORDPOS(MYFUNC1,VALFUNC1) = 0 THEN MYFUNC1 = 'A'
   HYFUNC1 = MYFUNC1
   MYDSRC = 'COMMAREA'
   HYDSRC = MYDSRC
   'ISPEXEC VGET (MYCMD) ASIS'
   IF RC ^= 0 THEN SIGNAL EXIITRC8
   IF MYCMD = '' THEN SIGNAL EXITRC8
   IF WORDPOS(MYCMD,VALCMDS) = 0 THEN SIGNAL EXITRC8
   IF WORDPOS(MYCMD,TECCMDS) = 0 THEN DO
    MYICA = ''
    SIGNAL NOT_TECCMD
    END
   IF MYCMD='CEMT' THEN DFTCA='CEMT INQUIRE SYSTEM'
   IF MYCMD='CEDA' THEN DFTCA= 'CEDA EXPAND GROUP(XXXXXXXX)'
   'ISPEXEC VGET (MYICA) ASIS'
   IF RC \= 0 THEN DO
    MYICA=DFTCA
    END
    ELSE DO
    W1 = WORD(MYICA,1)
    IF W1 \= MYCMD THEN MYICA = DFTCA
    END
NOT_TECCMD:
   'ISPEXEC VPUT (MYICA) ASIS'
   'ISPEXEC VGET (MYCA MYCAL) ASIS'
   IF RC ^= 0 THEN DO
    MYCA = MYICA
    MYCAL=4080
   'ISPEXEC VPUT (MYCA MYCAL) ASIS'
    END
    ELSE DO
    MYCA = MYICA
    MYCAL=4080
    'ISPEXEC VPUT (MYCA MYCAL) ASIS'
    END
   IF MYCMD = 'LINK' THEN DO
    'ISPEXEC VGET (MYPROG MYTRANID) ASIS'
    IF RC ^= 0 THEN DO
     MYPROG= ''
     MYTRANID=''
     END
    SELN='INPUT'
    LINKPMSG='ENTER LINK-TO PROGRAM'
    LINKTMSG='ENTER TRANSID TO INVOKE'
    IF MYPROG='' THEN HYPROG='--------'
     ELSE HYPROG=MYPROG
    IF MYTRANID = '' THEN HYTRANID='----'
     ELSE HYTRANID = MYTRANID
    END
    ELSE DO
    SELN='OUTPUT'
    LINKPMSG=''
    LINKTMSG=''
    HYPROG='--------'
    HYTRANID='----'
    END
  /* TRACE I */
   H_CAL=MYCAL
   H_PROG = HYPROG
   H_TRANID=HYTRANID
RES_CA:
   HYFUNC1=MYFUNC1
   HYCAL=MYCAL
   HYCA=MYCA
   SIGNAL ARND_CLR_CA
CLR_CA:
   HYCA=''
ARND_CLR_CA:
   L_CA=LENGTH(HYCA)
   MX_L_CA = (20*59)
   IF L_CA > MX_L_CA THEN DO
     L_CA_RM = MX_L_CA
     HYCA = SUBSTR(HYCA,1,MX_L_CA - 1)||'+'
     END
    ELSE L_CA_RM = L_CA
   J = 1
   DO I = 1 TO 20
    IF L_CA_RM < 1 THEN H.I = ''
     ELSE DO
     IF L_CA_RM > 59 THEN L_CA_SP = 59
      ELSE L_CA_SP = L_CA_RM
     H.I = SUBSTR(HYCA,J,L_CA_SP)
     J = J + L_CA_SP
     L_CA_RM = L_CA_RM - L_CA_SP
     END
/*   TRACE OFF  */
    END
  /* TRACE I */
RESET:
   DO I = 1 TO 20
    INTERPRET "F"I" = H.I"
    TRACE OFF
    END
  /* TRACE I */
   HYPROG = H_PROG
   HYTRANID = H_TRANID
DISPP:
    INTERPRET TRCCMD
   "ISPEXEC DISPLAY PANEL(DSPAFOCD)"
   IF RC = 8 THEN SIGNAL DONEIT
   IF RC ^= 0 THEN SIGNAL EXITRC8
   IF ZCMD = 'HELP' | ZCMD = '?' THEN SIGNAL SHOWFMT
   IF ZCMD = 'RESET' THEN SIGNAL RESET
   IF ZCMD = 'RESCA' THEN SIGNAL RES_CA
   IF ZCMD = 'CLRCA' THEN SIGNAL CLR_CA
   IF ZCMD = 'SETODSN' THEN SIGNAL SET_ODSN
   IF ZCMD = 'CANCEL' THEN SIGNAL EXITRC8
   IF ZCMD = 'CANALL' THEN SIGNAL EXITRC20
   IF ZCMD = 'END' THEN SIGNAL DONEIT
   MCMD=ZCMD
   IF MCMD ^= '' THEN DO
    PARSE VAR MCMD FCMD RCMD
    IF FCMD = 'TRACE' THEN TRCCMD=MCMD
     ELSE "TSO MCMD"
    END
   INTERPRET TRCCMD
   IF RC = 0 THEN SIGNAL DISPP
   SIGNAL DISPP
SHOWFMT:
 MSGBOXTX=FFX||'THE CLRCA WILL RESET THE COMMAREA TO NULLS'||FFX||,
 'THE CLRCA WILL RESET THE COMMAREA TO NULLS'||FFX||,
 'THE RESCA WILL RESE THE CA BACK TO VALUE SHOWN AT FIRST ENTRY'||FFX||,
 'CANCEL WILL END ANY FRUTHER EXECUTION'||FFX||,
 'THE RESET REFRESHES THE CA BACK TO THE LAST ENTER KEY'||FFX||,
 'SETODSN IS USEFUL IF YOU WANT A SPECIFIC DSN NAME FOR QUIET'||FFX||,
 'CANCEL CANCEL THIS SINGLE SELECTION PROCESS'||FFX||,
 'CANALL CANCEL OUT OF A COMMAND PROCESS'||FFX||,
 'END AND '||FFX||,
 'PF3 PROCESSES THE REQUEST. NOTE, I DO NOT DO ANY SYNTAX CHECKING.'
 CALL MSGBOX MSGBOXTX
   SIGNAL DISPP
SET_ODSN:
   XC = 0
   CALL GET_ODSN
   IF XC > 4 THEN SIGNAL RESET
   ADDRESS ISPEXEC "VGET (EDSN) ASIS"
   IF RC ^= 0 THEN SIGNAL RESET
   ODSN = EDSN
   ADDRESS ISPEXEC "VGET (MYVERB) ASIS"
   IF RC ^= 0 THEN SIGNAL RESET
   IF MYVERB ^= '' THEN DO
    IF MYVERB='ABORT' | MYVERB='CANCEL' THEN SIGNAL RESET
    END
DONEIT:
   HYCA=''
   DO J = 1 TO 20
    INTERPRET 'TMP = F'J
    IF TMP = '' THEN ITERATE
    HYCA=HYCA||TMP
    END
/* TRACE ?I */
   IF WORDPOS(MYCMD,TECCMDS) ^= 0 THEN DO
    FW_HYCA=WORD(HYCA,1)
    IF WORDPOS(FW_HYCA,TECCMDS) = 0 THEN HYCA=MYCMD||' '||HYCA
     ELSE IF FW_HYCA ^= MYCMD THEN HYCA=MYCMD||' '||DELWORD(HYCA,1,1)
    END
   L_HCA = LENGTH(HYCA)
   IF L_HCA > HYCAL THEN DO
    IF HYCAL = 0 THEN HYCA = ''
     ELSE HYCA=SUBSTR(HYCA,1,HYCAL)
    END
   MYFUNC1=HYFUNC1
   UPPER AUTOSAVE
   IF AUTOSAVE = 'Y' THEN DO
    CALL GET_ODSN
    IF XC > 4 THEN SIGNAL RESET
    ADDRESS ISPEXEC "VGET (EDSN) ASIS"
    IF RC ^= 0 THEN SIGNAL RESET
    DSPLYADS = EDSN
    ADDRESS ISPEXEC "VPUT (DSPLYADS) ASIS"
    ADDRESS ISPEXEC "VGET (MYVERB) ASIS"
    IF RC ^= 0 THEN SIGNAL RESET
    IF MYVERB ^= '' THEN DO
     IF MYVERB='ABORT' | MYVERB='CANCEL' THEN SIGNAL RESET
     END
    END
   MYCA = HYCA
   MYCAL =HYCAL
   MYICA=MYCA
   "ISPEXEC VPUT (MYCA MYICA MYCAL MYFUNC1 AUTOSAVE) ASIS"
   IF MYCMD = 'LINK' THEN DO
    MYPROG = HYPROG
    MYTRANID = HYTRANID
    "ISPEXEC VPUT (MYPROG MYTRANID) ASIS"
    END
JSTRET0:
 CMDIND = 0
 SIGNAL EXITIT
EXITRC8:
 CMDIND = 8
 SIGNAL EXITIT
EXITRC20:
 CMDIND = 20
 SIGNAL EXITIT
EXITRC24:
 CMDIND = 24
 SIGNAL EXITIT_
EXITIT:
 "ISPEXEC REMPOP"
EXITIT_:
 "ISPEXEC VPUT (CMDIND) ASIS"
 RETURN CMDIND
GET_ODSN:
   "ISPEXEC VGET (DSPLYADS EMBR) ASIS"
   IF RC \= 0 THEN DO
    CALL GETUDSN 'AFOLIST'
    PULL EDSN
    END
    ELSE EDSN=DSPLYADS
   EXECSEL = 'DSPAFOC'
   DSEMSG = 'CHANGE OUTPUT DSN TARGET'
   MYVERB = 'CANCEL ABORT END'
   "ISPEXEC VPUT (EDSN) ASIS"
   "ISPEXEC VPUT (DSEMSG EXECSEL) ASIS"
   "ISPEXEC VPUT (MYVERB) ASIS"
   CALL DSNWIND
   XC = RESULT
   RETURN XC
###END DSPAFOC
$$$BEG TRXCNCL2
/*  REXX   */
/*         */
/* trace i */
/* ALWAYS RETURN THIS VAR WITH A QUICK NOTE SUCCESS/FAILURE */
MSGOUT_NOTE='INITIAL'
/* ALWAYS RETURN THESE VARS: AS A STEM VARIABLE */
/*  WITH THE APPLID AS THE PREFIX, AND THE FOLLOWING AS THE SUFFIX */
RXCNCLN2_RSP_LOG='INITIAL'
RETURN_CN_LIST=''
/* REQUIRED RX VARS */
PROGRAM_NM='UCEMPINR'
APPLID_NM='CGE5'
TRANID_NM='UXXX'
PNLLOADED=0
PLLLOADED=0
/* AND THEN WE PROVIDE A SINGLE RX VAR AS THE SINGLE PARM TO       *\
|*   THE PROGRAM IN WHICH WE ISSUE THE RX CMD:                     *|
|* ADDRESS LINK 'RXCNCLN2 RXVARPARM'                               *|
|* THE RXVARPARM IS EITHER                                         *|
|*   COMMAREA  - YEP THE ACTUAL 'COMMAREA' LITERAL                 *|
|*   OR                                                            *|
|*   SOME_CHAN_NAME - A RX VAR WHICH DEFINES A CHANNEL NAME        *|
|*             - AND WHO'S CONTENTS IS A COMMA SEPARATED LIST      *|
|*             - OF CONTAINERS (WHICH ARE RX VARS WITH THE ACTUAL  *|
|*             - CN DATA)                                          *|
|*   FOR EACH, YOU CAN OPTIONALLY CODE ADDITIONAL RX STEM VARS     *|
|*    WHICH HAVE THE 'COMMAREA' OR SOME_CONT_NAME WITH A '.L'      *|
|*    SUFFIX. THIS IS USED TO CONVEY A LENGTH FOR THE CA OR CN     *|
|*   AND FOR CN VARS, THE SAME SOME_CONT_NAME WITH A '.T' CAN      *|
|*    OPTIONALLY CONVEY THE CN DATATYPE                            *|
|*                                                                 *|
|*                                                                 *|
|*                                                                 *|
\*                                                                 */
/* TEST PARMS                   */
COMMAREA='PINGTHIS IS A TEST'
COMMAREA.L='4096'
CEMT0001='CEMT INQUIRE TASK'
CEMT0001.L='100'
CEMT0001.T='CHAR'
JUNK0001='NOTHING BUT JUNK'
JUNK0001.T='BIT'
CEDA0001='CEDA EXPAND GROUP(CEM)'
MY_CHAN='CEMT0001,JUNK0001,CEDA0001'
/* SIGNAL DO_TEST                */
/* TEST PARMS                    */
'GETCPU1 <PUSH>'
PULL CURCPU CURGRP CURCPUG
 SELECT
  WHEN CURCPU = 'GRP1' THEN APPLID_NM='CGE5'
  WHEN CURCPU = 'GRP2' THEN APPLID_NM='CGE9'
  WHEN CURCPU = 'GRP5' THEN APPLID_NM='BEN0'
  OTHERWISE DO
  APPLID_NM='><'
  SAY 'WARNING: CANNOT DETERMINE WHICH SYSPLEX GROUP'
  SAY '         THIS IS RUNNING ON:GRP:'CURCPU':'
  SAY '         CAN NOT SUPPLY A DEFAULT APPLID'
  SAY '         'APPLID_NM
  END
 END
SAY 'THIS IS A TEST HARNESS TO INVOKE THE EXCI INTERFACE'
SAY ' TO A CICS REGION, UTILIZING CHANNEL AND CONTAINERS'
SAY ' INVOKING NEW COBOL EXCI PROGRAM RXCNCLNK'
SAY 'THIS EXEC HAS REQUIRED AND OPTIONAL PARAMETERS'
SAY '  THAT YOU MUST PROVIDE:'
SAY ' LINK TO CICS PROGRAM NAME (RX NAME PROGRAM_NM):'PROGRAM_NM
SAY ' LINK TO CICS APPLID       (RX NAME APPLID_NM ):'APPLID_NM
SAY ' LINK TO CICS TRANSID      (RX NAME TRANID    ):'TRANID
SAY ' LINK TO CICS COMMAREA     (RX NAME COMMAREA  ):'COMMAREA
SAY ' OR'
SAY ' LINK TO CICS CHANNEL      (RX NAME WHATEVER  ):'MY_CHAN
SAY ' AND SET THE VALUE OF THE WHATEVER RX VAR TO '
SAY '  A LIST OF CONTAINER NAMES:'
SAY '  WITH EACH CN NAMED IS A RX VAR WITH A DATA VALUE'
SAY 'YOU MAY PROVIDE A STEM VAR COMMAREA.L'
SAY '                     OR CONTAINNAME.L TO CONVEY A DATALENGTH'
SAY ' AND (FOR A CONMTAINERNAME YOU CAN SPECIFY'
SAY '        AN RX STEM VAR  CONTAINNAME.T TO CONVEY A DATATYPE'
SAY 'OVERRIDE THE REQUIRED OR PRESS ENTER TO JUST ACCEPT'
SAY ' AND PROVIDE COMMAREA OR A CHANNEL NAME AND FOLLOW THE PROMPTS'
SAY ' TO PROVIDE THE COMMAREA DATA OR CONTAINER NAMES (IN A LOOP)'
SAY '  FOLLOWED BY DATA.'
SAY ''
SAY 'PROGRAM_NM:'PROGRAM_NM
ANS = ''
PULL ANS
ANS = STRIP(ANS,'B')
IF ANS \= '' THEN DO
  IF LENGTH(ANS) > 8 THEN ANS = SUBSTR(ANS,1,8)
  PROGRAM_NM = ANS
  END

SAY ' APPLID_NM:'APPLID_NM
ANS = ''
PULL ANS
ANS = STRIP(ANS,'B')
IF ANS \= '' THEN DO
  IF LENGTH(ANS) > 8 THEN ANS = SUBSTR(ANS,1,8)
  APPLID_NM = ANS
  END

SAY ' TRANID_NM:'TRANID_NM
ANS = ''
PULL ANS
ANS = STRIP(ANS,'B')
IF ANS \= '' THEN DO
  IF LENGTH(ANS) > 4 THEN ANS = SUBSTR(ANS,1,8)
  TRANID_NM = ANS
  END

 RETRYCT = 0
  say 'Provide the Data Source:'
  SAY '(Warning: CAPS are on FOR COMMAREA, CHANNEL AND CONTAINER Names)'
  SAY ' Provide COMMAREA or a CHANNEL name (alway converted to UPPER)'
  SAY ' (IRXEXCOM pgm interface cannot deal with lower case RX var nm)'
  GET_CA_OR_CHANNEL:
  SAY 'ENTER THE WORD COMMAREA, OR A CHANNEL NAME (caps are off):'
  PULL ANS
  IF LENGTH(ANS) = 0 THEN DO
   IF RETRYCT > 0 THEN DO
    SAY 'YOU SELECTED TO QUIT. BYE.'
    RETURN
    END
   SAY 'YOU DID NOT IDENTIFY THE DATA SOURCE. RETRY ONCE'
   SAY ' OR JUST PRESS ENTER AGAIN TO ABORT:'
   RETRYCT = 1
   SIGNAL GET_CA_OR_CHANNEL
   END
/*  TRACE ?I */
  TMP = ANS
  UPPER TMP
  /* TEST FOR COMMAREA OR anyname_CH CHANNEL NAME */
  IF TMP = 'COMMAREA' THEN DO
   CALL GET_COMMAREA
   say RX_RQ_DATA
   say RX_RQ_DATA.L
   IF RC \= 0 THEN DO
    SAY 'ABORT OR CANCEL ENCOUNTERED GETTING THE COMMAREA DATA. BYE'
    RETURN
    END
 /* the RX var passed to the RXCNCLN2 program is either the word   *\
 |*  'COMMAREA' or a channel name. The RX var RX_CNC_CH_NM will    *|
 |*  contain one those two options.                                *|
 |*  address LINK 'RXCNCLN2 RX_CNC_CH_NM'                          *|
 |*  where RX_CNC_CH_NM contains the 'list' of request elements    *|
 |*   a list of CN names, or COMMAREA                              *|
 |*   each element is a RX var of that name, in which is the req   *|
 |*  so RX_CNC_CH_NM = 'COMMAREA'                                  *|
 |*  and RX var commarea=RX_RQ_DATA                                *|
 \*   which is the commearea data collected                        */
   RX_CNC_CH_NM = TMP     /* set the channel to 'COMMAREA' as the  */
                          /*     RX var containing the list of req */
                          /*     variable names; in this case only */
                          /*     the one RX var named commarea     */
   CN_LST = 'RX_RQ_DATA'  /* now put the 'list' of RX req var names*/
                          /*     into the RX var holding that list */
                          /* for commarea, ther is only one RX req */
   /* Later, the var named by RX_CNC_CH_NM will be set to CN_LST   */
   Z = APPLID_NM||'_RX_RQ_DATA'
   INTERPRET Z' = ""'
   SAY Z
   INTERPRET 'SAY 'Z
   INTERPRET "SAY "Z
   SIGNAL DONE_COMMAREA
   END
 /* NOT COMMAREA                */
  /* HERE WE HAVE A CHANNEL NAME */
  /* HERE WE HAVE A CHANNEL NAME */
 RETRY_CH:
  IF LENGTH(ANS) > 16 THEN DO
   RX_CNC_CH_NM = SUBSTR(ANS,1,16)
   SAY 'YOU SPECIFIED A CHANNEL NAME THAT IS TOO LONG.'
   SAY ' NAME IS TRUNCATED TO 16 CHARACTERS>'RX_CNC_CH_NM'<'
   SAY ' IF THIS IS CORRECT, PRESS ENTER TO ACCEPT THIS NAME,'
   SAY ' SPECIFY A DIFFERENT CHANNEL NAME, OR '
   SAY ' ENTER A "!" TO ABORT:'
   PARSE PULL ANS
   IF ANS = '' THEN SIGNAL GOT_CH_NM
   IF ANS = '!' THEN DO
    SAY 'YOU DECIDED TO ABORT WITH CHANNEL NAME PROBLEMS. BYE'
    RETURN
    END
   SIGNAL RETRY_CH
   END
   ELSE DO
   RX_CNC_CH_NM = ANS
   END
 GOT_CH_NM:
  SAY ' YOU PROVIDED A CHANNEL NAME:'RX_CNC_CH_NM

  SAY ''
  SAY 'ENTERING LOOP TO GET CONTAINERS for CHANNEL:'RX_CNC_CH_NM
  SAY ''
  SAY 'NOTE: CAPS are Set to off for Container Names:'
  say ' (utilize your CAPS Lock to force UPPERCASE)'
  say ' Provide the CN Name: You will then capture the request'
  say '   CN data, Length and the CN DataType (C)har or (B)it'
  say '   using a separate panel.'
  say ''
  CN_CT = 0
  CN_LST=''
 TOP_CN_LOOP:
  SAY ' First enter the CN Name (1 - 16 VALID CHARACTERS):'
  SAY ' OR just press ENTER to indicate this loop is complete'
  SAY ' OR enter a single "!" to indicate ABORT processing)'
  ANS = ''
  PULL ANS
  IF ANS = '!' THEN DO
   SAY 'You have indicated ABORT. Bye.'
   RETURN
   END
  IF ANS = '' THEN SIGNAL DONE_CN_LOOP
 RETRY_CN:
  IF LENGTH(ANS) > 16 THEN DO
   RX_CNC_CN_NM = SUBSTR(ANS,1,16)
   SAY 'YOU SPECIFIED A CONTAINER NAME THAT IS TOO LONG.'
   SAY ' NAME IS TRUNCATED TO 16 CHARACTERS>'RX_CNC_CN_NM'<'
   SAY ' IF THIS IS CORRECT, PRESS ENTER TO ACCEPT THIS NAME,'
   SAY ' SPECIFY A DIFFERENT CONTAINER NAME, OR'
   SAY ' ENTER A "!" TO ABORT:'
   PARSE PULL ANS
   IF ANS = '' THEN SIGNAL GOT_CN_NM
   IF ANS = '!' THEN DO
    SAY 'YOU DECIDED TO ABORT WITH CONTAINER NAME PROBLEMS. BYE'
    RETURN
    END
   SIGNAL TOP_CN_LOOP
   END
   ELSE DO
   RX_CNC_CN_NM = ANS
   END
 GOT_CN_NM:
  IF WORDPOS(RX_CNC_CN_NM,CN_LST) > 0 THEN DO
   SAY 'WARNING: CN NAME:'RX_CNC_CN_NM': IS ALREADY CREATED.'
   SAY ' ENTER (C) continue to reuse this existing CN, or'
   say ' ENTER any other key to get a different CN name:'
   pull ans
   if ans \= 'C' then signal TOP_CN_LOOP
   END
  TMP = RX_CNC_CN_NM
  CALL GET_CONTAINER
  IF RC \= 0 THEN RETURN
  CN_CT = CN_CT + 1
  IF WORDPOS(RX_CNC_CN_NM,CN_LST) = 0 THEN CN_LST = CN_LST||TMP||' '
  INTERPRET TMP' = RX_RQ_DATA'
  INTERPRET TMP'.L = RX_RQ_DATA.L'
  INTERPRET TMP'.T = RX_RQ_DATA.T'
  IF CN_CT < 99 THEN SIGNAL TOP_CN_LOOP
  /* MAX 99 CONTAINERS PER REQUEST BY DESIGN */
  SAY 'REACHED MAX 99 CONTAINERS PER REQUEST BY DESIGN'
 DONE_CN_LOOP:
  IF WORDS(CN_LST) < 1 THEN DO
   SAY 'You Have Entered ZERO CONTAINERS'
   SAY 'If this is OK, enter Y, otherwise enter anything else to ABORT'
   PULL ANS
   IF ANS \= 'Y' THEN RETURN
   END
   ELSE DO
   CN_LST=STRIP(CN_LST,'T')
   END
  SAY ' FINISHED CN LOOP WITH 'CN_CT' CONTAINERS'
 DONE_COMMAREA:
    /*                                                              *\
    |* note: the RX_CNC_CH_NM is a var that we pass to pgm RXCNCLN2 *|
    |*  that var contents is either 'COMMAREA' or a channel name    *|
    |*  is either case: that value content is used as a name of the *|
    |*  RX var, in which a list of RX request var names define the  *|
    |*  set of RX reqest vars with data.                            *|
    |*  for commarea:                                               *|
    |*   RX_CNC_CH_NM = 'COMMAREA'                                  *|
    |*     and interpret resolves to COMMAREA=CN_LST                *|
    |*         for which CN_LST='RX_RQ_DATA'                        *|
    |*  for CnC:                                                    *|
    |*   RX_CNC_CH_NM = 'Some_Channel__NM'                          *|
    |*     and interpret resolves to Some_Channel__NM=CN_LST        *|
    |*         for which CN_LST='Cn_one,CN_2,CN_nn'                 *|
    |*   RX_RQ_DATA is the commarea data collected                  *|
    |*   and each CN                                                *|
    |*   had it's value set via an INTERPRET                        *|
    |*     INTERPRET rx_cnc_cn_nm' = rx_rq_data'                    *|
    |*       where the rx_cnc_cn_nm = 'Cn_one'    etc               *|
    |*             and rx_rq_data= 'is the cn data contents'        *|
    \*                                                              */
  INTERPRET RX_CNC_CH_NM' = CN_LST'

  SAY 'LET US REVIEW:'
  SAY 'PROGRAM_NM    :' PROGRAM_NM
  SAY 'APPLID_NM     :' APPLID_NM
  SAY 'TRANID_NM     :' TRANID_NM
  SAY 'Request CA|CH :' RX_CNC_CH_NM
  INTERPRET "SAY 'CN_LST rq list:'"RX_CNC_CH_NM
  J = WORDS(CN_LST)
  SAY 'Sending the following REQUEST RX data vars:'
  DO I = 1 TO j
   tmp_rq_nm = word(cn_lst,i)
   SAY 'rq NAME:'tmp_rq_nm
   interpret 'tmp_data = 'tmp_rq_nm
   SAY 'rq DATA:'tmp_data
   SAY '---'
   END
  SAY 'Here we GO:'
  SAY 'NOTE: THE COBOL Pgm IS EXPECTED TO RETURN THE FOLLOWING VARS:'
  SAY 'MSGOUT-NOTE  - RX var with simple success/failure note'
  SAY 'RXCNCLN2_RSP_LOG - LOG of RXCNCLN2 actions'
  SAY 'RETURN_CN_LIST lIST OF RETURNED VARS - WHICH ARE CICS CONTAINERS'
  SAY 'Other RX vars (CNC CN) migh be included in the return set'
  SAY ''
  IF PLLLOADED > 0 THEN SIGNAL GOTMYDSN
   MYDSN='TTEP.TSK.E.TCEM.PDSE'
   IDVAL_CT = 0
 TRYAGN_ISPL:
   IDVAL=''
   'ISPEXEC QLIBDEF 'ISPLLIB' ID(IDVAL)'
   XC = RC
   IF IDVAL \= '' THEN DO
    IF IDVAL_CT > 1 THEN DO
     SAY 'COULD NOT LIBDEF ISPLLIB. LOOP??'
     RETURN 8
     END
    XDSN=TRANSLATE(IDVAL,"  ",",'")
    IF WORDPOS(MYDSN,XDSN) \= 0 THEN SIGNAL GOTMYDSN
    CALL EXPLLDEF 'ISPLLIB' MYDSN 'STACK' 'QUIET'
    XC=RESULT
    IDVAL_CT = IDVAL_CT + 1
    SIGNAL TRYAGN_ISPL
    END
   IF IDVAL = '' THEN DO
    CALL EXPLLDEF 'ISPLLIB' MYDSN 'STACK' 'QUIET'
    XC=RESULT
    IF XC > 4 THEN DO
     SAY 'COULD NOT LIBDEF ISPLLIB. RC WAS'RC
     RETURN 8
     END
    END
 GOTMYDSN:
    PLLLOADED = 1
/* TRACE ?I */
/*    CALL COBOL PROGRAM   */
/*ADDRESS TSO */
/*ALLOC FI(SYSOUT) DA(*) SHR REUSE' */
/* "CALL 'TTED.TSK.P.TCEM.LOADLIB(EXPLPGM3)' 'TVAR1,TVAR2'" */
/* CALL DOES NOT INITIALIZE THE ENVIRONMENT BLOCK */
/*"CALL 'TTEP.TSK.E.TCEM.PDSE(RXVARS)' 'TVAR1,TVAR2'" */
/*  "CALL 'TTEP.TSK.E.TCEM.PDSE(RXCNCLNK)' 'PROGRAM_NM,"||,         *\
|*  "APPLID_NM,RX_CNC_CH_NM,RX_CNC_CN_REQ_LST,RX_CNC_CN_RSP_LST,"||,*|
\*  "TRANID_NM'"                                                    */
/*    CALL COBOL PROGRAM   */
/*    CALL COBOL PROGRAM   */
  SAY 'CALL COBOL PROGRAM? Enter G to Co, or anykey to abort:'
  pull ans
  IF ANS \= 'G' THEN DO
   SAY 'YOU CHOOSE TO ABORT. BYE.'
   RETURN
   END
  /* TRACE I */
  address link "RXCNCLN2 RX_CNC_CH_NM"
  XC = RC
  SAY XC
  TRACE OFF
/* SHOW VARS */
  SAY 'RETURN FROM RXCNCLNK WITH RC:'RC
/*TRACE ?I */
  IF RC > 4 THEN DO
   SAY 'NON ZERO RETURN CODE' RC
   END
  TRACE OFF
  SAY ''
  SAY 'MSGOUT_NOTE MESSAGE (IF ANY)'
  SAY MSGOUT_NOTE
  SAY ''
  SAY 'REXX VARIABLES SENT:'
  SAY 'PROGRAM_NM    :' PROGRAM_NM
  SAY 'APPLID_NM     :' APPLID_NM
  SAY 'TRANID_NM     :' TRANID_NM
  SAY 'RX_CNC_CH_NM  :' RX_CNC_CH_NM
  SAY 'CA|CN  LIST   :' CN_LST
  SAY ''
DO_TEST:
 /*  TRACE ?I */
  IF EXCI_MESSAGE \= 'INITIALIZE' THEN DO
   SAY 'EXCI response values for fialure:'
   SAY ' EXCI_RESP1  :'||EXCI_RESP1
   SAY ' EXCI_RESP2  :'||EXCI_RESP2
   SAY ' EXCI_ABCODE :'||EXCI_ABCODE
   SAY ' EXCI_MESSAGE:'||EXCI_MESSAGE
   SAY '---'
   END
  /* TRACE ?I */
  SAY 'EXPECT REXX RETURN VARIABLES: RXCNCLN2_RSP_LOG & RETURN_CN_LIST'
  TMP_NM = 'RXCNCLN2_RSP_LOG'
  TMP_CN_MSG = RXCNCLN2_RSP_LOG
  SAY 'DISPLAY 'TMP_NM' CONTENTS?'
  SAY 'ENTER Y TO DISPLAY DATA OR ANY OTHER KEY TO BYPASS:'
  PULL ANS
  IF ANS = 'Y' THEN CALL SHOWRXDATA
  SAY ''
  TMP_NM = 'RETURN_CN_LIST'
  TMP_CN_MSG = RETURN_CN_LIST
  SAY 'DISPLAY 'TMP_NM' CONTENTS?'
  SAY 'ENTER Y TO DISPLAY DATA OR ANY OTHER KEY TO BYPASS:'
  PULL ANS
  IF ANS = 'Y' THEN CALL SHOWRXDATA
  SAY ''
  /*  SHOW RESP DATA                                */
  IF RETURN_CN_LIST = '' THEN DO
   SAY 'LIST OF RETURNED DATA VARS (RETURN_CN_LIST) IS EMPTY.'
   SAY ' NO DATA TO DISPLAY.'
   SIGNAL FINIT
   END
/*trace ?i   */
  WP=POS('(',RETURN_CN_LIST)
  IF WP > 1 THEN DO
   RETURN_CN_LIST=SUBSTR(RETURN_CN_LIST,WP + 1)
  END
  RETURN_CN_LIST = TRANSLATE(RETURN_CN_LIST,' ',',')
  CN_CT = WORDS(RETURN_CN_LIST)
  CN_WD_NUM=0
  CN_WD=''
 GOT_RSP_DATA:
/*trace ?i */
  CN_WD_NUM = CN_WD_NUM + 1
  IF CN_WD_NUM > CN_CT THEN DO
   SAY 'ALL DATA RESP VARS PROCESSED.'
   SIGNAL FINIT
   END
  RSPNM=WORD(RETURN_CN_LIST,CN_WD_NUM)
/*IF RX_CNC_CH_NM = 'COMMAREA' THEN RSPNM=APPLID_NM||'_'||RSPNM */
  /*  interpret 'TMP_NM = "'APPLID_NM||'_'||RSPNM'"' */
  interpret 'TMP_NM = "'RSPNM'"'
  interpret 'TMP_CN_MSG = 'tmp_nm
  tmp_cn_msg=strip(tmp_cn_msg,'t','00'x)
  SAY 'DISPLAY: 'RSPNM': CONTENTS?'
  SAY 'ENTER Y TO DISPLAY DATA OR ANY OTHER KEY TO BYPASS:'
  PULL ANS
  IF ANS = 'Y' THEN CALL SHOWRXDATA
  SAY ''
  SIGNAL GOT_RSP_DATA
 FINIT:
  SAY ''
  SAY 'FINISHED TRXCNCL2. BYE'
  EXIT
/* SUB ROUTINE TO DISPLAY RETURNED DATA */
SHOWRXDATA: PROCEDURE EXPOSE TMP_NM TMP_CN_MSG
MSG_LF_DLM='15'X
CPY_#=COPIES('-',60)
RSPCT = 0
DO WHILE TMP_CN_MSG \= ''
 PARSE VAR TMP_CN_MSG TMP (MSG_LF_DLM) TMP_CN_MSG
 IF TMP \= '' THEN DO
  RSPCT = RSPCT + 1
  RSP.RSPCT = TMP
  END
 END
SAY 'FOUND<' RSPCT '> LINES IN RESP_CN_MSG'
M0 = 1
ANS = '>'
DO WHILE ((POS(ANS,'<=>')) \= 0)
 CURLN = M0
 MXLN = RSPCT - CURLN
 IF MXLN > 60 THEN MXLN = CURLN + 60
  ELSE MXLN = CURLN + MXLN
 DO I = CURLN TO MXLN
   SAY RSP.I
   SAY CPY_#
   END
  SAY 'LAST DISPLAY: LINE:' CURLN ' THRU:' MXLN ' OF:' RSPCT
  SAY 'ENTER > TO CONTINUE FORWARD'
  SAY '      = TO RE DISPLAY CURRRENT SET'
  SAY '      < TO CONTINUE FORWARD'
  SAY ' OR ANY OTHER KEY STOP THIS MESSAGE DISPLAY'
  PULL ANS
  SELECT
   WHEN ANS = '>' THEN DO
                  M0 = CURLN + MXLN
                  IF M0 >= RSPCT THEN M0 = (RSPCT - MXLN) + 1
                  END
   WHEN ANS = '=' THEN M0 = CURLN
   WHEN ANS = '<' THEN DO
                  M0 = CURLN - MXLN
                  IF M0 <= 0 THEN M0 = 1
                  END
   OTHERWISE SAY 'SELECTED TO LEAVE:' ANS ':'
   END
 END
 RETURN
  /* GET THE CONTAINER */
  /* GET THE CONTAINER */
  /* GET THE CONTAINER */
 GET_CONTAINER:
/* TRACE ?I */
   TMP4 = SUBSTR(rx_cnc_cn_nm,1,4)
   SELECT
    WHEN TMP4 = 'CEMT' THEN LR1='CEMT INQUIRE TASK'
    WHEN TMP4 = 'CEDA' THEN LR1='CEDA EXPAND GROUP(XXXXXXXX)'
    WHEN TMP4 = 'PING' THEN LR1='PINGThis Is A TesT!'
    WHEN TMP4 = 'LINK' THEN LR1='LINK,PROGRAM(UCEMPINQ)'
    OTHERWISE LR1='Enter The Request Data'
    END
   RX_RQ_DATA = LR1
   RX_RQ_DATA.L = length(RX_RQ_DATA)
   RX_RQ_DATA.T = 'CHAR'
 GET_CONTAINER_AGN:
   /*  'ISPEXEC SELECT CMD(TSTAFOCN 'tmp') ' */
   call TSTAFOCN rx_cnc_ch_nm
   IF RC \= 0 THEN RETURN 8
   SAY 'CONTAINER Data Provided for:'RX_CNC_CN_NM
   SAY STRIP(RX_RQ_DATA,'T')
   SAY RX_RQ_DATA.L
   SAY RX_RQ_DATA.T
   cal=RX_RQ_DATA.L
   IF CAL = '' then signal get_cNl_retry0
   IF DATATYPE(CAL,'W') = 0 then signal get_cNl_retry1
   if cal = 0 then signal get_cNl_retry2
   if cal < 0 | cal > 200000 then signal get_cNl_retry3
   return 0     /* return to                              */
  get_cNl_retry0:
    say 'You specified an invalid value for the CONTAINER length:'
    signal get_cNl_retry
  get_cNl_retry1:
    say 'You specified an non numeric value for the CONTAINER length:'
    signal get_cNl_retry
  get_cNl_retry2:
    say 'Your CONTAINER length is zero. Confirm with (C)continue:'
    signal get_cNl_retry
  get_cNl_retry2:
    say 'Your CONTAINER length is not in a valid range 0 - 200000:'
    signal get_cNl_retry
  get_cNl_retry:
    say 'Cn_L>'cal'<'
    do forever
    say ' Press C to Continue with no  CONTAINER:'
    say ' Press R to Retry Get CONTAINER logic'
    say ' Press A to ABORT:'
    pull ans
    if ans = 'C' then return 0
    if ans = 'A' then return 8
    if ans = 'R' then leave
    end
   signal GET_CONTAINER_AGN
 GET_CONTAINER_AGN_XIT:
    RETURN 16
  /* GET THE COMMAREA */
  /* GET THE COMMAREA */
  /* GET THE COMMAREA */
 GET_COMMAREA:
/* trace ?i */
 GET_COMMAREA_AGN:
   RX_RQ_DATA = 'CEMT INQUIRE TASK'
   RX_RQ_DATA.L = '4096'
   /*  'ISPEXEC SELECT CMD(TSTAFOCN 'tmp') ' */
    call TSTAFOCN 'COMMAREA'
   IF RC \= 0 THEN RETURN 8
   SAY 'COMMAREA Provided:'
   SAY STRIP(RX_RQ_DATA,'T')
   SAY RX_RQ_DATA.L
   cal = RX_RQ_DATA.L
   IF CAL = '' then signal get_cal_retry0
   IF DATATYPE(CAL,'W') = 0 then signal get_cal_retry1
   if cal = 0 | cal > 32000 then signal get_cal_retry2
   if cal < 0 | cal > 32000 then signal get_cal_retry3
   return 0
  get_cal_retry0:
    say 'You specified an invalid value for the COMMAREA length:'
    signal get_cal_retry
  get_cal_retry1:
    say 'You specified an non numeric value for the COMMAREA length:'
    signal get_cal_retry
  get_cal_retry2:
    say 'Your COMMAREA length is zero. Confirm with (C)continue:'
    signal get_cal_retry
  get_cal_retry2:
    say 'Your COMMAREA length is not in a valid range 0 - 32000:'
    signal get_cal_retry
  get_cal_retry:
    say 'CAL>'cal'<'
    do forever
    say ' Press C to Continue with no COMMAREA'
    say ' Press R to Retry Get COMMAREA logic'
    say ' Press A to ABORT:'
    pull ans
    if ans = 'C' then return 0
    if ans = 'A' then return 8
    if ans = 'R' then leave
    end
   signal GET_COMMAREA_AGN
 GET_COMMAREA_L_XIT:
    RETURN 16
/* REXX */
 TSTAFOCN:
/* trace ?i */
  XC = 0
  CA_OR_CN = ''
  ARG CA_OR_CN
  IF CA_OR_CN = '' THEN RETURN 8
  IF PNLLOADED > 0 THEN SIGNAL GOTMYPNL
  ADDRESS ISPEXEC
  'ISPEXEC CONTROL ERRORS RETURN'
  MYPNL='TTED.TSK.D.TCEM.ISPPLIB'
  IDVAL_CT = 0
 TRYAGN:
  IDVAL=''
  'ISPEXEC QLIBDEF 'ISPPLIB' ID(IDVAL)'
  XC = RC
  IF IDVAL \= '' THEN DO
   IF IDVAL_CT > 1 THEN DO
    SAY 'COULD NOT LIBDEF ISPPLIB. LOOP??'
    RETURN 8
    END
   XDSN=TRANSLATE(IDVAL,"  ",",'")
   IF WORDPOS(MYPNL,XDSN) \= 0 THEN SIGNAL GOTMYPNL
   CALL EXPLLDEF 'ISPPLIB' MYPNL 'STACK' 'QUIET'
   XC=RESULT
   IDVAL_CT = IDVAL_CT + 1
   SIGNAL TRYAGN
   END
  IF IDVAL = '' THEN DO
   STKLIBS=MYPNL
   CALL EXPLLDEF 'ISPPLIB' STKLIBS 'STACK' 'QUIET'
   XC=RESULT
   IF RC > 4 THEN DO
    SAY 'COULD NOT LIBDEF ISPPLIB. RC WAS'RC
    RETURN 8
    END
   END
 GOTMYPNL:
  PNLLOADED = 1
  mysc = 'PAGE'
  execsel='TSTAFOCN'
  LR1 = RX_RQ_DATA
  LR1LNG = RX_RQ_DATA.L
  IF CA_OR_CN = 'COMMAREA' THEN DO
   cnto='COMMAREA'
   cnty = ''
   cntystr=''
   cncchnm='COMMAREA'
   GET_PNL_NM = 'GETAFOCA'
   END
   ELSE DO
   cnto=rx_cnc_cn_nm
   cnty='CHAR'
   cntystr='CHAR,BIT,CDSN,BDSN'
   cncchnm = CA_OR_CN
   GET_PNL_NM = 'GETAFOCN'
   END
  canstr='ABORT,CANCEL'
  cmdstr='END,COPY,CDSN,BDSN,RESET,'||CANSTR
  cnstrip='Y'
  h_cnto=cnto
  h_cnty=cnty
  h_LR1LNG=LR1LNG
  h_cnstrip=cnstrip
  xc = 0
  acmd = ''
  "ISPEXEC ADDPOP"
 TOPOFLOP:
   zcmd = ''
   execsel='TSTAFOCN'
   "ISPEXEC DISPLAY PANEL("GET_PNL_NM")"
   xc = rc
   acmd = zcmd
   if xc = 8 then signal donit
   if acmd = 'CANCEL' then signal canit
   if acmd = 'RESET' then do
    call doreset
    signal topoflop
    end
   if acmd = 'COPY' then do
    call docopy
    signal topoflop
    end
   if acmd = 'CDSN' | acmd = 'BDSN' then do
    if substr(cnty,1,1) \= substr(acmd,1,1) then do
     cmcmsg = acmd':failed:cn type:'cnty
     signal topoflop
     end
    call docopy
    if rc \= 0 then do
     cmcmsg = acmd':failed:gdsn'
     signal topoflop
     end
    LR1 = '<'||EDSN||'>'
    cnty=acmd
    signal topoflop
    end
   IF CA_OR_CN = 'COMMAREA' THEN
    cncmsg='ENTER more COMMAREA DATA'
    ELSE
    cncmsg='ENTER more CONTAINER DATA'
   signal topoflop
donit:
   say 'donit!'
   SAY 'RQ:'||CNTO
   SAY 'RQ TYPE:'||cnty||':'
   SAY 'rq Strip Trailing Spaces:'cnstrip':'
   if cnstrip = 'Y' then do
    lr1 = strip(lr1,'T')
    IF CA_OR_CN \= 'COMMAREA' THEN LR1LNG = length(LR1)
    end
   SAY 'RQ Data:'
   SAY LR1
   SAY 'LENGTH:'||LENGTH(LR1)||':'
   RX_RQ_DATA = LR1
   RX_RQ_DATA.L = LR1LNG
   RX_RQ_DATA.T = cnty
 canit:
  "ISPEXEC REMPOP"
 return xc
/* sub routines */
/* sub routines */
/* sub routines */
 docopy:
  edsn = 'src.for.cn.dsn'
  embr = 'src_mbr'
  dsemsg = 'Enter DSN (opt MBR) for 'CA_OR_CN' data'
  "ISPEXEC VPUT (EDSN EMBR DSEMSG EXECSEL) ASIS"
  IF RC > 0 THEN DO
   cmcmsg = 'COPY failed to get 'CA_OR_CN' data (vput)'
   signal donecopy
   end
  call gdsnnmbr
  if rc > 4 then do
   cmcmsg = 'COPY failed to get 'CA_OR_CN' data (gdsn)'
   signal donecopy
   end
  "ISPEXEC Vget (EDSN EMBR) ASIS"
  IF RC > 0 THEN DO
   cmcmsg = 'COPY failed to get 'CA_OR_CN' data (vget_gdsn)'
   signal donecopy
   end
  if EDSN = '' THEN DO
   cmcmsg = 'COPY failed to get 'CA_OR_CN' data (vget_EDSN)'
   signal donecopy
   end
  if EMBR \= '' THEN DO
   EDSN = EDSN||'('||EMBR||')'
   "ISPEXEC VPUT (EDSN) ASIS"
   IF RC > 0 THEN DO
    cmcmsg = 'COPY failed to get CN DSN (VPUT)'
    signal donecopy
    end
   end
  if mcmd \= 'COPY' then return xc
  tgtdata = ''
  CALL CPDS2VAR "<EDSN> <TGTDATA>"
  if rc = 0 then do
   "ISPEXEC VGET (TGTDATA) ASIS"
   IF RC > 0 THEN DO
    cmcmsg = 'COPY failed to get CN data(VGET)'
    signal donecopy
    end
   LR1 = TGTDATA
   lr1lng = length(TGTDATA)
 donecopy:
  xc = rc
  return xc

doreset:
 IF CA_OR_CN = 'COMMAREA' THEN
  cncmsg='(reset)ENTER COMMAREA DATA'
  ELSE
  cncmsg='(reset)ENTER CONTAINER DATA'
 cnto=h_cnto
 cnty=h_cnty
 LR1LNG=h_LR1LNG
 cnstrip=h_cnstrip
 CN_CMD=SUBSTR(CNTO,1,4)
 SELECT
 WHEN CN_CMD = 'CEMT' THEN LR1 = 'CEMT INQUIRE SYSTEM'
 WHEN CN_CMD = 'CEDA' THEN LR1 = 'CEDA EXPAND GROUP(XXXXXXXX)'
 WHEN CN_CMD = 'PING' THEN LR1 = 'PINGThis is a PING test'
 OTHERWISE LR1 = 'ENTER CN DATA'
 END
 return
###END TRXCNCL2
$$$BEG DSPCNCCH
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA          -                                              */
 /* CEMHELP          - TSO BASE, RESTRICTED                         */
 /* CEMHELP          - not used                                     */
 /* CEMHELP END                                                     */
 HELPTOP:
 /*                                                                 *\
 |* MANGE THE SET OF CHANNELS:                                      *|
 |*  CHANNEL TEMPLATE IS CREATED FOR YOU IN CHANNEL AFO_DFLT_CHNM   *|
 |*   WITH THREE CONTAINERS CEMT000# CEDA000# PING000#              *|
 |*  EDIT    REVIEW AND EDIT THE CN CONTENTS                        *|
 |*  COPY    COPY CHANNEL CONTAINERS TO A NEW CHANNEL               *|
 |*  ADD     ADD A EMPTY, NEW CHANNEL; GO TO EDIT CHANNEL           *|
 |*  DELETE  REMOVE A CHANNEL AND CONTAINERS                        *|
 |*  USE EDIT   TO REVIEW/EDIT THE CONTAINER LIST                   *|
 |*                                                                 *|
 |*  PF3 OR END WILL PROCESS; CANCEL WILL ABORT CNC ACTION          *|
 |*  ? TO SEE THIS HELP DATA                                        *|
 \*                                                                 */
 HELPBOT:
  HELPTOP_SRCLN = 8
  HELPBOT_SRCLN = 20
 /*                                                                 *\
 |* THE ABOVE SRCLN VARS ARE USE IN THE HELP OPTION                 *|
 |*  IF YOU ADD OR DELETE LINES WITHIN THE HELPTOP:HELPBOT LABELS   *|
 |*   YOU MUST ADJUST THE SCRLN VARS ACCORDINGLY                    *|
 \*                                                                 */
  FFX ='FF'X
  HELPDATA=FFX
 /* TRACE I */
  ADDRESS ISPEXEC
  'ISPEXEC LIBDEF ISPPLIB'
  XC = 8
  CHNM_DFT='AFO_DFLT_CHNM'
  ICHCT=0
  ICNCT=0
   /*                                                     *\
   |*  VGET CHANNEL VARS TO SEE IF THIS IS FIRST TIME     *|
   |*   IF NF (FIRST), CREATE DEFAULT CH AND CN           *|
   \*                                                     */
  ICHLST = ''
  'ISPEXEC VGET (ICHLST) ASIS'
   /*                                                     *\
   |* if ichlst is not found then set it up for initial   *|
   |* enter the initialization do loop                    *|
   \*                                                     */
  ICHCT = WORDS(ICHLST)
   /*                                                     *\
   |* USING ISP VAR TO STORE THE FOLLOWING:               *|
   |*  CHANNEL NAMES (01 TO 99) STORED IN VAR ICH__       *|
   |*  WHERE THE __ PROVIDES ACCESS TO THE CH NAME        *|
   |*  THE LIST OF CHANNEL NAMES ARE IN VAR ICHLST        *|
   |*  USING THE POSITION OF THE CH NAME, WE CAN IMPLY    *|
   |*  THE REFERENCE TO THE RESPECTIVE SET OF CN FOR CH   *|
   |*  BY USING WORDPOS TO DERIVE THE __ COMPONENT OF     *|
   |*  THE RESPECTIVE ICN__## ICV__## PAIRS               *|
   |*                                                     *|
   |*  CONTAINER NAMES ARE ASSOCIATED WITH THE CHANNEL    *|
   |*  NUMERIC. UP TO 99 CONTAINERS PER CHANNEL AND       *|
   |*  THEIR UNIQUE NAMES ARE STORE IN VAR ICN__##        *|
   |*  AND THE ASSOCIATED VALUE IN VAR     ICV__##        *|
   |*  AND THE ASSOCIATED CN TYPE IN VAR   ICT__##        *|
   |*  ALL ACTUAL CN NAMES PER  CH IN VAR  ICN__LST       *|
   |*  NOTE: THE __ ASSOCIATES TO THE ICH__ CH NAME       *|
   |*  AND   THE ## PROVIDES ACCESS TO 01-99 CN AS A GROUP*|
   |*                                                     *|
   |*  WHEN WE WANT TO GAIN ACCESS TO ALL CH DEFINED      *|
   |*   GET THE ISP VAR ICHLST:    EACH ICH__ VAR         *|
   |*   IS LISTED SPACE SEPARATED                         *|
   |*                                                     *|
   |*  USING wordpos calculated from the ichlst entry     *|
   |*   WE CAN GET THE ASSOCIATED CN LIST FOR THAT        *|
   |*   CH.                                               *|
   |*  GET THE LIST OF CN FOR THE CH BY VGET THE VAR      *|
   |*   ICN__LST. the wordpos of the cn in icn__lst       *|
   |*   is used to access the icn__## icv__## ISP VARs    *|
   |*   where the __ is RESPECTIVE to ich0__ name         *|
   |*   AND THE ## IS A 01-99 VALUE and is respective to  *|
   |*   ## in ICN__## CONTAINING THE CONTAINER NAME       *|
   |*   and ## in ICv__## CONTAINING THE CONTAINER value  *|
   |*                                                     *|
   |*  FOR EXAMPLE: (NOTE:LOWER CASE IS ACCEPTABLE)       *|
   |*   ICHLST HOLDS 'AFO_DFLT_CHNM A_NEW_CHANNEL_NM' LIST*|
   |*   ICH01 HOLDS LIST OF CN IN CH AFO_DFLT_CHN         *|
   |*         'CEMT000# CEDA000#_IS_LONG'                 *|
   |*   ICN0101='CEMT000#'                                *|
   |*   ICV0101='CEMT INQUIRE TASK'                       *|
   |*   ICT0101='CHAR'                                    *|
   |*   ICN0102='CEDA000#_IS_LONG'                        *|
   |*   ICV0102='CEDA EXPAND GROUP(XXXXXXXX)'             *|
   |*   ICT0102='CHAR'                                    *|
   |*                                                     *|
   |* NOTE: TO DYNAMICALLY FORMAT THE ICN AND ICV VAR NAME*|
   |*  USE THE SAMPLE CODE WHERE '2' IS THE NUM OF DIGITS *|
   |*  TO BE INSERTED INTO THE VAR NAME :01-99 UNIQUE VARS*|
   |*  WORDS FUNCTION ALWAYS TRUNCATES LEATING ZEROS      *|
   |*  '0' MAKES 1 PREFIX DIGIT AVAILABLE                 *|
   |* U='ICN'||SUBSTR('0'||WORDS(ICHLST),LENGTH(ICHLST),2)*|
   |* INTERPRET U' = "AFO_CN_NAME'                        *|
   \*                                                     */
  IF RC > 0 | ICHCT = 0 THEN DO
   "ISPEXEC VERASE (ICHLST) BOTH"
   ICH01=''
   ICHLST=CHNM_DFT
   'ISPEXEC VPUT (ICH01 ICHLST) ASIS'
   IF RC > 0 THEN DO
    SIGNAL VPUT_DFT_FAILED
    END
   ICN0101='CEMT000#'
   ICV0101='CEMT INQUIRE TASK'
   ICT0101='CHAR'
   ICH01=ICH01||' '||ICN0101
   'ISPEXEC VPUT (ICN0101 ICV0101 ICT0101 ICH01) ASIS'
   IF RC > 0 THEN DO
    SIGNAL VPUT_DFT_FAILED
    END
   ICN0102='CEDA000#'
   ICV0102='CEDA EXPAND GROUP(XXXXXXXX)'
   ICT0102='CHAR'
   ICH01=ICH01||' '||ICN0102
   'ISPEXEC VPUT (ICN0102 ICV0102 ICT0102 ICH01) ASIS'
   IF RC > 0 THEN DO
    SIGNAL VPUT_DFT_FAILED
    END
   ICN0103='PING000#'
   ICV0103='PINGThiS is A TEStToo'
   ICT0103='CHAR'
   ICH01=ICH01||' '||ICN0103
   'ISPEXEC VPUT (ICN0103 ICV0103 ICT0103 ICH01) ASIS'
   IF RC > 0 THEN DO
    SIGNAL VPUT_DFT_FAILED
    END
   /*                                                     *\
   |* VPUT SIDE IS DONE ABOVE                             *|
   \*                                                     */
   END
  /*                                                      *\
  |* exit   the initialization do loop                    *|
  |* VGET SIDE IS DONE BELOW FOR CHANNEL TABLE            *|
  \*                                                      */
  /* ARG ICHLST */
  SUID=SYSVAR(SYSUID)
  SDT=DATE('U')
  FDS=1
  AMT='CSR'
  ACTION='-'
  SIGNAL OFF ERROR
  ADDRESS ISPEXEC
  "ISPEXEC CONTROL ERRORS RETURN"
  MDSN='TTED.TSK.D.TCEM.ISPPLIB'
  "ISPEXEC LIBDEF ISPPLIB DATASET ID('"MDSN"') COND"
  IF RC > 8  THEN DO
    MSGTXT='ERROR ON LIBDEF ISPPLIB::'MDSN
    CALL   SHOWMBOX
    SIGNAL DO_FIN
    END
  ZWINTTL = 'AFOLIST CNC'
  "ISPEXEC ADDPOP ROW(2) COLUMN(20)"
  /* TBLCNCCH HAS 4 COLS: ACTION CHANNELNAME CN_COUNT 1ST_CN_NAME */
  "ISPEXEC TBCREATE TBLCNCCH "||,
    "NAMES(ACTION FA FB FC FD) NOWRITE REPLACE"
   IF RC > 4 THEN DO
   MSGTXT ='COULD NOT CREATE THE TBLCNCCH CHANNEL NAMES TABLE FOR LIST'
   CALL   SHOWMBOX
   SIGNAL DO_FIN
   END
  FB = 0
  FD = '---'
  ICHCT = WORDS(ICHLST)
  DO I = 1 TO ICHCT
   FA = WORD(ICHLST,I)
   U='ICH'||SUBSTR('0'||I,LENGTH(I),2)
   'ISPEXEC VGET ('U') ASIS'
   IF RC > 4 THEN DO
   MSGTXT ='COULD NOT ACCESS ISP VAR:'U': FROM CHLST:'ICHLST':'
   CALL   SHOWMBOX
   SIGNAL DO_FIN
   END
   INTERPRET 'FB = "0"||WORDS('U')'
   FB = SUBSTR('0'||FB,LENGTH(FB),2)
   INTERPRET 'FC = WORD('U',1)'
   "ISPEXEC TBADD TBLCNCCH"
   IF I > 5 THEN TRACE OFF
   END
  /* TRACE I */
  EXECSEL='DSPCNCCH'
  "ISPEXEC TBTOP TBLCNCCH"
  "ISPEXEC VPUT (EXECSEL) ASIS"
  CANSTR='CANCEL ABORT'
  DONSTR='DONE END'
  CMDSTR=CANSTR||' '||DONSTR
  PROCLST='-,E,C,A,D'
  PROCLST_WDS=TRANSLATE(PROCLST,' ',',')
  PROCLSTWD='- EDIT COPY ADD DELETE'
  MCMD=''
  UPDTIND=0
  LSTHDR='AFOLIST CHANNEL LISTS'
  CHORCN='CHANNEL LIST NAME'
  MYCRP = 0
  /* trace ?i */
  "ISPEXEC TBDISPL TBLCNCCH PANEL(DSPCNCHL) ROWID(MDROW#) POSITION(MYCRP)"
  SIGNAL ARND_TOP
 TOPOFLOP:
  "ISPEXEC TBTOP   TBLCNCCH"
  "ISPEXEC TBSKIP  TBLCNCCH NUMBER("ZTDTOP")"
  "ISPEXEC TBDISPL TBLCNCCH PANEL(DSPCNCHL)"
 ARND_TOP:
  XC = RC
  IF XC > 8 THEN DO
   MSGTXT ='SEVERE ERROR FROM TBDISPL FUNCTION.  ABORT.'
   CALL   SHOWMBOX
   SIGNAL OKDOIT
   END
  NUD=ZTDSELS
  HR#=MDROW#
  HC#=MYCRP
  IF ZTDSELS > 0 THEN DO
   DO WHILE (ZTDSELS > 0)
    R#=MDROW#
    ACT_W#=WORDPOS(ACTION,PROCLST_WDS)
    ACT_WD=WORD(PROCLSTWD,ACT_W#)
    FD ='P:'||ACT_WD||':@:'||R#
    ACTION = '-'
    "ISPEXEC TBPUT TBLCNCCH"
    CHWD=WORDPOS(FA,ICHLST)
    IF ACT_WD = 'EDIT' THEN DO
    TRACE I
      CALL DSPCNCCN  FA
     END
    IF ACT_WD = 'COPY' THEN DO
     ichct = words(ichlst)
     if ichct > 98 then do
      MSGTXT ='PF3 OR END SELECTED. FINISHING UP.'
      CALL   SHOWMBOX
      end
      else do
      CALL DO_COPY
      END
     END
    "ISPEXEC TBDISPL TBLCNCCH"
    IF ZTDSELS < 2 THEN LEAVE
    END
   END
  IF XC = 8 THEN DO
   MSGTXT ='PF3 OR END SELECTED. FINISHING UP.'
   CALL   SHOWMBOX
   MCMD = 'END'
   END
  IF POS('?',MCMD) > 0 THEN DO
   CALL DO_HELP
   MCMD = ''
   SIGNAL TOPOFLOP
   END
  IF WORDPOS(MCMD,CMDSTR) = 0 THEN SIGNAL TOPOFLOP
  IF WORDPOS(MCMD,CANSTR) \=  0 THEN DO
   MSGTXT='COMMAND:'MCMD' SIGNALS ABORT'
   CALL   SHOWMBOX
   SIGNAL DO_FIN
   END
  IF WORDPOS(MCMD,DONSTR) \= 0 THEN SIGNAL OKDOIT
  MSGTXT='UNKNOWN COMMAND:'MCMD' SIGNALS ABORT'
  CALL   SHOWMBOX
  SIGNAL TOPOFLOP
/*PROCESS COMMANDS */
/*LOOP TO TOPOFLOP UNTIL SAVE COMMAND */
 OKDOIT:
 TRACE I
  "ISPEXEC TBCLOSE TBLCNCCH"
   /* TRACE I */
 DO_FIN:
/*                                                                   *\
|* ADDPOP/REMPOP service in relation to CONTROL service              *|
|*                                                                   *|
|* The ADDPOP service performs the equivalent of a                   *|
|* CONTROL DISPLAY SAVE                                              *|
|* prior to creating the pop-up window and the REMPOP service        *|
|* performs the equivalent of a CONTROL DISPLAY RESTORE after        *|
|* removing the current  pop-up window.                              *|
|*  A dialog should not issue its own                                *|
|* CONTROL DISPLAY SAVE/RESTORE around an ADDPOP/REMPOP sequence     *|
|*                                                                   *|
|*                                                                   *|
\* A                                                                 */
  "ISPEXEC REMPOP"
   'ISPEXEC LIBDEF ISPPLIB'
   ADDRESS TSO
   MSGTXT='FINISHED PROCESSING TABLE'
   XC = 0
   RETURN 0
SHOWMBOX:
   CALL MSGBOX MSGTXT
   RETURN
DO_COPY:
      CNCTYP = ACT_WD||'-CHAN'
      CNCMSG='enter new channelnm'
      CNFROM=FA
      CNTO='-'
      CMD=''
      VALCMD='CANCEL END'
  /*  "ISPEXEC CONTROL DISPLAY SAVE"  */
      ZWINTTL = 'Copy Channel'
      "ISPEXEC ADDPOP POPLOC(FB)"
 TOPOFCOPY:
      "ISPEXEC DISPLAY PANEL(GETAFOCH)"
      YC=RC
      XCMD=ZCMD
      IF YC > 8 | WORDPOS(XCMD,CANSTR) \=  0 THEN SIGNAL FIN_COPY
      IF YC = 8 THEN XCMD = 'END'
      IF CNTO \= '-' THEN DO
       IF WORDPOS(CNTO,ICHLST) \= 0 THEN DO
        XCMD = ''
        cncmsg = 'Channel exists!'
        end
        else do
        j = wordpos(fa,ichlst)
        U='ICH'||SUBSTR('0'||j,LENGTH(I),2)
        k = words(ichlst) + 1
        v='ICH'||SUBSTR('0'||k,LENGTH(I),2)
        'ISPEXEC VGET ('U') ASIS'
        IF RC > 4 THEN DO
         msgtxt = 'error: could not copy:'fa':ispf var error:'rc
         signal fin_copy
         end
        interpret 'a = 'u
        interpret v' =  a'
        'ISPEXEC Vput ('V') ASIS'
        IF RC > 4 THEN DO
         msgtxt = 'error: could not vput:'v':ispf var error:'rc
         signal fin_copy
         end
        interpret 'w = words('v')'
        hcnwd1=''
        do x = 1 to w
         y = u||SUBSTR('0'||x,LENGTH(x),2)
         y = 'ICN'||substr(y,4)
         z = v||SUBSTR('0'||x,LENGTH(x),2)
         z = 'ICN'||substr(z,4)
         'ISPEXEC VGET ('Y') ASIS'
         IF RC > 4 THEN DO
          msgtxt = 'error: could not copy:'y':ispf var error:'rc
         signal fin_copy
         end
         if x = 1 then interpret 'hcnwd1 = 'y
         interpret 'a = 'y
         interpret z' = a'
         'ISPEXEC VPUT ('Z') ASIS'
         IF RC > 4 THEN DO
          msgtxt = 'error: could not vput:'z':ispf var error:'rc
         signal fin_copy
         end
         y = 'ICV'||substr(y,4)
         z = 'ICV'||substr(z,4)
         'ISPEXEC VGET ('Y') ASIS'
         IF RC > 4 THEN DO
          msgtxt = 'error: could not copy:'y':ispf var error:'rc
         signal fin_copy
         end
         interpret 'a = 'y
         interpret z' = a'
         'ISPEXEC VPUT ('Z') ASIS'
         IF RC > 4 THEN DO
          msgtxt = 'error: could not vput:'z':ispf var error:'rc
         signal fin_copy
         end
         Y = 'ICT'||SUBSTR(Y,4)
         Z = 'ICT'||SUBSTR(Z,4)
         'ISPEXEC VGET ('Y') ASIS'
         IF RC > 4 THEN DO
          msgtxt = 'error: could not copy:'y':ispf var error:'rc
         signal fin_copy
         end
         interpret 'a = 'y
         interpret z' = a'
         'ISPEXEC VPUT ('Z') ASIS'
         IF RC > 4 THEN DO
          msgtxt = 'error: could not vput:'z':ispf var error:'rc
         signal fin_copy
         end
        end
  trace ?i
       ichlst = ichlst||' '||cnto
       "ISPEXEC VPUT (ICHLST) ASIS"
       IF RC > 4 THEN DO
        msgtxt = 'error: could not vput UPDATED CHANNEL LIST:'ICHLST
        signal fin_copy
        END
       FA = cnto
       FB = w
       FB = SUBSTR('0'||FB,LENGTH(FB),2)
       FC = hcnwd1
       FD = '---'
       "ISPEXEC TBADD TBLCNCCH"
       SAY 'COPY FROM:'CNFROM':TO:'CNTO':'
       CNTO = '-'
       XCMD = 'DONE'
       END
      IF WORDPOS(XCMD,DONSTR) =  0 THEN SIGNAL TOPOFCOPY
 FIN_COPY:
      IF RC > 0 THEN DO
       CALL SHOWMBOX
       END
      "ISPEXEC REMPOP"
  /*  "ISPEXEC CONTROL DISPLAY RESTORE"     */
      RETURN
DO_ADD:
      CNCTYP = ACT_WD||'-CHAN'
      CNCMSG='enter new channelnm'
      CNFROM=''
      CNTO='-'
      CMD=''
      VALCMD='CANCEL END'
  /*  "ISPEXEC CONTROL DISPLAY SAVE"        */
      ZWINTTL = 'ADD  CHANNEL'
      "ISPEXEC ADDPOP POPLOC(FB)"
 TOPOFADD:
      "ISPEXEC DISPLAY PANEL(GETAFOCH)"
      YC=RC
      XCMD=ZCMD
      IF YC > 8 | WORDPOS(XCMD,CANSTR) \=  0 THEN SIGNAL FIN_COPY
      IF YC = 8 THEN XCMD = 'END'
      IF CNTO \= '-' THEN DO
       IF WORDPOS(CNTO,ICHLST) \= 0 THEN DO
        XCMD = ''
        cncmsg = 'Channel exists!'
        end
        else do
        ICHLST = ICHLST||' '||CNTO
        J = WORDS(ICHLST)
        "ISPEXEC VPUT (ICHLST) ASIS"
        IF RC > 4 THEN DO
         MSGTXT = 'ERROR: COULD NOT VPUT UPDATED CHANNEL LIST:'ICHLST
         SIGNAL FIN_ADD
         END
        U='ICH'||SUBSTR('0'||j,LENGTH(I),2)
        INTERPRET U' =  ""'
        'ISPEXEC VPUT ('U') ASIS'
        IF RC > 4 THEN DO
         MSGTXT = 'ERROR: COULD NOT VPUT:'U':ISPF VAR ERROR:'RC
         SIGNAL FIN_ADD
         end
        FA = CNTO
        FB = W
        FB = SUBSTR('0'||FB,LENGTH(FB),2)
        FC = HCNWD1
        FD = '---'
        "ISPEXEC TBADD TBLCNCCH"
        SAY 'ADD NEW  :------:AS:'CNTO':'
        CNTO = '-'
        XCMD = 'DONE'
        END
       END
      IF WORDPOS(XCMD,DONSTR) =  0 THEN SIGNAL TOPOFADD
 FIN_ADD:
      IF RC > 0 THEN DO
       CALL SHOWMBOX
       END
      "ISPEXEC REMPOP"
  /*  "ISPEXEC CONTROL DISPLAY RESTORE"     */
  /*                                        */
      RETURN
 DO_HELP:
  IF LENGTH(HELPDATA) < 2 THEN DO
   DO I = HELPTOP_SRCLN TO  HELPBOT_SRCLN
    TMP=STRIP(SOURCELINE(I),'B')
    TMP=TRANSLATE(TMP,'    ','/\|*')
    HELPDATA=HELPDATA||STRIP(TMP,'B')||FFX
    END
   END
  CALL MSGBOX HELPDATA
    RETURN XC
###END DSPCNCCH
$$$BEG TSTAFONN
/* REXX */
   ADDRESS ISPEXEC
   'ISPEXEC CONTROL ERRORS RETURN'
   MYDSN='TTEP.TSK.E.TCEM.PDSE'
   MYPNL='TTED.TSK.D.TCEM.ISPPLIB'
  TRYAGN:
   IDVAL=''
   'ISPEXEC QLIBDEF 'ISPLLIB' ID(IDVAL)'
   IF IDVAL \= '' THEN DO
    XDSN=TRANSLATE(IDVAL,"  ",",'")
    IF WORDPOS(MYDSN,XDSN) \= 0 THEN SIGNAL TRYPNL
    "ISPEXEC LIBDEF ISPLLIB"
    SIGNAL TRYAGN
    END
   IF IDVAL = '' THEN DO
    STKLIBS=MYDSN||',TTED.TSK.G.R540.SYS.EXCILIB,'||,
            'TTED.TSK.F.R540.LOADLIB'
    CALL EXPLLDEF 'ISPLLIB' STKLIBS 'STACK' 'QUIET'
    XC = RC
    END
  TRYPNL:
   IDVAL=''
   'ISPEXEC QLIBDEF 'ISPPLIB' ID(IDVAL)'
   IF IDVAL \= '' THEN DO
    XDSN=TRANSLATE(IDVAL,"  ",",'")
    IF WORDPOS(MYPNL,XDSN) \= 0 THEN SIGNAL GOTMYDSN
    "ISPEXEC LIBDEF ISPPLIB"
    SIGNAL TRYPNL
    END
   IF IDVAL = '' THEN DO
    STKLIBS=MYPNL
    CALL EXPLLDEF 'ISPPLIB' STKLIBS 'STACK' 'QUIET'
    XC = RC
    END
 GOTMYDSN:
   CNOSTR='DONE ABORT CANCEL DELETE ?'
   CANSTR='ABORT CANCEL'
   CMDSTR='GO BACK CDSN BDSN '||CANSTR
   CNTYSTR='CHAR,BIT,CDSN,BDSN'
   CNTO=''
   CNTY='CHAR'
   CNCCHNM = 'TEST_CH_NM'
   GET_PNL_NM = 'GETAFOCN'
   CNLST=''
   CNCT=0
   LR1LSCRL='<'
   LR1RSCRL='>'
   TRACE I
/* "ISPEXEC ADDPOP ROW(1) COL(10)" */
   "ISPEXEC ADDPOP"
   LASTCC = RC
  /*                                                                 *\
  |* TOP: GET CONTAINER NAMES, OR DONE/CANCEL                        *|
  \*                                                                 */
 TOPOFLOP:
   IF CNOMSG = '' THEN CNOMSG='USE COMMAND OR ENTER NEW CN NM'
   EXECSEL='TSTAFONN'
   ZCMD = ''
   CNLSTL=LENGTH(CNLST)
   CNLSTCNT=WORDS(CNLST)
   CMDACTN='ADD'
   "ISPEXEC DISPLAY PANEL(GETAFONN)"
   LASTCC=RC
/* TRACE ?I */
   MCMD = WORD(ZCMD,1)
   IF MCMD = 'DONE' THEN SIGNAL GOT_ALL_CNTO
   IF MCMD = '?' THEN DO
    CALL SHOWHELP
    SIGNAL TOPOFLOP
    END
   IF MCMD = 'CANCEL' | MCMD = 'ABORT' THEN SIGNAL DO_CANCEL
   IF LASTCC = 8 THEN SIGNAL GOT_ALL_CNTO
   IF MCMD = 'DELETE' THEN DO
    IF CNTO = '' THEN DO
     CNOMSG='DELETE:MISSING CN NAME'
     SIGNAL TOPOFLOP
     END
    WP = WORDPOS(CNTO,CNLST)
    IF WP = 0 THEN DO
     CNOMSG='DELETE:'CNTO' NOT ON CN LIST'
     SIGNAL TOPOFLOP
     END
    CNLST=DELWORD(CNLST,WP,1)
    CNOMSG='DELETED:'CNTO' FROM CN LIST'
    SIGNAL TOPOFLOP
    END
  /* PROCESS A CNTO */
   IF CNTO = '' THEN DO
    CNOMSG='MISSING A CONTAINER NAME. RETRY.'
    SIGNAL TOPOFLOP
    END
   WP = WORDPOS(CNTO,CNLST)
   IF WP > 0 THEN DO
    CMDACTN='EDIT'
    CNCMSG = 'EDIT THIS CONTAINER DATA'
    INTERPRET 'TMP = 'CNTO
    INTERPRET 'LR1 = "'TMP'"'
    INTERPRET 'LR1LNG  = 'CNTO'.L'
    INTERPRET 'CNTY    = 'CNTO'.T'
    SIGNAL GET_CN_DATA
    END
    ELSE DO
    IF WORDS(CNLST) > 98 THEN DO
     CNOMSG='MAX CN NAMES; DELETE, ABORT OR DONE'
     SIGNAL TOPOFLOP
     END
    IF LENGTH(CNTO) > 3 THEN CN_CMD=SUBSTR(CNTO,1,4)
     ELSE CN_CMD=CNTO
    SELECT
      WHEN CN_CMD = 'CEMT' THEN LR1 = 'CEMT INQUIRE SYSTEM'
      WHEN CN_CMD = 'CEDA' THEN LR1 = 'CEDA EXPAND GROUP(XXXXXXXX)'
      WHEN CN_CMD = 'PING' THEN LR1 = 'PINGTHIS IS A PING TEST'
      WHEN CN_CMD = 'LINK' THEN LR1 = 'LINK,PROGRAM(UCEMPINQ)'
      OTHERWISE LR1 = 'ENTER REQUEST DATA'
      END
    LR1LNG = LENGTH(LR1)
    CNTY = 'CHAR'
    END
GET_CN_DATA:
   CNSTRIP = 'Y'
   CNCMSG='ENTER DATA FOR:'CNTO
   ZCMD = ''
   "ISPEXEC DISPLAY PANEL("GET_PNL_NM")"
   XC = RC
   ACMD = ZCMD
   IF ACMD = 'GO' THEN SIGNAL DON_AFO_SRC_DATA
   IF ACMD = 'BACK' THEN DO
    CNOMSG='BACK OFF LAST CN NAME'
    SIGNAL TOPOFLOP
    END
   IF ACMD = 'END' THEN SIGNAL DON_AFO_SRC_DATA
   IF ACMD = 'SETODSN' THEN DO
    CALL SET_ODSN
    SIGNAL GET_CN_DATA
    END
   IF WORDPOS(ACMD,CANSTR) > 0 THEN DO
    CNOMSG='CANCEL GETDATA FOR CN'
    SIGNAL TOPOFLOP
    END
   IF XC = 8 THEN SIGNAL DON_AFO_SRC_DATA
   IF ACMD = 'CDSN' | ACMD = 'BDSN' THEN DO
    IF SUBSTR(CNTY,1,1) \= SUBSTR(ACMD,1,1) THEN DO
     CNCMSG = ACMD':INCONSIST TYPE:'CNTY
     SIGNAL GET_CN_DATA
     END
     CALL DOCOPY
     IF RC \= 0 THEN DO
      CMCMSG = ACMD':FAILED:GDSN'
      SIGNAL GET_CN_DATA
      END
     LR1 = '<'||EDSN||'>'
    CNTY=ACMD
    SIGNAL GET_CN_DATA
    END
   CNCMSG='ENTER MORE CONTAINER DATA'
   SIGNAL GET_CN_DATA
DON_AFO_SRC_DATA:
   CNCMSG = 'ADDED THIS CONTAINER:'CNTO
   IF CNSTRIP = 'Y' THEN DO
    LR1=STRIP(LR1,'T')
    LR1LNG = LENGTH(LR1)
    END
   INTERPRET CNTO'.L = LR1LNG'
   INTERPRET CNTO'.T = CNTY'
   INTERPRET CNTO' = LR1'
   IF WORDPOS(CNTO,CNLST) = 0 THEN DO
    CNOMSG = 'CONT:'||CNTO||':ADDED. MORE OR DONE?'
    CNLST=CNLST||' '||CNTO
    END
    ELSE DO
    CNOMSG = 'CONT:'||CNTO||':EDITED. MORE OR DONE?'
    END
   SIGNAL TOPOFLOP
GOT_ALL_CNTO:
   CNCT = WORDS(CNLST)
  IF CNCT < 1 THEN DO
   CALL GO_OR_NO  'YOU HAVE ENTERED ZERO CONTAINERS. OK (CONTINUE)  '||,
    ' OR CANCEL TO ABORT'
   IF RESULT > 0 THEN SIGNAL DO_CANCEL
   END
   ELSE DO
   CNLST=STRIP(CNLST,'T')
   END
   DO I = 1 TO CNCT
    TMP = WORD(CNLST,I)
    SAY 'CN:'TMP
    INTERPRET 'LR1 = 'TMP
    SAY LR1
    INTERPRET 'LR1LNG = 'TMP'.L'
    SAY 'LENGTH:'LR1LNG
    INTERPRET 'CNTY   = 'TMP'.T'
    SAY '  TYPE:'CNTY
    END
   XC = 0
 DO_CANCEL:
  DSEMSG = EXECSEL||' REQUESTED CANCEL'
  "ISPEXEC VPUT (DSEMSG) ASIS"
  XC = 8
 DONE_IT:
  "ISPEXEC REMPOP"
  RETURN XC
/*       */
 SHOWHELP:
  MSGBOX 'HELP INFO'
  RETURN
  /*                                                                 *\
  |* OK CANCEL BOX - DETERMINES HOW TO CONTINUE WHEN WE NEED TO KNOW *|
  \*                                                                 */
 GO_OR_NO:
    ARG OKCAN1
    OKCAN2 = '(O)K TO CONTINUE, (C)ANCEL TO ABORT'
    OKCANX = 'C'
    ADDRESS ISPEXEC 'VPUT (OKCAN1 OKCAN2 OKCANX) ASIS'
    CALL OKCANBOX
    IF RESULT \= 0 THEN RETURN 8
    ADDRESS ISPEXEC 'VGET (OKCANX) ASIS'
    IF OKCANX \= 'O' THEN RETURN 4
    RETURN 0
###END TSTAFONN
$$$BEG DYMWIND
 /* REXX */
 ADDRESS 'ISPEXEC'
 "ISPEXEC CONTROL ERRORS RETURN"
  MYAREA = ''
  CMD = ''
  zCMD = ''
  x01='01'x
  x02='02'x
 TOPOFLOP:
  TRACE ?I
  suid = sysvar(sysuid)
  sudt=DATE('N')
  stim=TIME('N')
  DYNWAREA = suid
 /* "ISPEXEC ADDPOP ROW(2) COLUMN(2)" */
 /* "ISPEXEC ADDPOP" */
 "ISPEXEC DISPLAY PANEL(DYMWIND)"
 XC = RC
/* "ISPEXEC REMPOP" */
 IF XC \= 0 THEN SIGNAL EXITRC0
 SAY 'LAST ITERATION WAS'
 SAY ' COLW='DYNWCOL'  ROWD='DYNWROW' AND ATTR WAS 'MYAT
 SIGNAL TOPOFLOP
EXITRC8:
 SAY 'BYE BYE'
 RETURN 0
/*  preserve ????
)ATTR
  # AREA(DYNAMIC) SCROLL(ON) EXTEND(ON) DATAMOD(0c)
  + TYPE(TEXT) INTENS(LOW) SKIP(ON)
  _ TYPE(&myat) INTENS(HIGH) CAPS(ON)
   TYPE(INPUT) INTENS(HIGH)
  ! TYPE(TEXT) INTENS(HIGH) SKIP(ON) COLOR(TURQ) HILITE(REVERSE)
  \ TYPE(TEXT) INTENS(HIGH) SKIP(ON) COLOR(YELLOW)
  @ TYPE(OUTPUT) INTENS(LOW) CAPS(OFF)
  $ TYPE(OUTPUT) INTENS(HIGH) CAPS(OFF) COLOR(GREEN)
  { TYPE(OUTPUT) INTENS(LOW) CAPS(OFF) COLOR(TURQ)
)BODY WINDOW(&dynwcol,&dynwrow) <+++ this does not work
! Command : ZCMD    +
+Date === $SUDT    + Time === $STIM +
+_dynwarea
#myarea                                                                        #
)PROC
 &cmd=&zcmd
 &myverb=&zverb
)END
*/
###END DYMWIND
$$$BEG ALOCPNL
/* rexx */

ADDRESS 'ISPEXEC'
"ISPEXEC CONTROL ERRORS RETURN"
mypnl = 'TTED.TSK.D.TCEM.ISPPLIB'
call explldef 'ispplib' mypnl 'stack'
exit
###END ALOCPNL
$$$BEG DYNWIN
 /* REXX */
 ADDRESS 'ISPEXEC'
 "ISPEXEC CONTROL ERRORS RETURN"
  MYAT = 'INPUT'
  DYNWCOL=0
  DYNWCMIN=37
  DYNWCMAX=75
  DYNWROW=0
  DYNWRMIN=5
  DYNWRMAX=20
  DYNWSCOL=2
  DYNWSCMN=2
  DYNWSCMX=78-DYNWCOL
  DYNWSROW=0
  DYNWSRMN=5
  DYNWSRMX=20
  DYNWAREA = ''
  MYAREA = ''
  CMD = ''
 TOPOFLOP:
 COLLOOP:
  SAY 'ENTER DYNWCOL (COL WIDTH OF WINDOW) 'DYNWCMIN' - 'DYNWCMAX
  PULL TDCOL
  IF TDCOL < DYNWCMIN | TDCOL > DYNWCMAX THEN DO
   SAY 'INVALID COLUME WIDTH. RETRY'
   SIGNAL COLLOOP
   END
  DYNWCOL = TDCOL
 ROWLOOP:
  SAY 'ENTER DYNWROW (ROW DEPTH OF WINDOW) 'DYNWRMIN' - 'DYNWRMAX
  PULL TDROW
  IF TDROW < DYNWRMIN | TDROW > DYNWRMAX THEN DO
   SAY 'INVALID ROW DEPTH. RETRY'
   SIGNAL ROWLOOP
   END
  DYNWROW = TDROW
 ATRLOOP:
  SAY 'ENTER DYNWAREA ATTRIBUTE (MYAT) INPUT OR OUTPUT'
  PULL TMYAT
  IF TMYAT ^= 'INPUT' & TMYAT ^= 'OUTPUT' THEN DO
   SAY 'INVALID ATTRIBUTE. RETRY'
   SIGNAL ATRLOOP
   END
  MYAT = TMYAT
  SAY 'ENTER DYNWAREA MESSAGE (MAX LENGTH 'DYNWCOL')'
  PULL DYNWAREA
  MXMA = DYNWROW-3
  TMSG = ''
  MYAREA = ''
  SAY 'NOW ENTER 0 TO 'MXMA' MESSAGES FOR MYAREA (ENTER NULL TO END)'
  DO I = 1 TO MXMA
   PULL TMSG
   IF TMSG = '' THEN LEAVE
   MYAREA = MYAREA||TMSG
   END
  MXMAL = (MXMA*DYNWCMAX)-(2*MXMA)
  TRACE ?I
 /* "ISPEXEC ADDPOP ROW(2) COLUMN(2)" */
 /* "ISPEXEC ADDPOP" */
 "ISPEXEC DISPLAY PANEL(DYMWIND)"
 XC = RC
/* "ISPEXEC REMPOP" */
 IF XC \= 0 THEN SIGNAL EXITRC0
 SAY 'LAST ITERATION WAS'
 SAY ' COLW='DYNWCOL'  ROWD='DYNWROW' AND ATTR WAS 'MYAT
 SIGNAL TOPOFLOP
EXITRC8:
 SAY 'BYE BYE'
 RETURN 0
###END DYNWIN
$$$BEG EXPLPNS
/* REXX */
trace ?i
ADDRESS 'ISPEXEC'
"ADDPOP row(1) column(10)"
"DISPLAY PANEL(EXPLPNS)"
"REMPOP"
acmd=zcmd
if zsel \= '?' then do
"SELECT " zsel
end
###END EXPLPNS
$$$BEG DSPAFO#
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA DSPAFOD  - SUBROUTINE TO AFOLIST. SEE AFOLIST           */
 /* CEMHELP DSPAFOD  - SUBROUTINE TO AFOLIST. SEE AFOLIST           */
 /* CEMHELP          - V3                                           */
 /* CEMHELP END                                                     */
 /* PRESERVED COPY OF DSPAFOD AS PRE CNC COPY 20181017 */
 /*                IN DSPAFODO                20181017 */
 /* PRESERVED COPY OF DSPAFOD AS PRE CNC COPY 20181017 */
 /*                IN DSPAFODO                20181017 */
 /* PRESERVED COPY OF DSPAFOD AS PRE CNC COPY 20181017 */
 /*                IN DSPAFODO                20181017 */
 /* THIS VERSION ATTEMPTS TO USE COBOL PGM    20181211 */
 /*  CLBAFOD IN SELECT PGM, TO CREATE A CNC   20181211 */
 /*  AND THEN THE COBOL PROGRAM ISSUES A      20181211 */
 /*  SELECT CMD(DSPAFOC) FOR SUBSEQUENT LOGIC 20181211 */
 ADDRESS TSO
 /* TRACE I */
ARG MYTYP MYTYTOT
FSAVSTR=''
 IF MYTYTOT = '' THEN DO
  ADDRESS ISPEXEC
  "ISPEXEC VGET (MYTYP MYTYTOT DSEMSG) ASIS"
  IF RC \= 0 THEN SIGNAL NOPOOL
  AFOLISTV = DSEMSG
  END
 DSEMSG=' '
 MYAREA=''
 IF MYTYTOT \> 0 THEN SIGNAL NOPOOL
 A = VALUE(MYTYP)
 MXLNG = 0
 APLP=WORDPOS('MYAPLID',AFOLISTV)
 DO I = 1 TO MYTYTOT
  VGETSTR=VGETSTR||' '||MYTYP||I
  END
 BKSLH = ' \'
 FNDWDS='\@ \$ \! \\'  /* SUBSTITUTE \ APPLID JOBNAME */
 RWCT=WORDS(FNDWDS)
 SUBWDS='MYAPLID JOBN S#PARM BKSLH'
 TECCMDS = 'CEMT CEDA PLAY'
 TC1='E D P'
 VALCMDS = 'PING LINK '||TECCMDS||' PING MAKE APPEND'
 VALCMD1 = 'G L '||TC1||' Q M A'
 DFT_UCEMPIN='UCEMPINQ'
 DFT_PING_CAL=1008
 MAX_CAL=32400
 DFT_CAL=4080
 TEST=''
 ACCP=''
 PROD=''
 MYCCPU = MVSVAR('SYSNAME')
 "ISPEXEC VGET ("VGETSTR") ASIS"
 DO I = 1 TO MYTYTOT
  INTERPRET 'TMP = 'A||I
  SRCT.I = SUBSTR(TMP,1,24)
  TEST=TEST||' '||WORD(SRCT.I,APLP)
  SRCA.I = SUBSTR(TMP,26,24)
  ACCP=ACCP||' '||WORD(SRCA.I,APLP)
  SRCP.I = SUBSTR(TMP,51,24)
  PROD=PROD||' '||WORD(SRCP.I,APLP)
  END
 TEST=STRIP(TEST,'B')
 ACCP=STRIP(ACCP,'B')
 PROD=STRIP(PROD,'B')
 APLLSTALL = TEST||' '||ACCP||' '||PROD
 VALLISTS='TEST ACCP PROD APLLSTALL '
  "ISPEXEC VGET (MYAFOIND CURGRP CURCPU CURCPUG) ASIS"
 VALCPU = ''
 L_CPUG=LENGTH(CURCPUG)
 VALCPU = ''
 DO I = 1 TO L_CPUG
  TH = SUBSTR(CURCPUG,I,1)
  INTERPRET 'VALCPU = VALCPU || " 'TH'SYS"'
  END
 VALCPU = STRIP(VALCPU,'B')
 'ISPEXEC VGET (HOSTLIST) ASIS'
 'ISPEXEC VGET ('HOSTLIST') ASIS'
 VALLISTS=VALLISTS||HOSTLIST
 CURRLIST = ''
 TMPLST='CURRLIST'
 MAFOLSTS=''
/* CREATES ADDITIONAL REGION LISTS FROM PROFILE DSN */
 CALL DSPAFOE
 'ISPEXEC VGET (MAFOLSTS) ASIS'
 'ISPEXEC VGET ('MAFOLSTS') ASIS'
 /* TRACE I
 NW=WORDS(MAFOLSTS)
 DO I = 1 TO NW
  INTERPRET 'XX='WORD(MAFOLSTS,I)
  END
 */
 MAFOLSTS='CURRLIST '||MAFOLSTS
 VALLISTS=VALLISTS||' '||MAFOLSTS
 TRACE OFF
 MXLNG = 79
 SUDT=DATE('U')
 BOTLN=MYTYTOT
 CURLN=1
 CURCL=1
 SP78=COPIES(' ',78)
 DL78=SUBSTR('-'||SP78,1,78)
  "ISPEXEC VGET (ZSCREEND) ASIS"
  MYSCRD=ZSCREEND-4
  MYPNLD='AFOLTABD'
  IF MYSCRD > 20 THEN DO
   IF MYSCRD > 39 THEN MYSCRD = 39
   MYPNLD='AFOLTABE'
   END
  UP_PG=MYSCRD-1
  D_STR = ''
  CMD_W2 = ''
DSPLOOP:
  /* TRACE I */
 CMDIND=0
 "ISPEXEC VPUT (CMDIND) ASIS"
 STIM=TIME()
 TOPLN=CURLN
 TOPCL=CURCL
 DO I = 1 TO MYSCRD
  INTERPRET 'MITAT'I'= ""'
  INTERPRET 'MITAA'I'= ""'
  INTERPRET 'MITAP'I'= ""'
  IF CURLN > BOTLN THEN DO
   INTERPRET 'MYDST'I' = DL78'
   INTERPRET 'MYDSA'I' = DL78'
   INTERPRET 'MYDSP'I' = DL78'
   END
   ELSE DO
   TLNG = 80
   INTERPRET 'MYDST'I' = SRCT.CURLN'
   INTERPRET 'MYDSA'I' = SRCA.CURLN'
   INTERPRET 'MYDSP'I' = SRCP.CURLN'
   END
  CURLN = CURLN + 1
  TRACE OFF
  END
 /* TRACE I */
 CMD = ''
 CMD1 = ''
 MYVERB=''
 DSEMSG=D_STR
 "ISPEXEC DISPLAY PANEL("MYPNLD")"
 LASTCC=RC
 MYCMD = WORD(CMD,1)
 IF CMD \= '' THEN "ISPEXEC VPUT (CMD) ASIS"
 IF CMD = 'END' THEN SIGNAL TRYEND
 IF LASTCC = 8 THEN RETURN 8
 IF CMD = 'CANCEL' THEN RETURN 8
 IF CMD = '' THEN SIGNAL DO_LOOP
 IF CMD = '?' THEN SIGNAL SHOWNLOOP
 IF CMD = 'LISTS?' THEN SIGNAL SHOWLISTS
 IF MYCMD = 'SHOWLIST' THEN SIGNAL SHOWONELIST
 /* TRACE I  */
 WP=WORDPOS(MYCMD,VALCMDS)
 IF WP = 0 THEN DO
  IF MYCMD \= '' THEN DSEMSG='!UNKNOWN CMD:'CMD':ENTERED'
  SIGNAL DO_LOOP
  END
 /* TRACE I  */
 CMD1 = WORD(VALCMD1,WP)
 CMD_W2 = WORD(CMD,2)
 /* TRACE I */
 IF CMD1 = 'M' THEN DO
  /* TRACE ?I */
  IF CMD_W2 = '' THEN TMPLST='CURRLIST'
   ELSE DO
    IF LENGTH(CMD_W2) < 1 | LENGTH(CMD_W2) > 8 | ,
     (DATATYPE(SUBSTR(CMD_W2,1,1)) \= 'CHAR') THEN DO
     ERRMSG = 'MAKE VAR NAME INVALID'
     SIGNAL DO_LOOP
     END
    TMPLST=CMD_W2
   END
  IF WORDPOS(TMPLST,MAFOLSTS) = 0 THEN DO
   MAFOLSTS=MAFOLSTS||' '||TMPLST
   VALLISTS=VALLISTS||' '||TMPLST
   END
  INTERPRET TMPLST'=""'
  "ISPEXEC VPUT ("TMPLST") ASIS"
  D_STR = ''
  MYCMD='APPEND'
  ZCMD='APPEND'
  CMD1='A'
  SIGNAL DO_LOOP
  END
 /* TRACE I */
 IF CMD1 = 'A' THEN SIGNAL DO_LOOP
 CMD_W2 = WORD(CMD,2)
 /* TRACE I */
 IF CMD1 \= 'P' THEN SIGNAL ARNDPLAY
 IF CMD_W2 = '' THEN DO
  CMD1=''
  CALL MSGBOX 'ERROR:PLAY LIST SELECT MISSING.VALID LISTS:'MAFOLSTS
  SIGNAL ARND_LOOP
  END
 /* TRACE I */
ARNDPLAY:
 /* TRACE I */
 IF CMD_W2 = 'LIST' THEN DO
  TRACE I
  IF D_STR = '' THEN  D_STR = '@ '||MYCMD||' '
  SIGNAL DO_LOOP
  END
 TX=WORDPOS(CMD_W2,VALCPU)
 IF TX \= 0 THEN DO
  TH = SUBSTR(WORD(VALCPU,TX),1,1)
  /* INTERPRET "D_STR = CPUHOST"TH */
  INTERPRET "D_STR = "TH"SYS"
  IF WORDS(D_STR) = 0 THEN SIGNAL DO_LOOP
  SIGNAL DO_INTGI
  END
 IF WORDPOS(CMD_W2,'TEST ACCP PROD') \= 0 THEN DO
  INTERPRET "D_STR = "CMD_W2
  SIGNAL DO_INTGI
  END
 TX=WORDPOS(CMD_W2,MAFOLSTS)
 IF TX = 0 THEN DO
  CALL MSGBOX 'ERROR:LIST('CMD_W2') IS NOT VALID'
  D_STR = ''
  SIGNAL ARND_LOOP
  END
 TH = CMD_W2
/* IF TH = 'CURRLIST' THEN D_STR=CURRLIST
  ELSE DO                                  */
 IF WORDPOS(TH,MAFOLSTS) > 0  THEN DO
  'ISPEXEC VGET ('TH') ASIS'
  IF RC \= 0 THEN DO
   CMD1=''
   CALL MSGBOX 'ERROR:INV LIST:'TH'<VALID LISTS:'MAFOLSTS
   SIGNAL ARND_LOOP
   END
  TMPLST = TH
  INTERPRET 'D_STR = 'TH
  END
 IF WORDS(D_STR) = 0 THEN DO
  CALL MSGBOX 'ERROR:EMPTY LIST:'TH'<'
  CMD1=''
  D_STR = ''
  SIGNAL ARND_LOOP
  END
/*  SIGNAL DO_INTGI
  END */
DO_INTGI:
 TMP=CMD1
 CALL INTGI
DO_INTGI_X:
 D_STR = ''
 MYCMD = ''
 CMD = ''
 ZCMD=''
 TRACE OFF
 SIGNAL ARND_LOOP
SHOWLISTS:
 CALL MSGBOX 'KNOWN LISTS:'||VALLISTS
 SIGNAL ARND_LOOP
SHOWONELIST:
  CMD_W2 = WORD(CMD,2)
  IF WORDPOS(CMD_W2,VALLISTS) \= 0 THEN DO
   INTERPRET 'XXX = 'CMD_W2
   IF XXX = CMD_W2 THEN 'ISPEXEC VGET ('XXX') ASIS'
   INTERPRET 'MSGBOXTX = 'XXX
   END
   ELSE MSGBOXTX = CMD_W2' IS NOT A VALID LIST'
 CALL MSGBOX 'LIST:'CMD_W2'='MSGBOXTX
 SIGNAL ARND_LOOP
SHOWNLOOP:
 CALL MSGBOX 'COMMANDS: '||VALCMDS||' LISTS? SHOWLIST END OR CANCEL'
 SIGNAL ARND_LOOP
DO_LOOP:
 /* TRACE I */
 CL=TOPLN
 HYCMD = ''
 DO I = 1 TO MYSCRD
  Q = I + TOPLN -1
  DO T = 1 TO 1
   INTERPRET 'TMP = MITAT'I
   TP=WORDPOS(TMP,VALCMD1)
   IF TP \= 0 THEN DO
    IF TMP = 'M' | TMP = 'A' THEN DO
     "ISPEXEC VGET ("TMPLST") ASIS"
     IF RC > 0 THEN INTERPRET TMPLST" = ''"
     INTERPRET 'TMP = 'TMPLST
     TMP = TMP ||' '||WORD(SRCT.Q,1)
     D_STR=TMP
     INTERPRET TMPLST '= TMP'
     "ISPEXEC VPUT ("TMPLST") ASIS"
     LEAVE T
     END
     ELSE DO
     MYCMD=WORD(VALCMDS,TP)
     END
    END
   IF TMP = "I" THEN DO
    LNREST = SRCT.Q
    CALL INTCI
    LEAVE T
    END
   IF WORDPOS(TMP,VALCMD1) \= 0 THEN DO
    IF WORD(D_STR,1) = '@' THEN DO
     D_STR=D_STR||' '||WORD(SRCT.Q,1)
     LEAVE T
     END
    LNREST = SRCT.Q
    D_STR=WORD(SRCT.Q,1)
    CALL INTGI
    LEAVE T
    END
   IF TMP = "V" THEN DO
    LNREST = SRCT.Q
    CALL INTVI
    LEAVE T
    END
   END T
  DO A = 1 TO 1
   INTERPRET 'TMP = MITAA'I
   TP=WORDPOS(TMP,VALCMD1)
   IF TP \= 0 THEN DO
    IF TMP = 'M' | TMP = 'A' THEN DO
     "ISPEXEC VGET ("TMPLST") ASIS"
     IF RC > 0 THEN INTERPRET TMPLST" = ''"
     INTERPRET 'TMP = 'TMPLST
     TMP = TMP ||' '||WORD(SRCA.Q,1)
     D_STR=TMP
     INTERPRET TMPLST '= TMP'
     "ISPEXEC VPUT ("TMPLST") ASIS"
     LEAVE A
     END
     ELSE DO
     MYCMD=WORD(VALCMDS,TP)
     END
    END
   IF TMP = "I" THEN DO
    LNREST = SRCA.Q
    CALL INTCI
    LEAVE A
    END
   IF WORDPOS(TMP,VALCMD1) \= 0 THEN DO
    IF WORD(D_STR,1) = '@' THEN DO
     D_STR=D_STR||' '||WORD(SRCA.Q,1)
     LEAVE A
     END
    LNREST = SRCA.Q
    D_STR=WORD(SRCA.Q,1)
    CALL INTGI
    LEAVE A
    END
   IF TMP = "V" THEN DO
    LNREST = SRCA.Q
    CALL INTVI
    LEAVE A
    END
   END A
  DO P = 1 TO 1
   INTERPRET 'TMP = MITAP'I
   TP=WORDPOS(TMP,VALCMD1)
   IF TP \= 0 THEN DO
    IF TMP = 'M' | TMP = 'A' THEN DO
     "ISPEXEC VGET ("TMPLST") ASIS"
     IF RC > 0 THEN INTERPRET TMPLST" = ''"
     INTERPRET 'TMP = 'TMPLST
     TMP = TMP ||' '||WORD(SRCP.Q,1)
     D_STR=TMP
     INTERPRET TMPLST '= TMP'
     "ISPEXEC VPUT ("TMPLST") ASIS"
     LEAVE P
     END
     ELSE DO
     MYCMD=WORD(VALCMDS,TP)
     END
    END
   IF TMP = "I" THEN DO
    LNREST = SRCP.Q
    CALL INTCI
    LEAVE P
    END
   IF WORDPOS(TMP,VALCMD1) \= 0 THEN DO
    IF WORD(D_STR,1) = '@' THEN DO
     D_STR=D_STR||' '||WORD(SRCP.Q,1)
     LEAVE P
     END
    LNREST = SRCP.Q
    D_STR=WORD(SRCP.Q,1)
    CALL INTGI
    LEAVE P
    END
   IF TMP = "V" THEN DO
    LNREST = SRCP.Q
    CALL INTVI
    LEAVE P
    END
   END P
  IF I > 1 THEN TRACE OFF
  END
 /*TRACE I */
ARND_LOOP:
 IF MYVERB = 'LEFT' THEN DO
  CURCL = CURCL-78
  IF CURCL < 1 THEN CURCL=1
  SIGNAL REDSPLY
  END
 IF MYVERB = 'LEFT M' THEN DO
  CURCL = 1
  SIGNAL REDSPLY
  END
 IF MYVERB = 'RIGHT' THEN DO
  CURCL = CURCL+78
  IF CURCL > MXLNG THEN DO
   CURCL=MXLNG-77
   IF CURCL < 1 THEN CURCL = 1
   END
  SIGNAL REDSPLY
  END
 IF MYVERB = 'RIGHT M' THEN DO
  CURCL = MXLNG-77
  IF CURCL < 1 THEN CURCL = 1
  SIGNAL REDSPLY
  END
 IF MYVERB = 'UP' THEN DO
  CURLN = TOPLN-UP_PG
  IF CURLN < 1 THEN CURLN=1
  SIGNAL DSPLOOP
  END
 IF MYVERB = 'UP M' THEN DO
  CURLN = 1
  SIGNAL DSPLOOP
  END
 IF MYVERB = 'DOWN M' THEN DO
  CURLN = BOTLN-MYSCRD
  IF CURLN < 1 THEN CURLN=1
  SIGNAL DSPLOOP
  END
 IF MYVERB = 'DOWN' THEN DO
  IF CURLN > BOTLN THEN SIGNAL REDSPLY
  CURLN = CURLN - 1
  SIGNAL DSPLOOP
  END
 /* TRACE I */
  IF WORD(D_STR,1) = '@' THEN DO
   PARSE VAR D_STR '@' CMD  D_STR
   WP=WORDPOS(MYCMD,VALCMDS)
   TMP = WORD(VALCMD1,WP)
   IF D_STR \= '' THEN DO
    CALL INTGI
    D_STR = ''
    MYCMD = ''
    CMD = ''
    ZCMD=''
    END
    ELSE CMD = ''
   END
  TRACE OFF
 CURCL=TOPCL
REDSPLY:
 CURLN=TOPLN
 SIGNAL DSPLOOP
NOPOOL:
  ZEDSMSG = "NO POOLED DATA"
  ZEDLMSG = "NO DATA PREVIOUSLY POOLED FOR RECALL"
  XC = 4
 SIGNAL WRITIT
 WRITIT:
 IF FSAVSTR \= '' THEN SAY FSAVSTR
 "ISPEXEC SETMSG MSG(ISRZ001)"
 RETURN XC
 TRYEND:
 IF FSAVSTR \= '' THEN DO
  FSAVSTR = SUBSTR(FSASTR,2)
  MYTYRSP=FSAVSTR
  "ISPEXEC VPUT (MYTYRSP) ASIS"
  END
 RETURN 0
/* INTGI: PROCEDURE EXPOSE MYCMD HYCMD LNREST APLP TMP D_STR CMDIND */
INTGI:
 /* TRACE I */
   IF APLP = 0 THEN RETURN 8
   IF TMP = 'G' | TMP = 'Q' THEN DO
    MYCMD='PING'
    MYCA = 'PING DSPAFOD MSG FROM \@'
    MYPROG= DFT_UCEMPIN
    IF TMP = 'G' THEN DO
     MYCAL = DFT_PING_CAL
     MYFUNC = 'MSGBOXONLY'
     END
    IF TMP = 'Q' THEN DO
     MYCAL = 0
     MYFUNC = 'QUIET'
     END
    "ISPEXEC VPUT (MYCMD MYCA MYCAL MYPROG MYFUNC) ASIS"
    END
   IF TMP = 'P' THEN DO
    MYCMD='PLAY'
    MYCAL = MAX_CAL
    MYCA=''
    MYPROG=''
    MYFUNC = 'MSGBOXALL'
    CALL GET_PLAY
    IF RC > 4 THEN SIGNAL BYP_CMD
    IF SUBSTR(D_STR,1,1) = '@' THEN PARSE VAR D_STR '@' . D_STR
    MYAPLID=D_STR
    "ISPEXEC VPUT (MYAPLID MYCMD MYCA MYCAL MYPROG MYFUNC) ASIS"
    CALL AFOLPLAY
    XC = RESULT
    MYAREA = ''
   "ISPEXEC VPUT (MYAREA) ASIS"
    RETURN XC
    END
   IF TMP = 'E' | TMP = 'L' | TMP = 'D' THEN DO
 /* TRACE I */
    IF HYCMD \= MYCMD THEN CMDIND = 0
    IF CMDIND = 0 THEN DO
     MYFUNC1 = 'O'
     "ISPEXEC VPUT (MYCMD MYFUNC1 CMDIND MYAPLID) ASIS"
     CALL DSPAFOC
     "ISPEXEC VGET (CMDIND MYFUNC1) ASIS"
     IF CMDIND > 1 THEN SIGNAL BYP_CMD
     VALFUNC='QUIET MSGBOXONLY MSGBOXALL VERBOSE'
     VALFUNC1='Q O A V'
     MYFUNC = WORD(VALFUNC,WORDPOS(MYFUNC1,VALFUNC1))
     "ISPEXEC VPUT (MYFUNC) ASIS"
     END
    END
DO_CALL:
   IF D_STR = '' THEN DO
    MYAPLID = WORD(LNREST,APLP)
    END
    ELSE DO
    MYAPLID = D_STR
    MYAPLID = TRANSLATE(MYAPLID,' ','@')
    END
   "ISPEXEC VPUT (MYAPLID) ASIS"
   IF RC \= 0 THEN SIGNAL BYP_CMD
   /* !@! */
   /* SUBSTITUTE SPECIFIC CHARACTER INDICATORS FOR JOBNAME OR *\
   \*  APPLID, TO CAUSE DYNAMIC CA DATA BASED ON JOB OR APPLID*/
/* CALL SUBJOBN                       *\
\* IF RESULT /= 0 THEN SIGNAL BYP_CMD */
   MYPRM= "MYCMD=<MYCMD> MYAPLID=<MYAPLID> MYCA=<MYCA> "|| ,
     "MYCAL=<MYCAL> MYPROG=<MYPROG> MYTRANID=<MYTRANID> ODSN=<MYODSN>"
   CALL EXCIS0 MYFUNC MYPRM
   XC = RESULT
   MYAREA = ''
   TRACE OFF
   "ISPEXEC VPUT (MYAREA) ASIS"
   IF D_STR = '' THEN RETURN XC
BYP_CMD:
   RETURN 8
/* INTCI: PROCEDURE EXPOSE LNREST */
INTCI:
   IF LNREST = '' THEN RETURN 4
   ARGAFO =STRIP(SUBSTR(LNREST,1,8),'T')
   CALL COPYINFO ARGAFO
   XC = RESULT
   RETURN XC
INTVI: PROCEDURE EXPOSE LNREST FSAVSTR
   IF LNREST = '' THEN RETURN 4
   ARGAFO =STRIP(SUBSTR(LNREST,1,8),'T')
   XC=POS(ARGAFO,FSAVSTR)
   IF XC = 0 THEN FSAVSTR=FSAVSTR||','||ARGAFO
   NOVAR:
   RETURN XC
GET_PLAY:
 DROP AFOSC.
 SCRPCMDI=0
 AFOSCTOT=0
 ADDRESS TSO "NEWSTACK"
 HDSEMSG = DSEMSG
 DSEMSG='ENTER VALID COMMANDS OR ? FOR HELP'
 "ISPEXEC VPUT (DSEMSG) ASIS"
 CALL REXXSRC "PULL(AFOSC)"
 XC = RESULT
 DSEMSG = HDSEMSG
 IF XC > 2 THEN DO
  CMD1=''
  CALL MSGBOX 'ERROR:PLAY LIST: COULD NOT CAPTURE SCRIPT.'
  RETURN 8
  END
 MY#VCT = QUEUED()
 IF MY#VCT > 99 THEN DO
  CMD1=''
  CALL MSGBOX 'ERROR:PLAY LIST: TOO MANY COMMANDS IN SCRIPT:'MY#VCT
  RETURN 4
  END
 K=0
 SCRPTLST=''
 DO J = 1 TO MY#VCT
  PULL AFOSC.J
  SCRPTMP=STRIP(AFOSC.J,'B')
  IF SCRPTMP  \= '' THEN DO
   IF SUBSTR(SCRPTMP,1,1) = '#' THEN ITERATE
   K=K+1
   INTERPRET 'AFOSC'K' = SCRPTMP'
   SCRPTLST=SCRPTLST||' AFOSC'||K
   END
  END
 ADDRESS TSO "DELSTACK"
 IF K < 1 THEN DO
  CMD1=''
  CALL MSGBOX 'ERROR:PLAY LIST: NO COMMANDS IN SCRIPT!'
  RETURN 8
  END
 AFOSCTOT=K
 "ISPEXEC VPUT (AFOSCTOT) ASIS"
 "ISPEXEC VPUT ("SCRPTLST") ASIS"
 IF RC \= 0 THEN DO
  CMD1=''
  CALL MSGBOX 'ERROR:PLAY LIST: COULD NOT SAVE COMMANDS'
  RETURN 8
  END
 RETURN 0
/* ROUTINE TO SUBSTITUTE JOB OR APPLID VALUE IN CA */
SUBJOBN:
/* JOB#PTR IS THE CURRENT JOBNAME FROM THE SUPPLIED LIST */
/* IF ZERO JOBNAMES WERE SUPPLIED, THEN WE CAN NOT PERFORM */
/*   THE $ SUBSTITUTION.                                 */
/* WE SHOULD NOT BE HERE IF THE JOB#PTR IS > NUMBER OF   */
/*   JOBNAMES PROVIDED IN THE JOBLIST ARGUMENT.          */
/* TRACE ?I */
  "ISPEXEC VGET (MYCA MYCAL) ASIS"
  IF RC \= 0 THEN RETURN 8
  IF LENGTH(MYCA) < 1 THEN RETURN 0
  LOOPCT=100
  V=1
  X = OUTTRAP('JNL.')
  CALL CVTJN2RG MYAPLID
  X = OUTTRAP('OFF')
  IF WORD(JNL.1,1) = '!!!!!!!!' THEN RETURN 8
  JOBN=WORD(JNL.1,2)
  SUBCMD=STRIP(MYCA,'T')
  CURL=LENGTH(SUBCMD)
  CURP=1
  CURS=0
  NEWCMD=''
  /* NEW CODE V2 */
  TRACE I
  S#APLID = MYAPLID
  IF LENGTH(S#APLID) < 7 THEN INTERPRET "T#PARM = 'S#"||S#APLID||"'"
    ELSE INTERPRET "T#PARM = 'S#"||SUBSTR(S#APLID,3)||"'"
  INTERPRET T#PARM " = S#VALUE"
  'ISPEXEC VGET ('T#PARM') ASIS'
  IF RC > 0 THEN S#PARM = MYAPLID
   ELSE INTERPRET 'S#PARM = 'T#PARM
  /* NEW CODE V2 */

TOPOFQLOP:
  JP = WORDPOS(SUBSTR(SUBCMD,CURP,1),FNDWDS)
  IF JP = 0 THEN SIGNAL NXT_POS
  /* TRACE ?I */

  SUBWD = WORD(SUBWDS,JP)
  INTERPRET 'REPWD = 'SUBWD
  IF CURP = 1 THEN DO
   NEWCMD = REPWD
   END
   ELSE DO
   IF CURS = 0 THEN NEWCMD = SUBSTR(SUBCMD,1,CURP - 1)
   NEWCMD=SUBSTR(NEWCMD,1)||REPWD
   END
  LOOPCT = LOOPCT - 1
  IF LOOPCT < 1 THEN RETURN 8
  CURS = CURP + 1
NXT_POS:
  CURP=CURP + 1
  IF CURP <= CURL THEN SIGNAL TOPOFQLOP
  IF CURS < CURP THEN DO
   IF CURS = 0 THEN NEWCMD = SUBCMD
   ELSE NEWCMD=SUBSTR(NEWCMD,1)||SUBSTR(SUBCMD,CURS)
   END
  IF LENGTH(NEWCMD) > MYCAL THEN MYCA = SUBSTR(NEWCMD,1,MYCAL)
   ELSE MYCA =  NEWCMD
  "ISPEXEC VPUT (MYCA MYCAL) ASIS"
  IF RC \= 0 THEN RETURN 8
  TRACE OFF
 RETURN 0
###END DSPAFO#
$$$BEG AFO#NTL1
)ATTR
  + TYPE(TEXT) INTENS(LOW) SKIP(ON)
  _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) PAD(_)
   TYPE(INPUT) INTENS(HIGH) CAPS(ON)
  ! TYPE(TEXT) INTENS(HIGH) SKIP(ON) COLOR(TURQ) HILITE(REVERSE)
  \ TYPE(TEXT) INTENS(HIGH) SKIP(ON) COLOR(YELLOW)
  @ TYPE(OUTPUT) INTENS(LOW) CAPS(OFF)
  $ TYPE(OUTPUT) INTENS(HIGH) CAPS(OFF) COLOR(GREEN)
  { TYPE(OUTPUT) INTENS(LOW) CAPS(OFF) COLOR(TURQ)
)BODY
! Command : ZCMD                                                      +
+Date === $SUDT    + Jdate == $SJDT + Day  === $WDT+ Time === $STIM    +
+V1: CICS Copy Display Based: AFOPER Load at @myafoind                 +
+ Brws PARMLIB(STARTUP) Z+    Brws SIT Z+    Brws TABLE.SOURCE Z    +
+ Disp Xtended JOB Info Z+  LIST Copy DSN Z+ Disp JCL/PROC OvRd Z+
+ Expand JCL Z+      Search DFHRPL for Member (enter member) Z       +
+                     Expand DFHRPL Extents listingZ+
+ Srch Tblstbl + Selected CICS string was $mysst                      +
+APPLID $myaplid   +COPYNAME $mycopyn  +CPU $mycpu  +REL $myrel  +
+      Current PARMLIB SIT Override is $mysit +
+  $mytno +Beep # $mydbno          $mynbno          +
+  Up/Down Times $mysnp                                                +
+ UPMEM    $myupm     +COLDMEM  $mycoldm    +EMERVFYM $myemervm +
+ UPJOB    $myupj     +COLDJOB  $mycoldj    +EMERVFYJ $myemervj +
+ DOWNMEM  $mydownm   +UCC7MEM  $myucc7m    +VERIFYM  $myverfym +
+ DOWNJOB  $mydownj   +UCC7JOB  $myucc7j    +VERIFYJ  $myverfyj +
+ JRNLMEM  $myjrnlm   +BTCHMEM  $mybtchm    +CMFMEM   $mycmfm   +
+ JRNLJOB  $myjrnlj   +BTCHJOB  $mybtchj    +CMFJOB   $mycmfj   +
+ TYPE $Z     + ABTASK $myabtas +  DISOSS  $mydisoss+  DBRC $mydbrc +
+ DB2  $mydb2 +  RECYCLE $myrecyc +  UCC7    $myucc7  +  RCT  $myrct  +
+ DB2NAME  $mydb2n +   Shutdown Wait Interval $mydwnwt +
+COMMENT: $mycommnt                           +
)INIT
 .ZVARS='(bpl,bsit,bts,dext,dtab,djcl,ejcl,srpl4mbr,xtnt,myctypor)'
)PROC
 &myverb = &zverb
 VER (&bpl,LIST,Y,N)
 VER (&bts,alpha)
 VER (&bsit,LIST,Y,N)
 VER (&dext,LIST,Y,N)
 VER (&dtab,LIST,Y,N)
 VER (&djcl,LIST,Y,N)
 VER (&ejcl,LIST,Y,N)
 VER (&srpl4mbr,name)
 &CMD=&zcmd
 &myscln=&zscrolln
)END
/* remove this mbr as it exists in other places */
###END AFO#NTL1
$$$BEG AFO#NTLE
)ATTR
  + TYPE(TEXT) INTENS(LOW) SKIP(ON)
  _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) PAD(_)
   TYPE(INPUT) INTENS(HIGH) CAPS(ON)
  ! TYPE(TEXT) INTENS(HIGH) SKIP(ON) COLOR(TURQ) HILITE(REVERSE)
  \ TYPE(TEXT) INTENS(HIGH) SKIP(ON) COLOR(YELLOW)
  @ TYPE(OUTPUT) INTENS(LOW) CAPS(OFF)
  $ TYPE(OUTPUT) INTENS(HIGH) CAPS(OFF) COLOR(GREEN)
  { TYPE(OUTPUT) INTENS(LOW) CAPS(OFF) COLOR(TURQ)
)BODY
! Command : ZCMD                                                      +
+Date === $SUDT    + Jdate == $SJDT + Day  === $WDT+ Time === $STIM    +
+CICS Copy Display Based on AFOPER Load at @myafoind                 +
+Selected CICS string was $mysst                          +
+APPLID $myaplid   +COPYNAME $mycopyn  +CPU $mycpu  +REL $myrel  +
+      Current PARMLIB SIT Override is $mysit +
+  $mytno +Beep # $mydbno          $mynbno          +
+  Up/Down Times $mysnp                                                +
+ J01ASWAP $myj1asw   +J10ASWAP $myj10asw   +J21ASWAP $myj21asw +
+ J01BSWAP $myj1bsw   +J10BSWAP $myj10bsw   +J21BSWAP $myj21bsw +
+ J01XSWAP $myj1xsw   +
+ RADARJOB $myrdrsw   +
+ UJ1ASWAP $myu1asw   +UJ2ASWAP $myu2asw    +UJ3ASWAP $myu3asw +
+ UJ1BSWAP $myu1bsw   +UJ2BSWAP $myu2bsw    +UJ3BSWAP $myu3bsw +
+ UJ4ASWAP $myu4asw   +
+ UJ4BSWAP $myu4bsw   +

+ USRJSWAP $myuj      +

+ CALLMISA $mycmisa   +CALLMISB $mycmisb  +

+ ENDODATA $myeod  +
)PROC
 &CMD=' '
 &myscln=&zscrolln
)END
/* remove this mbr as it exists in other places */
###END AFO#NTLE
$$$BEG AFO#NTLD
)ATTR
  + TYPE(TEXT) INTENS(LOW) SKIP(ON)
  _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) PAD(_)
   TYPE(INPUT) INTENS(HIGH) CAPS(ON)
  ! TYPE(TEXT) INTENS(HIGH) SKIP(ON) COLOR(TURQ) HILITE(REVERSE)
  \ TYPE(TEXT) INTENS(HIGH) SKIP(ON) COLOR(YELLOW)
  @ TYPE(OUTPUT) INTENS(LOW) CAPS(OFF)
  $ TYPE(OUTPUT) INTENS(HIGH) CAPS(OFF) COLOR(GREEN)
  { TYPE(OUTPUT) INTENS(LOW) CAPS(OFF) COLOR(TURQ)
)BODY
! Command : ZCMD                                                      +
+Date === $SUDT    + Jdate == $SJDT + Day  === $WDT+ Time === $STIM    +
+CICS Copy Display Based on AFOPER Load at @myafoind                 +
+ Brws PARMLIB(STARTUP) Z+    Brws SIT Z+    Brws TABLE.SOURCE Z    +
+ Disp Xtended JOB Info Z+  LIST Copy DSN Z+ Disp JCL/PROC OvRd Z+
+ Expand JCL Z+      Search DFHRPL for Member (enter member) Z       +
+                     Expand DFHRPL Extents listingZ+
+ Srch Tblstbl + Selected CICS string was $mysst                      +
+APPLID $myaplid   +COPYNAME $mycopyn  +CPU $mycpu  +REL $myrel  +
+  TYPE $Z+ SYSID$Z   +     Current PARMLIB SIT Override $mysit +
+  Up/Down Times $mysnp                                                +
+ UPJOB    $myupj     +COLDJOB  $mycoldj    +EMERVFYJ $myemervj +
+ DOWNJOB  $mydownj   +UCC7JOB  $myucc7j    +VERIFYJ  $myverfyj +
+ JRNLJOB  $myjrnlj   +BTCHJOB  $mybtchj    +CMFJOB   $mycmfj   +
+ ABTASK  $Z+  DISOSS $Z+  RECYCLE $Z+ UCC7 $Z+  DCP y/n$Z+
+ DB2 y/n $Z+               MQS y/n$Z+         DBCTLy/n $Z+
+ DB2NAME $Z   +            MQSNAME$Z   +      DBCTLNAME$Z   +
+ RCT Sufx$Z +                                 DBCTL PZP$Z +
+ DownTime Wait Interval $mydwnwt +
+COMMENT: $mycommnt                                                    +
+       : $mycmnt                                                      +
)INIT
 .ZVARS='(bpl,bsit,bts,dext,dtab,djcl,ejcl,srpl4mbr,xtnt,myctypor, +
    mysysid,myabtas,mydisoss,myrecyc,myucc7,mydcp, +
    mydb2,MYMQS,mydbctl,mydb2n,MYMQSN,MYDBCN,myrct,MYDBCSX)'
)PROC
 &myverb = &zverb
 VER (&bpl,LIST,E,Y,N)
 VER (&bts,alpha)
 VER (&bsit,LIST,E,Y,N)
 VER (&dext,LIST,Y,N)
 VER (&dtab,LIST,Y,N)
 VER (&djcl,LIST,Y,N)
 VER (&ejcl,LIST,Y,N)
 VER (&srpl4mbr,name)
 &CMD=&zcmd
 &myscln=&zscrolln
)END
/* remove this mbr as it exists in other places */
###END AFO#NTLD
$$$BEG AFO#NTLB
)ATTR
  + TYPE(TEXT) INTENS(LOW) SKIP(ON)
  _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) PAD(_)
   TYPE(INPUT) INTENS(HIGH) CAPS(ON)
  ! TYPE(TEXT) INTENS(HIGH) SKIP(ON) COLOR(TURQ) HILITE(REVERSE)
  \ TYPE(TEXT) INTENS(HIGH) SKIP(ON) COLOR(YELLOW)
  @ TYPE(OUTPUT) INTENS(LOW) CAPS(OFF)
  $ TYPE(OUTPUT) INTENS(HIGH) CAPS(OFF) COLOR(GREEN)
  { TYPE(OUTPUT) INTENS(LOW) CAPS(OFF) COLOR(TURQ)
)BODY
! Command : ZCMD                                                      +
+Date === $SUDT    + Jdate == $SJDT + Day  === $WDT+ Time === $STIM    +
+CICS Copy Display Based on AFOPER Load at @myafoind                 +
+ Brws PARMLIB(STARTUP) Z+    Brws SIT Z+    Brws TABLE.SOURCE Z    +
+ Disp Xtended JOB Info Z+  LIST Copy DSN Z+ Disp JCL/PROC OvRd Z+
+ Expand JCL Z+      Search DFHRPL for Member (enter member) Z       +
+                     Expand DFHRPL Extents listingZ+
+ Srch Tblstbl + Selected CICS string was $mysst                      +
+APPLID $myaplid   +COPYNAME $mycopyn  +CPU $mycpu  +REL $myrel  +
+      Current PARMLIB SIT Override is $mysit +
+  $mytno +Beep # $mydbno          $mynbno          +
+  Up/Down Times $mysnp                                                +
+ UPMEM    $myupm     +COLDMEM  $mycoldm    +EMERVFYM $myemervm +
+ UPJOB    $myupj     +COLDJOB  $mycoldj    +EMERVFYJ $myemervj +
+ DOWNMEM  $mydownm   +UCC7MEM  $myucc7m    +VERIFYM  $myverfym +
+ DOWNJOB  $mydownj   +UCC7JOB  $myucc7j    +VERIFYJ  $myverfyj +
+ JRNLMEM  $myjrnlm   +BTCHMEM  $mybtchm    +CMFMEM   $mycmfm   +
+ JRNLJOB  $myjrnlj   +BTCHJOB  $mybtchj    +CMFJOB   $mycmfj   +
+ TYPE $Z     + ABTASK $myabtas +  DISOSS  $mydisoss+  DBRC $mydbrc +
+ DB2  $mydb2 +  RECYCLE $myrecyc +  UCC7    $myucc7  +  RCT  $myrct  +
+ DB2NAME  $mydb2n +   Shutdown Wait Interval $mydwnwt +
+COMMENT: $mycommnt                           +
)INIT
 .ZVARS='(bpl,bsit,bts,dext,dtab,djcl,ejcl,srpl4mbr,xtnt,myctypor)'
)PROC
 &myverb = &zverb
 VER (&bpl,LIST,Y,N)
 VER (&bts,alpha)
 VER (&bsit,LIST,Y,N)
 VER (&dext,LIST,Y,N)
 VER (&dtab,LIST,Y,N)
 VER (&djcl,LIST,Y,N)
 VER (&ejcl,LIST,Y,N)
 VER (&srpl4mbr,name)
 &CMD=&zcmd
 &myscln=&zscrolln
)END
/* remove this mbr as it exists in other places */
###END AFO#NTLB
$$$BEG AFO#TABE
)ATTR
  # AREA(DYNAMIC) SCROLL(ON)
  + TYPE(TEXT) INTENS(LOW) SKIP(ON)
  _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) PAD(_)
   TYPE(INPUT) INTENS(low) CAPS(ON)
  ! TYPE(OUTPUT) INTENS(HIGH) SKIP(OFF) COLOR(TURQ) HILITE(REVERSE)
  \ TYPE(TEXT) INTENS(HIGH) SKIP(ON) COLOR(YELLOW)
  @ TYPE(OUTPUT) INTENS(LOW) CAPS(OFF)
  $ TYPE(OUTPUT) INTENS(HIGH) CAPS(OFF) COLOR(GREEN)
  { TYPE(OUTPUT) INTENS(LOW) CAPS(OFF) COLOR(TURQ)
)BODY
\ Command : ZCMD                                                      +
+CICS Copy Display Based on AFOPER Load at @myafoind                   +
+ @dsemsg                                                              +
#myarea --------------------------------------------------------------#
_Z!mydst1                  _Z!mydsa1                 _Z!mydsp1
_Z!mydst2                  _Z!mydsa2                 _Z!mydsp2
_Z!mydst3                  _Z!mydsa3                 _Z!mydsp3
_Z!mydst4                  _Z!mydsa4                 _Z!mydsp4
_Z!mydst5                  _Z!mydsa5                 _Z!mydsp5
_Z!mydst6                  _Z!mydsa6                 _Z!mydsp6
_Z!mydst7                  _Z!mydsa7                 _Z!mydsp7
_Z!mydst8                  _Z!mydsa8                 _Z!mydsp8
_Z!mydst9                  _Z!mydsa9                 _Z!mydsp9
_Z!mydst10                 _Z!mydsa10                _Z!mydsp10
_Z!mydst11                 _Z!mydsa11                _Z!mydsp11
_Z!mydst12                 _Z!mydsa12                _Z!mydsp12
_Z!mydst13                 _Z!mydsa13                _Z!mydsp13
_Z!mydst14                 _Z!mydsa14                _Z!mydsp14
_Z!mydst15                 _Z!mydsa15                _Z!mydsp15
_Z!mydst16                 _Z!mydsa16                _Z!mydsp16
_Z!mydst17                 _Z!mydsa17                _Z!mydsp17
_Z!mydst18                 _Z!mydsa18                _Z!mydsp18
_Z!mydst19                 _Z!mydsa19                _Z!mydsp19
_Z!mydst20                 _Z!mydsa20                _Z!mydsp20
_Z!mydst21                 _Z!mydsa21                _Z!mydsp21
_Z!mydst22                 _Z!mydsa22                _Z!mydsp22
_Z!mydst23                 _Z!mydsa23                _Z!mydsp23
_Z!mydst24                 _Z!mydsa24                _Z!mydsp24
_Z!mydst25                 _Z!mydsa25                _Z!mydsp25
_Z!mydst26                 _Z!mydsa26                _Z!mydsp26
_Z!mydst27                 _Z!mydsa27                _Z!mydsp27
_Z!mydst28                 _Z!mydsa28                _Z!mydsp28
_Z!mydst29                 _Z!mydsa29                _Z!mydsp29
_Z!mydst30                 _Z!mydsa30                _Z!mydsp30
_Z!mydst31                 _Z!mydsa31                _Z!mydsp31
_Z!mydst32                 _Z!mydsa32                _Z!mydsp32
_Z!mydst33                 _Z!mydsa33                _Z!mydsp33
_Z!mydst34                 _Z!mydsa34                _Z!mydsp34
_Z!mydst35                 _Z!mydsa35                _Z!mydsp35
_Z!mydst36                 _Z!mydsa36                _Z!mydsp36
_Z!mydst37                 _Z!mydsa37                _Z!mydsp37
_Z!mydst38                 _Z!mydsa38                _Z!mydsp38
_Z!mydst39                 _Z!mydsa39                _Z!mydsp39
)INIT
 .CURSOR=zcmd
 .ZVARS='(mitat1,mitaa1,mitap1,mitat2,mitaa2,mitap2,mitat3,mitaa3, +
        mitap3,mitat4,mitaa4,mitap4,mitat5,mitaa5,mitap5, +
        mitat6,mitaa6,mitap6,mitat7,mitaa7,mitap7, +
        mitat8,mitaa8,mitap8,mitat9,mitaa9,mitap9,mitat10,mitaa10, +
        mitap10,mitat11,mitaa11,mitap11,mitat12,mitaa12,mitap12, +
        mitat13,mitaa13,mitap13,mitat14,mitaa14,mitap14, +
        mitat15,mitaa15,mitap15,mitat16,mitaa16,mitap16, +
        mitat17,mitaa17,mitap17,mitat18,mitaa18,mitap18, +
        mitat19,mitaa19,mitap19, +
        mitat20,mitaa20,mitap20,mitat21,mitaa21,mitap21, +
        mitat22,mitaa22,mitap22,mitat23,mitaa23,mitap23, +
        mitat24,mitaa24,mitap24,mitat25,mitaa25,mitap25, +
        mitat26,mitaa26,mitap26,mitat27,mitaa27,mitap27, +
        mitat28,mitaa28,mitap28,mitat29,mitaa29,mitap29, +
        mitat30,mitaa30,mitap30,mitat31,mitaa31,mitap31, +
        mitat32,mitaa32,mitap32,mitat33,mitaa33,mitap33, +
        mitat34,mitaa34,mitap34,mitat35,mitaa35,mitap35, +
        mitat36,mitaa36,mitap36,mitat37,mitaa37,mitap37, +
        mitat38,mitaa38,mitap38,mitat39,mitaa39,mitap39) '
)PROC
 &CMD=&ZCMD
 &myverb=&zverb
)END
/* remove this mbr as it exists in other places */
###END AFO#TABE
$$$BEG AFO#TABD
)ATTR
  # AREA(DYNAMIC) SCROLL(ON)
  + TYPE(TEXT) INTENS(LOW) SKIP(ON)
  _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) PAD(_)
   TYPE(INPUT) INTENS(low) CAPS(ON)
  ! TYPE(OUTPUT) INTENS(HIGH) SKIP(OFF) COLOR(TURQ) HILITE(REVERSE)
  \ TYPE(TEXT) INTENS(HIGH) SKIP(ON) COLOR(YELLOW)
  @ TYPE(OUTPUT) INTENS(LOW) CAPS(OFF)
  $ TYPE(OUTPUT) INTENS(HIGH) CAPS(OFF) COLOR(GREEN)
  { TYPE(OUTPUT) INTENS(LOW) CAPS(OFF) COLOR(TURQ)
)BODY
\ Command : ZCMD                                                      +
+CICS Copy Display Based on AFOPER Load at @myafoind                   +
+ @dsemsg                                                              +
#myarea --------------------------------------------------------------#
_Z!mydst1                  _Z!mydsa1                 _Z!mydsp1
_Z!mydst2                  _Z!mydsa2                 _Z!mydsp2
_Z!mydst3                  _Z!mydsa3                 _Z!mydsp3
_Z!mydst4                  _Z!mydsa4                 _Z!mydsp4
_Z!mydst5                  _Z!mydsa5                 _Z!mydsp5
_Z!mydst6                  _Z!mydsa6                 _Z!mydsp6
_Z!mydst7                  _Z!mydsa7                 _Z!mydsp7
_Z!mydst8                  _Z!mydsa8                 _Z!mydsp8
_Z!mydst9                  _Z!mydsa9                 _Z!mydsp9
_Z!mydst10                 _Z!mydsa10                _Z!mydsp10
_Z!mydst11                 _Z!mydsa11                _Z!mydsp11
_Z!mydst12                 _Z!mydsa12                _Z!mydsp12
_Z!mydst13                 _Z!mydsa13                _Z!mydsp13
_Z!mydst14                 _Z!mydsa14                _Z!mydsp14
_Z!mydst15                 _Z!mydsa15                _Z!mydsp15
_Z!mydst16                 _Z!mydsa16                _Z!mydsp16
_Z!mydst17                 _Z!mydsa17                _Z!mydsp17
_Z!mydst18                 _Z!mydsa18                _Z!mydsp18
_Z!mydst19                 _Z!mydsa19                _Z!mydsp19
_Z!mydst20                 _Z!mydsa20                _Z!mydsp20
_Z!mydst21                 _Z!mydsa21                _Z!mydsp21
)INIT
 .CURSOR=zcmd
 .ZVARS='(mitat1,mitaa1,mitap1,mitat2,mitaa2,mitap2,mitat3,mitaa3, +
        mitap3,mitat4,mitaa4,mitap4,mitat5,mitaa5,mitap5, +
        mitat6,mitaa6,mitap6,mitat7,mitaa7,mitap7, +
        mitat8,mitaa8,mitap8,mitat9,mitaa9,mitap9,mitat10,mitaa10, +
        mitap10,mitat11,mitaa11,mitap11,mitat12,mitaa12,mitap12, +
        mitat13,mitaa13,mitap13,mitat14,mitaa14,mitap14, +
        mitat15,mitaa15,mitap15,mitat16,mitaa16,mitap16, +
        mitat17,mitaa17,mitap17,mitat18,mitaa18,mitap18, +
        mitat19,mitaa19,mitap19,mitat20,mitaa20,mitap20, +
        mitat21,mitaa21,mitap21) '
)PROC
 &CMD=&ZCMD
 &myverb=&zverb
)END
/* remove this mbr as it exists in other places */
###END AFO#TABD
$$$BEG DSPAFODN
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA DSPAFOD  - SUBROUTINE TO AFOLIST. SEE AFOLIST           */
 /* CEMHELP DSPAFOD  - SUBROUTINE TO AFOLIST. SEE AFOLIST           */
 /* CEMHELP          - V3 CNC LOGIC ADDED                           */
 /* CEMHELP          - V2 PRESERVED IN DSPAFODO                     */
 /* CEMHELP END                                                     */
 /* THIS IS THE MAIN PROGRAM AND PANEL FOR AFOLIST                  */
 /* CNC LOGIC:                                                      */
 /* CREATE A LIST OF CHANNEL NAMES (TEMPLATE CHANNEL IS USED TO     */
 /*  MANAGE THE SET OF TEMPLATE CONTAINERS. IT CAN NOT BE SENT      */
 /*  ON THE EXCI CALL).                                             */
 /* CREATE A SET OF TEMPLATE CONTAINERS, ADDING EACH TO THE         */
 /*  TEMPLATE CHANNEL. THEY ARE COPIED TO REQUEST CONTAINERS.       */
 /*  AS A TEMPLATE, THEY ARE NEVER ALTERED. THE COPY IS ALTERED     */
 /*  ON THE EXCI CALL.                                              */
 /* THE PRIMARY COMMANDS:                                           */
 /*  CNCLIST - DISPLAYS A TABLE OF KNOWN CHANNELS                   */
 /*            CHOOSE L TO LIST THE CONTAINERS IN THE CHANNEL       */
 /*                   E TO EDIT THE LIST OF CONTAINETRS IN THE CH   */
 /*                   D TO DELETE SET OF CONTAINETRS IN THE CH      */
 /*                   C TO COPY   SET OF CONTAINETRS TO A NEW CH    */
 /*          - CNCLIST LAUNCHED THE DSPCNC PROGRAM AND PANEL        */
 /* YOU MANAGE THE SET OF TEMPLATES, TO CREATE UNIQUE CHANNELS      */
 /*  WITH COPIES OF TEMPLATE CONTAINERS                             */
 /* ON RESPONSE FROM THE EXCI CALL, YOU CAN MANIPULATE THE          */
 /*  RETURNED SET OF CONTAINERS IN THE ASSOCIATED CHANNEL           */
 /*                                                                 */
 /*                                                                 */
 /*                                                                 */
 /*                                                                 */
CHNM_DFT='#TEMPLATE_CH'
/* CNCCHLST WILL KEEP THE LIST OF ALL CHANNELS DEFINED */
CNCCHLST=CHNM_DFT
CNNM_DFT_CEMT='CEMT INQUIRE TASK'
CNNM_DFT_CEDA='CEDA EXPAND GROUP(XXXXXXXX)'
CNNM_DFT_PING='PING PINGED USING CNC'
CNNM_DFT_LINK='LINK PROGRAM('||UCEMPIN_||') TRANSID(UXXX)'
CNCCNLST=CNNM_DFT_CEMT||' '||CNNM_DFT_CEDA||' '||CNNM_DFT_PING||' '||,
   CNNM_DFT_LINK
CNNM_DFT_PLAY='PLAY CN_LIST('||CNCCNLST||')'
CNCCNLST=CNCCNLST||' '||CNNM_DFT_PLAY
/* NOTE: EACH CHANNEL DEFINED WILL HAVE A '.LIST' STEM WHICH       */
/*       WILL MANAGE THE LIST OF CONTAINERS ASSOC WITH A SPECIFIC  */
/*       CHANNEL (REQUEST AND RESPONSE)                            */
/* #TEMPLATE_CH.LIST HAS THE LIST OF TEMPLATE CONTAINERS           */
#TEMPLATE_CH.LIST = CNCCNLST
/*  END OF CNC SET UP                     */
 ADDRESS TSO
 /* TRACE I */
ARG MYTYP MYTYTOT
FSAVSTR=''
 IF MYTYTOT = '' THEN DO
  ADDRESS ISPEXEC
  "ISPEXEC VGET (MYTYP MYTYTOT DSEMSG) ASIS"
  IF RC \= 0 THEN SIGNAL NOPOOL
  AFOLISTV = DSEMSG
  END
 DSEMSG=' '
 MYAREA=''
 IF MYTYTOT \> 0 THEN SIGNAL NOPOOL
 A = VALUE(MYTYP)
 MXLNG = 0
 APLP=WORDPOS('MYAPLID',AFOLISTV)
 DO I = 1 TO MYTYTOT
  VGETSTR=VGETSTR||' '||MYTYP||I
  END
 BKSLH = ' \'
 FNDWDS='\@ \$ \! \\'  /* SUBSTITUTE \ APPLID JOBNAME */
 RWCT=WORDS(FNDWDS)
 SUBWDS='MYAPLID JOBN S#PARM BKSLH'
 TECCMDS = 'CEMT CEDA PLAY CNC'
 TC1='E D P N'
 VALCMDS = 'PING LINK '||TECCMDS||' PING MAKE APPEND'
 VALCMD1 = 'G L '||TC1||' Q M A'
 DFT_UCEMPIN='UCEMPINR'
 DFT_PING_CAL=1008
 MAX_CAL=32400
 DFT_CAL=4080
 TEST=''
 ACCP=''
 PROD=''
 MYCCPU = MVSVAR('SYSNAME')
 "ISPEXEC VGET ("VGETSTR") ASIS"
 DO I = 1 TO MYTYTOT
  INTERPRET 'TMP = 'A||I
  SRCT.I = SUBSTR(TMP,1,24)
  TEST=TEST||' '||WORD(SRCT.I,APLP)
  SRCA.I = SUBSTR(TMP,26,24)
  ACCP=ACCP||' '||WORD(SRCA.I,APLP)
  SRCP.I = SUBSTR(TMP,51,24)
  PROD=PROD||' '||WORD(SRCP.I,APLP)
  END
 TEST=STRIP(TEST,'B')
 ACCP=STRIP(ACCP,'B')
 PROD=STRIP(PROD,'B')
 APLLSTALL = TEST||' '||ACCP||' '||PROD
 VALLISTS='TEST ACCP PROD APLLSTALL '
  "ISPEXEC VGET (MYAFOIND CURGRP CURCPU CURCPUG) ASIS"
 VALCPU = ''
 L_CPUG=LENGTH(CURCPUG)
 VALCPU = ''
 DO I = 1 TO L_CPUG
  TH = SUBSTR(CURCPUG,I,1)
  INTERPRET 'VALCPU = VALCPU || " 'TH'SYS"'
  END
 VALCPU = STRIP(VALCPU,'B')
 'ISPEXEC VGET (HOSTLIST) ASIS'
 'ISPEXEC VGET ('HOSTLIST') ASIS'
 VALLISTS=VALLISTS||HOSTLIST
 CURRLIST = ''
 TMPLST='CURRLIST'
 MAFOLSTS=''
 CALL DSPAFOE
 'ISPEXEC VGET (MAFOLSTS) ASIS'
 'ISPEXEC VGET ('MAFOLSTS') ASIS'
 /* TRACE I
 NW=WORDS(MAFOLSTS)
 DO I = 1 TO NW
  INTERPRET 'XX='WORD(MAFOLSTS,I)
  END
 */
 MAFOLSTS='CURRLIST '||MAFOLSTS
 VALLISTS=VALLISTS||' '||MAFOLSTS
 TRACE OFF
 MXLNG = 79
 SUDT=DATE('U')
 BOTLN=MYTYTOT
 CURLN=1
 CURCL=1
 SP78=COPIES(' ',78)
 DL78=SUBSTR('-'||SP78,1,78)
  "ISPEXEC VGET (ZSCREEND) ASIS"
  MYSCRD=ZSCREEND-4
  MYPNLD='AFOLTABD'
  IF MYSCRD > 20 THEN DO
   IF MYSCRD > 39 THEN MYSCRD = 39
   MYPNLD='AFOLTABE'
   END
  UP_PG=MYSCRD-1
  MYVERB1 = ''
  D_STR = ''
DSPLOOP:
  /* TRACE I */
 CMDIND=0
 "ISPEXEC VPUT (CMDIND) ASIS"
 STIM=TIME()
 TOPLN=CURLN
 TOPCL=CURCL
 DO I = 1 TO MYSCRD
  INTERPRET 'MITAT'I'= ""'
  INTERPRET 'MITAA'I'= ""'
  INTERPRET 'MITAP'I'= ""'
  IF CURLN > BOTLN THEN DO
   INTERPRET 'MYDST'I' = DL78'
   INTERPRET 'MYDSA'I' = DL78'
   INTERPRET 'MYDSP'I' = DL78'
   END
   ELSE DO
   TLNG = 80
   INTERPRET 'MYDST'I' = SRCT.CURLN'
   INTERPRET 'MYDSA'I' = SRCA.CURLN'
   INTERPRET 'MYDSP'I' = SRCP.CURLN'
   END
  CURLN = CURLN + 1
  TRACE OFF
  END
 /* TRACE I */
 CMD = ''
 CMD1 = ''
 MYVERB=''
 MYEND=''
 DSEMSG=D_STR
 "ISPEXEC DISPLAY PANEL("MYPNLD")"
 LASTCC=RC
 MYCMD = WORD(CMD,1)
 MYVERB1 = CMD
 IF CMD \= '' THEN "ISPEXEC VPUT (CMD) ASIS"
 IF CMD = 'END' THEN SIGNAL TRYEND
 IF LASTCC = 8 THEN RETURN 8
 IF CMD = 'CANCEL' THEN RETURN 8
 IF CMD = '' THEN SIGNAL DO_LOOP
 IF CMD = '?' THEN SIGNAL SHOWNLOOP
 IF CMD = 'LISTS?' THEN SIGNAL SHOWLISTS
 IF MYCMD = 'SHOWLIST' THEN SIGNAL SHOWONELIST
 /* TRACE I  */
 WP=WORDPOS(MYCMD,VALCMDS)
 IF WP = 0 THEN SIGNAL DO_LOOP
 CMD1 = WORD(VALCMD1,WP)
 CMD_W2 = WORD(CMD,2)
 /* TRACE I */
 IF CMD1 = 'M' THEN DO
  /* TRACE ?I */
  IF CMD_W2 = '' THEN TMPLST='CURRLIST'
   ELSE DO
    IF LENGTH(CMD_W2) < 1 | LENGTH(CMD_W2) > 8 | ,
     (DATATYPE(SUBSTR(CMD_W2,1,1)) \= 'CHAR') THEN DO
     ERRMSG = 'MAKE VAR NAME INVALID'
     SIGNAL DO_LOOP
     END
    TMPLST=CMD_W2
   END
  IF WORDPOS(TMPLST,MAFOLSTS) = 0 THEN DO
   MAFOLSTS=MAFOLSTS||' '||TMPLST
   VALLISTS=VALLISTS||' '||TMPLST
   END
  INTERPRET TMPLST'=""'
  "ISPEXEC VPUT ("TMPLST") ASIS"
  D_STR = ''
  MYCMD='APPEND'
  ZCMD='APPEND'
  CMD1='A'
  SIGNAL DO_LOOP
  END
 IF CMD1 = 'A' THEN SIGNAL DO_LOOP
 CMD_W2 = WORD(CMD,2)
 IF CMD1 \= 'P' THEN SIGNAL ARNDPLAY
 /* TRACE I */
 IF CMD_W2 = '' THEN DO
  CMD1=''
  CALL MSGBOX 'ERROR:PLAY LIST SELECT MISSING.VALID LISTS:'MAFOLSTS
  SIGNAL ARND_LOOP
  END
 /*
 CALL GET_PLAY
 IF RC > 5 THEN SIGNAL ARND_LOOP
 DROP AFOSC.
 SCRPCMDI=0
 AFOSCTOT=0
 ADDRESS TSO "NEWSTACK"
 HDSEMSG = DSEMSG
 DSEMSG='ENTER VALID COMMANDS'
 "ISPEXEC VPUT (DSEMSG) ASIS"
 CALL REXXSRC "PULL(AFOSC)"
 XC = RESULT
 DSEMSG = HDSEMSG
 IF XC > 2 THEN DO
  CMD1=''
  CALL MSGBOX 'ERROR:PLAY LIST: COULD NOT CAPTURE SCRIPT.'
  SIGNAL ARND_LOOP
  END
 MY#VCT = QUEUED()
 IF MY#VCT > 99 THEN DO
  CMD1=''
  CALL MSGBOX 'ERROR:PLAY LIST: TOO MANY COMMANDS IN SCRIPT:'MY#VCT
  SIGNAL ARND_LOOP
  END
 K=0
 SCRPTLST=''
 DO J = 1 TO MY#VCT
  PULL AFOSC.J
  SCRPTMP=STRIP(AFOSC.J,'B')
  IF SCRPTMP  \= '' THEN DO
   IF SUBSTR(SCRPTMP,1,1) = '#' THEN ITERATE
   K=K+1
   INTERPRET 'AFOSC'K' = SCRPTMP'
   SCRPTLST=SCRPTLST||' AFOSC'||K
   END
  END
 ADDRESS TSO "DELSTACK"
 IF K < 1 THEN DO
  CMD1=''
  CALL MSGBOX 'ERROR:PLAY LIST: NO COMMANDS IN SCRIPT!'
  SIGNAL ARND_LOOP
  END
 AFOSCTOT=K
 "ISPEXEC VPUT (AFOSCTOT) ASIS"
 "ISPEXEC VPUT ("SCRPTLST") ASIS"
 IF RC \= 0 THEN DO
  CMD1=''
  CALL MSGBOX 'ERROR:PLAY LIST: COULD NOT SAVE COMMANDS'
  SIGNAL ARND_LOOP
  END
  */
ARNDPLAY:
 /* TRACE I */
 IF CMD1 = 'N' THEN DO
  SIGNAL DO_CNC
  END
 IF CMD_W2 = 'LIST' THEN DO
  IF D_STR = '' THEN  D_STR = '@ '||MYCMD||' '
  SIGNAL DO_LOOP
  END
 TX=WORDPOS(CMD_W2,VALCPU)
 IF TX \= 0 THEN DO
  TH = SUBSTR(WORD(VALCPU,TX),1,1)
  /* INTERPRET "D_STR = CPUHOST"TH */
  INTERPRET "D_STR = "TH"SYS"
  IF WORDS(D_STR) = 0 THEN SIGNAL DO_LOOP
  SIGNAL DO_INTGI
  END
 IF WORDPOS(CMD_W2,'TEST ACCP PROD') \= 0 THEN DO
  INTERPRET "D_STR = "CMD_W2
  SIGNAL DO_INTGI
  END
 TX=WORDPOS(CMD_W2,MAFOLSTS)
 IF TX = 0 THEN DO
  CALL MSGBOX 'ERROR:LIST('CMD_W2') IS NOT VALID'
  D_STR = ''
  SIGNAL ARND_LOOP
  END
 TH = CMD_W2
/* IF TH = 'CURRLIST' THEN D_STR=CURRLIST
  ELSE DO                                  */
 IF WORDPOS(TH,MAFOLSTS) > 0  THEN DO
  'ISPEXEC VGET ('TH') ASIS'
  IF RC \= 0 THEN DO
   CMD1=''
   CALL MSGBOX 'ERROR:INV LIST:'D_STR'<VALID LISTS:'MAFOLSTS
   SIGNAL ARND_LOOP
   END
  TMPLST = TH
  INTERPRET 'D_STR = 'TH
  END
 IF WORDS(D_STR) = 0 THEN DO
  CALL MSGBOX 'ERROR:EMPTY LIST:'D_STR'<'
  D_STR = ''
  SIGNAL ARND_LOOP
  END
/*  SIGNAL DO_INTGI
  END */
DO_INTGI:
 TMP=CMD1
 CALL INTGI
DO_INTGI_X:
 D_STR = ''
 MYCMD = ''
 CMD = ''
 ZCMD=''
 TRACE OFF
 SIGNAL ARND_LOOP
 /*    ADDED CNC LOGIC */
DO_CNC:
 TMP=CMD1
 'ISPEXEC SELECT CMD (DSPCNC)'
 D_STR = ''
 MYCMD = ''
 CMD = ''
 ZCMD=''
 TRACE OFF
 SIGNAL ARND_LOOP
 /*    ADDED CNC LOGIC */
SHOWLISTS:
 CALL MSGBOX 'KNOWN LISTS:'||VALLISTS
 SIGNAL ARND_LOOP
SHOWONELIST:
  CMD_W2 = WORD(CMD,2)
  IF WORDPOS(CMD_W2,VALLISTS) \= 0 THEN DO
   INTERPRET 'XXX = 'CMD_W2
   IF XXX = CMD_W2 THEN 'ISPEXEC VGET ('XXX') ASIS'
   INTERPRET 'MSGBOXTX = 'XXX
   END
   ELSE MSGBOXTX = CMD_W2' IS NOT A VALID LIST'
 CALL MSGBOX 'LIST:'CMD_W2'='MSGBOXTX
 SIGNAL ARND_LOOP
SHOWNLOOP:
 CALL MSGBOX 'COMMANDS: '||VALCMDS||' LISTS? SHOWLIST END OR CANCEL'
 SIGNAL ARND_LOOP
DO_LOOP:
 /* TRACE I */
 CL=TOPLN
 HYCMD = ''
 DO I = 1 TO MYSCRD
  Q = I + TOPLN -1
  DO T = 1 TO 1
   INTERPRET 'TMP = MITAT'I
   TP=WORDPOS(TMP,VALCMD1)
   IF TP \= 0 THEN DO
    IF TMP = 'M' | TMP = 'A' THEN DO
     "ISPEXEC VGET ("TMPLST") ASIS"
     IF RC > 0 THEN INTERPRET TMPLST" = ''"
     INTERPRET 'TMP = 'TMPLST
     TMP = TMP ||' '||WORD(SRCT.Q,1)
     D_STR=TMP
     INTERPRET TMPLST '= TMP'
     "ISPEXEC VPUT ("TMPLST") ASIS"
     LEAVE T
     END
     ELSE DO
     MYCMD=WORD(VALCMDS,TP)
     END
    END
   IF TMP = "I" THEN DO
    LNREST = SRCT.Q
    CALL INTCI
    LEAVE T
    END
   IF WORDPOS(TMP,VALCMD1) \= 0 THEN DO
    IF WORD(D_STR,1) = '@' THEN DO
     D_STR=D_STR||' '||WORD(SRCT.Q,1)
     LEAVE T
     END
    LNREST = SRCT.Q
    D_STR=WORD(SRCT.Q,1)
    CALL INTGI
    LEAVE T
    END
   IF TMP = "V" THEN DO
    LNREST = SRCT.Q
    CALL INTVI
    LEAVE T
    END
   END T
  DO A = 1 TO 1
   INTERPRET 'TMP = MITAA'I
   TP=WORDPOS(TMP,VALCMD1)
   IF TP \= 0 THEN DO
    IF TMP = 'M' | TMP = 'A' THEN DO
     "ISPEXEC VGET ("TMPLST") ASIS"
     IF RC > 0 THEN INTERPRET TMPLST" = ''"
     INTERPRET 'TMP = 'TMPLST
     TMP = TMP ||' '||WORD(SRCA.Q,1)
     D_STR=TMP
     INTERPRET TMPLST '= TMP'
     "ISPEXEC VPUT ("TMPLST") ASIS"
     LEAVE A
     END
     ELSE DO
     MYCMD=WORD(VALCMDS,TP)
     END
    END
   IF TMP = "I" THEN DO
    LNREST = SRCA.Q
    CALL INTCI
    LEAVE A
    END
   IF WORDPOS(TMP,VALCMD1) \= 0 THEN DO
    IF WORD(D_STR,1) = '@' THEN DO
     D_STR=D_STR||' '||WORD(SRCA.Q,1)
     LEAVE A
     END
    LNREST = SRCA.Q
    D_STR=WORD(SRCA.Q,1)
    CALL INTGI
    LEAVE A
    END
   IF TMP = "V" THEN DO
    LNREST = SRCA.Q
    CALL INTVI
    LEAVE A
    END
   END A
  DO P = 1 TO 1
   INTERPRET 'TMP = MITAP'I
   TP=WORDPOS(TMP,VALCMD1)
   IF TP \= 0 THEN DO
    IF TMP = 'M' | TMP = 'A' THEN DO
     "ISPEXEC VGET ("TMPLST") ASIS"
     IF RC > 0 THEN INTERPRET TMPLST" = ''"
     INTERPRET 'TMP = 'TMPLST
     TMP = TMP ||' '||WORD(SRCP.Q,1)
     D_STR=TMP
     INTERPRET TMPLST '= TMP'
     "ISPEXEC VPUT ("TMPLST") ASIS"
     LEAVE P
     END
     ELSE DO
     MYCMD=WORD(VALCMDS,TP)
     END
    END
   IF TMP = "I" THEN DO
    LNREST = SRCP.Q
    CALL INTCI
    LEAVE P
    END
   IF WORDPOS(TMP,VALCMD1) \= 0 THEN DO
    IF WORD(D_STR,1) = '@' THEN DO
     D_STR=D_STR||' '||WORD(SRCP.Q,1)
     LEAVE P
     END
    LNREST = SRCP.Q
    D_STR=WORD(SRCP.Q,1)
    CALL INTGI
    LEAVE P
    END
   IF TMP = "V" THEN DO
    LNREST = SRCP.Q
    CALL INTVI
    LEAVE P
    END
   END P
  IF I > 1 THEN TRACE OFF
  END
 /*TRACE I */
ARND_LOOP:
 IF MYVERB = 'LEFT' THEN DO
  CURCL = CURCL-78
  IF CURCL < 1 THEN CURCL=1
  SIGNAL REDSPLY
  END
 IF MYVERB = 'LEFT M' THEN DO
  CURCL = 1
  SIGNAL REDSPLY
  END
 IF MYVERB = 'RIGHT' THEN DO
  CURCL = CURCL+78
  IF CURCL > MXLNG THEN DO
   CURCL=MXLNG-77
   IF CURCL < 1 THEN CURCL = 1
   END
  SIGNAL REDSPLY
  END
 IF MYVERB = 'RIGHT M' THEN DO
  CURCL = MXLNG-77
  IF CURCL < 1 THEN CURCL = 1
  SIGNAL REDSPLY
  END
 IF MYVERB = 'UP' THEN DO
  CURLN = TOPLN-UP_PG
  IF CURLN < 1 THEN CURLN=1
  SIGNAL DSPLOOP
  END
 IF MYVERB = 'UP M' THEN DO
  CURLN = 1
  SIGNAL DSPLOOP
  END
 IF MYVERB = 'DOWN M' THEN DO
  CURLN = BOTLN-MYSCRD
  IF CURLN < 1 THEN CURLN=1
  SIGNAL DSPLOOP
  END
 IF MYVERB = 'DOWN' THEN DO
  IF CURLN > BOTLN THEN SIGNAL REDSPLY
  CURLN = CURLN - 1
  SIGNAL DSPLOOP
  END
 /* TRACE I */
  IF WORD(D_STR,1) = '@' THEN DO
   PARSE VAR D_STR '@' CMD  D_STR
   WP=WORDPOS(MYCMD,VALCMDS)
   TMP = WORD(VALCMD1,WP)
   IF D_STR \= '' THEN DO
    CALL INTGI
    D_STR = ''
    MYCMD = ''
    CMD = ''
    ZCMD=''
    END
    ELSE CMD = ''
   END
  TRACE OFF
 CURCL=TOPCL
REDSPLY:
 CURLN=TOPLN
 SIGNAL DSPLOOP
NOPOOL:
  ZEDSMSG = "NO POOLED DATA"
  ZEDLMSG = "NO DATA PREVIOUSLY POOLED FOR RECALL"
  XC = 4
 SIGNAL WRITIT
 WRITIT:
 IF FSAVSTR \= '' THEN SAY FSAVSTR
 "ISPEXEC SETMSG MSG(ISRZ001)"
 RETURN XC
 TRYEND:
 IF FSAVSTR \= '' THEN DO
  FSAVSTR = SUBSTR(FSASTR,2)
  MYTYRSP=FSAVSTR
  "ISPEXEC VPUT (MYTYRSP) ASIS"
  END
 RETURN 0
/* INTGI: PROCEDURE EXPOSE MYCMD HYCMD LNREST APLP TMP D_STR CMDIND */
INTGI:
 /* TRACE I */
  IF APLP = 0 THEN RETURN 8
  IF TMP = 'G' | TMP = 'Q' THEN DO
   MYCMD='PING'
   MYCA = 'PING DSPAFOD MSG FROM \@'
   MYPROG= DFT_UCEMPIN
   IF TMP = 'G' THEN DO
    MYCAL = DFT_PING_CAL
    MYFUNC = 'MSGBOXONLY'
    END
   IF TMP = 'Q' THEN DO
    MYCAL = 0
    MYFUNC = 'QUIET'
    END
   "ISPEXEC VPUT (MYCMD MYCA MYCAL MYPROG MYFUNC) ASIS"
   END
   IF TMP = 'P' THEN DO
    MYCMD='PLAY'
    MYCAL = MAX_CAL
    MYCA=''
    MYPROG=''
    MYFUNC = 'MSGBOXALL'
    CALL GET_PLAY
    IF RC > 4 THEN SIGNAL BYP_CMD
    IF SUBSTR(D_STR,1,1) = '@' THEN PARSE VAR D_STR '@' . D_STR
    MYAPLID=D_STR
    "ISPEXEC VPUT (MYAPLID MYCMD MYCA MYCAL MYPROG MYFUNC) ASIS"
    CALL AFOLPLAY
    XC = RESULT
    MYAREA = ''
   "ISPEXEC VPUT (MYAREA) ASIS"
    RETURN XC
    END
   IF TMP = 'E' | TMP = 'L' | TMP = 'D' THEN DO
 /* TRACE I */
    IF HYCMD \= MYCMD THEN CMDIND = 0
    IF CMDIND = 0 THEN DO
     MYFUNC1 = 'O'
     "ISPEXEC VPUT (MYCMD MYFUNC1 CMDIND MYAPLID) ASIS"
     CALL DSPAFOC
     "ISPEXEC VGET (CMDIND MYFUNC1) ASIS"
     IF CMDIND > 1 THEN SIGNAL BYP_CMD
     VALFUNC='QUIET MSGBOXONLY MSGBOXALL VERBOSE'
     VALFUNC1='Q O A V'
     MYFUNC = WORD(VALFUNC,WORDPOS(MYFUNC1,VALFUNC1))
     "ISPEXEC VPUT (MYFUNC) ASIS"
     END
    END
DO_CALL:
   IF D_STR = '' THEN DO
    MYAPLID = WORD(LNREST,APLP)
    END
    ELSE DO
    MYAPLID = D_STR
    MYAPLID = TRANSLATE(MYAPLID,' ','@')
    END
   "ISPEXEC VPUT (MYAPLID) ASIS"
   IF RC \= 0 THEN SIGNAL BYP_CMD
   /* !@! */
   /* SUBSTITUTE SPECIFIC CHARACTER INDICATORS FOR JOBNAME OR *\
   \*  APPLID, TO CAUSE DYNAMIC CA DATA BASED ON JOB OR APPLID*/
/* CALL SUBJOBN                       *\
\* IF RESULT /= 0 THEN SIGNAL BYP_CMD */
   MYPRM= "MYCMD=<MYCMD> MYAPLID=<MYAPLID> MYCA=<MYCA> "|| ,
     "MYCAL=<MYCAL> MYPROG=<MYPROG> MYTRANID=<MYTRANID> ODSN=<MYODSN>"
   CALL EXCIS0 MYFUNC MYPRM
   XC = RESULT
   MYAREA = ''
   TRACE OFF
   "ISPEXEC VPUT (MYAREA) ASIS"
   IF D_STR = '' THEN RETURN XC
BYP_CMD:
   RETURN 8
/* INTCI: PROCEDURE EXPOSE LNREST */
INTCI:
   IF LNREST = '' THEN RETURN 4
   ARGAFO =STRIP(SUBSTR(LNREST,1,8),'T')
   CALL COPYINFO ARGAFO
   XC = RESULT
   RETURN XC
INTVI: PROCEDURE EXPOSE LNREST FSAVSTR
   IF LNREST = '' THEN RETURN 4
   ARGAFO =STRIP(SUBSTR(LNREST,1,8),'T')
   XC=POS(ARGAFO,FSAVSTR)
   IF XC = 0 THEN FSAVSTR=FSAVSTR||','||ARGAFO
   NOVAR:
   RETURN XC
GET_PLAY:
 DROP AFOSC.
 SCRPCMDI=0
 AFOSCTOT=0
 ADDRESS TSO "NEWSTACK"
 HDSEMSG = DSEMSG
 DSEMSG='ENTER VALID COMMANDS OR ? FOR HELP'
 "ISPEXEC VPUT (DSEMSG) ASIS"
 CALL REXXSRC "PULL(AFOSC)"
 XC = RESULT
 DSEMSG = HDSEMSG
 IF XC > 2 THEN DO
  CMD1=''
  CALL MSGBOX 'ERROR:PLAY LIST: COULD NOT CAPTURE SCRIPT.'
  RETURN 8
  END
 MY#VCT = QUEUED()
 IF MY#VCT > 99 THEN DO
  CMD1=''
  CALL MSGBOX 'ERROR:PLAY LIST: TOO MANY COMMANDS IN SCRIPT:'MY#VCT
  RETURN 4
  END
 K=0
 SCRPTLST=''
 DO J = 1 TO MY#VCT
  PULL AFOSC.J
  SCRPTMP=STRIP(AFOSC.J,'B')
  IF SCRPTMP  \= '' THEN DO
   IF SUBSTR(SCRPTMP,1,1) = '#' THEN ITERATE
   K=K+1
   INTERPRET 'AFOSC'K' = SCRPTMP'
   SCRPTLST=SCRPTLST||' AFOSC'||K
   END
  END
 ADDRESS TSO "DELSTACK"
 IF K < 1 THEN DO
  CMD1=''
  CALL MSGBOX 'ERROR:PLAY LIST: NO COMMANDS IN SCRIPT!'
  RETURN 8
  END
 AFOSCTOT=K
 "ISPEXEC VPUT (AFOSCTOT) ASIS"
 "ISPEXEC VPUT ("SCRPTLST") ASIS"
 IF RC \= 0 THEN DO
  CMD1=''
  CALL MSGBOX 'ERROR:PLAY LIST: COULD NOT SAVE COMMANDS'
  RETURN 8
  END
 RETURN 0
/* ROUTINE TO SUBSTITUTE JOB OR APPLID VALUE IN CA */
SUBJOBN:
/* JOB#PTR IS THE CURRENT JOBNAME FROM THE SUPPLIED LIST */
/* IF ZERO JOBNAMES WERE SUPPLIED, THEN WE CAN NOT PERFORM */
/*   THE $ SUBSTITUTION.                                 */
/* WE SHOULD NOT BE HERE IF THE JOB#PTR IS > NUMBER OF   */
/*   JOBNAMES PROVIDED IN THE JOBLIST ARGUMENT.          */
/* TRACE ?I */
  "ISPEXEC VGET (MYCA MYCAL) ASIS"
  IF RC \= 0 THEN RETURN 8
  IF LENGTH(MYCA) < 1 THEN RETURN 0
  LOOPCT=100
  V=1
  X = OUTTRAP('JNL.')
  CALL CVTJN2RG MYAPLID
  X = OUTTRAP('OFF')
  IF WORD(JNL.1,1) = '!!!!!!!!' THEN RETURN 8
  JOBN=WORD(JNL.1,2)
  SUBCMD=STRIP(MYCA,'T')
  CURL=LENGTH(SUBCMD)
  CURP=1
  CURS=0
  NEWCMD=''
  /* NEW CODE V2 */
  TRACE I
  S#APLID = MYAPLID
  IF LENGTH(S#APLID) < 7 THEN INTERPRET "T#PARM = 'S#"||S#APLID||"'"
    ELSE INTERPRET "T#PARM = 'S#"||SUBSTR(S#APLID,3)||"'"
  INTERPRET T#PARM " = S#VALUE"
  'ISPEXEC VGET ('T#PARM') ASIS'
  IF RC > 0 THEN S#PARM = MYAPLID
   ELSE INTERPRET 'S#PARM = 'T#PARM
  /* NEW CODE V2 */

TOPOFQLOP:
  JP = WORDPOS(SUBSTR(SUBCMD,CURP,1),FNDWDS)
  IF JP = 0 THEN SIGNAL NXT_POS
  /* TRACE ?I */

  SUBWD = WORD(SUBWDS,JP)
  INTERPRET 'REPWD = 'SUBWD
  IF CURP = 1 THEN DO
   NEWCMD = REPWD
   END
   ELSE DO
   IF CURS = 0 THEN NEWCMD = SUBSTR(SUBCMD,1,CURP - 1)
   NEWCMD=SUBSTR(NEWCMD,1)||REPWD
   END
  LOOPCT = LOOPCT - 1
  IF LOOPCT < 1 THEN RETURN 8
  CURS = CURP + 1
NXT_POS:
  CURP=CURP + 1
  IF CURP <= CURL THEN SIGNAL TOPOFQLOP
  IF CURS < CURP THEN DO
   IF CURS = 0 THEN NEWCMD = SUBCMD
   ELSE NEWCMD=SUBSTR(NEWCMD,1)||SUBSTR(SUBCMD,CURS)
   END
  IF LENGTH(NEWCMD) > MYCAL THEN MYCA = SUBSTR(NEWCMD,1,MYCAL)
   ELSE MYCA =  NEWCMD
  "ISPEXEC VPUT (MYCA MYCAL) ASIS"
  IF RC \= 0 THEN RETURN 8
  TRACE OFF
 RETURN 0
###END DSPAFODN
$$$BEG TRXCNCL1
/*  REXX   */
/*  000219 if datatype(ans,'w') = 0 THEN DO */
trace i
/* ALWAYS RETURN THIS VAR WITH A QUICK NOTE SUCCESS/FAILURE */
MSGOUT_NOTE='INITIAL'
/* ALWAYS RETURN THESE VARS: AS A STEM VARIABLE */
/*  WITH THE APPLID AS THE PREFIX, AND THE FOLLOWING AS THE SUFFIX */
THISPGM_RSP_LOG='INITIAL'
RETURN_CN_LIST=''
/* REQUIRED RX VARS */
PROGRAM_NM='UCEMPINR'
APPLID_NM='CGE7'
TRANID_NM='UXXX'
/* AND THEN WE PROVIDE A SINGLE RX VAR AS THE SINGLE PARM TO       *\
|*   THE PROGRAM IN WHICH WE ISSUE THE RX CMD:                     *|
|* ADDRESS LINK 'RXCNCLN2 RXVARPARM'                               *|
|* THE RXVARPARM IS EITHER                                         *|
|*   COMMAREA  - YEP THE ACTUAL 'COMMAREA' LITERAL                 *|
|*   OR                                                            *|
|*   SOME_CHAN_NAME - A RX VAR WHICH DEFINES A CHANNEL NAME        *|
|*             - AND WHO'S CONTENTS IS A COMMA SEPARATED LIST      *|
|*             - OF CONTAINERS (WHICH ARE RX VARS WITH THE ACTUAL  *|
|*             - CN DATA)                                          *|
|*   FOR EACH, YOU CAN OPTIONALLY CODE ADDITIONAL RX STEM VARS     *|
|*    WHICH HAVE THE 'COMMAREA' OR SOME_CONT_NAME WITH A '.L'      *|
|*    SUFFIX. THIS IS USED TO CONVEY A LENGTH FOR THE CA OR CN     *|
|*   AND FOR CN VARS, THE SAME SOME_CONT_NAME WITH A '.T' CAN      *|
|*    OPTIONALLY CONVEY THE CN DATATYPE                            *|
|*                                                                 *|
|*                                                                 *|
|*                                                                 *|
\*                                                                 */
/* TEST PARMS                   */
COMMAREA='PINGTHIS IS A TEST'
COMMAREA.L='4096'
CEMT0001='CEMT INQUIRE TASK'
CEMT0001.L='100'
CEMT0001.T='CHAR'
JUNK0001='NOTHING BUT JUNK'
JUNK0001.T='BIT'
CEDA0001='CEDA EXPAND GROUP(CEM)'
MY_CHAN='CEMT0001,JUNK0001,CEDA0001'
SIGNAL DO_TEST
/* TEST PARMS                    */
'GETCPU1 <PUSH>'
PULL CURCPU CURGRP CURCPUG
 SELECT
  WHEN CURCPU = 'GRP1' THEN APPLID_NM='CGE5'
  WHEN CURCPU = 'GRP2' THEN APPLID_NM='CGE9'
  WHEN CURCPU = 'GRP5' THEN APPLID_NM='BEN0'
  OTHERWISE DO
  APPLID_NM='><'
  SAY 'WARNING: CANNOT DETERMINE WHICH SYSPLEX GROUP'
  SAY '         THIS IS RUNNING ON:GRP:'CURCPU':'
  SAY '         CAN NOT SUPPLY A DEFAULT APPLID'
  SAY '         'APPLID_NM
  END
 END
SAY 'THIS IS A TEST HARNESS TO INVOKE THE EXCI INTERFACE'
SAY ' TO A CICS REGION, UTILIZING CHANNEL AND CONTAINERS'
SAY ' INVOKING NEW COBOL EXCI PROGRAM RXCNCLNK'
SAY 'THIS EXEC HAS REQUIRED AND OPTIONAL PARAMETERS'
SAY '  THAT YOU MUST PROVIDE:'
SAY ' LINK TO CICS PROGRAM NAME (RX NAME PROGRAM_NM):'PROGRAM_NM
SAY ' LINK TO CICS APPLID       (RX NAME APPLID_NM ):'APPLID_NM
SAY ' LINK TO CICS TRANSID      (RX NAME TRANID    ):'TRANID
SAY ' LINK TO CICS COMMAREA     (RX NAME COMMAREA  ):'COMMAREA
SAY ' OR'
SAY ' LINK TO CICS CHANNEL      (RX NAME WHATEVER  ):'MY_CHAN
SAY ' AND SET THE VALUE OF THE WHATEVER RX VAR TO '
SAY '  A LIST OF CONTAINER NAMES:'
SAY '  WITH EACH CN NAMED IS A RX VAR WITH A DATA VALUE'
SAY 'YOU MAY PROVIDE A STEM VAR COMMAREA.L'
SAY '                     OR CONTAINNAME.L TO CONVEY A DATALENGTH'
SAY ' AND (FOR A CONMTAINERNAME YOU CAN SPECIFY'
SAY '        AN RX STEM VAR  CONTAINNAME.T TO CONVEY A DATATYPE'
SAY 'OVERRIDE THE REQUIRED OR PRESS ENTER TO JUST ACCEPT'
SAY ' AND PROVIDE COMMAREA OR A CHANNEL NAME AND FOLLOW THE PROMPTS'
SAY ' TO PROVIDE THE COMMAREA DATA OR CONTAINER NAMES (IN A LOOP)'
SAY '  FOLLOWED BY DATA.'
SAY ''
SAY ' PROGRAM_NM:'PROGRAM_NM
ANS = ''
PULL ANS
ANS = STRIP(ANS,'B')
IF ANS \= '' THEN DO
  IF LENGTH(ANS) > 8 THEN ANS = SUBSTR(ANS,1,8)
  PROGRAM_NM = ANS
  END

SAY '  APPLID_NM:'APPLID_NM
ANS = ''
PULL ANS
ANS = STRIP(ANS,'B')
IF ANS \= '' THEN DO
  IF LENGTH(ANS) > 8 THEN ANS = SUBSTR(ANS,1,8)
  APPLID_NM = ANS
  END

SAY ' TRANID_NM:'TRANID_NM
ANS = ''
PULL ANS
ANS = STRIP(ANS,'B')
IF ANS \= '' THEN DO
  IF LENGTH(ANS) > 4 THEN ANS = SUBSTR(ANS,1,8)
  TRANID_NM = ANS
  END

RETRYCT = 0
say 'Provide the Data Source:'
SAY '(Warning: CAPS are off. COMMAREA will be shifted to upper case:'
SAY '                       CHANNEL name can be UPPER or lower case)'
GET_CA_OR_CHANNEL:
SAY 'ENTER THE WORD COMMAREA, OR A CHANNEL NAME (caps are off):'
PARSE PULL ANS
IF LENGTH(ANS) = 0 THEN DO
 IF RETRYCT > 0 THEN DO
  SAY 'YOU SELECTED TO QUIT. BYE.'
  RETURN
  END
 SAY 'YOU DID NOT IDENTIFY THE DATA SOURCE. RETRY ONCE'
 SAY ' OR JUST PRESS ENTER AGAIN TO ABORT:'
 RETRYCT = 1
 SIGNAL GET_CA_OR_CHANNEL
 END
TMP = ANS
UPPER TMP
IF TMP = 'COMMAREA' THEN DO
 CALL GET_COMMAREA
 IF RC \= 0 THEN DO
  SAY 'ABORT OR CANCEL ENCOUNTERED GETTING THE COMMAREA DATA. BYE'
  RETURN
  END
 SIGNAL GOT_ALL_REQUEST_INFO
 END
/* HERE WE HAVE A CHANNEL NAME */
RETRY_CH:
IF LENGTH(ANS) > 16 THEN DO
 RX_CNC_CH_NM = SUBSTR(ANS,1,16)
 SAY 'YOU SPECIFIED A CHANNEL NAME THAT IS TOO LONG.'
 SAY ' NAME IS TRUNCATED TO 16 CHARACTERS>'RX_CNC_CH_NM'<'
 SAY ' IF THIS IS CORRECT, PRESS ENTER TO ACCEPT THIS NAME,'
 SAY ' SPECIFY A DIFFERENT CHANNEL NAME, OR ENTER A "!" TO ABORT:'
 PARSE PULL ANS
 IF ANS = '' THEN SIGNAL GOT_CH_NM
 IF ANS = '!' THEN DO
  SAY 'YOU DECIDED TO ABORT WITH CHANNEL NAME PROBLEMS. BYE'
  RETURN
  END
 SIGNAL RETRY_CH
 END
 ELSE DO
 RX_CNC_CH_NM = ANS
 END
GOT_CH_NM:
SAY ' YOU PROVIDED A CHANNEL NAME:'RX_CNC_CH_NM

SAY ''
SAY 'ENTERING LOOP TO GET CONTAINERS for CHANNEL:'RX_CNC_CH_NM
SAY ''
SAY 'NOTE: CAPS are Set to off for both Container Names and dAtA:'
say ' (utilize your CAPS Lock to force UPPERCASE)'
say ' Provide the CN Name, followed by optional CN datalength'
say '   and then optionally the CN DataType (C)har or (B)it'
say '   (just press enter for each optionaly prompt'
say '     to use default (actual) datalength and CHAR datatype)'
CN_CT = 0
CN_LIST=''
TOP_CN_LOOP:
SAY ' First enter the CN Name (1 - 16 VALID CHARACTERS):'
SAY ' OR just press ENTER to indicate this loop is complete'
SAY ' OR enter a single "!" to indicate ABORT processing)'
ANS = ''
PARSE PULL ANS
IF ANS = '!' THEN DO
 SAY 'You have indicated ABORT. Bye.'
 RETURN
 END
IF ANS = '' THEN SIGNAL GOT_ALL_CN
RETRY_CN:
IF LENGTH(ANS) > 16 THEN DO
 RX_CNC_CN_NM = SUBSTR(ANS,1,16)
 SAY 'YOU SPECIFIED A CONTAINER NAME THAT IS TOO LONG.'
 SAY ' NAME IS TRUNCATED TO 16 CHARACTERS>'RX_CNC_CN_NM'<'
 SAY ' IF THIS IS CORRECT, PRESS ENTER TO ACCEPT THIS NAME,'
 SAY ' SPECIFY A DIFFERENT CONTAINER NAME, OR ENTER A "!" TO ABORT:'
 PARSE PULL ANS
 IF ANS = '' THEN SIGNAL GOT_CN_NM
 IF ANS = '!' THEN DO
  SAY 'YOU DECIDED TO ABORT WITH CONTAINER NAAME PROBLEMS. BYE'
  RETURN
  END
 SIGNAL RETRY_CN
 END
 ELSE DO
 RX_CNC_CN_NM = ANS
 END
GOT_CN_NM:
SAY ' Now enter the request data for CN Name:'RX_CNC_CN_NM
SAY ' OR just press ENTER to indicate no data (this is OK)'
SAY ' OR enter a single "!" to indicate ABORT processing)'
ANS = ''
PARSE PULL ANS
IF ANS = '!' THEN DO
  SAY 'YOU DECIDED TO ABORT WITH CONTAINER data PROBLEMS. BYE'
  RETURN
  END
INTERPRET RX_CNC_CN_NM' = ANS'
CN_DATA_L = LENGTH(ANS)
SAY ' The container data has a length:'cn_data_l
SAY '  Just press ENTER to indicate this is the desired length'
SAY '  Enter a valid numeric value (0 - 1000000) to override'
SAY ' OR enter a single "!" to indicate ABORT processing)'
ANS = ''
PARSE PULL ANS
IF ANS = '!' THEN DO
  SAY 'YOU DECIDED TO ABORT WITH CONTAINER length PROBLEMS. BYE'
  RETURN
  END
IF DATATYPE(ANS,'W') = 0 THEN DO
 SAY 'YOU HAVE ENTERED AN NON-NUMERIC OR NON-WHOLE NUMBER. RETRY.'
 SIGNAL RETRY_CN_L
 END
INTERPRET RX_CNC_CN_NM' = ANS'
CN_DATA_L = LENGTH(ANS)
SAY ' FOR EACH REQUEST, ENTER A CCONTAINERNAME=CONTAINER DATA VALUES'
SAY ' CONTAINERNAME IS 1 TO 16 CHARACTERS, VALID FOR A CONTAINER NAME'
SAY ' AND A CONTAINER VALUE STRING (CHAR CONTAINERS ONLY)'
SAY ' AT END, JUST ENTER NOTHING AT THE PROMPT OR ATTN TO ABORT'
EQ='='
CN_CNT = 0
CN_PROMPT='ENTER FOR CN#:'
CN_NM='CONTINUE'
/* TRACE I */
QN_LOOP:DO WHILE CN_NM \= ''
 SAY CN_PROMPT||CN_CNT + 1
 PARSE PULL CN_NM (EQ) CN_DATA
 CN_NM = STRIP(CN_NM,'B')
 IF CN_NM = '' THEN DO
  SAY 'YOU SIGNALED YOU ARE FINISHED ENTERING REQUEST CN DATA'
  LEAVE
  END
 IF T1 = '>' THEN UPPER CN_NM
 IF T2 = '>' THEN UPPER CN_DATA
 CN_CNT=CN_CNT + 1
 IF LENGTH(CN_NM) > 16 THEN DO
  CN_NM=SUBSTR(CN_NM,1,16)
  SAY 'CONTAINER NAME LENGTH IS GT 16; TRUNCATE TO:'CN_NM':'
  END
 QN.CN_CNT=CN_NM
 QD.CN_CNT=CN_DATA
 END
QN.0=CN_CNT
SAY 'YOU ENTERED:'CN_CNT': REQUEST CONTAINERS'
SAY ''
SAY 'NOW ENTER RESPONSE CONTAINERS'
SAY 'NOTE: TO DEFAULT THE SET OF RESPONSE CONTAINER NAMES TO'
SAY '       THE SET OF REQUEST CONTAINER NAMES, ENTER SINGLE ""*""'
SAY '       AND THEN ADD MORE IF NEEDED'
SAY 'ALSO: IF YOU EXPECT YOUR CICS PROGRAM TO RETURN A CONTAINER'
SAY '       IN WHICH THE PROGRAM SPECIFIES THE CONTAINERS RETURNED'
SAY '       THEN YOU CAN SPECIFY @X..X WHERE X..X IS THE NAME OF'
SAY '       CONTAINER WHICH WILL HOLD THAT LIST.'
SAY '       UCEMPINR WILL RETURN A CONTAINER NAMED RETURN_CN_LIST'
SAY '        IN WHICH CASE YOU WOULD SPECIFY @RETURN_CN_LIST'
SAY '       AND THEN ADD MORE IF NEEDED'
SAY ''
SAY 'AGAIN: CAPS are Set to off for RESPONSE container names:'
SAY ' Enter a single value to choose lower or UPPER case CN names:'
SAY ' where < indicates lower case and > INDICATES UPPERCASE:'
T1 = '<'
T2 = '<'
ANS = ''
PULL ANS
IF ANS \= '' THEN DO
 TMP = ANS
 T1 = SUBSTR(ANS,1,1)
 IF T1 \= '>' THEN T1 = '<'
 END
SAY ''
SAY 'ENTERING LOOP TO COLLECT RESPONSE CONTAINERS CHANNEL:'RX_CNC_CH_NM
SAY ' FOR EACH PROMPT, ENTER A CONTAINERNAME OR '
SAY '  A * OR THE @X..X RESPONSE:'
GOT_ASK=0
GOT_AT=0
CN_CNT = 0
CN_PROMPT='ENTER FOR CN#:'
CN_NM='CONTINUE'
PN_LOOP:DO WHILE CN_NM \= ''
 SAY CN_PROMPT||CN_CNT + 1
 CN_NM=''
 PARSE PULL CN_NM
 CN_NM = STRIP(CN_NM,'B')
 IF CN_NM = '' THEN DO
  SAY 'YOU SIGNALED YOU ARE FINISHED ENTERING REQUEST CN DATA'
  LEAVE
  END
 IF T1 = '>' THEN UPPER CN_NM
 FC=SUBSTR(CN_NM,1,1)
 CN_CNT=CN_CNT + 1
 IF FC = '@' THEN DO
  IF GOT_AT \= 0 THEN DO
   SAY 'ERROR: ONLY A SINGLE @ REQUEST IS VALID'
   CN_CNT = CN_CNT - 1
   ITERATE
   END
  IF SUBSTR(CN_NM,2,1) = '*' THEN DO
   SAY 'ERROR: * CAN NOT BE TARGET OF @ REQUEST'
   CN_CNT = CN_CNT - 1
   ITERATE
   END
  GOT_AT=CN_CNT
  FP = 2
  END
  ELSE DO
  FP = 1
  END
 CN_NM = SUBSTR(CN_NM,FP)
 IF LENGTH(CN_NM) > 16 THEN DO
  CN_NM=SUBSTR(CN_NM,1,16)
  SAY 'CONTAINER NAME LENGTH IS GT 16; TRUNCATE TO:'CN_NM':'
  END
 IF SUBSTR(CN_NM,1,1) = '*' THEN DO
  IF GOT_ASK \= 0 THEN DO
   SAY 'ERROR: * REQUEST ALREADY PROCESSED'
   CN_CNT = CN_CNT - 1
   ITERATE
   END
   ELSE GOT_ASK = CN_CNT
  END
 PN.CN_CNT=CN_NM
 END
PN.0=CN_CNT
SAY 'YOU ENTERED:'CN_CNT': RESPONSE CONTAINERS'
SAY ''
NMP=''
NMS=''
DO I = 1 TO QN.0
 NMP=QN.I
 NMS = NMS||NMP||','
 TMP = QD.I
 INTERPRET NMP'="'TMP'"'
 END
RX_CNC_CN_REQ_LST=SUBSTR(NMS,1,LENGTH(NMS) - 1)
NMP=''
NMS=''
DO I = 1 TO PN.0
 NMP=PN.I
 IF I = GOT_AT THEN DO
  NMP='@'||NMP
  PN.I=NMP
  END
 NMS = NMS||NMP||','
 END
RX_CNC_CN_RSP_LST=SUBSTR(NMS,1,LENGTH(NMS) - 1)
SAY 'LET US REVIEW:'
SAY 'PROGRAM_NM SENT TO RXCNCLNK     :' PROGRAM_NM
SAY 'APPLID_NM SENT                 :' APPLID_NM
SAY 'TRANID_NM SENT                 :' TRANID_NM
SAY 'RX_CNC_CH_NM SENT                 :' RX_CNC_CH_NM
SAY 'RX_CNC_CN_REQ_LST                 :' RX_CNC_CN_REQ_LST
SAY 'RX_CNC_CN_REQ_LST ELEMENTS        :'
DO I = 1 TO QN.0
 SAY 'CN NAME:'QN.I
 SAY 'CN DATA:'QD.I
 SAY '---'
 END
SAY 'RX_CNC_CN_RSP_LST                 :' RX_CNC_CN_RSP_LST
SAY 'RX_CNC_CN_RSP_LST ELEMENTS        :'
DO I = 1 TO PN.0
 SAY 'CN NAME:'PN.I
 SAY '---'
 END
SAY 'Here we GO:'
SAY 'NOTE: THE COBOL PROGRAM IS EXPECTED TO RETURN THE FOLLOWING VARS:'
SAY 'RESP_CN_MESG - LOG OF COBOL ACTIONS'
SAY 'RESP_CN_LIST - LIST OF RETURNED VARS - WHICH ARE CICS CONTAINERS'
SAY 'LOOK FOR RESP_CN_MESG AND OPTIONALLY RESP_CN_LIST'
SAY ''
/* TRACE ?I */
/*    CALL COBOL PROGRAM   */
ADDRESS TSO
/*ALLOC FI(SYSOUT) DA(*) SHR REUSE' */
/* "CALL 'TTED.TSK.P.TCEM.LOADLIB(EXPLPGM3)' 'TVAR1,TVAR2'" */
/* CALL DOES NOT INITIALIZE THE ENVIRONMENT BLOCK */
/*"CALL 'TTEP.TSK.E.TCEM.PDSE(RXVARS)' 'TVAR1,TVAR2'" */
"CALL 'TTEP.TSK.E.TCEM.PDSE(RXCNCLNK)' 'PROGRAM_NM,"||,
  "APPLID_NM,RX_CNC_CH_NM,RX_CNC_CN_REQ_LST,RX_CNC_CN_RSP_LST,"||,
  "TRANID_NM'"
/* SHOW VARS */
IF RC > 4 THEN DO
   SAY 'NON ZERO RETURN CODE' RC
   SAY 'MSGOUT_ERR(?):' MSGOUT_ERR
   RETURN 12
   END
SAY 'RETURN FROM RXCNCLNK'
SAY ''
SAY 'MSGOUT ERROR MESSAGE (IF ANY)'
SAY MSGOUT_ERR
SAY
SAY
SAY 'REXX VARIABLES SENT:'
SAY 'PROGRAM_NM SENT TO COBOL PROGRAM:' PROGRAM_NM
SAY 'APPLID_NM SENT                 :' APPLID_NM
SAY 'RX_CNC_CH_NM SENT                 :' RX_CNC_CH_NM
SAY 'TRANID_NM SENT                 :' TRANID_NM
SAY 'RX_CNC_CN_REQ_LST                 :' RX_CNC_CN_REQ_LST
SAY 'RX_CNC_CN_RSP_LST                 :' RX_CNC_CN_RSP_LST
SAY ''
DO_TEST:
TRACE ?I
SAY 'EXPECTED REXX RETURN VARIABLES: RESP_CN_MESG AND RESP_CN_LIST'
TMP_NM = 'RESP_CN_MESG'
TMP_CN_MSG = RESP_CN_MESG
SAY 'DISPLAY 'TMP_NM' CONTENTS?'
  SAY 'ENTER Y TO DISPLAY DATA OR ANY OTHER KEY TO BYPASS:'
  PULL ANS
  IF ANS = 'Y' THEN CALL SHOWRXDATA
  SAY ''
TMP_NM = 'RESP_CN_LIST'
TMP_CN_MSG = RESP_CN_LIST
SAY 'DISPLAY 'TMP_NM' CONTENTS?'
  SAY 'ENTER Y TO DISPLAY DATA OR ANY OTHER KEY TO BYPASS:'
  PULL ANS
  IF ANS = 'Y' THEN CALL SHOWRXDATA
  SAY ''
AK = 0
AK = POS('*',RX_CNC_CN_RSP_LST)
IF AK > 0 THEN DO
   SAY 'RX_CNC_CN_RSP_LS INCLUDED A WILD CARD * '
   SAY ' SUBSTITUTE * WITH THE SUPPLIED RX_CNC_CN_REQ_LST'
   IF AK > 2 THEN TMPRSP1=SUBSTR(RX_CNC_CN_RSP_LST,1,AK - 1)
   ELSE TMPRSP1=''
   TMPRSP=SUBSTR(RX_CNC_CN_RSP_LST,AK + 1)
   NP = POS(',',TMPRSP)
   TMPRSP2=''
   IF NP > 0 THEN TMPRSP2= SUBSTR(TMPRSP,NP)
   TMPRSP3 = RX_CNC_CN_REQ_LST
   RX_CNC_CN_RSP_LST=TMPRSP1||TMPRSP3||TMPRSP2
   SAY RX_CNC_CN_RSP_LST
   SAY ''
   END
/*     POSSIBLE SCENERIOS                       *\
|*   @A                                         *|
|*   A,@B                                       *|
|*   A,@B,C                                     *|
|*   @                                          *|
|*   A,@                                        *|
|*   A,@,B                                      *|
\*                                              */
AP = 0
AP = POS('@',RX_CNC_CN_RSP_LST)
IF AP > 0 THEN DO
   TMPRSP0 = RX_CNC_CN_RSP_LST||' '
   IF AP > 1 THEN TMPRSP1=SUBSTR(RX_CNC_CN_RSP_LST,1,AP - 1)
   ELSE TMPRSP1=''
   TMPRSP=STRIP(SUBSTR(TMPRSP0,AP + 1),'T')
   LP = LENGTH(TMPRSP)
   IF LP < 1 THEN DO
    SAY  'ERRROR: INVALID CN NAME FOLLOWS >@< WILDCARD. BYPASS.'
    RX_CNC_CN_RSP_LST=TMPRSP1
    SIGNAL GOT_RSP_DATA
    END
   NP = POS(',',TMPRSP)
   TMPRSP2=''
   IF NP = 0 THEN NP = LP + 1
     ELSE TMPRSP2=SUBSTR(TMPRSP,NP)
   TMPRSP = SUBSTR(TMPRSP,1,NP - 1)
   LP = LENGTH(TMPRSP)
   IF LP < 2 then do
    SAY  'ERRROR: INVALID CN NAME FOLLOWS >@< WILDCARD. BYPASS.'
    RX_CNC_CN_RSP_LST=TMPRSP1||STRIP(TMPRSP2,'L',',')
    SIGNAL GOT_RSP_DATA
    END
   INTERPRET 'TMPRSP3='TMPRSP
   IF PROGRAM_NM = 'UCEMPINR' & TMPRSP = 'RETURN_CN_LIST' THEN DO
    OP = '('
    RSP_SYSID=''
    TMPRSP4=''
    PARSE VAR TMPRSP3 RSP_SYSID (OP) TMPRSP4
    IF TMPRSP4 \= '' THEN DO
     TMPRSP3=TMPRSP4
     SAY 'FOUND SYSID PREFIX:' RSP_SYSID
     SAY '  AND FOLLOWING RESPONSE CN LIST:'
     SAY TMPRSP3
     END
    END
   SAY 'RX_CNC_CN_RSP_LS INCLUDED A WILD CARD @ '
   SAY ' WE ARE GOING TO USE THE IDENTIFIED CN LIST' TMPRSP3
   RX_CNC_CN_RSP_LST=TMPRSP1||TMPRSP3||TMPRSP2
 END
GOT_RSP_DATA:
SAY 'RX_CNC_CN_RSP_LST CN LIST:'
SAY RX_CNC_CN_RSP_LST
SAY 'RX_CNC_CN_RSP_LST RESPONSE ELEMENTS        :'
 A1 = TRANSLATE(RX_CNC_CN_RSP_LST,' ',',')
 DO WHILE (A1 \= '')
  PARSE VAR A1 A2 A1
  INTERPRET "C1  = '"A2"'"
  ML = LENGTH(C1)
  SAY 'ELEMENT:'||LEFT(A2,16)||': HAS LENGTH:' ML
  TMP_NM = A2
  TMP_CN_MSG = C1
  SAY 'ENTER Y TO DISPLAY DATA OR ANY OTHER KEY TO BYPASS:'
  PULL ANS
  IF ANS = 'Y' THEN CALL SHOWRXDATA
  SAY ''
  END
SAY ''
ANS = 'FIRST'
DO WHILE ANS \= ''
 SAY 'ENTER A REXX VAR TO INTERPRET:'
 PULL ANS
 IF ANS = '' THEN LEAVE
 TMP_NM = ANS
 INTERPRET 'TMP_CN_MSG = 'ANS
 SAY TMP_CN_MSG
/* CALL SHOWRXDATA */
 END
SAY ''
SAY 'FINISHED TRXCNCLK! BYE'
EXIT
/* SUB ROUTINE TO DISPLAY RETURNED DATA */
SHOWRXDATA: PROCEDURE EXPOSE TMP_NM TMP_CN_MSG
MSG_LF_DLM='15'X
CPY_#=COPIES('-',60)
RSPCT = 0
DO WHILE TMP_CN_MSG \= ''
 PARSE VAR TMP_CN_MSG TMP (MSG_LF_DLM) TMP_CN_MSG
 IF TMP \= '' THEN DO
  RSPCT = RSPCT + 1
  RSP.RSPCT = TMP
  END
 END
SAY 'FOUND<' RSPCT '> LINES IN RESP_CN_MSG'
M0 = 1
ANS = '>'
DO WHILE ((POS(ANS,'<=>')) \= 0)
 CURLN = M0
 MXLN = RSPCT - CURLN
 IF MXLN > 60 THEN MXLN = CURLN + 60
  ELSE MXLN = CURLN + MXLN
 DO I = CURLN TO MXLN
   SAY RSP.I
   SAY CPY_#
   END
  SAY 'LAST DISPLAY: LINE:' CURLN ' THRU:' MXLN ' OF:' RSPCT
  SAY 'ENTER > TO CONTINUE FORWARD'
  SAY '      = TO RE DISPLAY CURRRENT SET'
  SAY '      < TO CONTINUE FORWARD'
  SAY ' OR ANY OTHER KEY STOP THIS MESSAGE DISPLAY'
  PULL ANS
  SELECT
   WHEN ANS = '>' THEN DO
                  M0 = CURLN + MXLN
                  IF M0 >= RSPCT THEN M0 = (RSPCT - MXLN) + 1
                  END
   WHEN ANS = '=' THEN M0 = CURLN
   WHEN ANS = '<' THEN DO
                  M0 = CURLN - MXLN
                  IF M0 <= 0 THEN M0 = 1
                  END
   OTHERWISE SAY 'SELECTED TO LEAVE:' ANS ':'
   END
 END
 RETURN
GET_COMMAREA:
 COMMAREA = 'CEMT INQUIRE TASK'
 COMMAREA.L = 4096
 'ISPEXEC SELECT CMD(TSTAFOCN)'
 IF RC \= 0 THEN RETURN 8
 SAY STRIP(COMMAREA,'T')
 SAY COMMAREA.L
 RETURN 0
OLD_COMMAREA:
 SAY 'COMMAREA SELECTED:'
GET_COMMAREA0:
 COMMAREA=''
 Y_N='N'
 SAY ' NOW PROVIDE THE DATA VALUE FOR THE COMMAREA (caps are off):'
 PARSE PULL COMMAREA
 COMMAREA.L = LENGTH(COMMAREA)
 IF COMMAREA = '' THEN
  SAY '!!!COMMAREA IS EMPTY.'
  ELSE
  SAY 'REQUESTED COMMAREA IS LENGTH:'COMMAREA.L
 SAY 'IS THIS WHAT YOU WANT(Y/N or CANCEL)?'
 PULL Y_N
 IF Y_N = 'Y' THEN SIGNAL GET_COMMAREA_L
 IF Y_N = 'CANCEL' THEN RETURN 8
 SAY '... OK RETRY YOUR COMMAREA...'
 SIGNAL GET_COMMAREA0
GET_COMMAREA_L:
 CAL = ''
 SAY 'OVERRIDE THE COMMAREA LENGTH:'COMMAREA.L': OR'
 SAY ' JUST PRESS ENTER TO ACCEPT LENGTH OR'
 SAY 'ENTER CANCEL TO ABORT:'
 PULL CAL
 IF  CAL = '' THEN RETURN 0
 IF CAL = 'CANCEL' THEN DO
  SAY 'ABORTING THIS REQUEST'
  RETURN 8
  END
 IF DATATYPE(CAL,'W') = 1 THEN
  IF CAL < 0 THEN DO
    CAL = 0
    SAY 'COMMAREA LENGTH CANNOT BE LT ZERO. SET TO ZERO.'
    END
   ELSE IF CAL > 32000 THEN DO
    CAL = 32000
    SAY 'COMMAREA LENGTH CANNOT BE GT 32000. SET TO 32000'
    END
   COMMAREA.L = CAL
   SAY 'COMMAREA.L STEM IS SET TO:'COMMAREA.L
   RETURN 0
   END
  SAY 'YOUR COMMAREA LENGTH ENTRY:'CAL': IS NOT VALID 0 - 32000. RETRY'
  SIGNAL GET_COMMAREA_L
 GET_COMMAREA_L_XIT:
  RETURN 16
###END TRXCNCL1
$$$BEG GETAFOCN
/* REXX */
/*  trace ?i */
/* for testing only */
 cncchnm='AFO_CH_NAME'
 cnto='CEMT0001'
 cnty='CHAR'
 LR1LNG='30'
 cnstrip='Y'
/* for testing only */
parse arg cncchnm cnto cnty lr1lng lr1
ADDRESS 'ISPEXEC'
mysc = 'PAGE'
execsel='TSTAFOCN'
canstr='ABORT,CANCEL'
cmdstr='END,COPY,CDSN,BDSN,RESET,'||CANSTR
cntystr='CHAR,BIT,CDSN,BDSN'
 h_cnto=cnto
 h_cnty=cnty
 h_LR1LNG=LR1LNG
 h_cnstrip=cnstrip
xc = 0
acmd = ''
"ADDPOP"
topoflop:
 zcmd = ''
 execsel='TSTAFOCN'
 "DISPLAY PANEL(GETAFOCN)"
 xc = rc
 acmd = zcmd
 if xc = 8 then signal donit
 if acmd = 'CANCEL' then signal canit
 if acmd = 'RESET' then do
  call doreset
  signal topoflop
  end
 if acmd = 'COPY' then do
  call docopy
  signal topoflop
  end
 if acmd = 'CDSN' | acmd = 'BDSN' then do
  if substr(cnty,1,1) \= substr(acmd,1,1) then do
   cmcmsg = acmd':failed:cn type:'cnty':'acmd
   signal topoflop
   end
  call docopy
  if rc \= 0 then do
   cmcmsg = acmd':failed:gdsn'
   signal topoflop
   end
  LR1 = '<'||EDSN||'>'
  cnty=acmd
  signal topoflop
  end
 cncmsg='ENTER more CONTAINER DATA'
 signal topoflop
donit:
 say 'donit!'
 SAY 'CN:'||CNTO
 SAY 'CN Strip Trailing Spaces:'cnstrip
 if cnstrip = 'Y' then lr1 = strip(lr1,'T')
 SAY 'CN Data:'
 SAY LR1
 SAY 'LENGTH:'||LENGTH(LR1)||':'
 cnty=substr(cnty,1,1)||LENGTH(LR1)
 SAY 'CN TYPE:'
 SAY cnty
canit:
"REMPOP"
return xc
/* sub routines */
 docopy:
  edsn = 'src.for.cn.dsn'
  embr = 'src_mbr'
  dsemsg = 'Enter DSN (opt MBR) for CN data'
  "ISPEXEC VPUT (EDSN EMBR DSEMSG EXECSEL) ASIS"
  IF RC > 0 THEN DO
   cmcmsg = 'COPY failed to get CN data(vput)'
   signal donecopy
   end
  call gdsnnmbr
  if rc > 4 then do
   cmcmsg = 'COPY failed to get CN data(gdsn)'
   signal donecopy
   end
  "ISPEXEC Vget (EDSN EMBR) ASIS"
  IF RC > 0 THEN DO
   cmcmsg = 'COPY failed to get CN data(vget_gdsn)'
   signal donecopy
   end
  if EDSN = '' THEN DO
   cmcmsg = 'COPY failed to get CN data(vget_EDSN)'
   signal donecopy
   end
  if EMBR \= '' THEN DO
   EDSN = EDSN||'('||EMBR||')'
   "ISPEXEC VPUT (EDSN) ASIS"
   IF RC > 0 THEN DO
    cmcmsg = 'COPY failed to get CN DSN (VPUT)'
    signal donecopy
    end
   end
  if mcmd \= 'COPY' then return xc
  tgtdata = ''
  CALL CPDS2VAR "<EDSN> <TGTDATA>"
  if rc = 0 then do
   "ISPEXEC VGET (TGTDATA) ASIS"
   IF RC > 0 THEN DO
    cmcmsg = 'COPY failed to get CN data(VGET)'
    signal donecopy
    end
   LR1 = TGTDATA
   lr1lng = length(TGTDATA)
 donecopy:
  xc = rc
  return xc

doreset:
 cncmsg='(reset)ENTER DATA FOR CONTAINER'
 cnto=h_cnto
 cnty=h_cnty
 LR1LNG=h_LR1LNG
 cnstrip=h_cnstrip
 CN_CMD=SUBSTR(CNTO,1,4)
 SELECT
 WHEN CN_CMD = 'CEMT' THEN LR1 = 'CEMT INQUIRE SYSTEM'
 WHEN CN_CMD = 'CEDA' THEN LR1 = 'CEDA EXPAND GROUP(XXXXXXXX)'
 WHEN CN_CMD = 'PING' THEN LR1 = 'PINGThis is a PING test'
 OTHERWISE LR1 = 'ENTER CN DATA'
 END
 return
###END GETAFOCN
$$$BEG TSTRXVLS
  /* REXX */
  /* THIS PROGRAM TESTS TTED.TSK.D.TCEM.ASM(RXVARSLS) */
  /* TRACE ?I */
  ADDRESS ISPEXEC
  'ISPEXEC CONTROL ERRORS RETURN'
  MYDSN='TTEP.TSK.E.TCEM.PDSE'
 TRYAGN:
  IDVAL=''
  'ISPEXEC QLIBDEF 'ISPLLIB' ID(IDVAL)'
  IF IDVAL \= '' THEN DO
   XDSN=TRANSLATE(IDVAL,"  ",",'")
   IF WORDPOS(MYDSN,XDSN) \= 0 THEN SIGNAL GOTMYDSN
   CALL EXPLLDEF 'ISPLLIB' mydsn 'STACK'
   SIGNAL TRYAGN
   END
  IF IDVAL = '' THEN DO
   STKLIBS=MYDSN||',TTED.TSK.G.R540.SYS.EXCILIB,'||,
           'TTED.TSK.F.R540.LOADLIB'
   CALL EXPLLDEF 'ISPLLIB' STKLIBS 'STACK'
   XC = RC
   END
 GOTMYDSN:
  SAY 'STARTING...'
  aaa='abc'
  BBB='def g'
  ccc.1='hij    '
  This_is_valid_cn='CEMT INQUIRE CONNECTION(CGE5)'
  rxlst='aaa,bbb,ccc.1,This_is_valid_cn'
/*  SAVE WORDS IN LIST IN H_ VARS */
  H_RXLST = TRANSLATE(RXLST,' ',',')
  WDS_CT=WORDS(H_RXLST)
  DO I = 1 TO WDS_CT
   TMP=WORD(H_RXLST,I)
   INTERPRET 'TMP_VAL = 'TMP
   INTERPRET 'H_'||TMP||' = TMP_VAL'
   SAY TMP '>'||TMP_VAL||'< LNG:'||LENGTH(TMP_VAL)
   END
  UPPER RXLST
  trace ?i
/* "ISPEXEC SELECT PGM(RXVARSLS) NEWAPPL(AFO) PASSLIB parm('rxlst')" */
/* link, linkmvs, and linkpgm limited to a single rx var              */
/* address link "RXVARSLS RXLST"    */  /* no var expansion - r1 addr */
     /* ptr1 points to another ptr: which points to the parm val      */
     /* ptr2 points to another ptr: which contains the var lng        */
/* 000A5CB0                                                           *\
 000000 => 000A5CB8 800A5CBC  000A5CC0 00000005 = ..*...*...*{....
 000010 => D9E7D3E2 E3000000  00000000 00000000 = RXLST...........
\*                                                                    */
   address link "RXVARSCB RXLST"        /* no var expansion - cobol   */
                                        /*  USING PARM-IN             */
/*  mem PARM-IN  ptr to the var data followed by var data length      *\
000A5CB8
 00000000 => 000A5CC0 00000005  D9E7D3E2 E3000000 = ..*{....RXLST...
 00000010 => 00000000 00000000  000A              = ..........
\*                                                                    */
/* address linkmvs "REXXCOBV RXLST" */  /* expand var to os linkage */
/* mem PARM-IN   looks like jcl parm linkage (rx var is expanded)     *\
 000134004
 0000000 => 000DC1C1 C16BC2C2  C26BC3C3 C34BF100 = ..AAA,BBB,CCC.1.
 0000010 => 00000000 00000000  0000              = ..........
\*                                                                    */
/* address linkpgm "REXXCOBV RXLST" */  /* expand var to direct lkage*/
/* mem PARM-IN    no llll, but rx expanded parm data                  *\
 001340064
 000000 => C1C1C16B C2C2C26B  C3C3C34B F1000000 = AAA,BBB,CCC.1....
 000010 => 00000000 00000000  0000              = ..........
\*                                                                    */
/*  CALL RXVARSLS 'RXLST'     */      /* no var expansion             */
/* 14D0C4B8       passes in the rx envb in r0 and efpl in r1          *\
 000000 => 00000000 00000000  00000000 00000000 = ................
 000010 => 14E5F5D8 14BB6C7C  00000000 00000000 = .V5Q..%@........
 000020 => D9E7E5C1 D9E2D3E2  D9E7E5C1 D9E2D3E2 = RXVARSLSRXVARSLS
 14E5F5D8
 000000 => 14E5F4D0 00000005  FFFFFFFF FFFFFFFF = .V4}............
 14E5F4D0
 000000 => D9E7D3E2 E3406E88  89914040 40404C40 = RXLST >hij    <
\*                                                                    */
/* note attempt to call below with cee3pr2 returns nothing (excobdly) */
/*  CALL REXXCOBV 'RXLST'           */  /* nothing is passed to cobol*/
/*                                  */  /* blows up the test s0c1     */
  XC = RC
  call proc_queue
  return 0
 proc_queue:
  myqd=queued()
  SAY 'NUMBER OF items found on stack:' myqd
  do i = 1 to myqd
   pull x
   say x
   end
  DO I = 1 TO WDS_CT
   TMP=WORD(H_RXLST,I)
   INTERPRET 'TMP_VAL = 'TMP
   SAY TMP '>'||TMP_VAL||'< LNG:'||LENGTH(TMP_VAL)
   INTERPRET 'TMP_VAL = H_'||TMP
   SAY 'H_'||TMP '>'||TMP_VAL||'< LNG:'||LENGTH(TMP_VAL)
   END
   return
###END TSTRXVLS
$$$BEG REXXTCOB
/*  REXX   */
/*TRACE ?I */
  ADDRESS ISPEXEC
  'ISPEXEC CONTROL ERRORS RETURN'
  MYDSN='TTEP.TSK.E.TCEM.PDSE'
 TRYAGN:
  IDVAL=''
  'ISPEXEC QLIBDEF 'ISPLLIB' ID(IDVAL)'
  IF IDVAL \= '' THEN DO
   XDSN=TRANSLATE(IDVAL,"  ",",'")
   IF WORDPOS(MYDSN,XDSN) \= 0 THEN SIGNAL GOTMYDSN
   CALL EXPLLDEF 'ISPLLIB' MYDSN 'STACK'
   SIGNAL TRYAGN
   END
  IF IDVAL = '' THEN DO
   STKLIBS=MYDSN||',TTED.TSK.G.R540.SYS.EXCILIB,'||,
           'TTED.TSK.F.R540.LOADLIB'
   STKLIBS=MYDSN
   CALL EXPLLDEF 'ISPLLIB' STKLIBS 'STACK'
   XC = RC
   END
GOTMYDSN:
TVAR1='1234'
HVAR1=TVAR1
TVAR2='QRST'
HVAR2=TVAR2
TVAR.1='TVAR DOT 1 STEM'
HVAR3=TVAR.1
TVAR.2='5678'
HVAR4=TVAR.2
SAY 'HVAR1:' HVAR1 ' TVAR1:' TVAR1
SAY 'HVAR2:' HVAR2 ' TVAR2:' TVAR2
SAY 'HVAR3:' HVAR3 ' TVAR.1:' TVAR.1
SAY 'HVAR4:' HVAR4 ' TVAR.2:' TVAR.2
/*
L = 3
TVAR.L='LAST TVAR STEM'
SAY 'TVAR.L:' TVAR.L
SAY 'TVAR.3:' TVAR.3
INTERPRET 'SAY TVAR.'L   */
SAY 'TVAR1 VALUE SENT TO COBOL PROGRAM IS:' TVAR1
SAY 'TVAR2 VALUE SENT TO COBOL PROGRAM IS:' TVAR2
TRACE ?I
/*    CALL COBOL PROGRAM   */
ADDRESS TSO
/* 'ALLOC FI(SYSOUT) DA(*) SHR REUSE' */
/* "CALL 'TTED.TSK.P.TCEM.LOADLIB(EXPLPGM3)' 'TVAR1,TVAR2'" */
/*CALL SHOWVARS */
/* CALL DOES NOT INITIALIZE THE ENVIRONMENT BLOCK */
/*"CALL 'TTEP.TSK.E.TCEM.PDSE(RXVARS)' 'TVAR1,TVAR2'" */
ADDRESS TSO
SAY 'ISSUE "CALL &QUOTE& LIB(TESTREXC)&QUOTE& &QUOTE&PARMS&QUOTE&"'
/* "CALL 'TTEP.TSK.E.TCEM.PDSE(TESTREXC)' 'TVAR1,TVAR2,ABCDEFGH1234'"*/
/* WHEN YOU INVOKE A REXX EXEC USING EITHER THE CALL INSTRUCTION OR *\
|* A REXX FUNCTION CALL, YOU CAN PASS UP TO 20 ARGUMENTS TO AN EXEC.*|
\* EACH ARGUMENT MUST BE SEPARATED BY A COMMA.                      */
ADDRESS TSO
SAY 'TEST WITH OS (JCL) PARM FORMAT'
SAY 'ISSUE TTEP.TSK.E.TCEM.PDSE(TESTRXOS) &QUOTE&PARMS&QUOTE&'
 "CALL 'TTEP.TSK.E.TCEM.PDSE(TESTRXOS)' 'TVAR1,TVAR2,ABCDEFGH1234'"
CALL SHOWVARS
CALL RESETVARS
SAY 'TEST WITH OS (JCL) PARM FORMAT'
SAY 'ISSUE SELECT PGM(TESTRXOS) PARM(PARMS)'
ADDRESS ISPEXEC "SELECT PGM(TESTRXOS) PARM(TVAR1,TVAR2,ABCDEFGH1234)"
IF RC <> 0 THEN SAY 'NON ZERO RETURN CODE' RC
CALL SHOWVARS
CALL RESETVARS
SAY 'TEST WITH RX LINK PARM FORMAT SINGLE PARM'
SAY 'ISSUE ADDRESS LINK &QUOTE&TESTRXLK PARM&QUOTE&'
ADDRESS LINK 'TESTRXLK TVAR1'
IF RC <> 0 THEN SAY 'NON ZERO RETURN CODE' RC
CALL SHOWVARS
CALL RESETVARS
SAY 'TEST WITH RX FUNCTION PARM FORMAT SINGLE PARM'
SAY 'ISSUE RXVARS_RESULT = RXVARS(PARMS,PARMS)'
RXVARS_RESULT = RXVARS('TVAR1','TVAR.1','TVAR.L','TVAR.2')
'FREE FI(SYSOUT)'
IF RC <> 0 THEN SAY 'NON ZERO RETURN CODE' RC
CALL SHOWVARS
EXIT
/*  */
RESETVARS:
TRACE OFF
TVAR1=HVAR1
TVAR2=HVAR2
TVAR.1=HVAR3
TVAR.2=HVAR4
RETURN
/*  */
SHOWVARS:
TRACE OFF
SAY 'SET VALUES: AND RETURNED VALUES:'
SAY 'HVAR1:' HVAR1 ' TVAR1:' TVAR1
SAY 'HVAR2:' HVAR2 ' TVAR2:' TVAR2
SAY 'HVAR3:' HVAR3 ' TVAR.1:' TVAR.1
SAY 'HVAR4:' HVAR4 ' TVAR.2:' TVAR.2
SAY
RETURN
###END REXXTCOB
$$$BEG EXPLALTB
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA          -                                              */
 /* CEMHELP          - TSO BASE, RESTRICTED                         */
 /* CEMHELP          -                                              */
 /* CEMHELP END                                                     */
 ADDRESS TSO
 TRACE ?I
 CALL TSTALTLB   /* NOTE THE IS NOT ESTABLISHED */
 "%TSTALTLB"     /* USUAL SYSEXEC OR SYSPROC */
 "ALTLIB DISPLAY"
 A = 'TTED.TSK.P.TCEM'
 "ALLOC FI(SYSUPROC) "||,
   "DA('"A".IPCSCLST') SHR REUSE"
 "ALTLIB ACTIVATE USER(CLIST)"
 "ALTLIB DISPLAY"
 CALL TSTALTLB   /* NOTE THE ALTLIB IS IGNORED */
 "%TSTALTLB"     /* USE ALTLIB SYSUPROC      */
 "ALTLIB RESET"
 "ALTLIB DISPLAY"
 "%TSTALTLB"     /* USUAL SYSEXEC OR SYSPROC */
###END EXPLALTB
$$$BEG EXRTNVAL
/* rexx */
/* demonstrate the call and return functions */
  i = 0
  j = 10
  k = 'abc'
  l = 'def'
  m = 'a btoo'
  trace ?i
  x = intrtn3(i j l m)
  say x
  say h
  say i j k l m ans ans2
  x = intrtn2(i j l m)
  say x
  say i j k l m ans ans2
  call intrtn i j l m
  say i j k l m ans ans2
  call intrtn2 i j l m
  say i j k l m ans ans2
  exit
 intrtn:procedure
  say i j k l m
  ans = k||l
  ans2 = ans||m
  return ans ans2
 intrtn2:procedure expose ans ans2
  say i j k l m
  ans = k||l
  ans2 = ans||m
  return ans ans2
 intrtn3:procedure expose ans ans2
  q=arg()
  do i = 1 to q
   say arg(i)
   end
  parse arg h i j k l m
  say i j k l m
  ans = k||l
  ans2 = ans||m
  return ans ans2
###END EXRTNVAL
$$$BEG TSTSELCT
/* REXX */
   ADDRESS ISPEXEC
   'ISPEXEC CONTROL ERRORS RETURN'
   MYDSN='TTEP.TSK.E.TCEM.PDSE'
   MYPNL='TTED.TSK.D.TCEM.ISPPLIB'
  TRYAGN:
   IDVAL=''
   'ISPEXEC QLIBDEF 'ISPLLIB' ID(IDVAL)'
   IF IDVAL \= '' THEN DO
    XDSN=TRANSLATE(IDVAL,"  ",",'")
    IF WORDPOS(MYDSN,XDSN) \= 0 THEN SIGNAL TRYPNL
    "ISPEXEC LIBDEF ISPLLIB UNSTACK"
    SIGNAL TRYAGN
    END
   IF IDVAL = '' THEN DO
    STKLIBS=MYDSN||',TTED.TSK.G.R540.SYS.EXCILIB,'||,
            'TTED.TSK.F.R540.LOADLIB'
    CALL EXPLLDEF 'ISPLLIB' STKLIBS 'STACK'
    XC = RC
    END
  TRYPNL:
   IDVAL=''
   'ISPEXEC QLIBDEF 'ISPPLIB' ID(IDVAL)'
   IF IDVAL \= '' THEN DO
    XDSN=TRANSLATE(IDVAL,"  ",",'")
    IF WORDPOS(MYPNL,XDSN) \= 0 THEN SIGNAL GOTMYDSN
    "ISPEXEC LIBDEF ISPPLIB UNSTACK"
    SIGNAL TRYPNL
    END
   IF IDVAL = '' THEN DO
    STKLIBS=MYPNL
    CALL EXPLLDEF 'ISPPLIB' STKLIBS 'STACK'
    XC = RC
    END
  GOTMYDSN:
   SAY 'STARTING...'
   DION = 'SOMETEST'
   RXID = 'NOID'
   RXID = 'DION'
   RXNAME = '----'
   SAY 'RXID='RXID
   INTERPRET "SAY 'RXID (INTERPRETED)='"RXID
   TRACE ?I
   SAY 'ISSUE CALL TO TSTSELC0: SEE IF RX VARS DION RXID RXNAME EXIST'
   CALL TSTSELC0      /* THIS DOES NOT PASS RX VARS */
   SAY 'ISSUE SELECT TO TSTSELC0: SEE IF RX VARS DION RXID RXNAME EXIST'
   "ISPEXEC SELECT PANEL(TSTSELCT)"  /*THIS DOES NOT PASS RX VARS */
   "ISPEXEC DISPLAY PANEL(TSTSELCT)"
   SAY 'RXID='RXID
   INTERPRET "SAY 'RXID (INTERPRETED)='"RXID
   SAY 'DION:'DION
   SAY 'RXNAME:'RXNAME
   EXIT
   'ISPEXEC VPUT (RXID RXNAME) ASIS'
   XC = RC
   "ISPEXEC SELECT PGM(EXPLVGET) NEWAPPL(AFO) PASSLIB"
   XC = RC
   'ISPEXEC VGET (RXID RXNAME) ASIS'
   XC = RC
   SAY '>'||RXID||'<'
   SAY '>'||RXNAME||'<'
###END TSTSELCT
$$$BEG TSTSELC0
/* REXX */
  TRACE ?I
  SAY '...IN TSTSELC0...'
  SAY 'DION?>'DION'<'
  SAY 'RXID?>'RXID'<'
  SAY 'RXNAME?>'RXNAME'<'
  RETURN 0
###END TSTSELC0
$$$BEG SEYUTSLB
PROC 1 KIXREL KIXCTYP(D) KIXENV(SYS)
CONTROL NOCONLIST NOSYMLIST
IF &KIXREL = ? THEN GOTO SHOWMSG
IF &LENGTH(&KIXREL) LT 3 THEN GOTO BADPARM
IF &LENGTH(&KIXREL) GT 3 THEN GOTO BADPARM
IF (&KIXCTYP NE D) AND +
   (&KIXCTYP NE T) AND +
   (&KIXCTYP NE P) THEN GOTO BADPARM
IF (&KIXENV NE SYS) AND +
   (&KIXENV NE PUT) THEN GOTO BADPARM
IF &SUBSTR(1:1,&KIXREL) EQ R THEN GOTO BADPARM
RETRYIT: -
SET &EDSN1='TTE&KIXCTYP..TSK.G.R&KIXREL..&KIXENV..SEYUAUTH'
LISTDSI &EDSN1 NORECALL
DO WHILE &LASTCC > 3
 IF &KIXCTYP = D THEN GOTO BADPARM
 SET &KIXCTYP = D
 GOTO RETRYIT
 END
TSOLIB ACTIVATE DATASET(&EDSN1)
TSOLIB DISPLAY
EXIT
BADPARM: -
WRITE INVALID PARM:
WRITE CICS 3 DIGIT RELEASE: &KIXREL
WRITE KIXCTYP : &KIXCTYP
WRITE KIXENV  : &KIXENV
WRITE OR THE LIBRARY &EDSN1 DOES NOT EXIST
WRITE OR THE LIBRARY &EDSN2 DOES NOT EXIST
SHOWMSG: -
WRITE PROVIDE A 3 DIGIT CICS RELEASE NUMBER (520, 540, ...)
WRITE AND SPECIFY AN OVERRIDE VARIABLE
WRITE     KIXCTYP(D)
WRITE OR  KIXCTYP(T)
WRITE OR  KIXCTYP(P)
WRITE     KIXENV(SYS)
WRITE OR  KIXENV(PUT)
EXIT
###END SEYUTSLB
$$$BEG TSTCBLVG
  /* REXX */
  TRACE ?I
  ADDRESS ISPEXEC
  'ISPEXEC CONTROL ERRORS RETURN'
  MYDSN='TTEP.TSK.E.TCEM.PDSE'
 TRYAGN:
  IDVAL=''
  'ISPEXEC QLIBDEF 'ISPLLIB' ID(IDVAL)'
  IF IDVAL \= '' THEN DO
   XDSN=TRANSLATE(IDVAL,"  ",",'")
   IF WORDPOS(MYDSN,XDSN) \= 0 THEN SIGNAL GOTMYDSN
   "ISPEXEC LIBDEF ISPLLIB UNSTACK"
   SIGNAL TRYAGN
   END
  IF IDVAL = '' THEN DO
   STKLIBS=MYDSN||',TTED.TSK.G.R540.SYS.EXCILIB,'||,
           'TTED.TSK.F.R540.LOADLIB'
   CALL EXPLLDEF 'ISPLLIB' STKLIBS 'STACK'
   XC = RC
   END
 GOTMYDSN:
  SAY 'STARTING...'
  RXID = 'NOID'
  rxid = 'dion'
  RXNAME = '----'
  interpret 'say 'RXID
  'ISPEXEC VPUT (rxid RXNAME) ASIS'
  XC = RC
  "ISPEXEC SELECT PGM(EXPLVGET) NEWAPPL(AFO) PASSLIB"
  XC = RC
  'ISPEXEC VGET (rxid RXNAME) ASIS'
  XC = RC
  SAY '>'||RXID||'<'
  SAY '>'||RXNAME||'<'
###END TSTCBLVG
$$$BEG TSTENUMV
 /* REXX */
 /* TEST THE ENUMRXVR PROGRAM */
 ADDRESS TSO
 /* TRACE I */
 SAY 'CAPTURE ELEMENT NAMES FOR STEM VARS TST.___'
 SAY ' AT PROMPT, PROVIDE THE STEM SUFFIX'
 SAY ' TO END, ENTER NOTHING AT THE PROMPT'
 SAY 'CALL PROGRAM ENUMRXVR TO ENUMERATE VARS'
 SAY ' PLACING THE VAR NAME ON THE RX QUEUE'
 SAY 'PROVIDE THE STEM VAR PREFIX'
 STMPFX = ''
 PULL STMPFX
 IF STMPFX = '' THEN DO
  SAY 'FAILED TO PROVIDE THE STEM VAR PREFIX VALUE'
  SAY 'GOOD BYE'
  EXIT
  END
 SFXLST = ''
 AAA = 'AAA VAR'
 AAB = 'AAB VAR'
 AAC = 'AAC VAR'
 AAD.Z = 'AAD.Z VAR'
 AAD.Y = 'AAD.Y VAR'
TOPOFLOP:
 ANS = ''
 SAY 'PROVIDE NEXT STEM NAME SUFFIX OR JUST ENTER TO QUIT'
 PULL ANS
 IF ANS = '' THEN SIGNAL DONEIT
 IF WORDPOS(ANS,SFXLST) > 0 THEN DO
  SAY 'SUFFIX:'ANS': ALREADY EXISTS IN STEM. TRY ANOTHER.'
  SIGNAL TOPOFLST
  END
 INTERPRET STMPFX"."ANS" = TIME('L')"
 SFXLST = ANS||' '||SFXLST
 SIGNAL TOPOFLOP
DONEIT:
 IF WORDS(SFXLST) < 1 THEN DO
  SAY 'FAILED TO PROVIDE ANY STEM VAR SUFFIX VALUE'
  SAY 'GOOD BYE'
  EXIT
  END
 SAY '*** CALLING ENUMRXVR TO REPORT ON JUST STEM PFX VALUES'
 "CALL 'TTEP.TSK.E.TCEM.PDSE(ENUMRXVR)' '"STMPFX"'"
 NM = QUEUED()
 SAY 'NUMBER OF STEM VARS FOUND FOR STEM:' STMPFX
 DO I = 1 TO NM
  PARSE PULL STMVAR
  INTERPRET 'TMP = 'STMVAR
  SAY STMVAR ' WAS ASSIGNED:' TMP
  END
 SAY 'FINISHED:'TIME('L')
###END TSTENUMV
$$$BEG TRXCNC
/*  REXX   */
RX_CNC_ACTION='PUT'
RX_CNC_CH_NM='MY_CNC_CH_NM'
RX_CNC_CN_NM='MY_CNC_CN_NM'
RX_CNC_CONTTYPE='CHAR'
RX_CNC_CHARDATA='THIS SHOULD BE DATA'
SAY 'RX_CNC_ACTION SENT   TO COBOL PROGRAM IS:' RX_CNC_ACTION
SAY 'RX_CNC_CH_NM SENT    TO COBOL PROGRAM IS:' RX_CNC_CH_NM
SAY 'RX_CNC_CN_NM SENT    TO COBOL PROGRAM IS:' RX_CNC_CN_NM
SAY 'RX_CNC_CONTTYPE SENT TO COBOL PROGRAM IS:' RX_CNC_CONTTYPE
SAY 'RX_CNC_CHARDATA SENT TO COBOL PROGRAM IS:' RX_CNC_CHARDATA
/*    CALL COBOL PROGRAM   */
ADDRESS TSO
/*ALLOC FI(SYSOUT) DA(*) SHR REUSE' */
/* "CALL 'TTED.TSK.P.TCEM.LOADLIB(EXPLPGM3)' 'TVAR1,TVAR2'" */
/* CALL DOES NOT INITIALIZE THE ENVIRONMENT BLOCK */
/*"CALL 'TTEP.TSK.E.TCEM.PDSE(RXVARS)' 'TVAR1,TVAR2'" */
"CALL 'TTEP.TSK.E.TCEM.PDSE(RXCNC)'    'RX_CNC_ACTION,"||,
  "RX_CNC_CH_NM,RX_CNC_CN_NM,RX_CNC_CONTTYPE,RX_CNC_CHARDATA'"
IF RC <> 0 THEN DO
   SAY 'NON ZERO RETURN CODE' RC
   RETURN 12
   END
/*             APPEND TO CN              */
RX_CNC_ACTION='APPEND'
RX_CNC_CHARDATA='...AND WE APPEND THIS DATA<'
SAY 'RX_CNC_ACTION SENT   TO COBOL PROGRAM IS:' RX_CNC_ACTION
SAY 'RX_CNC_CHARDATA SENT TO COBOL PROGRAM IS:' RX_CNC_CHARDATA
"CALL 'TTEP.TSK.E.TCEM.PDSE(RXCNC)'    'RX_CNC_ACTION,"||,
  "RX_CNC_CH_NM,RX_CNC_CN_NM,RX_CNC_CONTTYPE,RX_CNC_CHARDATA'"
IF RC <> 0 THEN DO
   SAY 'NON ZERO RETURN CODE' RC
   RETURN 12
   END
/*             GET    TO IRX VAR         */
RX_CNC_ACTION='GET'
RX_CNC_GETDATA=''
SAY 'RX_CNC_ACTION SENT   TO COBOL PROGRAM IS:' RX_CNC_ACTION
SAY 'RX_CNC_GETDATA  SENT TO COBOL PROGRAM IS:' RX_CNC_GETDATAA
"CALL 'TTEP.TSK.E.TCEM.PDSE(RXCNC)'    'RX_CNC_ACTION,"||,
  "RX_CNC_CH_NM,RX_CNC_CN_NM,RX_CNC_CONTTYPE,RX_CNC_GETDATA'"
IF RC <> 0 THEN DO
   SAY 'NON ZERO RETURN CODE' RC
   RETURN 12
   END
SAY 'RX_CNC_CH_NM=' RX_CNC_CH_NM
SAY 'RX_CNC_CN_NM=' RX_CNC_CN_NM
SAY 'RX_CNC_CHARDATA=' RX_CNC_CHARDATA
SAY 'RX_CNC_GETDATA =' RX_CNC_GETDATA
PULL ANS
/*             GET    TO CN              */
RX_CNC_ACTION='DELETE'
RX_CNC_CHARDATA=''
RX_CNC_GETDATA=''
SAY 'RX_CNC_ACTION SENT   TO COBOL PROGRAM IS:' RX_CNC_ACTION
SAY 'RX_CNC_GETDATA  SENT TO COBOL PROGRAM IS:' RX_CNC_GETDATAA
"CALL 'TTEP.TSK.E.TCEM.PDSE(RXCNC)'    'RX_CNC_ACTION,"||,
  "RX_CNC_CH_NM,RX_CNC_CN_NM,RX_CNC_CONTTYPE,RX_CNC_GETDATA'"
IF RC <> 0 THEN DO
   SAY 'NON ZERO RETURN CODE' RC
   RETURN 12
   END
SAY
SAY 'RX_CNC_CH_NM=' RX_CNC_CH_NM
SAY 'RX_CNC_CN_NM=' RX_CNC_CN_NM
SAY 'RX_CNC_CHARDATA=' RX_CNC_CHARDATA
SAY 'RX_CNC_GETDATA =' RX_CNC_GETDATA
###END TRXCNC
$$$BEG TRXCNCLK
/*  REXX   */
trace i
MSGOUT_ERR ='!!!NO MSGOUT_ERR RETURNED!!!'
RESP_CN_MESG=''
RESP_CN_LIST=''
RX_CNC_CN_REQ_LST=''
RX_CNC_CN_RSP_LST=
RX_CNC_PG_NM='UCEMPINR'
/* TEST PARMS                   */
RESP_CN_MESG='THIS IS A TEST'
RESP_CN_LIST='A,S,T'
RX_CNC_CN_REQ_LST='A,B,C'
RX_CNC_CN_RSP_LST='@RETURN_CN_LIST'
RETURN_CN_LIST='ABCD(Q,R,S,T,'
A='AAA'
B='BBB'
C='CCC'
D='DDD'
Q='QQQ'
R='RRR'
S='SSS'
T='TTT'
SIGNAL DO_TEST
/* TEST PARMS                    */
'GETCPU1 <PUSH>'
PULL CURCPU CURGRP CURCPUG
 SELECT
  WHEN CURCPU = 'GRP1' THEN RX_CNC_APLID='CGE5'
  WHEN CURCPU = 'GRP2' THEN RX_CNC_APLID='CGE9'
  WHEN CURCPU = 'GRP5' THEN RX_CNC_APLID='BEN0'
  OTHERWISE DO
  RX_CNC_APLID='><'
  SAY 'WARNING: CANNOT DETERMINE WHICH SYSPLEX GROUP'
  SAY '         THIS IS RUNNING ON:GRP:'CURCPU':'
  SAY '         CAN NOT SUPPLY A DEFAULT APPLID'
  SAY '         'RX_CNC_APLID
  END
 END
RX_CNC_CH_NM='TRXCNCLK_CH'
RX_CNC_TRNID='UXXX'
RX_CNC_CN_REQ_LST=''
RX_CNC_CN_RSP_LST=''
SAY 'THIS IS A TEST HARNESS TO INVOKE THE EXCI INTERFACE'
SAY ' TO A CICS REGION, UTILIZING CHANNEL AND CONTAINERS'
SAY ' INVOKING NEW COBOL EXCI PROGRAM RXCNCLNK'
SAY 'THIS EXEC HAS REQUIRED AND OPTIONAL PARAMETERS'
SAY '  THAT YOU MUST PROVIDE:'
SAY ' LINK TO CICS PROGRAM NAME (REQUIRED) DEFAULT 'RX_CNC_PG_NM
SAY ' LINK TO CICS APPLID       (REQUIRED) DEFAULT 'RX_CNC_APLID
SAY ' LINK TO CICS TRANSID      (REQUIRED) DEFAULT 'RX_CNC_TRNID
SAY ' LINK TO CICS CHANNEL NAME (REQUIRED) DEFAULT 'RX_CNC_CH_NM
SAY ' SET OF CONTAINER REQUESTS (REQUIRED) NO DEFAULTS'
SAY ' SET OF CONTAINER RESPONES (OPTIONAL) NO DEFAULTS'
SAY ''
SAY 'FOR EACH OF THE FOLLOWING PROMPTS, PLEASE PROVIDE'
SAY ' YOUR OWN SELECTION; OR PRESS ENTER TO JUST ACCEPT'
SAY ' THE DEFAULT; OR ATTN TO ABORT:'
SAY ''
SAY ' PROGRAM:'RX_CNC_PG_NM
ANS = ''
PULL ANS
ANS = STRIP(ANS,'B')
IF ANS /= '' THEN DO
  IF LENGTH(ANS) > 8 THEN ANS = SUBSTR(ANS,1,8)
  RX_CNC_PG_NM = ANS
  END

SAY '  APPLID:'RX_CNC_APLID
ANS = ''
PULL ANS
ANS = STRIP(ANS,'B')
IF ANS /= '' THEN DO
  IF LENGTH(ANS) > 8 THEN ANS = SUBSTR(ANS,1,8)
  RX_CNC_APLID = ANS
  END

SAY ' TRANSID:'RX_CNC_TRNID
ANS = ''
PULL ANS
ANS = STRIP(ANS,'B')
IF ANS /= '' THEN DO
  IF LENGTH(ANS) > 4 THEN ANS = SUBSTR(ANS,1,8)
  RX_CNC_TRNID = ANS
  END

SAY '(Warning: CAPS are off. CHANNEL name can be UPPER or lower case:'
SAY ' CHANNEL NAME:'RX_CNC_CH_NM
ANS = ''
PARSE PULL ANS
ANS = STRIP(ANS,'B')
IF ANS /= '' THEN DO
  IF LENGTH(ANS) > 16 THEN ANS = SUBSTR(ANS,1,16)
  RX_CNC_CH_NM = ANS
  END

SAY ''
SAY 'ENTERING LOOP TO COLLECT REQUEST CONTAINERS (CHANNEL:'RX_CNC_CH_NM
SAY ''
SAY 'First: CAPS are Set to off for both container names and data:'
SAY ' Enter two values: the first for CN name and 2nd for CN data:'
SAY ' where < indicates lower case and > INDICATES UPPERCASE:'
T1 = '<'
T2 = '<'
ANS = ''
PULL ANS
IF ANS /= '' THEN DO
 TMP = ANS
 T1 = SUBSTR(ANS,1,1)
 IF LENGTH(ANS) > 1 THEN T2 =  SUBSTR(ANS,2,1)
   ELSE T2 = '<'
 IF T1 /= '>' THEN T1 = '<'
 IF T2 /= '>' THEN T2 = '<'
 END
SAY ''
SAY ' FOR EACH REQUEST, ENTER A CCONTAINERNAME=CONTAINER DATA VALUES'
SAY ' CONTAINERNAME IS 1 TO 16 CHARACTERS, VALID FOR A CONTAINER NAME'
SAY ' AND A CONTAINER VALUE STRING (CHAR CONTAINERS ONLY)'
SAY ' AT END, JUST ENTER NOTHING AT THE PROMPT OR ATTN TO ABORT'
EQ='='
CN_CNT = 0
CN_PROMPT='ENTER FOR CN#:'
CN_NM='CONTINUE'
/* TRACE I */
QN_LOOP:DO WHILE CN_NM /= ''
 SAY CN_PROMPT||CN_CNT + 1
 PARSE PULL CN_NM (EQ) CN_DATA
 CN_NM = STRIP(CN_NM,'B')
 IF CN_NM = '' THEN DO
  SAY 'YOU SIGNALED YOU ARE FINISHED ENTERING REQUEST CN DATA'
  LEAVE
  END
 IF T1 = '>' THEN UPPER CN_NM
 IF T2 = '>' THEN UPPER CN_DATA
 CN_CNT=CN_CNT + 1
 IF LENGTH(CN_NM) > 16 THEN DO
  CN_NM=SUBSTR(CN_NM,1,16)
  SAY 'CONTAINER NAME LENGTH IS GT 16; TRUNCATE TO:'CN_NM':'
  END
 QN.CN_CNT=CN_NM
 QD.CN_CNT=CN_DATA
 END
QN.0=CN_CNT
SAY 'YOU ENTERED:'CN_CNT': REQUEST CONTAINERS'
SAY ''
SAY 'NOW ENTER RESPONSE CONTAINERS'
SAY 'NOTE: TO DEFAULT THE SET OF RESPONSE CONTAINER NAMES TO'
SAY '       THE SET OF REQUEST CONTAINER NAMES, ENTER SINGLE ""*""'
SAY '       AND THEN ADD MORE IF NEEDED'
SAY 'ALSO: IF YOU EXPECT YOUR CICS PROGRAM TO RETURN A CONTAINER'
SAY '       IN WHICH THE PROGRAM SPECIFIES THE CONTAINERS RETURNED'
SAY '       THEN YOU CAN SPECIFY @X..X WHERE X..X IS THE NAME OF'
SAY '       CONTAINER WHICH WILL HOLD THAT LIST.'
SAY '       UCEMPINR WILL RETURN A CONTAINER NAMED RETURN_CN_LIST'
SAY '        IN WHICH CASE YOU WOULD SPECIFY @RETURN_CN_LIST'
SAY '       AND THEN ADD MORE IF NEEDED'
SAY ''
SAY 'AGAIN: CAPS are Set to off for RESPONSE container names:'
SAY ' Enter a single value to choose lower or UPPER case CN names:'
SAY ' where < indicates lower case and > INDICATES UPPERCASE:'
T1 = '<'
T2 = '<'
ANS = ''
PULL ANS
IF ANS /= '' THEN DO
 TMP = ANS
 T1 = SUBSTR(ANS,1,1)
 IF T1 /= '>' THEN T1 = '<'
 END
SAY ''
SAY 'ENTERING LOOP TO COLLECT RESPONSE CONTAINERS CHANNEL:'RX_CNC_CH_NM
SAY ' FOR EACH PROMPT, ENTER A CONTAINERNAME OR '
SAY '  A * OR THE @X..X RESPONSE:'
GOT_ASK=0
GOT_AT=0
CN_CNT = 0
CN_PROMPT='ENTER FOR CN#:'
CN_NM='CONTINUE'
PN_LOOP:DO WHILE CN_NM /= ''
 SAY CN_PROMPT||CN_CNT + 1
 CN_NM=''
 PARSE PULL CN_NM
 CN_NM = STRIP(CN_NM,'B')
 IF CN_NM = '' THEN DO
  SAY 'YOU SIGNALED YOU ARE FINISHED ENTERING REQUEST CN DATA'
  LEAVE
  END
 IF T1 = '>' THEN UPPER CN_NM
 FC=SUBSTR(CN_NM,1,1)
 CN_CNT=CN_CNT + 1
 IF FC = '@' THEN DO
  IF GOT_AT /= 0 THEN DO
   SAY 'ERROR: ONLY A SINGLE @ REQUEST IS VALID'
   CN_CNT = CN_CNT - 1
   ITERATE
   END
  IF SUBSTR(CN_NM,2,1) = '*' THEN DO
   SAY 'ERROR: * CAN NOT BE TARGET OF @ REQUEST'
   CN_CNT = CN_CNT - 1
   ITERATE
   END
  GOT_AT=CN_CNT
  FP = 2
  END
  ELSE DO
  FP = 1
  END
 CN_NM = SUBSTR(CN_NM,FP)
 IF LENGTH(CN_NM) > 16 THEN DO
  CN_NM=SUBSTR(CN_NM,1,16)
  SAY 'CONTAINER NAME LENGTH IS GT 16; TRUNCATE TO:'CN_NM':'
  END
 IF SUBSTR(CN_NM,1,1) = '*' THEN DO
  IF GOT_ASK /= 0 THEN DO
   SAY 'ERROR: * REQUEST ALREADY PROCESSED'
   CN_CNT = CN_CNT - 1
   ITERATE
   END
   ELSE GOT_ASK = CN_CNT
  END
 PN.CN_CNT=CN_NM
 END
PN.0=CN_CNT
SAY 'YOU ENTERED:'CN_CNT': RESPONSE CONTAINERS'
SAY ''
NMP=''
NMS=''
DO I = 1 TO QN.0
 NMP=QN.I
 NMS = NMS||NMP||','
 TMP = QD.I
 INTERPRET NMP'="'TMP'"'
 END
RX_CNC_CN_REQ_LST=SUBSTR(NMS,1,LENGTH(NMS) - 1)
NMP=''
NMS=''
DO I = 1 TO PN.0
 NMP=PN.I
 IF I = GOT_AT THEN DO
  NMP='@'||NMP
  PN.I=NMP
  END
 NMS = NMS||NMP||','
 END
RX_CNC_CN_RSP_LST=SUBSTR(NMS,1,LENGTH(NMS) - 1)
SAY 'LET US REVIEW:'
SAY 'RX_CNC_PG_NM SENT TO RXCNCLNK     :' RX_CNC_PG_NM
SAY 'RX_CNC_APLID SENT                 :' RX_CNC_APLID
SAY 'RX_CNC_TRNID SENT                 :' RX_CNC_TRNID
SAY 'RX_CNC_CH_NM SENT                 :' RX_CNC_CH_NM
SAY 'RX_CNC_CN_REQ_LST                 :' RX_CNC_CN_REQ_LST
SAY 'RX_CNC_CN_REQ_LST ELEMENTS        :'
DO I = 1 TO QN.0
 SAY 'CN NAME:'QN.I
 SAY 'CN DATA:'QD.I
 SAY '---'
 END
SAY 'RX_CNC_CN_RSP_LST                 :' RX_CNC_CN_RSP_LST
SAY 'RX_CNC_CN_RSP_LST ELEMENTS        :'
DO I = 1 TO PN.0
 SAY 'CN NAME:'PN.I
 SAY '---'
 END
SAY 'Here we GO:'
SAY 'NOTE: THE COBOL PROGRAM IS EXPECTED TO RETURN THE FOLLOWING VARS:'
SAY 'RESP_CN_MESG - LOG OF COBOL ACTIONS'
SAY 'RESP_CN_LIST - LIST OF RETURNED VARS - WHICH ARE CICS CONTAINERS'
SAY 'LOOK FOR RESP_CN_MESG AND OPTIONALLY RESP_CN_LIST'
SAY ''
/* TRACE ?I */
/*    CALL COBOL PROGRAM   */
ADDRESS TSO
/*ALLOC FI(SYSOUT) DA(*) SHR REUSE' */
/* "CALL 'TTED.TSK.P.TCEM.LOADLIB(EXPLPGM3)' 'TVAR1,TVAR2'" */
/* CALL DOES NOT INITIALIZE THE ENVIRONMENT BLOCK */
/*"CALL 'TTEP.TSK.E.TCEM.PDSE(RXVARS)' 'TVAR1,TVAR2'" */
"CALL 'TTEP.TSK.E.TCEM.PDSE(RXCNCLNK)' 'RX_CNC_PG_NM,"||,
  "RX_CNC_APLID,RX_CNC_CH_NM,RX_CNC_CN_REQ_LST,RX_CNC_CN_RSP_LST,"||,
  "RX_CNC_TRNID'"
/* SHOW VARS */
IF RC > 4 THEN DO
   SAY 'NON ZERO RETURN CODE' RC
   SAY 'MSGOUT_ERR(?):' MSGOUT_ERR
   RETURN 12
   END
SAY 'RETURN FROM RXCNCLNK'
SAY ''
SAY 'MSGOUT ERROR MESSAGE (IF ANY)'
SAY MSGOUT_ERR
SAY
SAY
SAY 'REXX VARIABLES SENT:'
SAY 'RX_CNC_PG_NM SENT TO COBOL PROGRAM:' RX_CNC_PG_NM
SAY 'RX_CNC_APLID SENT                 :' RX_CNC_APLID
SAY 'RX_CNC_CH_NM SENT                 :' RX_CNC_CH_NM
SAY 'RX_CNC_TRNID SENT                 :' RX_CNC_TRNID
SAY 'RX_CNC_CN_REQ_LST                 :' RX_CNC_CN_REQ_LST
SAY 'RX_CNC_CN_RSP_LST                 :' RX_CNC_CN_RSP_LST
SAY ''
DO_TEST:
TRACE ?I
SAY 'EXPECTED REXX RETURN VARIABLES: RESP_CN_MESG AND RESP_CN_LIST'
TMP_NM = 'RESP_CN_MESG'
TMP_CN_MSG = RESP_CN_MESG
SAY 'DISPLAY 'TMP_NM' CONTENTS?'
  SAY 'ENTER Y TO DISPLAY DATA OR ANY OTHER KEY TO BYPASS:'
  PULL ANS
  IF ANS = 'Y' THEN CALL SHOWRXDATA
  SAY ''
TMP_NM = 'RESP_CN_LIST'
TMP_CN_MSG = RESP_CN_LIST
SAY 'DISPLAY 'TMP_NM' CONTENTS?'
  SAY 'ENTER Y TO DISPLAY DATA OR ANY OTHER KEY TO BYPASS:'
  PULL ANS
  IF ANS = 'Y' THEN CALL SHOWRXDATA
  SAY ''
AK = 0
AK = POS('*',RX_CNC_CN_RSP_LST)
IF AK > 0 THEN DO
   SAY 'RX_CNC_CN_RSP_LS INCLUDED A WILD CARD * '
   SAY ' SUBSTITUTE * WITH THE SUPPLIED RX_CNC_CN_REQ_LST'
   IF AK > 2 THEN TMPRSP1=SUBSTR(RX_CNC_CN_RSP_LST,1,AK - 1)
   ELSE TMPRSP1=''
   TMPRSP=SUBSTR(RX_CNC_CN_RSP_LST,AK + 1)
   NP = POS(',',TMPRSP)
   TMPRSP2=''
   IF NP > 0 THEN TMPRSP2= SUBSTR(TMPRSP,NP)
   TMPRSP3 = RX_CNC_CN_REQ_LST
   RX_CNC_CN_RSP_LST=TMPRSP1||TMPRSP3||TMPRSP2
   SAY RX_CNC_CN_RSP_LST
   SAY ''
   END
/*     POSSIBLE SCENERIOS                       *\
|*   @A                                         *|
|*   A,@B                                       *|
|*   A,@B,C                                     *|
|*   @                                          *|
|*   A,@                                        *|
|*   A,@,B                                      *|
\*                                              */
AP = 0
AP = POS('@',RX_CNC_CN_RSP_LST)
IF AP > 0 THEN DO
   TMPRSP0 = RX_CNC_CN_RSP_LST||' '
   IF AP > 1 THEN TMPRSP1=SUBSTR(RX_CNC_CN_RSP_LST,1,AP - 1)
   ELSE TMPRSP1=''
   TMPRSP=STRIP(SUBSTR(TMPRSP0,AP + 1),'T')
   LP = LENGTH(TMPRSP)
   IF LP < 1 THEN DO
    SAY  'ERRROR: INVALID CN NAME FOLLOWS >@< WILDCARD. BYPASS.'
    RX_CNC_CN_RSP_LST=TMPRSP1
    SIGNAL GOT_RSP_DATA
    END
   NP = POS(',',TMPRSP)
   TMPRSP2=''
   IF NP = 0 THEN NP = LP + 1
     ELSE TMPRSP2=SUBSTR(TMPRSP,NP)
   TMPRSP = SUBSTR(TMPRSP,1,NP - 1)
   LP = LENGTH(TMPRSP)
   IF LP < 2 then do
    SAY  'ERRROR: INVALID CN NAME FOLLOWS >@< WILDCARD. BYPASS.'
    RX_CNC_CN_RSP_LST=TMPRSP1||STRIP(TMPRSP2,'L',',')
    SIGNAL GOT_RSP_DATA
    END
   INTERPRET 'TMPRSP3='TMPRSP
   IF RX_CNC_PG_NM = 'UCEMPINR' & TMPRSP = 'RETURN_CN_LIST' THEN DO
    OP = '('
    RSP_SYSID=''
    TMPRSP4=''
    PARSE VAR TMPRSP3 RSP_SYSID (OP) TMPRSP4
    IF TMPRSP4 /= '' THEN DO
     TMPRSP3=TMPRSP4
     SAY 'FOUND SYSID PREFIX:' RSP_SYSID
     SAY '  AND FOLLOWING RESPONSE CN LIST:'
     SAY TMPRSP3
     END
    END
   SAY 'RX_CNC_CN_RSP_LS INCLUDED A WILD CARD @ '
   SAY ' WE ARE GOING TO USE THE IDENTIFIED CN LIST' TMPRSP3
   RX_CNC_CN_RSP_LST=TMPRSP1||TMPRSP3||TMPRSP2
 END
GOT_RSP_DATA:
SAY 'RX_CNC_CN_RSP_LST CN LIST:'
SAY RX_CNC_CN_RSP_LST
SAY 'RX_CNC_CN_RSP_LST RESPONSE ELEMENTS        :'
 A1 = TRANSLATE(RX_CNC_CN_RSP_LST,' ',',')
 DO WHILE (A1 /= '')
  PARSE VAR A1 A2 A1
  INTERPRET "C1  = '"A2"'"
  ML = LENGTH(C1)
  SAY 'ELEMENT:'||LEFT(A2,16)||': HAS LENGTH:' ML
  TMP_NM = A2
  TMP_CN_MSG = C1
  SAY 'ENTER Y TO DISPLAY DATA OR ANY OTHER KEY TO BYPASS:'
  PULL ANS
  IF ANS = 'Y' THEN CALL SHOWRXDATA
  SAY ''
  END
SAY ''
ANS = 'FIRST'
DO WHILE ANS /= ''
 SAY 'ENTER A REXX VAR TO INTERPRET:'
 PULL ANS
 IF ANS = '' THEN LEAVE
 TMP_NM = ANS
 INTERPRET 'TMP_CN_MSG = 'ANS
 SAY TMP_CN_MSG
/* CALL SHOWRXDATA */
 END
SAY ''
SAY 'FINISHED TRXCNCLK! BYE'
EXIT
/* SUB ROUTINE TO DISPLAY RETURNED DATA */
SHOWRXDATA: PROCEDURE EXPOSE TMP_NM TMP_CN_MSG
MSG_LF_DLM='15'X
CPY_#=COPIES('-',60)
RSPCT = 0
DO WHILE TMP_CN_MSG /= ''
 PARSE VAR TMP_CN_MSG TMP (MSG_LF_DLM) TMP_CN_MSG
 IF TMP /= '' THEN DO
  RSPCT = RSPCT + 1
  RSP.RSPCT = TMP
  END
 END
SAY 'FOUND<' RSPCT '> LINES IN RESP_CN_MSG'
M0 = 1
ANS = '>'
DO WHILE ((POS(ANS,'<=>')) /= 0)
 CURLN = M0
 MXLN = RSPCT - CURLN
 IF MXLN > 60 THEN MXLN = CURLN + 60
  ELSE MXLN = CURLN + MXLN
 DO I = CURLN TO MXLN
   SAY RSP.I
   SAY CPY_#
   END
  SAY 'LAST DISPLAY: LINE:' CURLN ' THRU:' MXLN ' OF:' RSPCT
  SAY 'ENTER > TO CONTINUE FORWARD'
  SAY '      = TO RE DISPLAY CURRRENT SET'
  SAY '      < TO CONTINUE FORWARD'
  SAY ' OR ANY OTHER KEY STOP THIS MESSAGE DISPLAY'
  PULL ANS
  SELECT
   WHEN ANS = '>' THEN DO
                  M0 = CURLN + MXLN
                  IF M0 >= RSPCT THEN M0 = (RSPCT - MXLN) + 1
                  END
   WHEN ANS = '=' THEN M0 = CURLN
   WHEN ANS = '<' THEN DO
                  M0 = CURLN - MXLN
                  IF M0 <= 0 THEN M0 = 1
                  END
   OTHERWISE SAY 'SELECTED TO LEAVE:' ANS ':'
   END
 END
 RETURN
###END TRXCNCLK
$$$BEG EXCIDADC
/* REXX */
/*----------------- SAMPLE1 REXX EXEC -------------------------------*\
|* PLEASE RUN THE TSOLIB COMMAND FROM NATIVE TSO                     *|
|*  (GO BACK TO READY)> CEM EXCITSLB
|*  (NOW RUN...)      > CICLOGON
|*                                                                   *|
|* THIS EXEC USES THE EXCI LINK INTERFACE TO EXECUTE A CICS PROGRAM  *|
|*                                                                   *|
|* "CA1DCALL "PROGRAM("PROGRAM_NAME")" ,                              *|
|*              "APPLID("VTAM_APPLID")" ,                            *|
|*              "USERID("USER_ID")" ,                                *|
|*              "COMMAREA(CA_NAME)" ,           /* OPTIONAL */       *|
|*              "LENGTH("CA_LENGTH")" ,         /* OPTIONAL */       *|
|*              "DATALENGTH("COMMAREA_DLEN")" , /* OPTIONAL */       *|
|*              "TRANSID("TRANS_ID")"           /* OPTIONAL */       *|
|* PROGRAM_NAME  - CONTAINS THE NAME OF THE CICS PROGRAM TO EXECUT   *|
|*                 FOLLOWING THE NAMING CONVENTIONS FOR CICS PROGR   *|
|*                                                                   *|
|* VTAM_APPLID   - CONTAINS THE VTAM APPLID FOR THE CICS REGION WH   *|
|*                 IS TO RECEIVE THE REQUEST.                        *|
|*                                                                   *|
|* USER_ID       - CONTAINS THE CICS USERID UNDER WHICH THE CICS     *|
|*                 PROGRAM WILL EXECUTE.  THIS USERID MUST BE        *|
|*                 VALIDATED PRIOR TO CALLING THE CICS PROGRAM BEC   *|
|*                 THERE IS NO ABILITY TO PASS A PASSWORD TO CICS.   *|
|*                                                                   *|
|* CA_NAME       - IS THE NAME OF THE REXX VARIABLE THAT CONTAINS    *|
|*                 COMMAREA CONTENTS.  (BE SURE TO WATCH THE '"' T   *|
|*                 AVOID THE REXX VARIABLE SUBSTITUTION. IF COMMAR   *|
|*                 NOT SPECIFIED, THEN LENGTH AND DATALENGTH ARE     *|
|*                 IGNORED IF SPECIFIED.                             *|
|*                                                                   *|
|* CA_LENGTH     - CONTAINS THE LENGTH OF THE COMMAREA TO BE USED    *|
|*                 THE EXCI.  THIS LENGTH CANNOT EXCEED 32768. IF    *|
|*                 VALUE IS NOT SUPPLIED BUT THE CA_NAME IS SPECIF   *|
|*                 THEN THE LENGTH OF THE REXX VARIABLE IS USED.     *|
|*                                                                   *|
|* COMMAREA_DLEN - CONTAINS THE LENGTH OF THE DATA TO BE PASSED IN   *|
|*                 COMMAREA.  THIS LENGTH MUST NOT BE LARGER THAN    *|
|*                 LENGTH OF THE COMMAREA. IF THIS VALUE IS NOT      *|
|*                 SUPPLIED BUT LENGTH IS SPECIFIED, THEN LENGTH I   *|
|*                 USED.  IF LENGTH IS NOT SPECIFIED THEN THE LENG   *|
|*                 THE CA_NAME REXX VARIABLE CONTENTS IS USED.       *|
|*                                                                   *|
|* TRANS_ID      - CONTAINS THE NAME OF A TRANSACTION TO BE USED F   *|
|*                 THE MIRROR FUNCTION.  IF NOT ENTERED THE DEFAUL   *|
|*                 MIRROR TRANSACTION, CSMI IS USED.                 *|
\*-------------------------------------------------------------------*/
TRACE I
ADDRESS TSO
ARG APPLID_NAME C_A
IF APPLID_NAME = '' THEN APPLID_NAME='CGE5'
PROGRAM_NAME = 'UCEMPINN'
COMMAREA_NAME= 'C_A'
IF C_A = '' THEN C_A = 'PING'
COMMAREA_DLEN = LENGTH(C_A)
C_A = C_A||COPIES(' ',4096-COMMAREA_DLEN)
COMMAREA_LEN = LENGTH(C_A)
/* APPLID_NAME='CGE7' */
USER_ID=SYSVAR(SYSUID)
TR_ID='CSMI'
PARM = "'PROGRAM("PROGRAM_NAME")','COMMAREA(C_A)',"||,
       "'TRANSID("TR_ID")',"||,
       "'LENGTH(COMMAREA_LEN)','APPLID("APPLID_NAME")'"
P1 = "PROGRAM("PROGRAM_NAME")"
P2 = "COMMAREA(C_A)"
P3 = "LENGTH("COMMAREA_LEN")"
P4 = "APPLID("APPLID_NAME")"
P5 = "TRANSID("TR_ID")"
P6 = "DATALENGTH(4)"
P7 = "USERID("USER_ID")"
EXCI_RESP='--'
EXCI_RESP2='##'
EXCI_ABCODE='____'
EXCI_MESSAGE='-'
SAY 'COMMAREA LENGTH IS:' LENGTH(C_A)
SAY 'COMMAREA CONTENTS BEFORE LINK ARE:'
SAY '>'||STRIP(C_A,'T')||'<'
SAY
SAY 'CALLING CICSLINK WITH PARAMETERS:'
PARM1 = PARM
DO UNTIL PARM1 = ''
  PARSE VAR PARM1 PART ',' PARM1
  SAY '   ' PART
  END
SAY 'PROCESSING REQUEST...'
/* CALL EXCI    */
/* 'INTERPRET "CALL CA1DLINK '"P1"','"P2"','"P3"','"P4"','"P5"'" */
"ISPEXEC SELECT PGM(CA1DLINK) PARM("P1","P2","P3","P4","P5")"
SAY 'MAIN EXEC - RESULT VARIABLE CONTENTS:' RESULT
SAY
SAY 'EXCI_RESP IS:' EXCI_RESP
SAY 'EXCI_RESP2 IS:' EXCI_RESP2
SAY 'EXCI_ABCODE IS:' EXCI_ABCODE
SAY 'EXCI_MESSAGE LENGTH IS:' LENGTH(EXCI_MESSAGE)
SAY 'EXCI_MESSAGE IS:' EXCI_MESSAGE
SAY
SAY 'COMMAREA CONTENTS AFTER LINK ARE:'
O_C_A_LEN=LENGTH(C_A)
SAY 'LENGTH IS:' O_C_A_LEN
IND = 0
X15='15'X
C_A=STRIP(C_A,'T')
N_C_A_LEN=LENGTH(C_A)
SAY ' STRIPPED 'O_C_A_LEN-N_C_A_LEN' SPACES AT END OF COMMAREA'
DO WHILE(C_A ^= '')
 PARSE VAR C_A TMP (X15) C_A
 SAY TMP
 END
/* SAY '<'||C_A||">" */
DONIT:
EXIT
###END EXCIDADC
$$$BEG EXCICNC
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA EXCICNC  - SUBROUTINE TO AFOLIST. SEE AFOLIST CNC       */
 /* CEMHELP EXCICNC  - SUBROUTINE TO AFOLIST. SEE AFOLIST CNC       */
 /* CEMHELP          -                                              */
 /* CEMHELP END                                                     */
 /* BASED ON EXCIS0 (NON CNC) 20181205                              */
 /* CHANNEL AND CONTAINERS IMPLEMENTATION                           */
 /*  USE ISPFEXEC SELECT PGM INTERFACE TO EXPOSE THE ISPF VARS      */
 /*  TO THE COBOL PROGRAM WHICH INVOKES THE EXCI CALL               */
 /*  KEY ISPFVAR FOR CNC EXECUTION:                                 */
 /*   ICHLST - IF NOT COMMAREA, THEN THIS VAR HOLDS LIST OF CHANNEL */
 /*  THIS RX EXPECTS THE FOLLOWING ARGS (PARMS)                     */
 /*   MYFUNC - SEE BELOW                                            */
 /*   CHNM   - SEE BELOW                                            */
 /*   MYCMD  - SEE BELOW                                            */
 /*   MYAPPLID - SEE BELOW                                          */
 /*   ODSN   - SEE BELOW                                            */
 /*   MYTRANID - (OPT) SEE BELOW                                    */
 /*   MYPROG   - (OPT) SEE BELOW                                    */
 /*   MYCA     - (OPT) SEE BELOW                                    */
 /*   MYCAL    - (OPT) SEE BELOW                                    */
 /*  WHEN CHNM VAR CONTAINS OTHER THAN 'COMMAREA' THEN ASSUME THAT  */
 /*   THIS IS A CNC CALL.                                           */
 /*   NOTE: TO SEND NO DATA TO THE EXCI INTERFACE, SET CHNM TO      */
 /*         'COMMAREA', BUT SET THE MYCA TO '' (NOTHING) AND        */
 /*         MYCAL SET TO '0' (ZERO)                                 */
 /*   NOTE:  SENDING A CHANNEL WITH NO CONTAINERS IS ALLOWED        */
 /*   SET THE CHNM VAR TO THE SELECTED CHANNEL, SO THAT THE CHNM    */
 /*   CAN BE FOUND IN THE ISHLST LIST OF CHANNEL NAMES.             */
 /*                                                                 */
 /*   NOTE: ALL OF THE CNC CHANNEL AND CONTAINER DATA VARS ARE      */
 /*         ESTABLISHED BY THE DSPCNCCH AND DSPCNCCN RX PGMS.       */
 /*                                                                 */
 /*         THE INVOKED COBOL PROGRAM WILL USE THE CHNM TO GENERATE */
 /*         ACCESS TO THE RESPECTIVE SET OF CONTAINERS              */
 /*                                                                 */
 /*                                                                 */
 /* REQUIRED PARAMETERS:                                            */
 /*  MYFUNC - FIRST PARM IDENTIFIES THE OUTPUT PROCESS              */
 /*         - SEE VAR VALFUNC                                       */
 /*  MYCMD  - DESIRED COMMAND PROCESSING OPTION                     */
 /*           SEE VAR VALPRMS                                       */
 /*  MYAPLID() - TARGET APPLID(S) EXPECTED AS COMMA DELM LIST       */
 /*  ODSN   - IF QUIET, IDENTIFIES THE TARGET DSN TO COLLECT THE    */
 /*           RESULTS                                               */
 /*                                                                 */
 /*  PARMS MUST BE IN THE FORMAT                                    */
 /*   ACTUAL LITERAL (SEE VALPRMS FOR LIST) EXPL: MYAPLID           */
 /*     MYAPLID=XXXX   SINGLE CHOICE                                */
 /*            =(XXXX YYYY ....) MULTIPLE CHOICES                   */
 /*            (XXXX YYYY ....) MULTIPLE CHOICES                    */
 /*            =<IIII> IDENTIFIES AN ISPFVAR NAME                   */
 /*            <IIII>                                               */
 /*    IIII ISPFVAR NAME - IS THE ACTUAL NAME OF AN ISPFVAR         */
 /*            WHICH WILL BE VGET. THE CONTENTS OF THAT VAR         */
 /*            WILL BE USED AS A LIST                               */
 /*                                                                 */
 /*  MYCMD   CAN NOT BE A LIST. IT IS USED TO DEFINE A SINGLE       */
 /*          COMMAND, TO BE USED WITH THE APPLID LIST               */
 /*          IF MYCMD IS LIST, CEMT, OR CEDA THEN YOU MUST          */
 /*          PROVIDE A MYCA AND MYCAL VARIABLE                      */
 /*                                                                 */
 /*  MYTRANID(T) THE NAME OF THE TRANS ID TO USE  IF MYCMD IS LINK  */
 /*          PASSED IN AN ISPF VAR AND THE T IS THE VARIABLE NAME   */
 /*                                                                 */
 /*  MYPROG(P) THE NAME OF THE PROGRAM TO LINK TO IF MYCMD IS LINK  */
 /*          PASSED IN AN ISPF VAR AND THE P IS THE VARIABLE NAME   */
 /*                                                                 */
 /*  MYCA<X> THE COMMAREA  ASSOCIATED WITH THE COMMAND MUST BE      */
 /*          PASSED IN AN ISPF VAR AND THE X IS THE VARIABLE NAME   */
 /*          (NOTE SYMBOLIC SUBSTITUTION VARS ARE AS FOLLOW:        */
 /*          \@ WILL SUBSTITUTE APPLID                              */
 /*          \$ WILL SUBSTITUTE JOBNAME                             */
 /*          \! WILL SUBSTITUTE PARM NAMED S#PARM                   */
 /*          \\ WILL SUBSTITUTE A SINGLE BACK SLASH                 */
 /*             AND NOT INTERPRET THIS FURTHER                      */
 /*                                                                 */
 /*                                                                 */
 /*  MYCAL<Y> SPEFICIES THE NAME OF THE ISPF VAR, WHICH DEFINES THE */
 /*          DESIRED COMMAREA LENGTH (0 - 32400)                    */
 /*          PASSED IN AN ISPF VAR AND THE Y IS THE VARIABLE NAME   */
 /*                                                                 */
 /*  ODSN - CAN BE 'DISPLAY' WHICH WILL DISPLAY UP TO 99 LINES      */
 /*       - A DATASET (NEW OR EXISTING) IF EXISTING, YOU ARE        */
 /*         PROMPTED TO ACCEPT REUSE. IT CAN BE A PDS(E) WITH MBR   */
 /*                                                                 */
 /*                                                                 */
 /*                                                                 */
 /*                                                                 */
  ADDRESS ISPEXEC
  /* TRACE I */
  "ISPEXEC CONTROL ERRORS RETURN"
  ARG MYFUNC PRMS
  IF MYFUNC = '' THEN SIGNAL BADFUNC
  VALFUNC='QUIET MSGBOXONLY MSGBOXALL VERBOSE'
  VALPRMS='CHNM MYCMD MYAPLID ODSN MYCA MYCAL MYPROG MYTRANID'
  VALCMDS = 'PING CEMT CEDA LINK'
  DFTPVALS='PING . .'
  IF PRMS ^= '' THEN DO
   NPW=WORDS(VALPRMS)
   DO I = 1 TO NPW
    TMP = WORD(VALPRMS,I)
    TMPV = WORD(DFTPVALS,I)
    IF TMPV = '.' THEN TMPV = ''
     ELSE IF TMPV = '\.' THEN TMPV = '.'
    INTERPRET TMP"='"TMPV"'"
    END
   END
   X15='15'X
   XFF='FF'X
   ERRMSG = ''
   I=0
   PRM_RC = 0
   DLM='(<{[='
   MDLM=')>}] '
   #DMM=LENGTH(DLM)
   REPWDS='\@ \$ \! \\'  /* SUBSTITUTE \ APPLID JOBNAME */
   RW_CT = WORDS(REPWDS)
   DFT_PING_CAL=1008
   MAX_CAL=32000
   DFT_CAL=4080
   DFT_UCEMPIN='UCEMPINR'
   DFT_CHNM=''
PRMLOOP:
   IF PRMS = '' THEN SIGNAL DONEPRMS
   PRMX = ''
   PARSE VAR PRMS PRM PRMS
   IF PRM = '' THEN SIGNAL EXITRC8
   PRM=PRM||' ' /* TACK ON A SPACE TO HELP FIND '=' END */
   L_PRM=LENGTH(PRM)
   FDLM = ''
   EDLM = ''
   DO I = 2 TO L_PRM
    PP=SUBSTR(PRM,I,1)
    CKPP=POS(PP,DLM)
    IF CKPP ^= 0 THEN DO
     FDLM=SUBSTR(DLM,CKPP,1)
     EDLM=SUBSTR(MDLM,CKPP,1)
     LEAVE
     END
    END
   IF FDLM = '' THEN SIGNAL BADPARM
   IF I >= L_PRM THEN SIGNAL BADPARM
   LP = LASTPOS(EDLM,PRM)
   IF LP = 0 THEN LP=L_PRM
    ELSE LP = LP - 1
   PRMVAL = SUBSTR(PRM,I+1,LP-I)
   PRM = SUBSTR(PRM,1,I-1)
   IF PP = '=' THEN SIGNAL GOTEQ
   IF PP = '<' THEN SIGNAL GOTBRKT
   SIGNAL GOTPARNT
GOTEQ:
   IF PRMVAL = '' THEN SIGNAL BADPARM
   L_PRM=LENGTH(PRMVAL)
   PP = SUBSTR(PRMVAL,1,1)
   CKPP=POS(PP,DLM)
   IF CKPP = 0 THEN DO
    SIGNAL GOT_PRMVAL
    END
   I = 1
   FDLM=SUBSTR(DLM,CKPP,1)
   EDLM=SUBSTR(MDLM,CKPP,1)
   LP = LASTPOS(EDLM,PRMVAL)
   IF LP = 0 THEN LP=L_PRM
    ELSE LP = LP - 1
   PRMVAL = SUBSTR(PRMVAL,I+1,LP-I)
   IF PP = '<' THEN SIGNAL GOTBRKT
   SIGNAL GOTPARNT
GOTPARNT:
   PARSE VAR PRMVAL . '<' TMPVAL '>'
   IF TMPVAL ^= '' THEN DO
    PRMVAL = TMPVAL
    SIGNAL GOTBRKT
    END
   SIGNAL GOT_SIMPLE
GOTBRKT:
   IF LENGTH(PRMVAL) > 8 THEN SIGNAL BADPARM
   "ISPEXEC VGET ("PRMVAL") ASIS"
   INTERPRET "PRMVAL = "PRMVAL
/* IF PRMVAL = '' THEN SIGNAL BADPARM */
   SIGNAL NXTPRMS
BADPARM:
    ERRMSG = ERRMSG||XFF||,
       'PARM:'PRM' IS NOT A EXPECTED PARAMETER. BYPASSING.'
    PRM_RC = 4
    SIGNAL      NXTPRMS
GOT_SIMPLE:
GOT_PRMVAL:
   INTERPRET PRM "='"||PRMVAL||"'"
NXTPRMS:
/* TRACE OFF */
   SIGNAL PRMLOOP
DONEPRMS:
/* TRACE I */
   IF PRM_RC > 4 THEN SIGNAL EXITRC4
   IF MYFUNC = '' THEN SIGNAL EXITRC8
   IF MYFUNC = 'QUIET' THEN DO
    IF ODSN = '' | ODSN = 'ODSN' THEN DO
     CALL GETUDSN 'AFOLIST'
     PULL ODSN
     END
    IF ODSN = '' THEN SIGNAL EXITRC10
    SIGNAL GOTFUNC
    END
   IF MYFUNC = 'MSGBOXONLY' THEN SIGNAL GOTFUNC
   IF MYFUNC = 'MSGBOXALL' THEN SIGNAL GOTFUNC
   IF MYFUNC = 'VERBOSE' THEN SIGNAL GOTFUNC
   SIGNAL EXITRC8
 GOTFUNC:
/*TRACE I */
   IF WORDPOS(MYCMD,VALCMDS) = 0 THEN SIGNAL EXITRC12
   "ISPEXEC VGET (AUTOSAVE) ASIS"
   IF RC \= 0 THEN AUTOSAVE = 'N'
/*                                                               *\
|* CHNM CAN SPECIFY '' (OMITTED PARM) TO SIGNAL USE OLD LOGIC    *|
|*  TWHICH USES PARMS FOR CA AND CAL.                            *|
|* CHNM SPECIFIES 'COMMAREA' THEN WE EXPECT ISPF VARS            *|
|*  COMMAREA TO HOLD THE COMMAREA DATA                           *|
|*  COMMALNG TO HOLD THE REQUESTED COMMAREA LENGTH               *|
|* CHNM HAS ANY OTHER VALUE, THEN WE USE THIS VALUE AS A CHANNEL *|
|* THIS VALUE MUST BE PRESENT IN ISPF VAR 'ICHLST', IN ORDER TO  *|
|* REFERENCE THE ASSOCIATED SET OF CONTAINERS                    *|
|* DSPCNCCH MANAGES CHANNEL NAMES                                *|
|* DSPCNCCN MANAGES CONTAINERS FOR EACH CHANNEL                  *|
|* A CHANNEL WILL HAVE AN ASSOCIATED ICH__ , WHICH IS THE LIST   *|
|*  CONTAINERS FOR A GIVEN CHANNEL, AND THE                      *|
|*  '__' IS A ASSIGNED NUMER 01 - 99 BASED ON POSITION IN THE    *|
|*  ICHLST GLOBAL LIST OF CHANNELS                               *|
|*  DEPENDING ON THE SET OF CONTAINER NAMES IN THE ICH__ VAR,    *|
|*  EACH CONTAINER WILL HAVE A SET OF ISPF VARS BASED ON THE '__'*|
|*  ASSIGNED CHANNEL REFERENCE WHERE THE SET IS NAMED            *|
|*   ICN__## WHERE THE ## IS A NUMERIC VALUE 01 - 99 ASSIGNED TO *|
|*           THE RESPECTIVE CONTAINER, BASED ON POS IN THE       *|
|*           ICH__ CONTAINER LIST                                *|
|*           AN THE 'ICN' PREFIXES IDENTIFIES THE CN NAME        *|
|*   ICV__## SIMILARLY IDENTIFIES THE CN VALUE                   *|
|*   ICT__## SIMILARLY IDENTIFIES THE CN TYPE((B OR C) FOLLOWED  *|
|*           THE DESIRED CN LENGTH (TRAILING NULLS/SPACES)       *|
|*                                                               *|
\*                                                               */
   IF CHNM \= '' THEN DO
    CALL CHK_CHNM
    IF XC > 4 THEN SIGNAL EXITRC20
    IF CHNM \= 'COMMAREA' THEN SIGNAL GOT_CNC
    END
   IF MYCMD = 'PING' THEN DO
    MYCA = 'PING EXCIS0 MSG FROM \@'
    MYCAL = DFT_PING_CAL
    SIGNAL SETPROG
    END
   IF MYCA = '' & MYCMD \= 'LINK' THEN SIGNAL BADCA
   IF MYCAL = '' THEN MYCAL = LENGTH(MYCA)
   IF DATATYPE(MYCAL) ^= 'NUM' THEN SIGNAL BADCA
   IF MYCAL < 0 | MYCAL > MAX_CAL THEN SIGNAL BADCA
   IF MYCMD = 'LINK' THEN DO
    IF MYPROG = '' THEN SIGNAL BADLINK
    IF MYTRANID = '' THEN MYTRANID = 'CSMI'
     ELSE DO
     LTRID = LENGTH(MYTRANID)
     IF LTRID < 1 | LTRID > 4 THEN SIGNAL BADLINK
     END
    SIGNAL SET_H_VARS
    END
SETPROG:
   IF MYTRANID = '' THEN MYTRANID = 'CSMI'
   MYPROG=DFT_UCEMPIN
SET_H_VARS:
   L_CA = LENGTH(MYCA)
   IF MYCAL < L_CA THEN MYCAL = L_CA
   H_MYCA = MYCA
   H_MYCAL = MYCAL
   H_MYPROG = MYPROG
   H_MYTRANID = MYTRANID
   TOTLNG=0
TSTAPLIDS:
   I = 0
   COMA=','
   IF MYAPLID = '' THEN SIGNAL EXITRC16
   DO WHILE(MYAPLID ^= '')
    I = I + 1
    PARSE VAR MYAPLID APL_STM.I MYAPLID
 /* TRACE OFF */
    END
   APL_STM.0 = I
   H_I = I
   JOBLS='N'
   "ISPEXEC VGET (AFOJOBLS AFOAPLLS) SHARED"
   IF RC = 0 THEN JOBLS='Y'
 /* OK HERE WE GO */
   IF MYFUNC = 'MSGBOXALL' | MYFUNC = 'QUIET' THEN DO
    MSGLOCK='Y'
    MSGSTAT='CONTPOP'
    MSGBOXTX='STARTING: PROCESSING ALL APPLIDS...'
    ADDRESS ISPEXEC "VPUT (MSGBOXTX) ASIS"
    ADDRESS ISPEXEC "VPUT (MSGLOCK MSGSTAT) ASIS"
    CALL MSGBOX
    END
   J = 0
   MXLNG = 132
TOPOFLOP:
   /* TRACE I */
   J = J + 1
   IF J > I THEN SIGNAL DONEIT
   MYAPLID = APL_STM.J
   MYCA = H_MYCA
   MYCAL = H_MYCAL
   IF JOBLS = 'Y' THEN DO
    APLPOS=WORDPOS(MYAPLID,AFOAPLLS)
    IF APLPOS = 0 THEN SIGNAL NOSUB_CA
    JOBNM=WORD(AFOJOBLS,APLPOS)
   /* NEW CODE V2 */
   /* TRACE I */
   S#APLID = MYAPLID
   IF LENGTH(S#APLID) < 7 THEN INTERPRET "T#PARM = 'S#"||S#APLID||"'"
     ELSE INTERPRET "T#PARM = 'S#"||SUBSTR(S#APLID,3)||"'"
   INTERPRET T#PARM " = S#VALUE"
   'ISPEXEC VGET ('T#PARM') ASIS'
   IF RC > 0 THEN S#PARM = MYAPLID
    ELSE INTERPRET 'S#PARM = 'T#PARM
      TRACE OFF
   /* NEW CODE V2 */
    SUBWDS= MYAPLID||' '||JOBNM||' '||S#PARM||' \'
    DO K = 1 TO RW_CT
     TMPCAL=LENGTH(MYCA)
     SWD = WORD(REPWDS,K)
     RWD = WORD(SUBWDS,K)
     WP = 999
     DO UNTIL WP = 0
      WP = POS(SWD,MYCA)
      IF WP > 0 THEN DO
       IF WP = 1 THEN DO
        MYCA=RWD||SUBSTR(MYCA,WP+2)
        END
        ELSE DO
        IF WP = TMPCAL - 1 THEN ,
         MYCA=SUBSTR(MYCA,1,WP-1)||RWD
         ELSE ,
         MYCA=SUBSTR(MYCA,1,WP-1)||RWD||SUBSTR(MYCA,WP+2)
        END
       TMPCAL=LENGTH(MYCA)
       END
      END
    IF TMPCAL > MAX_CAL THEN DO
     TMPCAL = MAX_CAL
     MYCA=SUBST(MYCA,1,MAX_CAL)
     END
    IF TMPCAL > H_MYCAL THEN DO
     MYCAL=TMPCAL
     END
    END
NOSUB_CA:
   MYPROG = H_MYPROG
   MYTRANID = H_MYTRANID
  "ISPEXEC VPUT (MYAPLID MYPROG MYCA MYCAL MYTRANID) ASIS"
   IF RC ^= 0 THEN SIGNAL CHK_ERR
   IF MYFUNC = 'MSGBOXALL' | MYFUNC = 'QUIET' THEN DO
    MSGBOXTX=MYFUNC||' '||MYCMD||'... PROCESSING >'||MYAPLID            T
    ADDRESS ISPEXEC "VPUT (MSGBOXTX) ASIS"
    CALL MSGBOX
    END
   CALL EXCIS2 MYFUNC
   XC = RESULT
   IF XC = 4 THEN SIGNAL DONEIT
   IF MYFUNC = 'MSGBOXALL' | MYFUNC = 'QUIET' THEN DO
    /* TRACE ?I */
    TMP=XFF||LEFT(MYAPLID,8)||'-->'||XFF
    IF XC ^= 0 THEN TMP = TMP||'WARNING - CALL RETURNED 'XC||XFF
    "ISPEXEC VGET (MYCA) ASIS"
    MYCA = STRIP(MYCA,'B')
    APL_STM.J = TMP||TRANSLATE(MYCA,XFF,X15)
    IF AUTOSAVE = 'N' THEN SIGNAL CHK_CAL
    "ISPEXEC VGET (DSPLYADS) ASIS"
    IF RC \= 0 THEN DO
     ZEDSMSG = 'AUTOSAVE DSN BAD'
     ZEDLMSG = 'AUTOSAVE FOR REGION 'MYAPLID' DSN BAD'
     'ISPEXEC SETMSG MSG(ISRZ000)'
     APL_STM.J ='AUTOSAVE FAIL:DSN BAD:'MYAPLID||XFF||APL_STM.J
     SIGNAL CHK_CAL
     END
    PARSE VAR DSPLYADS EDSN '(' EMBR ')'
    TDSN = EDSN
   /* DO THE AUTOSAVE ACTION */
    H_MYAREA=APL_STM.J
    L = 0
    DO WHILE H_MYAREA \= ''
     L = L + 1
     PARSE VAR H_MYAREA MYA.L (XFF) H_MYAREA
     WL=LENGTH(MYA.L)
     IF WL > MXLNG THEN MXLNG = WL
     TRACE OFF
     END
    /* TRACE ?I */
    MYA.0 = L
    EMBR=MYAPLID
    M# = MYA.0
    MYSTM='MYA.'
    CALL SAVIT
    DROP MYA.
    IF XC \= 0 THEN DO
     ZEDSMSG = 'AUTOSAVE FAILED.'
     ZEDLMSG = 'AUTOSAVE FOR REGION 'MYAPLID' FAILED.'
     'ISPEXEC SETMSG MSG(ISRZ000)'
     APL_STM.J ='AUTOSAVE FAIL:SAVIT:'MYAPLID||XFF||APL_STM.J
     END
     ELSE DO
     ZEDSMSG = 'AUTOSAVE SUCCESS'
     ZEDLMSG = 'AUTOSAVE FOR REGION 'MYAPLID' SUCCESSFUL.'
     'ISPEXEC SETMSG MSG(ISRZ000)'
     APL_STM.J ='AUTOSAVE SUCCESSFUL:'MYAPLID
     END
    END
 CHK_CAL:
    L_CA=LENGTH(APL_STM.J)
    TOTLNG=TOTLNG+L_CA
    IF L_CA > MAX_CAL THEN SIGNAL TOOMUCH
 GO_NEXT:
    SIGNAL TOPOFLOP
 DONEIT:
   IF MYFUNC = 'VERBOSE' | MYFUNC = 'MSGBOXONLY' THEN SIGNAL EXITRC0
   J = H_I
   IF MYFUNC = 'MSGBOXALL' THEN DO
    MSGSTAT='REMPOP'
    MSGBOXTX= '< FINISHED PROCESSING SELECTION LIST. WRITING RESULTS'
    ADDRESS ISPEXEC "VPUT (MSGSTAT MSGBOXTX) ASIS"
    CALL MSGBOX
    EXECSEL = 'MSGBOXAL'
    "ISPEXEC VPUT (EXECSEL) ASIS"
    MYAREA=''
    DO I = 1 TO J
     MYAREA=MYAREA||XFF||APL_STM.I
     END
    MYCA = H_MYCA
    MYAREA#=XFF
    MYAREA='PROCESSED 'J' REGIONS. FINISHED AT 'DATE('U')||' '||,
           TIME()||XFF||'TO:'||DSPLYADS||XFF||MYAREA
    M$L=LENGTH(MYAREA)
    IF M$L > MAX_CAL THEN DO
     M$CT=0
     MAVAR=''
     M$L_MX=MAX_CAL
     DO WHILE (M$L > 0)
      M$CT=M$CT +1
      DVAL=MYARE||M$CT
      INTERPRET DVAL||' = SUBSTR(MYAREA,1,'M$L_MX')'
      MAVAR = MAVAR||DVAL||' '
      MYAREA=SUBSTR(MYAREA,M$L_MX+1)
      M$L=LENGTH(MYAREA)
      IF M$L < M$L_MX THEN M$L_MX = M$L
      END
/*   MYAREA='!!OVERFLOW: PARTIAL RESULT RETURNED!!'||,
      SUBSTR(MYAREA,1,MAX_CAL - 38) */
     MAVAR=STRIP(MAVAR,'B')
     "ISPEXEC VPUT ("MAVAR") ASIS"
     MYAREA#=XFF||'<'||M$CT||'>'
     END
    "ISPEXEC VPUT (MYAREA MYAREA#) ASIS"
    CALL DSPLYA
    RETURN 0
    END
/* MYFUNC = QUIET : WRITE OP TO ODSN */
DO_ODSN:
  IF MYFUNC ^= 'QUIET' THEN SAY MUFUNC 'IS NOT EXPECTED:EXPECT:QUIET'
  IF ODSN = '' THEN SIGNAL EXITRC10
  MYSTM='APL_STM.'
  PARSE VAR ODSN TDSN '(' EMBR ')'
  EDSN = ODSN
SAVIT:
  EXECSEL='EXCIS0'
  DSPVAL='SHR REUSE'
  CALL MALOC TDSN
  XC=RESULT
  IF XC = 0 THEN SIGNAL CHKORG
  IF EMBR = '' THEN MYDSO='PS)'
   ELSE DO
    MYDSO='PO) DSNTYPE(LIBRARY)'
   END
  MODDSN = ''
  M=MXLNG+4
  DSEMSG = '(D) DEL/REALLOC,(A) ABORT'
  MODATTR="NEW BLKSIZE("M+4") DSORG("MYDSO" RECFM(V,B) SPACE(1,1)"||,
   "CYLINDER LRECL("M") CATALOG REUSE"
  "ISPEXEC VPUT (EDSN EXECSEL DSEMSG MODATTR MODDSN) ASIS"
  IF RC ^= 0 THEN SIGNAL EXITRC8
  CALL ALOCDSN
  XC = RESULT
  "ISPEXEC VGET (EDSN) ASIS"
  IF RC ^= 0 THEN RETURN 4
  SIGNAL DOWRITE
 CHKORG:
   XC=LISTDSI("'"TDSN"'" DIRECTORY NORECALL)
   MYDSO=SYSDSORG
   IF EMBR \= '' THEN DO
    IF MYDSO = 'PS' THEN SIGNAL BADOPDSNORG
    END
    ELSE DO
    IF MYDSO = PO THEN SIGNAL BADOPDSNORG
    IF AUTOSAVE = 'Y' THEN DSPVAL='MOD'
    END
  DOWRITE:
   /* TRACE ?I */
   DSPLYADS=EDSN
    IF EMBR \= '' THEN EDSN=EDSN||'('||EMBR||')'
   "ISPEXEC VPUT (DSPLYADS EMBR) ASIS"
   ADDRESS TSO "ALLOC FI(O) DA('"EDSN"') "DSPVAL
   ADDRESS TSO "EXECIO "M#" DISKW O (STEM "MYSTM" FINIS"
   ADDRESS TSO "FREE FI(O)"
   RETURN 0
BADOPDSNORG:
   CALL MSGBOX 'SAVE TO DSN DSORG INCONSISTENT WITH EXISTING DSN'
   RETURN 4
  END
 BADCA:
    ERR=MYCMD' COMMAND: MISSING COMMAREA'
    SIGNAL DOERR
 BADLINK::
    ERR='LINK  COMMAND: INVALID PROGRAM, COMMAREA OR TRANSID'
    SIGNAL DOERR
 BADPARM:
    ERR=TMP
    SIGNAL DOERR
 EXITRC4:
    ERR='PARAMETER ERROR:'||PRM_RC
    SIGNAL DOERR
 EXITRC8:
    ERR='NO VALID FUNCTION REQUESTED'
    SIGNAL DOERR
 EXITRC10:
    ERR='FUNCTION:QUIET, BUT NO OUTPUT DESTINATION PROVIDED.'
    SIGNAL DOERR
 EXITRC12:
    ERR='COMMAND:'MYCMD': IS NOT A VALID COMMAND.'
    SIGNAL DOERR
 EXITRC16:
    ERR='APPLID IS NOT PROVIDED.'
    SIGNAL DOERR
 EXITRC20:
    ERR='CHNM:'CHNM': IS NOT ON THE LIST OF VALID CHANNELS'
    SIGNAL DOERR
 EXITRC0:
 DOERR:
 RETURN XC
/*                                                               *\
|* USING THE CHNM, VERIFY THAT THE CHNM IS ON THE GLOBAL LIST    *|
|*  OF NOWN CHANNEL NAMES. IF NOT, THEN RETURN RC 8              *|
\*                                                               */
 CHK_CHNM:
   XC = 0
   'ISPEXEC VGET (ICHLST) ASIS'
   XC = RC
   IF XC > 4 THEN RETURN XC
   IF WORDPOS(CHNM,ICHLST) = 0 THEN RETURN 8
   RETURN 0
###END EXCICNC
$$$BEG DSPCNCCN
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA          -                                              */
 /* CEMHELP          - TSO BASE, RESTRICTED                         */
 /* CEMHELP          -                                              */
 /* CEMHELP END                                                     */
HELPTOP:
 /*                                                                 *\
 |* MANGE THE SET OF CONTAINERS ASSOCIATED WITH A CHANNEL           *|
 |*  CHANNEL NAME PASSED AS ARG; MUST EXIST; CN OPTIONS ARE:        *|
 |*  EDIT    REVIEW AND EDIT THE CN CONTENTS                        *|
 |*  COPY    COPY AS A NEW CONTAINER                                *|
 |*  ADD     ADD A NEW CONTAINER                                    *|
 |*  DELETE  REMOVE THE CONTAINER FROM THE CHANNEL                  *|
 |*  USE EDIT TO REVIEW THE CN CONTENTS                             *|
 \*                                                                 */
HELPBOT:
 HELPTOP_SRCLN = 8
 HELPBOT_SRCLN = 16
 /*                                                                 *\
 |* THE ABOVE SRCLN VARS ARE USE IN THE HELP OPTION                 *|
 |*  IF YOU ADD OR DELETE LINES WITHIN THE HELPTOP:HELPBOT LABELS   *|
 |*   YOU MUST ADJUST THE SCRLN VARS ACCORDINGLY                    *|
 \*                                                                 */
  FFX ='FF'X
  HELPDATA=FFX
  /* TRACE I */
     TRACE I
  PARSE ARG CHNM
  IF CHNM = '' THEN DO
   MSGTXT = '!!! ERROR - DISPLAY CHANNEL CONTAINERS REQUIRES 1 ARG:'||,
    FFX||'  CHANNEL_NAME. ABORTING.'
   CALL SHOWMBOX
   RETURN 8
   END
  ADDRESS ISPEXEC
   /*                                                     *\
   |*  VGET CHANNEL VARS TO SEE IF THIS IS FIRST TIME     *|
   |*   IF NF (FIRST), CREATE DEFAULT CH AND CN           *|
   \*                                                     */
  ICHLST = ''
  'ISPEXEC VGET (ICHLST) ASIS'
  IF RC > 4 THEN DO
   MSGTXT = '!!! ERROR - DISPLAY CHANNEL CONTAINERS COULD NOT VGET '||,
     ' CHANNEL LIST (ICHLST). ABORTING.'
   CALL SHOWMBOX
   RETURN 8
   END
  CN#=WORDPOS(CHNM,ICHLST)
  IF CN# = 0 THEN DO
   MSGTXT = '!!! ERROR - DISPLAY CHANNEL CONTAINERS FOUND 0 CHANNEL'||,
     ' NANMES IN CHANNEL LIST (ICHLST). ABORTING.'
   CALL SHOWMBOX
   RETURN 10
   END
  V='ICH'||SUBSTR('0'||CN#,LENGTH(I),2)
  H_V = V
  'ISPEXEC VGET ('V') ASIS'
  IF RC > 4 THEN DO
   MSGTXT = 'ERROR: COULD NOT ACCESS CONTAINER LIST FOR CHANNEL '||,
    'NAME:'CHNM': VGET RC:'RC':'
   CALL SHOWMBOX
   RETURN 12
   END
  INTERPRET 'CN_LST = 'V
  H_N = 'ICN'||SUBSTR(h_V,4)
  H_L = 'ICV'||SUBSTR(h_V,4)
  H_T = 'ICT'||SUBSTR(h_V,4)
  ICNCT = WORDS(CN_LST)
  XC = 8
  /*                                                      *\
  |*  USING ISP VAR TO STORE THE FOLLOWING:               *|
  |*   CHANNEL NAMES (01 TO 99) STORED IN VAR ICH__       *|
  |*   WHERE THE __ PROVIDES ACCESS TO THE CH NAME        *|
  |*   THE LIST OF CHANNEL NAMES ARE IN VAR ICHLST        *|
  |*   USING THE POSITION OF THE CH NAME, WE CAN IMPLY    *|
  |*   THE REFERENCE TO THE RESPECTIVE SET OF CN FOR CH   *|
  |*   BY USING WORDPOS TO DERIVE THE __ COMPONENT OF     *|
  |*   THE RESPECTIVE ICN__## ICV__## PAIRS               *|
  |*                                                      *|
  |*   CONTAINER NAMES ARE ASSOCIATED WITH THE CHANNEL    *|
  |*   NUMERIC. UP TO 99 CONTAINERS PER CHANNEL AND       *|
  |*   THEIR UNIQUE NAMES ARE STORE IN VAR ICN__##        *|
  |*   AND THE ASSOCIATED VALUE IN VAR     ICV__##        *|
  |*   AND THE ASSOCIATED CN TYPE IN VAR   ICT__##        *|
  |*   ALL ACTUAL CN NAMES PER  CH IN VAR  ICN__LST       *|
  |*   NOTE: THE __ ASSOCIATES TO THE ICH__ CH NAME       *|
  |*   AND   THE ## PROVIDES ACCESS TO 01-99 CN AS A GROUP*|
  |*                                                      *|
  |*   WHEN WE WANT TO GAIN ACCESS TO ALL CH DEFINED      *|
  |*    GET THE ISP VAR ICHLST:    EACH ICH__ VAR         *|
  |*    IS LISTED SPACE SEPARATED                         *|
  |*                                                      *|
  |*   USING wordpos calculated from the ichlst entry     *|
  |*    WE CAN GET THE ASSOCIATED CN LIST FOR THAT        *|
  |*    CH.                                               *|
  |*   GET THE LIST OF CN FOR THE CH BY VGET THE VAR      *|
  |*    ICN__LST. the wordpos of the cn in icn__lst       *|
  |*    is used to access the icn__## icv__## ISP VARs    *|
  |*    where the __ is RESPECTIVE to ich0__ name         *|
  |*    AND THE ## IS A 01-99 VALUE and is respective to  *|
  |*    ## in ICN__## CONTAINING THE CONTAINER NAME       *|
  |*    and ## in ICv__## CONTAINING THE CONTAINER value  *|
  |*    and ## in ICt__## CONTAINING THE CONTAINER type   *|
  |*       (B (bit) or C (char) followed by a length      *|
  |*       for instance: B23 or C65000)                   *|
  |*                                                      *|
  |*   FOR EXAMPLE: (NOTE:LOWER CASE IS ACCEPTABLE)       *|
  |*    ICHLST HOLDS 'AFO_DFLT_CHNM A_NEW_CHANNEL_NM' LIST*|
  |*    ICH01 HOLDS LIST OF CN IN CH AFO_DFLT_CHN         *|
  |*          'CEMT000# CEDA000#_IS_LONG'                 *|
  |*    ICN0101='CEMT000#'                                *|
  |*    ICV0101='CEMT INQUIRE TASK    '                   *|
  |*    ICT0101='C22'                                     *|
  |*    ICN0102='CEDA000#_IS_LONG'                        *|
  |*    ICV0102='CEDA EXPAND GROUP(XXXXXXXX)'             *|
  |*    ICT0102='C27'                                     *|
  |*                                                      *|
  |*  NOTE: TO DYNAMICALLY FORMAT THE ICN AND ICV VAR NAME*|
  |*   USE THE SAMPLE CODE WHERE '2' IS THE NUM OF DIGITS *|
  |*   TO BE INSERTED INTO THE VAR NAME :01-99 UNIQUE VARS*|
  |*   WORDS FUNCTION ALWAYS TRUNCATES LEATING ZEROS      *|
  |*   '0' MAKES 1 PREFIX DIGIT AVAILABLE                 *|
  |*  U='ICN'||SUBSTR('0'||WORDS(ICHLST),LENGTH(ICHLST),2)*|
  |*  INTERPRET U' = "AFO_CN_NAME'                        *|
  \*                                                      */
  /* channel or container names composed of 1 to 16:      *\
  |* The acceptable characters are A-Z a-z 0-9 $ @ # / %  *|
  |* & ? ! : | " = , ; < > . - and _                      *|
  \*                                                      */
  /*                                                      *\
  |* exit   the initialization do loop                    *|
  |* VGET SIDE IS DONE BELOW FOR CHANNEL TABLE            *|
  \*                                                      */
  /* ARG CHNM   */
  SUID=SYSVAR(SYSUID)
  SDT=DATE('U')
  FDS=1
  AMT='CSR'
  ACTION='-'
  SIGNAL OFF ERROR
  ADDRESS ISPEXEC
  "ISPEXEC CONTROL ERRORS RETURN"
  IF SYSVAR(SYSNEST) = 'NO' THEN DO
   MDSN='TTED.TSK.D.TCEM.ISPPLIB'
   "ISPEXEC LIBDEF ISPPLIB DATASET ID('"MDSN"') COND"
   IF RC \= 0 THEN DO
     MSGTXT='ERROR ON LIBDEF ISPPLIB::'MDSN
     SIGNAL SHOWMBOX
     END
   END
  ZWINTTL = 'AFOLIST CNC CN LIST'
  "ISPEXEC ADDPOP ROW(2) COLUMN(20)"
  /* TBLCNCCN HAS 5 COLS: ACTION CONTAINERNAME CN_TYPE CN_LNG CN_DATA */
  "ISPEXEC TBCREATE TBLCNCCN "||,
    "NAMES(ACTION FA FB FC FD) NOWRITE REPLACE"
   IF RC > 4 THEN DO
   MSGTXT ='COULD NOT CREATE: TBLCNCCN CONTAINER NAMES TABLE FOR LIST'
   CALL   SHOWMBOX
   SIGNAL DO_FIN
   END
  FA = '-'
  FB = '-'
  FC = 0
  FD = '---'
  IF ICNCT = 0 THEN DO
    "ISPEXEC TBADD TBLCNCCN"
   END
   ELSE DO
   DO I = 1 TO ICNCT
    FA = WORD(CN_LST,I)
    U=H_T||SUBSTR('0'||I,LENGTH(I),2)
    'ISPEXEC VGET ('U') ASIS'
    IF RC > 4 THEN DO
     MSGTXT ='COULD NOT ACCESS ISP VAR:'U': FROM CHLST:'ICHLST':'
     CALL   SHOWMBOX
     SIGNAL DO_FIN
     END
    INTERPRET 'FB = 'U
    U=H_L||SUBSTR('0'||I,LENGTH(I),2)
    'ISPEXEC VGET ('U') ASIS'
    IF RC > 4 THEN DO
     MSGTXT ='COULD NOT ACCESS ISP VAR:'U': FROM CHLST:'ICHLST':'
     CALL   SHOWMBOX
     SIGNAL DO_FIN
     END
    INTERPRET 'FD = 'U
    FC = LENGTH(FD)
    "ISPEXEC TBADD TBLCNCCN"
    IF I > 5 THEN TRACE OFF
    END
   END
  /* TRACE I */
  EXECSEL='DSPCNCCH'
  "ISPEXEC TBTOP TBLCNCCN"
  "ISPEXEC VPUT (EXECSEL) ASIS"
  CANSTR='CANCEL ABORT'
  DONSTR='DONE END'
  CMDSTR=CANSTR||' '||DONSTR
  PROCLST='-,E,C,A,D'
  PROCLST_WDS=TRANSLATE(PROCLST,' ',',')
  PROCLSTWD='- EDIT COPY ADD DELETE'
  MCMD=''
  UPDTIND=0
  LSTHDR='AFOLIST CONTAINER LIST'
  CHORCN='CONTAINER NAME'
  MYCRP = 0
  /* trace ?i */
 TOPOFLOP:
  "ISPEXEC TBDISPL TBLCNCCN PANEL(DSPCNCHL) ROWID(MDROW#) POSITION(MYCRP)"
  XC = RC
  IF XC > 8 THEN DO
   MSGTXT ='SEVERE ERROR FROM TBDISPL FUNCTION.  ABORT.'
   CALL   SHOWMBOX
   SIGNAL OKDOIT
   END
  NUD=ZTDSELS
  HR#=MDROW#
  HC#=MYCRP
  IF ZTDSELS > 0 THEN DO
   DO WHILE (ZTDSELS > 0)
    R#=MDROW#
    ACT_W#=WORDPOS(ACTION,PROCLST_WDS)
    ACT_WD=WORD(PROCLSTWD,ACT_W#)
    XX ='P:'||ACT_WD||':@:'||R#
    ACTION = '-'
    "ISPEXEC TBPUT TBLCNCCN"
    CNWD=WORDPOS(FA,CN_LST)
    IF ACT_WD = 'EDIT' THEN DO
      CALL getafocn chnm fa fb fc fd
      Y=H_T||SUBSTR('0'||CNWD,LENGTH(CNWD),2)
      INTERPRET Y' = FB'
      'ISPEXEC VPUT ('Y') ASIS'
      Y=H_L||SUBSTR('0'||CNWD,LENGTH(CNWD),2)
      INTERPRET Y' = FD'
      'ISPEXEC VPUT ('Y') ASIS'
     END
    IF ACT_WD = 'COPY' THEN DO
     ichct = words(ichlst)
     if ichct > 98 then do
      MSGTXT ='PF3 OR END SELECTED. FINISHING UP.'
      CALL   SHOWMBOX
      end
      else do
      CALL DO_COPY
      END
     END
    IF ACT_WD = 'DELETE' THEN DO
      CALL DO_DEL
     END
    "ISPEXEC TBDISPL TBLCNCCN"
    IF ZTDSELS < 2 THEN LEAVE
    END
   END
  IF XC = 8 THEN DO
   MSGTXT ='PF3 OR END SELECTED. FINISHING UP.'
   CALL   SHOWMBOX
   MCMD = 'END'
   END
  IF POS('?',MCMD) > 0 THEN DO
   CALL DO_HELP
   MCMD = ''
   SIGNAL TOPOFLOP
   END
  IF WORDPOS(MCMD,CMDSTR) = 0 THEN SIGNAL TOPOFLOP
  IF WORDPOS(MCMD,CANSTR) \=  0 THEN DO
   MSGTXT='COMMAND:'MCMD' SIGNALS ABORT'
   CALL   SHOWMBOX
   SIGNAL DO_FIN
   END
  IF WORDPOS(MCMD,DONSTR) \= 0 THEN SIGNAL OKDOIT
  MSGTXT='UNKNOWN COMMAND:'MCMD' SIGNALS ABORT'
  CALL   SHOWMBOX
  SIGNAL TOPOFLOP
/*PROCESS COMMANDS */
/*LOOP TO TOPOFLOP UNTIL SAVE COMMAND */
 OKDOIT:
  "ISPEXEC TBCLOSE TBLCNCCN"
   /* TRACE I */
 DO_FIN:
  "ISPEXEC REMPOP"
   'ISPEXEC LIBDEF ISPPLIB'
   ADDRESS TSO
   MSGTXT='FINISHED PROCESSING TABLE'
   XC = 0
SHOWMBOX:
   SAY MSGTXT
   RETURN
DO_COPY:
      CNCTYP = ACT_WD||'-CHAN'
      CNCMSG='enter new channelnm'
      CNFROM=FA
      CNTO='-'
      CMD=''
      VALCMD='CANCEL END'
/*    "ISPEXEC CONTROL DISPLAY SAVE" */
      ZWINTTL = 'Copy Channel'
      "ISPEXEC ADDPOP POPLOC(FB)"
 TOPOFCOPY:
      "ISPEXEC DISPLAY PANEL(GETAFOCH)"
      YC=RC
      XCMD=ZCMD
      IF YC > 8 | WORDPOS(XCMD,CANSTR) \=  0 THEN SIGNAL FIN_COPY
      IF YC = 8 THEN XCMD = 'END'
      IF CNTO \= '-' THEN DO
       IF WORDPOS(CNTO,ICHLST) \= 0 THEN DO
        XCMD = ''
        cncmsg = 'Channel exists!'
        end
        else do
        j = wordpos(fa,ichlst)
        U='ICH'||SUBSTR('0'||j,LENGTH(I),2)
        k = words(ichlst) + 1
        v='ICH'||SUBSTR('0'||k,LENGTH(I),2)
        'ISPEXEC VGET ('U') ASIS'
        IF RC > 4 THEN DO
         msgtxt = 'error: could not copy:'fa':ispf var error:'rc
         signal fin_copy
         end
        interpret 'a = 'u
        interpret v' =  a'
        'ISPEXEC Vput ('V') ASIS'
        IF RC > 4 THEN DO
         msgtxt = 'error: could not vput:'v':ispf var error:'rc
         signal fin_copy
         end
        interpret 'w = words('v')'
        hcnwd1=''
        do x = 1 to w
         y = u||SUBSTR('0'||x,LENGTH(x),2)
         y = 'ICN'||substr(y,4)
         z = v||SUBSTR('0'||x,LENGTH(x),2)
         z = 'ICN'||substr(z,4)
         'ISPEXEC VGET ('Y') ASIS'
         IF RC > 4 THEN DO
          msgtxt = 'error: could not copy:'y':ispf var error:'rc
         signal fin_copy
         end
         if x = 1 then interpret 'hcnwd1 = 'y
         interpret 'a = 'y
         interpret z' = a'
         'ISPEXEC VPUT ('Z') ASIS'
         IF RC > 4 THEN DO
          msgtxt = 'error: could not vput:'z':ispf var error:'rc
         signal fin_copy
         end
         y = 'ICV'||substr(y,4)
         z = 'ICV'||substr(z,4)
         'ISPEXEC VGET ('Y') ASIS'
         IF RC > 4 THEN DO
          msgtxt = 'error: could not copy:'y':ispf var error:'rc
         signal fin_copy
         end
         interpret 'a = 'y
         interpret z' = a'
         'ISPEXEC VPUT ('Z') ASIS'
         IF RC > 4 THEN DO
          msgtxt = 'error: could not vput:'z':ispf var error:'rc
         signal fin_copy
         end
         Y = 'ICT'||SUBSTR(Y,4)
         Z = 'ICT'||SUBSTR(Z,4)
         'ISPEXEC VGET ('Y') ASIS'
         IF RC > 4 THEN DO
          msgtxt = 'error: could not copy:'y':ispf var error:'rc
         signal fin_copy
         end
         interpret 'a = 'y
         interpret z' = a'
         'ISPEXEC VPUT ('Z') ASIS'
         IF RC > 4 THEN DO
          msgtxt = 'error: could not vput:'z':ispf var error:'rc
         signal fin_copy
         end
        end
  trace ?i
       ichlst = ichlst||' '||cnto
       "ISPEXEC VPUT (ICHLST) ASIS"
       IF RC > 4 THEN DO
        msgtxt = 'error: could not vput UPDATED CHANNEL LIST:'ICHLST
        signal fin_copy
        END
       FA = cnto
       FB = w
       FB = SUBSTR('0'||FB,LENGTH(FB),2)
       FC = hcnwd1
       FD = '---'
       "ISPEXEC TBADD TBLCNCCN"
       SAY 'COPY FROM:'CNFROM':TO:'CNTO':'
       CNTO = '-'
       XCMD = 'DONE'
       END
      IF WORDPOS(XCMD,DONSTR) =  0 THEN SIGNAL TOPOFCOPY
 FIN_COPY:
      IF RC > 0 THEN DO
       CALL SHOWMBOX
       END
      "ISPEXEC REMPOP"
 /*   "ISPEXEC CONTROL DISPLAY RESTORE" */
      RETURN
 DO_ADD:
      CNCTYP = ACT_WD||'-CN_NM'
      CNCMSG='ENTER NEW CONTAINER NM'
      CNFROM=''
      CNTO='-'
      CMD=''
      VALCMD='CANCEL END'
 /*   "ISPEXEC CONTROL DISPLAY SAVE" */
      ZWINTTL = '1ST CN NAME'
      "ISPEXEC ADDPOP POPLOC(FB)"
 TOPOFADD:
      "ISPEXEC DISPLAY PANEL(GETAFOCH)"
      YC=RC
      XCMD=ZCMD
      IF YC > 8 | WORDPOS(XCMD,CANSTR) \=  0 THEN SIGNAL FIN_add
      IF YC = 8 THEN XCMD = 'END'
      IF CNTO \= '-' THEN DO
       IF WORDPOS(CNTO,CN_LST) \= 0 THEN DO
        XCMD = ''
        CNCMSG = 'CONTAINER EXISTS!'
        end
        else do
        CN_LST = CN_LST||' '||CNTO
        cn_wds = words(cn_lst)
        v = h_v
        INTERPRET V' = CN_LST'
        "ISPEXEC VPUT ('V') ASIS"
        IF RC > 4 THEN DO
         MSGTXT = 'ERROR: COULD NOT VPUT UPDATED CONTAINER LIST:'V
         SIGNAL FIN_ADD
         END
        CN_PFX = SUBSTR(CNTO,1,4)
        SELECT
        WHEN CN_PFX = 'CEMT' THEN DO
         FB = 'CHAR'
         FD = 'CEMT INQUIRE TASK'
         FC = LENGTH(FD)
         END
        WHEN CN_PFX = 'CEDA' THEN DO
         FB = 'CHAR'
         FD = 'CEDA EXPAND GROUP(XXXXXXXX)'
         FC = LENGTH(FD)
         END
        WHEN CN_PFX = 'PING' THEN DO
         FB = 'CHAR'
         FD = 'PINGThis is a new Container'
         FC = LENGTH(FD)
         END
        otherwise do
         FA = CNTO
         FB = 'CHAR'
         FC = 50
         FD = '---'
        end
        call getafocn  chnm fa fb fc fd
        if rc > 4 then do
         msgtxt = 'Error: Could not add new CN:'cnto': RC='rc
         signal fin_add
         end
        "ISPEXEC TBADD TBLCNCCN"
        msgtxt = 'ADD NEW  :------:AS:'CNTO':'
        CNTO = '-'
        XCMD = 'DONE'
        END
       END
      IF WORDPOS(XCMD,DONSTR) =  0 THEN SIGNAL TOPOFADD
 FIN_ADD:
      IF RC > 0 THEN DO
       CALL SHOWMBOX
       END
      "ISPEXEC REMPOP"
 /*   "ISPEXEC CONTROL DISPLAY RESTORE" */
      RETURN
 DO_DEL:
  IF CNTO \= '-' THEN DO
   MSGTXT = 'NOT VALID CN'
   SIGNAL FIN_DEL
   END
   OKWINTL = 'Delete Container'
   OKCAN1 = 'Delete CN:'f1
   OKCAN2 = '(O)K TO DELETE, (C)ANCEL TO ABORT'
   OKCANX = 'C'
   ADDRESS ISPEXEC 'VPUT (OKWINTL OKCAN1 OKCAN2 OKCANX) ASIS'
   CALL OKCANBOX
   IF RESULT \= 0 THEN SIGNAL FIN_DEL
   CNTO=FA
   CNPOS = WORDPOS(CNTO,CN_LST)
   J = CNPOS
   CNWDS = WORDS(CN_LST)
   V = H_V
   U = H_V
 TOPOFDEL:
   K = J + 1
   Y = U||SUBSTR('0'||J,LENGTH(X),2)
   Y = 'ICN'||SUBSTR(Y,4)
   Z = V||SUBSTR('0'||K,LENGTH(X),2)
   Z = 'ICN'||SUBSTR(Z,4)
   IF J = CNWDS THEN SIGNAL DEL_LST_CN
   'ISPEXEC VGET ('Z') ASIS'
    IF RC > 4 THEN DO
     MSGTXT = 'ERROR: DEL VGET N_SRC:'Z':ISPF VAR ERROR:'RC
    SIGNAL FIN_DEL
    end
   INTERPRET 'A = 'Z
   INTERPRET Y' = A'
   'ISPEXEC VPUT ('Y') ASIS'
    IF RC > 4 THEN DO
     MSGTXT = 'ERROR: DEL VPUT N_TGT:'Y':ISPF VAR ERROR:'RC
    SIGNAL FIN_DEL
    end
   Y = 'ICV'||SUBSTR(Y,4)
   Z = 'ICV'||SUBSTR(Z,4)
   'ISPEXEC VGET ('Z') ASIS'
    IF RC > 4 THEN DO
     MSGTXT = 'ERROR: DEL VGET V_SRC:'Z':ISPF VAR ERROR:'RC
    SIGNAL FIN_DEL
    end
   INTERPRET 'A = 'Z
   INTERPRET Y' = A'
   'ISPEXEC VPUT ('Y') ASIS'
    IF RC > 4 THEN DO
     MSGTXT = 'ERROR: DEL VPUT V_TGT:'Y':ISPF VAR ERROR:'RC
    SIGNAL FIN_DEL
    end
   Y = 'ICT'||SUBSTR(Y,4)
   Z = 'ICT'||SUBSTR(Z,4)
   'ISPEXEC VGET ('Z') ASIS'
    IF RC > 4 THEN DO
     MSGTXT = 'ERROR: DEL VGET V_SRC:'Z':ISPF VAR ERROR:'RC
    SIGNAL FIN_DEL
    end
   INTERPRET 'A = 'Z
   INTERPRET Y' = A'
   'ISPEXEC VPUT ('Y') ASIS'
    IF RC > 4 THEN DO
     MSGTXT = 'ERROR: DEL VPUT V_TGT:'Y':ISPF VAR ERROR:'RC
    SIGNAL FIN_DEL
    end
  J = J + 1
  SIGNAL TOPOFDEL
DEL_LST_CN:
   'ISPEXEC VERASE('Y') ASIS'
    IF RC > 4 THEN DO
     MSGTXT = 'ERROR: DEL VERASE N_LST:'Y':ISPF VAR ERROR:'RC
    SIGNAL FIN_DEL
    end
   Y = 'ICV'||SUBSTR(Y,4)
   'ISPEXEC VERASE('Y') ASIS'
    IF RC > 4 THEN DO
     MSGTXT = 'ERROR: DEL VERASE V_LST:'Y':ISPF VAR ERROR:'RC
    SIGNAL FIN_DEL
    end
   Y = 'ICT'||SUBSTR(Y,4)
   'ISPEXEC VERASE('Y') ASIS'
    IF RC > 4 THEN DO
     MSGTXT = 'ERROR: DEL VERASE T_LST:'Y':ISPF VAR ERROR:'RC
    SIGNAL FIN_DEL
    end
   CN_LST = DELWORD(CN_LST,CNPOS)
   V = H_V
   INTERPRET V' = CN_LST'
   "ISPEXEC VPUT ('V') ASIS"
   IF RC > 4 THEN DO
        MSGTXT = 'ERROR: COULD NOT VPUT REPLACE CN LIST:'V
        SIGNAL FIN_DEL
        END
   ACTION = ""
   "ISPEXEC TBDELETE TBLCNCCN"
   IF RC > 4 THEN DO
        MSGTXT = 'ERROR: COULD NOT TBDEL CN NAME (ROW):'V
        SIGNAL FIN_DEL
        END
    "ISPEXEC TBQUERY TBLCNCCN POSITION(CRPNAME)"
    CRPNAME = CRPNAME + 1
    CURSOR_LOC = "CURSOR(ACTION) CSRROW("CRPNAME")"
 FIN_DEL:
      IF RC > 0 THEN DO
       CALL SHOWMBOX
       END
 /*   "ISPEXEC CONTROL DISPLAY RESTORE"  */
      RETURN
SHOWMBOX:
 CALL MSGBOX MSGTXT
   RETURN XC
DO_HELP:
 IF LENGTH(HELPDATA) < 2 THEN DO
  DO I = HELPTOP_SRCLN TO  HELPBOT_SRCLN
   TMP=STRIP(SOURCELINE(I),'B')
   TMP=TRANSLATE(TMP,'    ','/\|*')
   HELPDATA=HELPDATA||STRIP(TMP,'B')||FFX
   END
  END
 CALL MSGBOX HELPDATA
   RETURN XC
###END DSPCNCCN
$$$BEG IPCSTRCX
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA IPCSTRCX - TSO BASE, EXTRACT TASK# AND TASK DISPATCH SEQ*/
 /* CEMHELP          - TSO BASE, EXTRACT TASK# AND TASK DISPATCH SEQ*/
 /* CEMHELP          - FROM THE SUPPLIED ABBREV FORMAT TRACE LIST   */
 /* CEMHELP END                                                     */
 ADDRESS TSO
 CALL ON HALT NAME DOIT
 CALL ON ERROR NAME DOIT
 CALL ON FAILURE NAME DOIT
   ARG EDSN
   TRVAL = 'OFF'
   IF EDSN = '' | SYSDSN("'"EDSN"'") ^= 'OK' THEN DO
    SAY EDSN
    SAY 'ENTER A VALID IPCS PRINT DATASET WITH CICS ABBREV TRACE DATA'
    PULL EDSN
    IF EDSN = '' THEN EXIT
    IF SYSDSN("'"EDSN"'") ^= 'OK' THEN DO
     SAY EDSN ' IS INVALID! BYE!'
     EXIT
     END
    END
   "ALLOC FI(I) DA('"EDSN"') SHR"
   "EXECIO * DISKR I (STEM JCL. FINIS"
   "FREE FI(I)"
   INCR = 100
   TRCT=JCL.0
   IF TRCT > 1000 THEN INCR = 1000
   IN2=0
   INCT=INCR
   TSKSTR=''
   CCCT=0
   PREVC=''
   SAY 'LOOKING FOR -INTERNAL TRACE TABLE...'
   DO I = 1 TO TRCT
    IF I = INCT THEN DO
     SAY I
     INCT=INCT+INCR
     END
    TMP=JCL.I
    IF WORD(TMP,1) = '-INTERNAL' |,
       WORD(TMP,1) = '0INTERNAL' THEN DO
     SAY '... FOUND -INTERNAL AT TRACE ENTRY 'I
     LEAVE
     END
    END
   I = I + 1
   IF I > TRCT THEN DO
    SAY 'BAD INTERNAL TRACE SUPPLIED. NEVER FOUND -INTERNAL'
    PULL
    EXIT
    END
 /*  START OF FORMATTING LOGIC */
   OP.1 = 'REPORT RUN AT:'DATE('U') TIME('N')
   OP.2 = ''
   OP.3 = 'HERE WE GO STARTING AT LINE:'I
   OP.4 = JCL.I
   OP.5 ='NOTE:LOOK AT TRACE ENTRIES APFD11 XM1101 DS0002 FOR NEW TASKS'
   OP.6 ='(READ ENTIRE TRACE TABLE TO GATHER INFO:REPORT PROGRESS)'
   OCT=6
   SAY OP.2
   SAY JCL.I
   SAY OP.4
   STLN = I
   INCT=I + INCR
   TSK_SUP_STR=''
   TSK_SUP#_STR=''
   TSUP = ''
   BYP = '1+-'
   /* LIST OF TRACE DOMAIN AND ENTRIES FOR 'ENTRY ATTACH' NEW TASKS */
   ATTCHDM = 'AP XM DS'
   ATTCHDMTP = 'FD11 1101 0002'
   ATTCHDLIT = 'TERM TRANID TASK#'
   LSTATTCH=''
   ATTCT=0
   DO I = I TO TRCT
    IF I = INCT THEN DO
     OCT=OCT+1
     OP.OCT = I
     SAY I
     INCT=INCT+INCR
     END
    TMP=JCL.I
    IF SUBSTR(TMP,1,22) = '0---TRACE TABLE END---' THEN SIGNAL FIN_LOOP
    T1=SUBSTR(TMP,1,1)
    IF POS(T1,BYP) > 0 THEN ITERATE
    TMP=STRIP(SUBSTR(TMP,2),'B')
    PARSE VAR TMP T# TCB DM DMTP DMMOD REST
    WP=WORDPOS(DM,ATTCHDM)
    IF WP \= 0 THEN DO
     IF WORDPOS(DMTP,ATTCHDMTP) \= 0 THEN DO
  /* TRACE I      */
      REST = STRIP(REST,'B')
      IF SUBSTR(REST,1,12) = 'ENTRY ATTACH' THEN DO
       REST = STRIP(SUBSTR(REST,13),'B')
       REST = TRANSLATE(REST,' ',',')
       WDS = WORDS(REST)
       IF WP = 3 THEN WP2 = WDS - 1
        ELSE WP2 = 1
       LSTATTCH=LSTATTCH||WORD(ATTCHDLIT,WP)||':'||WORD(REST,WP2)||': '
       IF WP = 3 THEN DO
        ATTCT=ATTCT + 1
        ATTLN.ATTCT = 'TASK::'||T#||': ATTACHED:'||LSTATTCH||,
                  ': AT TRACE ENTRY:'||WORD(REST,WDS)
        LSTATTCH = ''
        END
       END
      END
  /*  TRACE OFF */
     END
    NW=WORDS(TMP)
    TSK=WORD(TMP,1)
    IF PREVC ^= TSK THEN DO
     PREVC=TSK
     CCCT = CCCT + 1
     CC.CCCT = TSK WORD(TMP,WORDS(TMP))
     END
    WP=WORDPOS(TSK,TSKSTR)
    IF WP = 0 THEN DO
     OCT=OCT+1
     OP.OCT = 'RUNNING TASK 'TSK' AT LINE NUMBER 'I
     SAY OP.OCT
     TSKSTR = TSKSTR||' '||TSK
     WP=WORDPOS(TSK,TSKSTR)
     TSKSTM.WP = 0
     END
    TSKSTM.WP = TSKSTM.WP + 1
 /* OCT=OCT+1 */
 /* OP.OCT=TMP */
    END
  FIN_LOOP:
   FINLN = I
   OP.2 = 'THERE ARE :'FINLN - STLN' TRACE ENTRIES'
   SAY OCT 'TRACE RECORDS TO PROCESS'
   IF ATTCT > 0 THEN DO
    OCT = OCT+1
    OP.OCT = ATTCT ' NEW TASKS WERE STARTED IN TRACE'
    SAY OP.OCT
    DO I = 1 TO ATTCT
     OCT = OCT+1
     OP.OCT = ATTLN.I
     SAY OP.OCT
     END
    END
    ELSE SAY 'ZERO NEW TASKS WERE STARTED IN TRACE'

   SAY '-------------------------------------'
   NWDS = WORDS(TSKSTR)
   OCT = OCT + 1
   OP.OCT = 'FOUND 'NWDS' TASKS IN TRACE TABLE'
   SAY OP.OCT
   DO I = 1 TO NWDS
    TSK=WORD(TSKSTR,I)
    TMP = TSKSTM.I
    OCT = OCT + 1
    OP.OCT = 'TASK #>'TSK'< HAS 'TMP' TRACE ENTRIES'
    SAY OP.OCT
    END
   OCT = OCT + 1
   OP.OCT = '------'
   SAY OP.OCT
   OCT = OCT + 1
   OP.OCT = 'THERE WERE 'CCCT' CHANGE IN CONTROL OCCURANCES'
   SAY OP.OCT
   SAY 'DO YOU WANT TO SEE THEM AT THE TERMINAL? Y/N?'
   PULL RESP
   OCT = OCT + 1
   OP.OCT = 'CHANGE IN CONTROL SEQUENCE....'
   IF RESP = 'Y' THEN SAY OP.OCT
   DO I = 1 TO CCCT
    PARSE VAR CC.I TSK T#
    OCT = OCT + 1
    OP.OCT = LEFT('TASK #>'TSK'<',13)||' AT 'T#
    IF RESP = 'Y' THEN SAY OP.OCT
    END
   SAY 'WRITING OUTPUT TO NOTES...' OCT ' LINES? Y/N?'
   PULL RESP
   IF RESP ^= 'Y' THEN EXIT
   EDSN='TTEP.TSK.P.TCEM.NOTES(IPCSTRAC)'
   EXECSEL = 'IPCSTRCX'
   DSEMSG = 'SAVE THE DATA TO YOUR PDS HERE'
   MYVERB = 'ABORT CANCEL'
   ADDRESS ISPEXEC
   "ISPEXEC VPUT (EDSN) ASIS"
   "ISPEXEC VPUT (DSEMSG EXECSEL) ASIS"
   "ISPEXEC VPUT (MYVERB) ASIS"
   CALL DSNWIND
   XC = RESULT
   IF XC > 4 THEN SIGNAL EXITRC2
   ADDRESS ISPEXEC "VGET (EDSN MYVERB) ASIS"
   IF RC ^= 0 THEN SIGNAL EXITRC8
 /* SIMPLE TEST OF MYVERB */
   IF MYVERB ^= '' THEN DO
    IF MYVERB='ABORT' | MYVERB='CANCEL' THEN SIGNAL EXITRC2
    END
 /* EXTENSIVE TEST OF MYVERB */
  SELECT
   WHEN MYVERB = 'ABORT' THEN SIGNAL EXITRC8
   WHEN MYVERB = 'BYPASS' THEN SIGNAL EXITRC8
   WHEN MYVERB = 'CANCEL' THEN SIGNAL EXITRC8
   WHEN MYVERB = 'REUSE' THEN SIGNAL DOREUSE
   WHEN MYVERB = 'HDEL' THEN NOP
   WHEN MYVERB = '' THEN SIGNAL DOWRITE
   OTHERWISE SIGNAL EXITRC8
   END
  DOWRITE:
  ADDRESS TSO
   "ALLOC FI(O) DA('"EDSN"') REUSE"
   "EXECIO * DISKW O (STEM OP. FINIS"
   "FREE FI(O)"
   SIGNAL EXITRC0
  EXITRC2:
  EXITRC4:
  EXITRC8:
  EXITRC0:
   EXIT
  DOIT: PROCEDURE EXPOSE TRVAL
   RESP='ENTER CMD'
   SAY 'TRACE VALUE IS 'TRVAL
   DO WHILE (RESP ^= '')
    SAY 'ENTER CMD'
    PULL RESP
    IF RESP = '' THEN RETURN
    INTERPRET RESP
    END
  RETURN
###END IPCSTRCX
$$$BEG CPDS2VAR
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA CPDS2VAR - ISPF BASE, COPY A DS DATA TO ISPF ARG        */
 /* CEMHELP CPDS2VAR - ISPF BASED, EXPECTS TWO ARGS                 */
 /* CEMHELP  FIRST ARG  IS A DSN OR DSN(MBR) OR <ISPFVAR>           */
 /* CEMHELP  SECOND ARG IS <ISPFVAR>                                */
 /* CEMHELP  WHERE THE <...> IDENTIFIES A VALID ISPF VAR NAME       */
 /* CEMHELP  FIRST VAR CAN BE SPECIFIED AS A DSN OR A ISPFVAR WHICH */
 /* CEMHELP   CONTAINS THE SOURCE DSN|DSN(MBR) NAME                 */
 /* CEMHELP  SECOND VAR IS ALWAYS ENCLOSED IN <..> BRACKETS, AND    */
 /* CEMHELP   INDICATES A ISPF VAR NAME AS THE TARGET               */
 /* CEMHELP  RETURNS 0 FOR SUCCESS                                  */
 /* CEMHELP          4 FOR PARTIAL SUCCESS (DATA LNG > 32760)       */
 /* CEMHELP          8 FAILURE (DSN OR ISPF VAR NAMES INVALID)      */
 /* CEMHELP END                                                     */
 ADDRESS TSO
 /* ---------------------------------------------------------------- *\
 |* CALLED FROM GETAFOCN PANEL TO COLLECT DATA FROM A DSN            *|
 |*  PLACE IT INTO A PANEL VAR TO BE USED AS THE CONTENTS FOR A      *|
 |*  CICS CONTAINER IN THE AFOLIST FACILITY                          *|
 \* ---------------------------------------------------------------- */
 /* TRACE ?I */
 ADDRESS ISPEXEC
 "ISPEXEC CONTROL ERRORS RETURN"
 ARG SRC TGT
 UPPER SRC
 UPPER TGT
 IF SUBSTR(SRC,1,1) = '<' THEN DO
  PARSE VAR SRC '<' SRCVAR '>' .
  IF SRCVAR = '' | LENGTH(SRCVAR) > 8 THEN SIGNAL EXITRC8
  "ISPEXEC VGET ("SRCVAR") ASIS"
  IF RC > 0 THEN SIGNAL EXITRC8
  INTERPRET 'SRCDSN = 'SRCVAR
  END
  ELSE DO
  SRCDSN = SRC
  IF LENGTH(SRCDSN) < 9 THEN  SIGNAL EXITRC8
  END
 SRCDSN_L = LENGTH(SRCDSN)
 IF SRCDSN_L < 9 |  SRCDSN_L > 63 THEN SIGNAL EXITRC8
PROCTGT:
 PARSE VAR TGT '<' TGTVAR '>' .
 IF TGTVAR = '' | LENGTH(TGTVAR) > 8 THEN SIGNAL EXITRC8
 XC=LISTDSI("'"SRCDSN"'" DIRECTORY NORECALL)
 IF XC > 4 THEN SIGNAL EXITRC8
 ADDRESS TSO
 "ALLOC FI(I) DA('"SRCDSN"') SHR"
 IF RC > 4 THEN SIGNAL EXITRC8
 "EXECIO * DISKR I (STEM S. FINIS"
 IF RC > 4 THEN SIGNAL EXITRC8
 "FREE FI(I)"
 XC = 0
 S_L = 0
 S_CT = S.0
 U = ''
 /* TRACE OFF */
 DO I = 1 TO S_CT
  V = S_L + LENGTH(S.I)
  IF V > 32760 THEN SIGNAL OVER_LNG
  U=U||S.I
  S_L = V
  END
 /* TRACE ?I */
 IF S_L > 0 THEN SIGNAL FINIT
OVER_LNG:
 XC = 4
FINIT:
 ADDRESS ISPEXEC
 INTERPRET TGTVAR' = U'
 "ISPEXEC VPUT ("TGTVAR") ASIS"
 XC = RC
 SIGNAL DONALL
EXITRC8:
 XC = 9
DONALL:
 RETURN XC
###END CPDS2VAR
$$$BEG REXXCMT
 /* ---------------------------------------------------------------- *\
 |*                                                                  *|
 \* ---------------------------------------------------------------- */
###END REXXCMT
$$$BEG TSDYNFLD
/* REXX */
/* trace ?i */
ADDRESS 'ISPEXEC'
"ISPEXEC CONTROL ERRORS RETURN"
EXECSEL='TSDYNFLD'
LR1 = 'HERE WE GO:'||COPIES('THIS IS A TEST',1000)
lr1scrNF='ON'
LR1scrls='<->'
LR1LNG=LENGTH(LR1)
Lr1Lfcol=1
Lr1Rfcol=0
"ADDPOP"
   trace ?i
topoflop:
"DISPLAY PANEL(EXPLDYN)"
 xc = rc
LL=LR1LNG
Lc=Lr1Lfcol
Rc=Lr1Rfcol
 if xc = 8 then signal donit
 if zcmd = 'CANCEL' then signal canit
 signal topoflop
donit:
   trace off
 say 'donit!'
 SAY 'LR1:'LR1
 SAY 'LENGTH:'LENGTH(LR1)
 signal finit
canit:
 say 'donit!'
finit:
"REMPOP"
###END TSDYNFLD
$$$BEG RXCOMENT
 /*                                                                 *\
 |*                                                                 *|
 \*                                                                 */
###END RXCOMENT
$$$BEG DSPCNCAA
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA DSPCNCAA - TEST CNC LOGIC                               */
 /* CEMHELP          - TSO BASE, RESTRICTED                         */
 /* CEMHELP          -                                              */
 /* CEMHELP END                                                     */
   ADDRESS ISPEXEC
/* TRACE I */
/* TRACE ?I */
/* SAY 'DSPCNC ' */
   TRCCMD='TRACE OFF'
   "ISPEXEC CONTROL ERRORS RETURN"
   "ISPEXEC ADDPOP ROW(1) COLUMN(10)"
   IF RC ^= 0 THEN SIGNAL EXITRC24
   EXECSEL='DSPCNC'
   DFLTM='CREATE CHANNELS CONTAINERS FIRST, THEN PROCESS.'
   DSEMSG=DFLTM
   AFOCHLST = ''
   AFOCNLST = 'CEMT0001 CEDA0001 PING0001'
   ISPEXEC VGET (AFOCHLST) ASIS"
   IF RC \= 0 THEN DO
    AFOCHLST = 'AFO_DFLT_CHNM'
    ISPEXEC VPUT (AFOCHLST) ASIS"
    IF RC \= 0 THEN SIGNAL EXITRC12
   VLL=''
   SP9 = '         '
   FFX='FF'X
   JCLSFMT=''
   ONCEIND=0
   HYCA=''
   VALFUNC='QUIET MSGBOXONLY MSGBOXALL VERBOSE'
   VALFUNC1='Q O A V'
   TECCMDS = 'CEMT CEDA'
   VALCMDS = 'PING LINK '||TECCMDS
   'ISPEXEC VGET (CMDIND MYFUNC1 AUTOSAVE) ASIS'
   IF CMDIND ^= 0 THEN CMDIND = 0
   AUTOSAVE='N'
   IF WORDPOS(MYFUNC1,VALFUNC1) = 0 THEN MYFUNC1 = 'O'
   HYFUNC1 = MYFUNC1
   'ISPEXEC VGET (MYCMD) ASIS'
   IF RC ^= 0 THEN SIGNAL EXIITRC8
   IF MYCMD = '' THEN SIGNAL EXITRC8
   IF WORDPOS(MYCMD,VALCMDS) = 0 THEN SIGNAL EXITRC8
    MYICA = ''
   IF WORDPOS(MYCMD,TECCMDS) = 0 THEN DO
    MYICA = ''
    SIGNAL NOT_TECCMD
    END
/*                                                                   *\
|* CNC                                                               *|
|* ESTABLISH DEFAULT CHANNEL, AND A SET OF DEFAULT CONTAINERS        *|
|*  WITH ASSOCIATED VARS.                                            *|
|* WE NEED TO USE ISPF TABLES TO COLLECT A SET OF VARS:              *|
|*  CHTBL - FLDA - CHANNEL NAME  (KEY)                               *|
|*          FLDB - SET OF ISPF VAR NAMES TO REPRESENT CONTAINERS     *|
|*  CNTBL - FLDA - CHANNELNAME.ONTAINERNAME                          *|
|*          FLDB - ISPF VAR TO HOLD CN BIT OR CHAR TYPE              *|
|*          FLDC - ISPF VAR TO HOLD THE CN VALUE                     *|
|*                                                                   *|
|*                                                                   *|
|*                                                                   *|
|*                                                                   *|
|*                                                                   *|
|*                                                                   *|
|*                                                                   *|
|*                                                                   *|
|*                                                                   *|
\*                                                                   */
   CNLST=''
   HCNLST=''
   HCHNM=''
   CHNM=''
   POPCNLST='N'
   DFTCH='DFT_CHANNEL'
   IF MYCMD='CEMT' THEN DO
    DFTCNV='CEMT INQUIRE SYSTEM'
    DFTCN='CEMT0001'
    END
   IF MYCMD='CEDA' THEN DO
    DFTCNV='CEDA EXPAND GROUP(XXXXXXXX)'
    DFTCN='CEDA0001'
    END
   IF MYCMD='PING' THEN DO
    DFTCNV='PING THIS IS A TEST'
    DFTCN='PING0001'
    END
   IF MYCMD='LINK' THEN DO
    DFTCNV='LINK THIS IS A TEST'
    DFTCN='LINK0001'
    END
   'ISPEXEC VGET (MYICA) ASIS'
   IF RC \= 0 THEN DO
    MYICA=DFTCNV
    END
    ELSE DO
    W1 = WORD(MYICA,1)
    IF W1 \= MYCMD THEN MYICA = DFTCNV
    END
NOT_TECCMD:
   'ISPEXEC VPUT (MYICA) ASIS'
   'ISPEXEC VGET (MYCA MYCAL) ASIS'
   IF RC ^= 0 THEN DO
    MYCA = MYICA
    MYCAL=4080
   'ISPEXEC VPUT (MYCA MYCAL) ASIS'
    END
    ELSE DO
    MYCA = MYICA
    MYCAL=4080
    'ISPEXEC VPUT (MYCA MYCAL) ASIS'
    END
   IF MYCMD = 'LINK' THEN DO
    'ISPEXEC VGET (MYPROG MYTRANID) ASIS'
    IF RC ^= 0 THEN DO
     MYPROG= ''
     MYTRANID=''
     END
    SELN='INPUT'
    LINKPMSG='ENTER LINK-TO PROGRAM'
    LINKTMSG='ENTER TRANSID TO INVOKE'
    IF MYPROG='' THEN HYPROG='--------'
     ELSE HYPROG=MYPROG
    IF MYTRANID = '' THEN HYTRANID='----'
     ELSE HYTRANID = MYTRANID
    END
    ELSE DO
    SELN='OUTPUT'
    LINKPMSG=''
    LINKTMSG=''
    HYPROG='--------'
    HYTRANID='----'
    END
  /* TRACE I */
   H_CAL=MYCAL
   H_PROG = HYPROG
   H_TRANID=HYTRANID
   MDSN='TTED.TSK.P.TCEM.CLIST'
   "ISPEXEC LIBDEF ISPPLIB DATASET ID('"MDSN"') UNCOND"
   IF RC ^= 0 THEN SIGNAL EXITRC8
RES_CA:
   HYFUNC1=MYFUNC1
   HYCAL=MYCAL
   HYCA=MYCA
   SIGNAL ARND_CLR_CA
CLR_CA:
   HYCA=''
ARND_CLR_CA:
   L_CA=LENGTH(HYCA)
   MX_L_CA = (20*59)
   IF L_CA > MX_L_CA THEN DO
     L_CA_RM = MX_L_CA
     HYCA = SUBSTR(HYCA,1,MX_L_CA - 1)||'+'
     END
    ELSE L_CA_RM = L_CA
   J = 1
   DO I = 1 TO 20
    IF L_CA_RM < 1 THEN H.I = ''
     ELSE DO
     IF L_CA_RM > 59 THEN L_CA_SP = 59
      ELSE L_CA_SP = L_CA_RM
     H.I = SUBSTR(HYCA,J,L_CA_SP)
     J = J + L_CA_SP
     L_CA_RM = L_CA_RM - L_CA_SP
     END
     TRACE OFF
    END
  /* TRACE I */
RESET:
   DO I = 1 TO 20
    INTERPRET "F"I" = H.I"
    TRACE OFF
    END
  /* TRACE I */
   HYPROG = H_PROG
   HYTRANID = H_TRANID
DISPP:
    INTERPRET TRCCMD
   "ISPEXEC DISPLAY PANEL(DSPAFOCH)"
   IF RC = 8 THEN SIGNAL DONEIT
   IF RC ^= 0 THEN SIGNAL EXITRC8
   IF ZCMD = 'HELP' | ZCMD = '?' THEN SIGNAL SHOWFMT
   IF ZCMD = 'RESET' THEN SIGNAL RESET
   IF ZCMD = 'RESCA' THEN SIGNAL RES_CA
   IF ZCMD = 'CLRCA' THEN SIGNAL CLR_CA
   IF ZCMD = 'CNC' THEN SIGNAL PROC_CNC
   IF ZCMD = 'SETODSN' THEN SIGNAL SET_ODSN
   IF ZCMD = 'CANCEL' THEN SIGNAL EXITRC8
   IF ZCMD = 'CANALL' THEN SIGNAL EXITRC20
   IF ZCMD = 'END' THEN SIGNAL DONEIT
   MCMD=ZCMD
   IF MCMD ^= '' THEN DO
    PARSE VAR MCMD FCMD RCMD
    IF FCMD = 'TRACE' THEN TRCCMD=MCMD
     ELSE "TSO MCMD"
    END
   INTERPRET TRCCMD
   IF RC = 0 THEN SIGNAL DISPP
   SIGNAL DISPP
SHOWFMT:
 MSGBOXTX=FFX||'THE CLRCA WILL RESET THE COMMAREA TO NULLS'||FFX||,
 'THE CLRCA WILL RESET THE COMMAREA TO NULLS'||FFX||,
 'THE RESCA WILL RESE THE CA BACK TO VALUE SHOWN AT FIRST ENTRY'||FFX||,
 'CANCEL WILL END ANY FRUTHER EXECUTION'||FFX||,
 'THE RESET REFRESHES THE CA BACK TO THE LAST ENTER KEY'||FFX||,
 'SETODSN IS USEFUL IF YOU WANT A SPECIFIC DSN NAME FOR QUIET'||FFX||,
 'CANCEL CANCEL THIS SINGLE SELECTION PROCESS'||FFX||,
 'CANALL CANCEL OUT OF A COMMAND PROCESS'||FFX||,
 'END AND '||FFX||,
 'PF3 PROCESSES THE REQUEST. NOTE, I DO NOT DO ANY SYNTAX CHECKING.'
 CALL MSGBOX MSGBOXTX
   SIGNAL DISPP
SET_ODSN:
   XC = 0
   CALL GET_ODSN
   IF XC > 4 THEN SIGNAL RESET
   ADDRESS ISPEXEC "VGET (EDSN) ASIS"
   IF RC ^= 0 THEN SIGNAL RESET
   ODSN = EDSN
   ADDRESS ISPEXEC "VGET (MYVERB) ASIS"
   IF RC ^= 0 THEN SIGNAL RESET
   IF MYVERB ^= '' THEN DO
    IF MYVERB='ABORT' | MYVERB='CANCEL' THEN SIGNAL RESET
    END
DONEIT:
   HYCA=''
   DO J = 1 TO 20
    INTERPRET 'TMP = F'J
    IF TMP = '' THEN ITERATE
    HYCA=HYCA||TMP
    END
/* TRACE ?I */
   IF WORDPOS(MYCMD,TECCMDS) ^= 0 THEN DO
    FW_HYCA=WORD(HYCA,1)
    IF WORDPOS(FW_HYCA,TECCMDS) = 0 THEN HYCA=MYCMD||' '||HYCA
     ELSE IF FW_HYCA ^= MYCMD THEN HYCA=MYCMD||' '||DELWORD(HYCA,1,1)
    END
   L_HCA = LENGTH(HYCA)
   IF L_HCA > HYCAL THEN DO
    IF HYCAL = 0 THEN HYCA = ''
     ELSE HYCA=SUBSTR(HYCA,1,HYCAL)
    END
   MYFUNC1=HYFUNC1
   UPPER AUTOSAVE
   IF AUTOSAVE = 'Y' THEN DO
    CALL GET_ODSN
    IF XC > 4 THEN SIGNAL RESET
    ADDRESS ISPEXEC "VGET (EDSN) ASIS"
    IF RC ^= 0 THEN SIGNAL RESET
    DSPLYADS = EDSN
    ADDRESS ISPEXEC "VPUT (DSPLYADS) ASIS"
    ADDRESS ISPEXEC "VGET (MYVERB) ASIS"
    IF RC ^= 0 THEN SIGNAL RESET
    IF MYVERB ^= '' THEN DO
     IF MYVERB='ABORT' | MYVERB='CANCEL' THEN SIGNAL RESET
     END
    END
   MYCA = HYCA
   MYCAL =HYCAL
   MYICA=MYCA
   "ISPEXEC VPUT (MYCA MYICA MYCAL MYFUNC1 AUTOSAVE) ASIS"
   IF MYCMD = 'LINK' THEN DO
    MYPROG = HYPROG
    MYTRANID = HYTRANID
    "ISPEXEC VPUT (MYPROG MYTRANID) ASIS"
    END
JSTRET0:
 CMDIND = 0
 SIGNAL EXITIT
PROC_CNC:
 XC = 0
 CALL DSPCNC
 IF XC > 4 THEN SIGNAL RESET
 CMDIND = 0
 SIGNAL EXITIT
EXITRC8:
 CMDIND = 8
 SIGNAL EXITIT
EXITRC20:
 CMDIND = 20
 SIGNAL EXITIT
EXITRC24:
 CMDIND = 24
 SIGNAL EXITIT_
EXITIT:
 "ISPEXEC REMPOP"
EXITIT_:
 "ISPEXEC VPUT (CMDIND) ASIS"
 RETURN CMDIND
GET_ODSN:
   "ISPEXEC VGET (DSPLYADS EMBR) ASIS"
   IF RC \= 0 THEN DO
    CALL GETUDSN 'AFOLIST'
    PULL EDSN
    END
    ELSE EDSN=DSPLYADS
   EXECSEL = 'DSPAFOC'
   DSEMSG = 'CHANGE OUTPUT DSN TARGET'
   MYVERB = 'CANCEL ABORT END'
   "ISPEXEC VPUT (EDSN) ASIS"
   "ISPEXEC VPUT (DSEMSG EXECSEL) ASIS"
   "ISPEXEC VPUT (MYVERB) ASIS"
   CALL DSNWIND
   XC = RESULT
   RETURN XC
###END DSPCNCAA
$$$BEG CPSMESSS
PROC 1 KIXREL KIXCTYP(D) KIXENV(SYS)
CONTROL NOCONLIST NOSYMLIST
IF &KIXREL = ? THEN GOTO SHOWMSG
IF &LENGTH(&KIXREL) LT 3 THEN GOTO BADPARM
IF &LENGTH(&KIXREL) GT 3 THEN GOTO BADPARM
IF (&KIXCTYP NE D) AND +
   (&KIXCTYP NE T) AND +
   (&KIXCTYP NE P) THEN GOTO BADPARM
IF (&KIXENV NE SYS) AND +
   (&KIXENV NE PUT) THEN GOTO BADPARM
IF &SUBSTR(1:1,&KIXREL) EQ R THEN GOTO BADPARM
WRITE CALLING EYU9XENF &KIXREL
TSOEXEC EYU9XENF '&KIXREL'
EXIT
BADPARM: -
WRITE INVALID PARM:
WRITE CICS 3 DIGIT RELEASE: &KIXREL
WRITE KIXCTYP : &KIXCTYP
WRITE KIXENV  : &KIXENV
WRITE OR THE LIBRARY &EDSN1 DOES NOT EXIST
SHOWMSG: -
WRITE PROVIDE A 3 DIGIT CICS RELEASE NUMBER (520, 540, ...)
WRITE AND SPECIFY AN OVERRIDE VARIABLE
WRITE     KIXCTYP(D)
WRITE OR  KIXCTYP(T)
WRITE OR  KIXCTYP(P)
WRITE     KIXENV(SYS)
WRITE OR  KIXENV(PUT)
EXIT
###END CPSMESSS
$$$BEG FREEISPP
/* REXX */
TRACE I
ADDRESS ISPEXEC
'ISPEXEC LIBDEF ISPPLIB'
###END FREEISPP
$$$BEG DSPAFOCH
)ATTR
/*.........1.........2.........3.........4.........5.........6 */
/* new version based on dspafocd allow to switch to cnc mode   */
  # AREA(scrl) extend(on)
  + TYPE(TEXT) INTENS(LOW) SKIP(ON) COLOR(BLUE)
  % TYPE(TEXT) INTENS(HIGH) SKIP(ON) COLOR(BLUE)
   TYPE(INPUT) INTENS(HIGH) COLOR(GREEN) JUST(ASIS)
  @ TYPE(&seln) INTENS(LOW) COLOR(GREEN) JUST(ASIS)
  $ TYPE(OUTPUT) INTENS(HIGH) CAPS(OFF) COLOR(red)
  { TYPE(OUTPUT) INTENS(HIGH) CAPS(OFF) COLOR(blue)
)BODY WINDOW(61,14)
{execsel +:ZCMD                         mysc+
$dsemsg
%Create CONTAINER template CN_NM:cnnm            +
+Enter the Container data below+
+(Remember: UCEMPINx program expects CN name(1:4) to reflect+
+  the command request (first 4 char of the CN data)) +
#myarea                                                     #
#                                                           #
)AREA MYAREA DEPTH(2)
f1                                                         +
f2                                                         +
f3                                                         +
f4                                                         +
f5                                                         +
f6                                                         +
f7                                                         +
f8                                                         +
f9                                                         +
f10                                                        +
f11                                                        +
f12                                                        +
f13                                                        +
f14                                                        +
f15                                                        +
f16                                                        +
f17                                                        +
f18                                                        +
f19                                                        +
f20
)INIT
 &zcmd = ''
 .ZVARS = '(hyfunc1,mycmd,autosave,hytranid)'
 .CURSOR = hycal
)PROC
 &cmd=&zcmd
 &myverb=&zverb
 VER (&hycal,NB,RANGE,0,32400)
 VER (&hyfunc1,LISTV,&valfunc1)
 VER (&autosave,LIST,Y,y,N,n)
)END
###END DSPAFOCH
$$$BEG DSPCNC
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA          -                                              */
 /* CEMHELP          - TSO BASE, RESTRICTED                         */
 /* CEMHELP          -                                              */
 /* CEMHELP END                                                     */
   ADDRESS ISPEXEC
/* TRACE I */
/* TRACE ?I */
/* SAY 'DSPCNC ' */
   TRCCMD='TRACE OFF'
   "ISPEXEC CONTROL ERRORS RETURN"
   "ISPEXEC ADDPOP ROW(1) COLUMN(10)"
   IF RC ^= 0 THEN SIGNAL EXITRC24
   EXECSEL='DSPCNC'
   DFLTM='ENTER ASSOCIATED DATA VALUES. PF3/END CANCEL RESET'
   DSEMSG=DFLTM
   VLL=''
   SP9 = '         '
   FFX='FF'X
   JCLSFMT=''
   ONCEIND=0
   HYCA=''
   VALFUNC='QUIET MSGBOXONLY MSGBOXALL VERBOSE'
   VALFUNC1='Q O A V'
   TECCMDS = 'CEMT CEDA'
   VALCMDS = 'PING LINK '||TECCMDS
   'ISPEXEC VGET (CMDIND MYFUNC1 AUTOSAVE) ASIS'
   IF CMDIND ^= 0 THEN CMDIND = 0
   AUTOSAVE='N'
   IF WORDPOS(MYFUNC1,VALFUNC1) = 0 THEN MYFUNC1 = 'O'
   HYFUNC1 = MYFUNC1
   'ISPEXEC VGET (MYCMD) ASIS'
   IF RC ^= 0 THEN SIGNAL EXIITRC8
   IF MYCMD = '' THEN SIGNAL EXITRC8
   IF WORDPOS(MYCMD,VALCMDS) = 0 THEN SIGNAL EXITRC8
    MYICA = ''
   IF WORDPOS(MYCMD,TECCMDS) = 0 THEN DO
    MYICA = ''
    SIGNAL NOT_TECCMD
    END
   CNLST=''
   HCNLST=''
   HCHNM=''
   CHNM=''
   POPCNLST='N'
   DFTCH='DFT_CHANNEL'
   IF MYCMD='CEMT' THEN DO
    DFTCNV='CEMT INQUIRE SYSTEM'
    DFTCN='CEMT0001'
    END
   IF MYCMD='CEDA' THEN DO
    DFTCNV='CEDA EXPAND GROUP(XXXXXXXX)'
    DFTCN='CEDA0001'
    END
   IF MYCMD='PING' THEN DO
    DFTCNV='PING THIS IS A TEST'
    DFTCN='PING0001'
    END
   IF MYCMD='LINK' THEN DO
    DFTCNV='LINK THIS IS A TEST'
    DFTCN='LINK0001'
    END
   'ISPEXEC VGET (MYICA) ASIS'
   IF RC \= 0 THEN DO
    MYICA=DFTCNV
    END
    ELSE DO
    W1 = WORD(MYICA,1)
    IF W1 \= MYCMD THEN MYICA = DFTCNV
    END
NOT_TECCMD:
   'ISPEXEC VPUT (MYICA) ASIS'
   'ISPEXEC VGET (MYCA MYCAL) ASIS'
   IF RC ^= 0 THEN DO
    MYCA = MYICA
    MYCAL=4080
   'ISPEXEC VPUT (MYCA MYCAL) ASIS'
    END
    ELSE DO
    MYCA = MYICA
    MYCAL=4080
    'ISPEXEC VPUT (MYCA MYCAL) ASIS'
    END
   IF MYCMD = 'LINK' THEN DO
    'ISPEXEC VGET (MYPROG MYTRANID) ASIS'
    IF RC ^= 0 THEN DO
     MYPROG= ''
     MYTRANID=''
     END
    SELN='INPUT'
    LINKPMSG='ENTER LINK-TO PROGRAM'
    LINKTMSG='ENTER TRANSID TO INVOKE'
    IF MYPROG='' THEN HYPROG='--------'
     ELSE HYPROG=MYPROG
    IF MYTRANID = '' THEN HYTRANID='----'
     ELSE HYTRANID = MYTRANID
    END
    ELSE DO
    SELN='OUTPUT'
    LINKPMSG=''
    LINKTMSG=''
    HYPROG='--------'
    HYTRANID='----'
    END
  /* TRACE I */
   H_CAL=MYCAL
   H_PROG = HYPROG
   H_TRANID=HYTRANID
   MDSN='TTED.TSK.P.TCEM.CLIST'
   "ISPEXEC LIBDEF ISPPLIB DATASET ID('"MDSN"') UNCOND"
   IF RC ^= 0 THEN SIGNAL EXITRC8
RES_CA:
   HYFUNC1=MYFUNC1
   HYCAL=MYCAL
   HYCA=MYCA
   SIGNAL ARND_CLR_CA
CLR_CA:
   HYCA=''
ARND_CLR_CA:
   L_CA=LENGTH(HYCA)
   MX_L_CA = (20*59)
   IF L_CA > MX_L_CA THEN DO
     L_CA_RM = MX_L_CA
     HYCA = SUBSTR(HYCA,1,MX_L_CA - 1)||'+'
     END
    ELSE L_CA_RM = L_CA
   J = 1
   DO I = 1 TO 20
    IF L_CA_RM < 1 THEN H.I = ''
     ELSE DO
     IF L_CA_RM > 59 THEN L_CA_SP = 59
      ELSE L_CA_SP = L_CA_RM
     H.I = SUBSTR(HYCA,J,L_CA_SP)
     J = J + L_CA_SP
     L_CA_RM = L_CA_RM - L_CA_SP
     END
     TRACE OFF
    END
  /* TRACE I */
RESET:
   DO I = 1 TO 20
    INTERPRET "F"I" = H.I"
    TRACE OFF
    END
  /* TRACE I */
   HYPROG = H_PROG
   HYTRANID = H_TRANID
DISPP:
    INTERPRET TRCCMD
   "ISPEXEC DISPLAY PANEL(DSPAFOCH)"
   IF RC = 8 THEN SIGNAL DONEIT
   IF RC ^= 0 THEN SIGNAL EXITRC8
   IF ZCMD = 'HELP' | ZCMD = '?' THEN SIGNAL SHOWFMT
   IF ZCMD = 'RESET' THEN SIGNAL RESET
   IF ZCMD = 'RESCA' THEN SIGNAL RES_CA
   IF ZCMD = 'CLRCA' THEN SIGNAL CLR_CA
   IF ZCMD = 'CNC' THEN SIGNAL PROC_CNC
   IF ZCMD = 'SETODSN' THEN SIGNAL SET_ODSN
   IF ZCMD = 'CANCEL' THEN SIGNAL EXITRC8
   IF ZCMD = 'CANALL' THEN SIGNAL EXITRC20
   IF ZCMD = 'END' THEN SIGNAL DONEIT
   MCMD=ZCMD
   IF MCMD ^= '' THEN DO
    PARSE VAR MCMD FCMD RCMD
    IF FCMD = 'TRACE' THEN TRCCMD=MCMD
     ELSE "TSO MCMD"
    END
   INTERPRET TRCCMD
   IF RC = 0 THEN SIGNAL DISPP
   SIGNAL DISPP
SHOWFMT:
 MSGBOXTX=FFX||'THE CLRCA WILL RESET THE COMMAREA TO NULLS'||FFX||,
 'THE CLRCA WILL RESET THE COMMAREA TO NULLS'||FFX||,
 'THE RESCA WILL RESE THE CA BACK TO VALUE SHOWN AT FIRST ENTRY'||FFX||,
 'CANCEL WILL END ANY FRUTHER EXECUTION'||FFX||,
 'THE RESET REFRESHES THE CA BACK TO THE LAST ENTER KEY'||FFX||,
 'SETODSN IS USEFUL IF YOU WANT A SPECIFIC DSN NAME FOR QUIET'||FFX||,
 'CANCEL CANCEL THIS SINGLE SELECTION PROCESS'||FFX||,
 'CANALL CANCEL OUT OF A COMMAND PROCESS'||FFX||,
 'END AND '||FFX||,
 'PF3 PROCESSES THE REQUEST. NOTE, I DO NOT DO ANY SYNTAX CHECKING.'
 CALL MSGBOX MSGBOXTX
   SIGNAL DISPP
SET_ODSN:
   XC = 0
   CALL GET_ODSN
   IF XC > 4 THEN SIGNAL RESET
   ADDRESS ISPEXEC "VGET (EDSN) ASIS"
   IF RC ^= 0 THEN SIGNAL RESET
   ODSN = EDSN
   ADDRESS ISPEXEC "VGET (MYVERB) ASIS"
   IF RC ^= 0 THEN SIGNAL RESET
   IF MYVERB ^= '' THEN DO
    IF MYVERB='ABORT' | MYVERB='CANCEL' THEN SIGNAL RESET
    END
DONEIT:
   HYCA=''
   DO J = 1 TO 20
    INTERPRET 'TMP = F'J
    IF TMP = '' THEN ITERATE
    HYCA=HYCA||TMP
    END
/* TRACE ?I */
   IF WORDPOS(MYCMD,TECCMDS) ^= 0 THEN DO
    FW_HYCA=WORD(HYCA,1)
    IF WORDPOS(FW_HYCA,TECCMDS) = 0 THEN HYCA=MYCMD||' '||HYCA
     ELSE IF FW_HYCA ^= MYCMD THEN HYCA=MYCMD||' '||DELWORD(HYCA,1,1)
    END
   L_HCA = LENGTH(HYCA)
   IF L_HCA > HYCAL THEN DO
    IF HYCAL = 0 THEN HYCA = ''
     ELSE HYCA=SUBSTR(HYCA,1,HYCAL)
    END
   MYFUNC1=HYFUNC1
   UPPER AUTOSAVE
   IF AUTOSAVE = 'Y' THEN DO
    CALL GET_ODSN
    IF XC > 4 THEN SIGNAL RESET
    ADDRESS ISPEXEC "VGET (EDSN) ASIS"
    IF RC ^= 0 THEN SIGNAL RESET
    DSPLYADS = EDSN
    ADDRESS ISPEXEC "VPUT (DSPLYADS) ASIS"
    ADDRESS ISPEXEC "VGET (MYVERB) ASIS"
    IF RC ^= 0 THEN SIGNAL RESET
    IF MYVERB ^= '' THEN DO
     IF MYVERB='ABORT' | MYVERB='CANCEL' THEN SIGNAL RESET
     END
    END
   MYCA = HYCA
   MYCAL =HYCAL
   MYICA=MYCA
   "ISPEXEC VPUT (MYCA MYICA MYCAL MYFUNC1 AUTOSAVE) ASIS"
   IF MYCMD = 'LINK' THEN DO
    MYPROG = HYPROG
    MYTRANID = HYTRANID
    "ISPEXEC VPUT (MYPROG MYTRANID) ASIS"
    END
JSTRET0:
 CMDIND = 0
 SIGNAL EXITIT
PROC_CNC:
 XC = 0
 CALL DSPCNC
 IF XC > 4 THEN SIGNAL RESET
 CMDIND = 0
 SIGNAL EXITIT
EXITRC8:
 CMDIND = 8
 SIGNAL EXITIT
EXITRC20:
 CMDIND = 20
 SIGNAL EXITIT
EXITRC24:
 CMDIND = 24
 SIGNAL EXITIT_
EXITIT:
 "ISPEXEC REMPOP"
EXITIT_:
 "ISPEXEC VPUT (CMDIND) ASIS"
 RETURN CMDIND
GET_ODSN:
   "ISPEXEC VGET (DSPLYADS EMBR) ASIS"
   IF RC \= 0 THEN DO
    CALL GETUDSN 'AFOLIST'
    PULL EDSN
    END
    ELSE EDSN=DSPLYADS
   EXECSEL = 'DSPAFOC'
   DSEMSG = 'CHANGE OUTPUT DSN TARGET'
   MYVERB = 'CANCEL ABORT END'
   "ISPEXEC VPUT (EDSN) ASIS"
   "ISPEXEC VPUT (DSEMSG EXECSEL) ASIS"
   "ISPEXEC VPUT (MYVERB) ASIS"
   CALL DSNWIND
   XC = RESULT
   RETURN XC
###END DSPCNC
$$$BEG FASRCHLS
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA FASRCHLS - FOR EACH DSN IN LIST, FIND TEXT STRING IN DSN*/
 /* CEMHELP FASRCHLS - TSO BASE, FOR EACH DSN IN LIST, FIND         */
 /* CEMHELP          - A TEXT STRING AND LIST THE MEMBERS WHERE     */
 /* CEMHELP          - THE STRING WAS FOUND.                        */
 /* CEMHELP          - TWO PROMPTS: THE DSN(MBR) CONTAINING THE     */
 /* CEMHELP          - LIST OF DSN TO BE SEARCHED (EACH DSN IN LIST */
 /* CEMHELP          - MUST START IN COL 1, NO QUOTES, 1 PER LINE   */
 /* CEMHELP          - SECOND IS THE TEXT TO BE SEARCHED FOR        */
 /* CEMHELP          - (CASE MATTERS, AND NO QUOTES ALLOWED)        */
 /* CEMHELP          - EACH DSN WILL BE SEARCHED AND A TEXT BOX     */
 /* CEMHELP          - WILL DISPLAY THE SUMMARY RESULTS.            */
 /* CEMHELP          - PF3 WILL ITERATE THROUGH THE LIST OF DSN     */
 /* CEMHELP          - ATTN AND 'HI' WILL ABORT THE PROCESS         */
 /* CEMHELP END                                                     */
 ADDRESS TSO
 SAY 'ENTER THE DSN(MBR) CONTAINING THE LIST OF DSN TO BE SEARCHED'
 SAY '(NO QUOTES!!!)'
 DSLST = ''
 PULL DSLST
 UPPER DSLST
 IF DSLST = '' THEN DO
  SAY 'YOU ENTERED NOTHING. BYE!'
  EXIT
  END
 "ALLOC FI(I) DA('"DSLST"') SHR"
 "EXECIO * DISKR I (STEM DSL. FINIS"
 "FREE FI(I)"
 IF DSL.0 = 0 THEN DO
  SAY 'YOUR DS LIST CONTAINED NO ENTRIES. BYE'
  EXIT
  END
 SAY 'ENTER THE TEXT STRING TO SEARCH FOR'
 SAY '(NO QUOTES!!!) (CASE MATTERS)'
 SRCH4 = ''
 PULL SRCH4
 IF DSLST = '' THEN DO
  SAY 'YOU ENTERED NOTHING. BYE!'
  EXIT
  END
 SRCSTR="C'"||SRCH4||"'"
 OCT=0
 SAY 'OK, HERE WE GO...'
 SUID = SYSVAR(SYSUID)
 CALL GETUDSN SUID
 PULL TGTDSN
 IF TDSN = '' THEN DO
  SAY 'COULD GENERATE A UNIQUE TGT DSN'
  EXIT
  END
 FFX='FF'X
 MYAREA=''
 DO I = 1 TO DSL.0
   SRCDSN=DSL.I
   CALL FAIDSRCH SRCDSN SRCSTR
   IF RESULT ^= 0 THEN RETURN 4
  END
 RETURN 0
###END FASRCHLS
$$$BEG DSPLY2B
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA          -                                              */
 /* CEMHELP          - TSO BASE, RESTRICTED                         */
 /* CEMHELP          -                                              */
 /* CEMHELP END                                                     */
  XC = 0
   ADDRESS ISPEXEC
   'ISPEXEC CONTROL ERRORS RETURN'
   FFX='FF'X
   AMT='HALF'
   MYAREA#=FFX
   ARG MYAREA
   IF MYAREA='' THEN  'ISPEXEC VGET (MYAREA MYAREA#) ASIS'
   IF MYAREA='' THEN SIGNAL NOPOOL
   IF MYAREA# = '' THEN DO
    FFX=SUBSTR(MYAREA#,1,1)
    END
    ELSE DO
    FFX= SUBSTR(MYAREA,1,1)
    IF FFX >= 'A' & FFX <= '9' THEN DO
     FFX=''
     END
    END
   I = 0
   "ISPEXEC VGET (EXECSEL) ASIS"
   IF RC ^= 0 THEN DO
    EXECSEL='DSPLY1B'
    "ISPEXEC VPUT (EXECSEL) ASIS"
    END
   IF SUBSTR(MYAREA#,2)='INPUT' THEN SELATTR='INPUT'
    ELSE SELATTR='OUTPUT'
   "ISPEXEC TBCREATE DSPLYTBL "||,
     "NAMES(MYD1,MYD2) NOWRITE REPLACE"
    IF RC > 4 THEN DO
     MSGTXT ='COULD NOT CREATE THE DISPLAY TABLE'
     SIGNAL SHOWMBOX
     END
    MXLNG=0
    MYD1=' '
   DO WHILE(MYAREA^='')
    IF FFX^='' THEN DO
     PARSE VAR MYAREA TMP (FFX) MYAREA
     END
     ELSE DO
     TMP=SUBSTR(MYAREA,1,78)
     LP=LASTPOS(' ',TMP)
     IF LP < 2 THEN LP=LENGTH(TMP)
     MYD2=SUBSTR(MYAREA,1,TMP-1)
     TLG=LENGTH(MYD2)
     IF TLG > MXLNG THEN MXLNG = TLG
     MYAREA=STRIP(SUBSTR(MYAREA,LP+1),'B')
     END
    I=I+1
    OP.I=TMP
    MYD2=TMP
    "ISPEXEC TBADD DSPLYTBL"
    END
   IF I ^> 0 THEN SIGNAL NOPOOL
   MYTYTOT=I
OUTOFBLD:
   SIGNAL ON HALT NAME FREEIT
   LCRP=0
   ADDRESS ISPEXEC
   "ISPEXEC CONTROL ERRORS RETURN"
   SVC=MYTYTOT
   "ISPEXEC TBTOP DSPLYTBL"
   CROW=0
 TOPOFLOP:
  "ISPEXEC TBTOP DSPLYTBL"
  "ISPEXEC TBSKIP DSPLYTBL NUMBER("CROW")"
 REDSPLY:
  "ISPEXEC TBDISPL DSPLYTBL PANEL(MYDSPAD2)"
  XC = RC
  IF XC > 8 THEN DO
   MSGTXT ='SEVERE ERROR FROM TBDISPL FUNCTION.  ABORT.'
   SIGNAL SHOWMBOX
   END
  IF CROW > 0 THEN CROW=CROW+0
 CKXC:
  CMD = ZCMD
  ZCMD = ''
  IF CMD = '' THEN SIGNAL CKPF8
  IF WORDPOS(CMD,CANSTR) ^= 0 THEN SIGNAL CANIT
  IF CMD='TCEMTRAI' THEN DO
   TRACE I
   SIGNAL REDSPLY
   END
  IF CMD='TCEMTRAO' THEN DO
   TRACE OFF
   SIGNAL REDSPLY
   END
  IF CMD='OS2PW' | ABBREV('OS2PNTN',CMD,4) = 1 |,
     CMD='PMBRW' | ABBREV('PMBRN',CMD,4) = 1 THEN DO
   CALL OS2PNT
   XC=RESULT
   IF XC=0 THEN DO
    IF CMD = 'OS2PW' | CMD='PMBRW' THEN DO
     CALL JRPPNT 'JRPPNTW'
     XC=RESULT
     END
     ELSE DO
     IF CMD='PMBRC' THEN CALL JRPPNT 'JRPPNTC'
      ELSE DO
       IF MXLNG > 80 THEN DDEST = 'JRPPNTC'
        ELSE DDEST = 'JRPPNT'
       CALL JRPPNT DDEST
       END
     XC=RESULT
     END
    XC = 0
    SIGNAL REDSPLY
    END
   END
  "ISPEXEC CONTROL DISPLAY SAVE"
   IF CMD = 'SAVE' THEN DO
    CALL SAVIT
    IF RESULT = 0 THEN DO
     ZEDSMSG = 'DATA SAVED'
     ZEDLMSG = 'DATASET SAVED AS DIRECTED'
     END
     ELSE DO
     ZEDSMSG = 'DATA NOT SAVED'
     ZEDLMSG = 'ERROR OCCURRED, OR ABORT SELECTED. NOTHING SAVED'
     END
    END
    ELSE '"'ZCMD'"'
   "ISPEXEC CONTROL DISPLAY RESTORE"
 CKPF8:
   IF XC = 8 THEN SIGNAL DONEALL
   IF XC ^= 0 THEN DO
    MSGTXT='ILLOGICAL VALUE FOR XC 'XC'. ABORT.'
    SIGNAL SHOWMBOX
    END
   SIGNAL TOPOFLOP
 DONEALL:
   RETURN 0
  CANIT:
   MSGTXT ='CANCEL/ABORT WAS COMMANDED.'
   SIGNAL SHOWMBOX
  NOPOOL:
   MSGTXT ='NO POOLED DATA TO DISPLAY.'
   SIGNAL SHOWMBOX
  FREEIT:
   MSGTXT='ATTENTION ROUTINE ENTERED. NOTHING SAVED.'
  SHOWMBOX:
   CALL MSGBOX MSGTXT
   RETURN XC
SIGNAL ON ERROR NAME ERROR
SIGNAL ON SYNTAX NAME SYNTAX
SIGNAL ON FAILURE NAME FAILURE
SIGNAL ON HALT NAME HALT
ERROR:
    XC=RC
    SAY 'REXX ERROR 'XC' ON LINE 'SIGL':'
    SAY 'REXX:- APPLICATION RETURNED AN ERRORLEVEL' XC
    SIGNAL START
SYNTAX:
    XC=RC
    SAY 'REXX ERROR 'XC' ON LINE 'SIGL':'ERRORTEXT(XC)
    SAY 'REXX:- ERROR' XC':' ERRORTEXT(XC)
    SIGNAL START
FAILURE:
    XC=RC
    SAY 'REXX ERROR 'XC' ON LINE 'SIGL':'
    IF XC = -3 THEN,
       SAY 'REXX:- PROGRAM NOT FOUND'
    ELSE IF XC = -8 THEN,
       SAY 'REXX:- INSUFFICIENT MEMORY FOR PROGRAM'
    ELSE,
       SAY 'REXX:- RETURN CODE' XC
    SIGNAL START
HALT:
    XC=RC
    SAY 'REXX:- CTRL-BREAK INTEXCEPTED'
START:
  XC=RC
SIGNAL ON HALT NAME XITIT
  SAY 'REXX ERROR 'XC' ON LINE 'SIGL':'ERRORTEXT(XC)
DO WHILE (1)
 SAY 'ENTER A VALID REXX COMMAND EXCEPT INTERPRET'
 PULL RESP
 IF WORD(RESP,1) = 'INTERPRET' THEN DO
  SAY 'DO NOT ENTER A INTERPRET COMMAND. RETRY'
  ITERATE
  END
 INTERPRET RESP
 END
 XITIT:
    PULL
    EXIT
 SAVIT: PROCEDURE EXPOSE MYA. MXLNG EXECSEL CMD
  /* TRACE ?I */
  "ISPEXEC VGET (DSPLYADS EMBR) ASIS"
  IF RC \= 0 THEN DO
   EDSN=SYSVAR(SYSUID)'.'EXECSEL'.DATA'
   EMBR=''
   END
   ELSE EDSN=DSPLYADS
  DSEMSG='ENTER TARGET DSN (NO MBR)'
  MYAT='INPUT'
  "ISPEXEC VPUT (EDSN EMBR DSEMSG MYAT) ASIS"
  CALL GDSNNMBR
  IF RESULT = 8 THEN RETURN 8
  "ISPEXEC VGET (EDSN EMBR) ASIS"
  IF RC ^= 0 THEN RETURN
  EMBR=STRIP(EMBR,'B')
  XMBR = ''
  /* DSN COULD HAVE BEEN SPECIFIED AS DSN(MBR)
     OR THE DSN AND MBR INPUT IN PANEL FIELDS,
     OR (CONFUSED) BOTH (IN WHICH CASE WE TAKE THE DSN(MBR)
     FORMATED BECAUSE WE FIGURE IT WAS INTENTIONAL).
  */
  PARSE VAR EDSN EDSN '(' XMBR ')'
  TDSN=EDSN
  IF XMBR \= '' THEN EMBR = XMBR
  IF EMBR = '$' THEN EMBR = EXECSEL
  /* SIMPLE CHECK TO INSURE DSN NOT MIGRATED */
  CALL MALOC TDSN
  XC=RESULT
  IF XC = 0 THEN SIGNAL CHKORG
  IF EMBR = '' THEN MYDSO='PS)'
   ELSE  MYDSO='PO) DSNTYPE(LIBRARY)'
  MODDSN = ''
  IF MXLNG < 128 THEN MXLNG = 128
  M=MXLNG+4
  DSEMSG = '(D) DEL/REALLOC,(A) ABORT'
  MODATTR="NEW BLKSIZE("M+4") DSORG("MYDSO" RECFM(V,B) SPACE(1,1)"||,
   "CYLINDER LRECL("M") CATALOG REUSE"
  EDSN = TDSN
  ADDRESS ISPEXEC "VPUT (EDSN EXECSEL DSEMSG MODATTR MODDSN) ASIS"
  IF RC ^= 0 THEN SIGNAL EXITRC8
  CALL ALOCDSN
  XC = RESULT
  "ISPEXEC VGET (EDSN) ASIS"
  IF RC ^= 0 THEN RETURN 4
  SIGNAL DOWRITE
 CHKORG:
  XC=LISTDSI("'"TDSN"'" DIRECTORY NORECALL)
  MYDSO=SYSDSORG
  IF EMBR \= '' THEN DO
   IF MYDSO = 'PS' THEN SIGNAL BADOPDSNORG
   END
   ELSE DO
   IF MYDSO = PO THEN SIGNAL BADOPDSNORG
   END
 DOWRITE:
  /* TRACE ?I */
  DSPLYADS=EDSN
  "ISPEXEC VPUT (DSPLYADS EMBR) ASIS"
  IF EMBR \= '' THEN EDSN=TDSN||'('||EMBR||')'
  IF XC = 0 THEN DO
   M# = MYA.0
   MSTM='MYA.'
   IF CMD = 'MOD' | CMD = 'APPEND' THEN DSPVAL='MOD'
    ELSE DSPVAL='SHR REUSE'
   IF EMBR \= '' THEN DO
    IF DSPVAL = 'MOD' THEN DO
     DSPVAL='SHR REUSE'
     ADDRESS TSO "ALLOC FI(I) DA('"EDSN"') "DSPVAL
     ADDRESS TSO "EXECIO * DISKR I (STEM MYB. FINIS"
     ADDRESS TSO "FREE FI(I)"
     MSTM='MYB.'
     MB#=MYB.0
     DO I = 1 TO M#
      MB#=MB# + 1
      MYB.MB#=MYA.I
      END
     M#=MB#
     END
    END
   ADDRESS TSO "ALLOC FI(O) DA('"EDSN"') "DSPVAL
   ADDRESS TSO "EXECIO "M#" DISKW O (STEM "MSTM" FINIS"
   ADDRESS TSO "FREE FI(O)"
   CALL MSGBOX 'DATA SAVED TO 'EDSN
   RETURN 0
  END
  RETURN XC
BADOPDSNORG:
   CALL MSGBOX 'SAVE TO DSN DSORG INCONSISTENT WITH EXISTING DSN'
   RETURN 4
OS2PNT: PROCEDURE EXPOSE MYTYP SVC
 IF SVC ^> 0 THEN RETURN 4
 MYCN=MYTYP
 "ISPEXEC VPUT (MYCN) ASIS"
  ZEDSMSG = "DATA PRINTED"
  ZEDLMSG = "DATA SENT TO PRINTER"
 "ISPEXEC SETMSG MSG(ISRZ001)"
 RETURN 0
###END DSPLY2B
$$$BEG CTGSTEDT
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA CGTSTEDT - REPORT CTG GC RATIO USES CTGSTATS MAC        */
 /* CEMHELP CGTSTEDT - TSO REPORT CTG GC RATIO USES CTGSTATS MAC    */
 /* CEMHELP          - REPORTS AND CALCULATES GC RATIO              */
 /* CEMHELP          - SE_CHEAPGCMIN / SE_SHEAPMAX                  */
 /* CEMHELP          - CTG DOC SPECIFIES .40 - .70 BEST             */
 /* CEMHELP          - ALSO REPORT GC COUNT                         */
 /* CEMHELP          - WRITES REPORT TO @MBRNM                      */
 /* CEMHELP END                                                     */
 SIGNAL ON ERROR NAME XRROR
 SIGNAL ON SYNTAX NAME XYNTAX
 SIGNAL ON FAILURE NAME XAILURE
 SIGNAL ON HALT NAME XALT
 ADDRESS TSO
 /* TRACE ?I */
  ARG EDSN
  NUMERIC DIGITS(3)
  "ALLOC FI(I) DA('"EDSN"') SHR"
  IF RC \= 0 THEN SIGNAL BADFILE
  "EXECIO * DISKR I (STEM STS. FINIS"
  "FREE FI(I)"
  IF STS.0 = 0 THEN SIGNAL BADFILE
  IF SUBSTR(STS.1,2,1) = ' ' THEN SIGNAL BADFILE
  TMP = STS.1
  IF WORD(TMP,1) \= '*WORDLIST:' THEN SIGNAL BADFILE
  IF WORD(TMP,2) \= 'CTG8239I' THEN SIGNAL BADFILE
  PARSE VAR TMP . '*WORDLIST:' TMP
  SAY TMP
  WORDLIST = TMP
  SE_CHEAPGCMIN = WORDPOS('SE_CHEAPGCMIN',WORDLIST)
  SE_SHEAPMAX   = WORDPOS('SE_SHEAPMAX',WORDLIST)
  IF SE_SHEAPMAX > 0 & SE_CHEAPGCMIN > 0 THEN DO
   DO_RATIO = 'Y'
   TMP=TMP||'  RATIO'
   END
   ELSE DO_RATIO = 'N'
  PARSE VAR EDSN ODSN '(' EMBR ')'
  XC=LISTDSI("'"ODSN"'" NORECALL)
  IF XC > 0 THEN SIGNAL BADFILE
  MYLRECL=SYSLRECL
  IF SUBSTR(EMBR,1,1) = '#' THEN M = '@'
    ELSE M = '#'
  EMBR = M||SUBSTR(EMBR,2)
  ODSN = ODSN||'('||EMBR||')'
  WDLSTCT=WORDS(WORDLIST)
  TMP_OP = ''
  DO I = 1 TO WDLSTCT
   FW.I=WORD(WORDLIST,I)
   WLIT.I = ' '||FW.I||':'
   WLIT_L.I = LENGTH(WLIT.I)
   IF I = 1 THEN ITERATE
   TMP_OP = TMP_OP||' '||WLIT.I
   END
  /* WDLSTCT = WDLSTCT - 1 */
 /* TRACE ?I */
  IF WORDPOS(FW.1,STS.2) = 0 THEN SIGNAL BADFILE
  OP.1 = 'TIME  '||TMP_OP
  STSCT=STS.0
  S.1 = SUBSTR(STS.2,2,8)
  OCT=1
  OP_MAXL = 0
  INVRECCT = 0
  RATIO = ''
  /*DO_RATIO = 'N' */
  /* TRACE ?I */
  /* BYPASS FIRST TWO LINES IN THE STATS FILE */
  /* WHICH CONTAINS 'WORDLIST' FOLLOWED BY FIRST TIME RECORD */
  DO I = 3 TO STSCT
   TMP=STRIP(STS.I,'B')
   /* LOOK FOR CTG8239I. WHEN FOUND, THEN PROCESS THE ACCUMULATED */
   IF WORDPOS(FW.1,TMP) \= 0 THEN DO
   /* TIME IS IN THE FIRST S. STEM VAR - PLACE IN OP STEM */
    TMP_OP = LEFT(S.1,8)||' >> '
   /* IGNORE CTG8239I IN  WORDLIST */
    IF DO_RATIO = 'Y' THEN DO
     IF S.SE_SHEAPMAX > 0 & S.SE_CHEAPGCMIN > 0 THEN DO
      HEAPX = S.SE_SHEAPMAX
      HEAPM = S.SE_CHEAPGCMIN
      IF HEAPX \= 0 & HEAPM \= 0 THEN RATIO = HEAPM / HEAPX
       ELSE RATIO = 0
      END
      ELSE RATIO = 0
     END
    DO J = 2 TO WDLSTCT
      TMP_OP = TMP_OP||LEFT(S.J,13)
      S.J = ''
      END
     OCT = OCT + 1
     OP.OCT = TMP_OP||' '||RATIO
     TMPL= LENGTH(OP.OCT)
     IF TMPL > MYLRECL THEN OP.OCT = SUBSTR(OP.OCT,1,MYLRECL)
 /*   OP.OCT = 'TIME:'||S.1||LEFT(': HEAP:'||S.2,20)||,
       LEFT(': HEAPGCMN:'||S.3,20)||LEFT(':RATIO:'||RATIO,16)||,
      'GC_CT:'||S.4                                             */
     S.1 = WORD(TMP,1)         /* TIME */
     END
    ELSE DO
     PARSE VAR TMP FWD '=' FVAL .
     FWDCT = WORDS(FWD)
     FWD = WORD(FWD,FWDCT)
     FWD = STRIP(FWD,'B')
     FVAL = STRIP(FVAL,'B')
     FWDPOS = WORDPOS(FWD,WORDLIST)
     IF FWDPOS \= 0 THEN DO
      S.FWDPOS = FVAL
      END
      ELSE DO
      INVRECCT = INVRECCT + 1
      INVREC.INVRECCT = TMP
      END
     END
    END
  /* ALL RECORDS PROCESS. LAST OP STEM NEEDS TO BE WRITTEN */
  TMP_OP = LEFT(S.1,8)||' >> '
 /* IGNORE CTG8239I IN  WORDLIST */
  IF DO_RATIO = 'Y' THEN DO
    IF S.SE_SHEAPMAX > 0 & S.SE_CHEAPGCMIN > 0 THEN DO
     HEAPX = S.SE_SHEAPMAX
     HEAPM = S.SE_CHEAPGCMIN
     IF HEAPX \= 0 & HEAPM \= 0 THEN RATIO = HEAPM / HEAPX
       ELSE RATIO = 0
     END
    END
  DO J = 2 TO WDLSTCT
      TMP_OP = TMP_OP||LEFT(S.J,13)
      S.J = 0
      END
  OCT = OCT + 1
  OP.OCT = TMP_OP||' '||RATIO
  IF TMPL > MYLRECL THEN OP.OCT = SUBSTR(OP.OCT,1,MYLRECL)
  IF INVRECCT > 0 THEN DO
   OCT = OCT + 1
   OP.OCT = '!!! INVALID RECORD COUNT IS:'INVRECCT
   DO I = 1 TO INVRECCT
    SAY INVREC.I
    END
   END
  SAY 'WRITING:'||OCT||': RECORDS TO:'ODSN
  OP.0 = OCT
  DO I = 1 TO OCT
   SAY OP.I
   END
"ALLOC FI(OT) DA('"ODSN"') SHR"
"EXECIO * DISKW OT (STEM OP. FINIS)"
SAY RC
"FREE FI(OT)"
  SAY 'FINISHED:' RC
  SIGNAL FINIT
 XRROR:
     XC=RC
     SAY 'REXX ERROR 'XC' ON LINE 'SIGL':'
     SAY 'REXX:- APPLICATION RETURNED AN ERRORLEVEL' XC
     SIGNAL FINIT
 XYNTAX:
     XC=RC
     SAY 'REXX SYNTAX 'XC' ON LINE 'SIGL':'ERRORTEXT(XC)
     SAY 'REXX:- SYNTAX' XC':' ERRORTEXT(XC)
     SIGNAL FINIT
 XAILURE:
     XC=RC
     SAY 'REXX FAILURE 'XC' ON LINE 'SIGL':'
     IF XC = -3 THEN,
        SAY 'REXX:- PROGRAM NOT FOUND'
     ELSE IF XC = -8 THEN,
        SAY 'REXX:- INSUFFICIENT MEMORY FOR PROGRAM'
     ELSE,
        SAY 'REXX:- RETURN CODE' XC
     SIGNAL FINIT
 XALT:
     XC=RC
     SAY 'REXX:- CTRL-BREAK INTEXCEPTED'
     SIGNAL FINIT
 BADFILE:
  SAY 'FIRST RECORD IS NOT IN EXPECTED FORMAT:'
  SAY ' HH.MM.SS JOB18582  CTG8239I RESPONSE RECEIVED...'
  SAY 'ABORT'
 FINIT:
  SAY 'BYE'
###END CTGSTEDT
$$$BEG KIXSOCK3
/* REXX */

/*
QUERY THE CICS NATIVE TCP EZACONFG FILE AND REPORT ON THE RESPECTIVE
 ASSOCIATED SOCKET.
USE THIS WHEN YOUR LIST OF REGIONS IS SIMPLY 3 WORDS
APPLID REGIONTYPE REGIONCPU
WHERE REGIONTYPE IS D,T,A,P
WHERE REGIONCPU IS LPAR CHARACTER (X OR H ...)
CGE5 D X
*/
ADDRESS TSO
/* TRACE ?I */
 LOGMSG=15
A=''
ARG KIXDSN
PARSE VAR KIXDSN A '"' KIXDSN '"'
IF A \= '' THEN KIXDSN=A
IF KIXDSN='' THEN DO
 SAY 'MISSING DSN WITH CICS REGIONS LIST (COPYSEL). BYE'
 EXIT 8
 END
RESP = SYSDSN("'"KIXDSN"'")
IF RESP ^= 'OK' THEN DO
 SAY 'DSN WITH CICS REGIONS LIST (COPYSEL) NOT FOUND. BYE'
 EXIT 8
 END
"ALLOC FI(I) DA('"KIXDSN"') SHR"
IF RC \= 0 THEN DO
 SAY 'DSN WITH CICS REGIONS LIST (COPYSEL) NOT ALLOC. BYE'
 EXIT 8
 END
"EXECIO * DISKR I (STEM KIX. FINIS"
IF RC \= 0 THEN DO
 SAY 'DSN WITH CICS REGIONS LIST (COPYSEL) NOT EXCIO. BYE'
 EXIT 8
 END
"FREE FI(I)"
IF KIX.0 <= 0 THEN DO
 SAY 'DSN WITH CICS REGIONS LIST (COPYSEL) NO RECORDS. BYE'
 EXIT 8
 END
KIXCT=0
KIXRCT=0
KIXBD=0
DO I = 1 TO KIX.0
 T$P=KIX.I;IF SUBSTR(T$P,1,1)="*" THEN ITERATE
 IF POS("!NON",T$P)>0 THEN ITERATE
 KIXRCT=KIXRCT+1
 APPLID=WORD(T$P,1)
 TYP=WORD(T$P,2)
 KIXCPU=WORD(T$P,3)
 IF TYP="E" THEN TYP="D"
 IF POS(TYP,'DTAP') = 0 THEN DO
  SAY 'REGION TYP (WORD 2):'TYP': IS NOT ONE OF D,T,A,P. BYPASS.'
  SAY KIX.I
  ITERATE
  END
 I$="TTE"TYP".TSK.B."APPLID".TCP.CONFIG"
 RESP = SYSDSN("'"I$"'")
 IF RESP \= 'OK' THEN DO
  SAY 'REGION:'APPLID||' CONFIG FILES DOES NOT EXIST'
  SAY '       'I$
  KIXBD=KIXBD + 1
  ITERATE
  END
 KIXCT=KIXCT+1
 KIXRGN.KIXCT=APPLID||' '||TYP||' '||KIXCPU||' '||I$
 END
IF KIXCT = 0 THEN DO
 SAY 'DSN WITH CICS REGIONS LIST (COPYSEL) HAD NO VALID REGIONS.BYE.'
 EXIT 8
 END
IF KIXBD > 0 THEN DO
 SAY 'BYPASSED 'KIXBD' REGIONS.'
 END
CALL EXPLLDEF ISPLLIB TTEP.TSK.E.TCEM.PDSE UNCOND
/* TRACE ?I */
DO I = 1 TO KIXCT
 APPLID = STRIP(WORD(KIXRGN.I,1),'B')
 DSN = STRIP(WORD(KIXRGN.I,4),'B')
 KIXCPU=STRIP(WORD(KIXRGN.I,3),'B')
 "ALLOCATE FILE(VSAMFILE) DSNAME('"DSN"') SHR"
 IF RC \= 0 THEN DO
  KIXRSLT.I='ALLOCATE FAILED RC('RC') FOR 'DSN
  ITERATE
  END
  MY_REC='EMPTY'
  /* MAKE SURE KEY LENGTH MATCHES THE VSAM KEYLEN */
  MK=LEFT(APPLID,8)||'L'
  INTERPRET "VR = RXVSAM1('R1GEKSDS','VSAMFILE','"MK"','MY_REC')"
  RXVSAM_RESULT=VR
  IF RXVSAM_RESULT = 0 THEN DO
   IF SUBSTR(MY_REC,1,8) = LEFT(APPLID,8) THEN DO
    DSPSOCK=SUBSTR(MY_REC,17,2)
    KIXRSLT.I=LEFT(APPLID,9)||'CPU:'||KIXCPU||': SOCKET>'C2D(DSPSOCK)'<'
    END
    ELSE DO
    KIXRSLT.I=LEFT(APPLID,9)||' RETURNED AN ERROR:'||MY_REC
    END
   END
   ELSE DO
   KIXRSLT.I= 'READ CONFIG FOR 'APPLID' FAILED'
   END
  "FREE FILE(VSAMFILE)"
  SAY KIXRSLT.I
  END
DONEALL:
CLOSE_AND_EXIT:
WRITE_LOG_AND_EXIT:
SIGNAL FINIT
FINIT:
 SAY 'FINISHED: 'KIXCT' OUT OF A POSSIBLE 'KIXRCT' REGIONS IN LIST.BYE'
RETURN 0
###END KIXSOCK3
$$$BEG KIXSOCK1
/* REXX */

/*
QUERY THE CICS NATIVE TCP EZACONFG FILE AND REPORT ON THE RESPECTIVE
 ASSOCIATED SOCKET.
*/
address TSO
 /*TRACE ?I */
 LOGMSG=15
A=''
ARG APPLID KIXTYP
IF APPLID='' THEN DO
 PULL A
 PARSE VAR A APPLID KIXTYP
 END
UPPER APPLID
APPLID=STRIP(APPLID,'B')
UPPER KIXTYP
KIXTYP=STRIP(KIXTYP,'B')
IF APPLID = '' THEN SIGNAL EXITRC8
IF KIXTYP = '' THEN SIGNAL EXITRC8
IF KIXTYP = 'E' THEN KIXTYP='D'
DSN = 'TTE'||KIXTYP||'.TSK.B.'APPLID'.TCP.CONFIG'
RESP = SYSDSN("'"DSN"'")
IF RESP ^= 'OK' THEN SIGNAL EXITRC12
ADDRESS TSO "ALLOCATE FILE(VSAMFILE) DSNAME('"dsn"') SHR"
IF rc \= 0 THEN
  DO
    SAY 'Allocate failed for VSAMFILE with a return code of' rc
    EXIT rc
  END
CALL EXPLLDEF ISPLLIB TTEP.TSK.E.TCEM.PDSE UNCOND
/* rxvsam_result = RXVSAM('OPENINPUT','VSAMFILE','KSDS')
    IF rxvsam_result ^= 0 THEN
      DO
        LOGMSG = 'OPENINPUT failed: '
        CALL log_errors
        SIGNAL close_and_exit
      END */
/*1*/
MY_REC='EMPTY'
/* make sure key length matches the vsam keylen */
MK=LEFT(APPLID,8)||'L'
INTERPRET "VR = RXVSAM1('R1GEKSDS','VSAMFILE','"MK"','MY_REC')"
RXVSAM_RESULT=VR
say my_rec
IF rxvsam_result = 0 THEN
  DO
        IF SUBSTR(MY_REC,1,8) = LEFT(APPLID,8) THEN DO
         DSPSOCK=SUBSTR(MY_REC,17,2)
         LOGMSG = LEFT(APPLID,9)||'SOCKET>'C2D(DSPSOCK)'<'
         END
         ELSE DO
         LOGMSG=LEFT(APPLID,9)||' returned an error:'||LEFT(MY_REC,1,8)
         END
  END
ELSE
  DO
    LOGMSG = 'READ CONFIG FOR 'APPLID' FAILED'
    call log_errors
    SIGNAL close_and_exit
  END

DONEALL:
close_and_exit: NOP
/* rxvsam_result = RXVSAM('CLOSE','VSAMFILE')
IF rxvsam_result ^= 0 THEN
  DO
    LOGMSG = LOGMSG||'!!FINAL CLOSE FAILED:'
    CALL log_errors
  END */

write_log_and_exit: NOP

ADDRESS TSO "FREE FILE(VSAMFILE)"
SIGNAL FINIT
EXITRC8:
 LOGMSG = '!!! NO/INVALID PARMS PASSED'
 signal finit
EXITRC12:
 LOGMSG = '!!! INVALID tcp config:'||resp
 signal finit
finit:
IF A \= '' THEN PUSH LOGMSG
 ELSE DO
 SAY LOGMSG
 END
RETURN 0
EXIT
/*1*/
log_errors: nop

LOGMSG =    '  Return msg -->  ' rxvsam_returnmsg
LOGMSG =    '  Error msg -->   ' rxvsam_vsamerrormsg

RETURN


###END KIXSOCK1
$$$BEG EXPLSTAK
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA          -                                              */
 /* CEMHELP          - TSO BASE, RESTRICTED                         */
 /* CEMHELP          -                                              */
 /* CEMHELP END                                                     */
 /* STACKS APPEAR TO BE THE CONTAINER FOR THE BUFS.  */
 /* BUFS CAN BE ALLOCATED WITHIN THE STACK.          */
 /* BUFS CAN BE REMOVED TO 0 AND NOT AFFECT THE STACK COUNT */
 /* STACK CAN BE DELETED AND ALL THE BUFS AND ELEMENTS ARE DELETED */
 /* ANY ELEMENTS PUSHED INTO ANY OF THE CURRENT BUFS ON THE CURRENT */
 /* STACK WILL BE EXECUTED AS TSO COMMANDS UPON EXIT.  IF A NEWSTACK */
 /* IS CREATED BEFORE EXIT, THE PUSHED ELEMENTS ARE HIDDEN IN THE    */
 /* DEEPER STACK LEVEL.  THE STACKS ARE NOT VISABLE ACROSS ISPF WIND.*/
 TRACE ?I
 ADDRESS TSO
  QSTACK
 DO WHILE RC > 1
   DELSTACK 1
   QSTACK
  END
 NEWSTACK
  QSTACK
  QBUF
  QELEM
 QUEUE 'FIRST QUEUED'
 PUSH  'FIRST PUSH'
 PUSH  'SECOND PUSH'
 QUEUE 'SECOND QUEUED'
 PUSH  'THIRD PUSH'
  QSTACK
  QBUF
  QELEM
  XC=QUEUED()
 MAKEBUF
  QSTACK
  QBUF
  QELEM
  XC=QUEUED()
 QUEUE 'MFIRST QUEUED'
 PUSH  'MFIRST PUSH'
 PUSH  'MSECOND PUSH'
 QUEUE 'MSECOND QUEUED'
 PUSH  'MTHIRD PUSH'
  QELEM
  XC=QUEUED()
 MAKEBUF
  QSTACK
  QBUF
  QELEM
  XC=QUEUED()
 QUEUE 'NFIRST QUEUED'
 PUSH  'NFIRST PUSH'
 PUSH  'NSECOND PUSH'
 QUEUE 'NSECOND QUEUED'
 PUSH  'NTHIRD PUSH'
 QELEM
  QBUF
  XC= QUEUED()
 PULL ELEM
  XC= QUEUED()
 SAY ELEM
  QBUF
  QSTACK
 DELSTACK
  QSTACK
  QBUF
  QELEM
  XC=QUEUED()
 DO WHILE RC > 0
  PULL ELEM
  SAY ELEM
  QELEM
  END
  QSTACK
  QELEM
  XC=QUEUED()
 DROPBUF
  QELEM
  XC=QUEUED()
 DO WHILE RC > 0
  PULL ELEM
  SAY ELEM
  QELEM
  END
 XC=QUEUED()
  QSTACK
  QELEM
  QBUF
 PUSH 'EXPLRAND'
  QELEM
  XC=QUEUED()
 EXIT
###END EXPLSTAK
$$$BEG AFOS#PRM
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA AFOS#PRM - ISPF, CREATES RGN LIST WITH SUBSTITUTION VAL */
 /* CEMHELP AFOS#PRM - ISPF BASED, USED WITH AFOLIST AS A TSO CMD.  */
 /*                  - OBJECT IS TO CREATE A TWO COL LIST, THAT IS  */
 /*                  - USED FOR SYMBOL SUBSTITUTION OF '/!' WHEN    */
 /*                  - RUNNING CEDA, CEMT, PLAY, AFORDOR COMMANDS   */
 /* - AFOS#PRM IS A ISPF DRIVEN COMMAND, THAT WILL CALL REXXSRC:      */
 /* -  COLLECTS A LIST OF SOURCE STATEMENTS. EACH ENTRY SHOULD BE     */
 /* -  COMPRISED OF THE REGION APPLID, A SPACE, AND A VALUE SPECIFIC  */
 /* -  FOR THE REGION IDENTIFIED.                                     */
 /* - REXXSRC GATHERS THE COMPLETE LIST OF REGIONS, AND RETURNS THE   */
 /* -  LIST (PUSHED ONTO THE STACK). THIS EXEC THEN USES EACH ENTRY   */
 /* -  TO CREATE AN ISPF VARIABLE VPUT FOR LATER USE.                 */
 /* - TO UNIQUELY ID EACH REGION, EACH ISPF  VAR IS NAMED WITH A      */
 /* -  PREFIX 'S#' FOLLOWED BY THE APPLID. APPLIDS > 6 CHARS, USE     */
 /* -  THE LAST 6 CHARS APPENDED ONTO THE 'S#'                        */
 /* - FOR EXAMPLE 'CICSGULL' WOULD CREATE A VAR S#CSGULL              */
 /* -                                                                 */
 /* - CEMHELP REXXSRC TO SEE OPTIONS AVAILABLE FOR CREATING SRC DATA  */
 /* -                                                                 */
 /* - IN ADDITION TO A SET OF ISPF VARS NAMED ABOVE, THIS EXEC ALSO   */
 /* -  VPUT A S#PRMCT  - COUNT OF REGION SRC LINES                    */
 /* -         S#PRMLST - LIST OF S#... VARIABLE IN THE SET            */
 /* -                                                                 */
 /* - THE SET OF VARS ARE AVAILABLE FOR COMMAND PROCESSING FOR THE    */
 /* -  DURATION OF THE SESSION, OR UNTIL ANOTHER AFOS#PRM IS RUN      */
 /* -  AN OVERWRITES THE SET.                                         */
 /* -                                                                 */
 /* CEMHELP END                                                       */
  ADDRESS TSO "NEWSTACK"
  ADDRESS ISPEXEC
  "ISPEXEC CONTROL ERRORS RETURN"
  FFX='FF'X
  XC = 0
/*TRACE ?I */
  ACTN='PULL'         /* PULL MEANS DON'T LOOK FOR ISPVARS */
  EXECSEL = 'AFOS#PRM'
  ACCUMSG = EXECSEL||' CREATE S#PARMS FROM LIST:'||FFX
  DSEMSG = 'CREATE S#PARM (TWO COLS OF APPLID PARMV. PF3 END'
  ADDRESS ISPEXEC "VPUT (EXECSEL DSEMSG) ASIS"
  MYVARO = 'MRDOR'
  CALL REXXSRC ACTN"("MYVARO")"
  XC = RESULT
  IF XC ^= 0 THEN SIGNAL ERR_REXXSRC
  CC=QUEUED()
  IF CC = 0 THEN SIGNAL NO_CMDS
/*TRACE ?I   */
  SRC#=0
  SRCX#=0
  S#PRMCT=0
  S#PRMLST = ''
  SP1=' '
  DO K = 1 TO CC
   PULL SRC.K
   S#APLID  = WORD(SRC.K,1)
   S#VALUE  = WORD(SRC.K,2)
   IF LENGTH(S#APLID) < 7 THEN INTERPRET "T#PARM = 'S#"||S#APLID||"'"
    ELSE INTERPRET "T#PARM = 'S#"||SUBSTR(S#APLID,3)||"'"
   INTERPRET T#PARM " = S#VALUE"
   'ISPEXEC VPUT ('T#PARM') ASIS'
   IF RC > 0 THEN DO
    ACCUMSG = ACCUMSG||'VPUT ERROR   FOR APPLID:'S#APLID||FFX
    SRCX# = SRCX# + 1
    END
    ELSE DO
    ACCUMSG = ACCUMSG||'VPUT SUCCESS FOR APPLID:'S#APLID||FFX
    S#PRMLST=S#PRMLST||T#PARM||SP1
    S#PRMCT = S#PRMCT + 1
    END
   SRC#=K
   END
  ACCUMSG = ACCUMSG||'VPUT COUNTS:'||FFX||,
   'SUCCESS:'||S#PRMCT||FFX||'ERROR  :'||SRCX#||FFX
  'ISPEXEC VPUT (S#PRMCT,S#PRMLST) ASIS'
 SIGNAL FINIT
 ERR_REXXSRC:
  ACCUMSG = ACCUMSG||'ERROR RETURNED FROM LIST CREATE:'||FFX
  XC = 8
 SIGNAL FINIT
 NO_CMDS:
  ACCUMSG = ACCUMSG||'NO LIST ENTRIES RETURNED'||FFX
  XC = 4
 SIGNAL FINIT
 FINIT:
 ADDRESS TSO "DELSTACK"
   'ISPEXEC VPUT (ACCUMSG) ASIS'
 /* PUSH ACCUMSG */
 RETURN XC
###END AFOS#PRM
$$$BEG KIXSOCK2
/* REXX */

/*
QUERY THE CICS NATIVE TCP EZACONFG FILE AND REPORT ON THE RESPECTIVE
 ASSOCIATED SOCKET.
use this when your list of regions was created by copysel
applid ........... cpu regiontype release
where cpu is in col 68, regiontype is col 69, release is 70-72
*/
ADDRESS TSO
/* TRACE ?I */
 LOGMSG=15
A=''
ARG KIXDSN
PARSE VAR KIXDSN A '"' KIXDSN '"'
IF A \= '' THEN KIXDSN=A
IF KIXDSN='' THEN DO
 SAY 'MISSING DSN WITH CICS REGIONS LIST (COPYSEL). BYE'
 EXIT 8
 END
RESP = SYSDSN("'"KIXDSN"'")
IF RESP ^= 'OK' THEN DO
 SAY 'DSN WITH CICS REGIONS LIST (COPYSEL) NOT FOUND. BYE'
 EXIT 8
 END
"ALLOC FI(I) DA('"KIXDSN"') SHR"
IF RC \= 0 THEN DO
 SAY 'DSN WITH CICS REGIONS LIST (COPYSEL) NOT ALLOC. BYE'
 EXIT 8
 END
"EXECIO * DISKR I (STEM KIX. FINIS"
IF RC \= 0 THEN DO
 SAY 'DSN WITH CICS REGIONS LIST (COPYSEL) NOT EXCIO. BYE'
 EXIT 8
 END
"FREE FI(I)"
IF KIX.0 <= 0 THEN DO
 SAY 'DSN WITH CICS REGIONS LIST (COPYSEL) NO RECORDS. BYE'
 EXIT 8
 END
KIXCT=0
KIXRCT=0
KIXBD=0
DO I = 1 TO KIX.0
 T$P=KIX.I;IF SUBSTR(T$P,1,1)="*" THEN ITERATE
 IF POS("!NON",T$P)>0 THEN ITERATE
 KIXRCT=KIXRCT+1
 APPLID=WORD(T$P,1);TYP=SUBSTR(T$P,69,1);KIXCPU=SUBSTR(T$P,68,1)
 IF TYP="E" THEN TYP="D"
 I$="TTE"TYP".TSK.B."APPLID".TCP.CONFIG"
 RESP = SYSDSN("'"I$"'")
 IF RESP \= 'OK' THEN do
  SAY 'REGION:'APPLID||' CONFIG FILES DOES NOT EXIST'
  SAY '       'I$
  KIXBD=KIXBD + 1
  ITERATE
  END
 KIXCT=KIXCT+1
 KIXRGN.KIXCT=APPLID||' '||TYP||' '||KIXCPU||' '||I$
 END
IF KIXCT = 0 THEN DO
 SAY 'DSN WITH CICS REGIONS LIST (COPYSEL) HAD NO VALID REGIONS.BYE.'
 EXIT 8
 END
IF KIXBD > 0 THEN DO
 SAY 'BYPASSED 'KIXBD' REGIONS.'
 END
CALL EXPLLDEF ISPLLIB TTEP.TSK.E.TCEM.PDSE UNCOND
/* TRACE ?I */
DO I = 1 TO KIXCT
 APPLID = STRIP(WORD(KIXRGN.I,1),'B')
 DSN = STRIP(WORD(KIXRGN.I,4),'B')
 KIXCPU=STRIP(WORD(KIXRGN.I,3),'B')
 "ALLOCATE FILE(VSAMFILE) DSNAME('"DSN"') SHR"
 IF RC \= 0 THEN DO
  KIXRSLT.I='ALLOCATE FAILED RC('RC') FOR 'DSN
  ITERATE
  END
  MY_REC='EMPTY'
  /* make sure key length matches the vsam keylen */
  MK=LEFT(APPLID,8)||'L'
  INTERPRET "VR = RXVSAM1('R1GEKSDS','VSAMFILE','"MK"','MY_REC')"
  RXVSAM_RESULT=VR
  IF RXVSAM_RESULT = 0 THEN DO
   IF SUBSTR(MY_REC,1,8) = LEFT(APPLID,8) THEN DO
    DSPSOCK=SUBSTR(MY_REC,17,2)
    KIXRSLT.I=LEFT(APPLID,9)||'CPU:'||KIXCPU||': SOCKET>'C2D(DSPSOCK)'<'
    END
    ELSE DO
    KIXRSLT.I=LEFT(APPLID,9)||' RETURNED AN ERROR:'||MY_REC
    END
   END
   ELSE DO
   KIXRSLT.I= 'READ CONFIG FOR 'APPLID' FAILED'
   END
  "FREE FILE(VSAMFILE)"
  SAY KIXRSLT.I
  END
DONEALL:
CLOSE_AND_EXIT:
WRITE_LOG_AND_EXIT:
SIGNAL FINIT
FINIT:
 SAY 'FINISHED: 'KIXCT' OUT OF A POSSIBLE 'KIXRCT' REGIONS IN LIST.BYE'
RETURN 0
###END KIXSOCK2
$$$BEG CEMHELP
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA CEMHELP  - PRESENT CEMHELP PANEL (ABREVIATED OR FULL CMD*/
 /* CEMHELP CEMHELP  - TSO ISPF BASED EXEC DISPLAYS A PANEL WITH    */
 /* CEMHELP          - ABREVIATED CEM COMMANDS AVAILABLE, OR IN     */
 /* CEMHELP          - RESPONSE TO A PARM SUPPLIED WHEN CEMHELP IS  */
 /* CEMHELP          - INVOKED, A PANEL WITH THE DETAIL INFO WRT THE*/
 /* CEMHELP          - PARM (CEM COMMAND).                          */
 /*                  - VERSION 2.                                   */
 /* CEMHELP END                                                     */
 ARG QCMD REST
 TQUL = 'CLIST'
 CMDCNT=0
 RESP=QCMD
 IF RESP ^= '' THEN SIGNAL SPECIFIC
 RESP = 'CEMCMDS'
 SIGNAL DISPIT
SPECIFIC:
 IF SYSDSN("'TTED.TSK.P.TCEM."TQUL"("RESP")'") = 'OK' THEN ,
  SIGNAL DISPIT
 TQUL='EDITMAC'
 IF SYSDSN("'TTED.TSK.P.TCEM."TQUL"("RESP")'") ^= 'OK' THEN DO
  SAY 'NO HELP AVAILABLE...'
  EXIT
  END
DISPIT:
 "ALLOC FI(I) DA('TTED.TSK.P.TCEM."TQUL"("RESP")') SHR REUSE"
 "EXECIO * DISKR I (STEM CMD. FINIS"
 "FREE FI(I)"
 ADDRESS ISPEXEC
XERR:
  MAL = 0
  FFX = 'FF'X
  MYAREA# = FFX
  MYAREA = ''
  CMDCNT=CMD.0
  CMDSFX=''
  IF RESP = 'CEMCMDS' THEN DO
   I = 0
   SIGNAL FND_BEGIN
   END
  DO I = 1 TO CMDCNT
    IF POS('/* CEMHELP BEGIN',CMD.I) ^= 0 THEN SIGNAL FND_BEGIN
    END
  SAY 'COULD NOT FIND BEGINNINGG OF EMBEDDED HELP. SORRY.'
  EXIT
 FND_BEGIN:
  J = I + 1
  DO I = J TO CMDCNT
   IF QCMD ^= '' THEN DO
    PARSE VAR CMD.I . '/*' CMHP  CMDSFX '*/'
    IF CMHP = '' & CMDSFX='' THEN ITERATE
    IF WORD(CMHP,1) = 'CEMHELP' &,
       WORD(CMDSFX,1) = 'END' THEN SIGNAL OUTOFLOP
    IF WORD(CMHP,1) = 'CEMHELP' THEN CMHP = ''
    IF WORD(CMHP,1) = 'CEMHELA' THEN CMHP = ''
/*  IF WORD(CMHP,1) = '-' THEN CMHP = '' */
    CMDSFX=STRIP(CMDSFX,'B')
/*  IF WORDPOS('END',CMDSFX) = 1 THEN SIGNAL OUTOFLOP */
    CMDSFX=STRIP(CMHP||CMDSFX,'B')
    END
    ELSE CMDSFX=STRIP(CMD.I,'B')
   MYAREA = MYAREA||CMDSFX||FFX
   MAL = MAL + LENGTH(CMDSFX) + 1
   IF MAL > 32000 THEN DO
    SAY 'EXCESSIVE OUTPUT TERMINATED AT LENGTH 'MAL
    SIGNAL OUTOFLOP
    END
   END
OUTOFLOP:
 EXECSEL = 'CEMHELP'
 'ISPEXEC VPUT (EXECSEL MYAREA MYAREA#) ASIS'
DOAGN:
 CALL DSPLYA
 EXIT
###END CEMHELP
$$$BEG REXXSRC
/* REXX */
/* CEMHELP BEGIN                                                     */
/* CEMHELA REXXSRC  -  ISPF COLLECT SRC DATA INTO A STACK OF VARS    */
/* CEMHELP REXXSRC  -  ISPF COLLECT SRC DATA INTO A STACK OF VARS    */
/* CEMHELP          -                                                */
/* - VALID COMMANDS FOR THIS EXEC                                    */
/* - END       - SIGNAL END (PF3)                                    */
/* -  CANCEL|ABORT|BYPASS   SIGNAL TO CALLER AN ERROR                */
/* -  REXP(N)                                                        */
/* -  PASTE(A/B) - PASTE AFTER OR BEFORE CURSOR POS ISPF CUT DATA    */
/* -  COPY(A/B)  - COPY DATA FROM A DS                               */
/* -  STOR       - REXXSRC SAVED IN VARS FOR REUSE                   */
/* -  RETV       - RETRIEVE STORED DATA FROM VARS                    */
/* -  RESET      - CLEAR THE SRC DATA (REFRESH)                      */
/* -  GETMAC     - ALLOW YOU TO RUN A ISPF EDIT MAC ON DATA          */
/* -  GETAFOL    - ALLOW YOU TO COPY A AFOLIST REGION VAR AS SRC DATA*/
/* -  ? OR HELP  - DISPLAY SHORT HELP DATA                           */
/* -                                                                 */
/* - REXXSRC IS A UTILITY PROGRAM DESIGNED TO COLLET DATA FOR        */
/* -  USE BY OTHER EXECS.                                            */
/* -  IT IS USUALLY ENGAGED TO COLLECT SINGLE LINE COMMAND REQUESTS  */
/* -  THAT IS USED TO DRIVE OTHER PROCESSES                          */
/* - OR TO COLLECT A K=V TYPE OF LIST                                */
/* -                                                                 */
/* - THE INTERFACE TO AFOLIST AFOS#PRM ALLOWS FOR LIST CREATION      */
/* -  THAT IS BASED ON A AFOLIST VAR NAMING A SET OF REGIONS         */
/* -                                                                 */
/* - AS SRC DATA IS ENTERED, IF YOU WOULD HONOR THE ONE OF THE       */
/* -  SYMBOLIC SUBSTITUTION SYMBOLS /@ /$ /! //                      */
/* -  YOU WOULD COMPOSE THE COMMANDS INCLUDING THOSE SYMBOLS AS      */
/* -  NEEDED: CEDA LIST LIST(/@)   LIST THE RDO LIST NAMED APLID     */
/* -                                                                 */
/* CEMHELP END                                                       */
 ADDRESS ISPEXEC
 "ISPEXEC ADDPOP "
 ARG MYVARO
 PARSE VAR MYVARO SVVAR '(' MYVARO ')' REST
 IF MYVARO = '' THEN DO
  MYVARO='SVVAR'
  SVVAR='PULL'
  END
 TP=POS('TRAC',SVVAR)
 FP=POS('ISPF',SVVAR)
 LP=POS('PULL',SVVAR)
 IF FP+LP < 1 THEN SIGNAL EXITRC12
 IF DATATYPE(SUBSTR(MYVARO,1,1)) ^= 'CHAR' THEN SIGNAL EXITRC12
 EXECSEL='REXXSRC'
 DSEMSG=''
 MYVERB = ''
 MYAREA = ''
 STORIND=0
 VALCMD = 'END,GETAFOL,PASTE(A/B),COPY(A/B),STOR,RETV,RESET,GETMAC'||,
  ',REXP(N)'
 "ISPEXEC VGET (EXECSEL DSEMSG) ASIS"
OKVARO:
/* IF LENGTH(MYVARO) > 5 THEN SIGNAL EXITRC8 */
 HDSEMSG = DSEMSG
 MXCT = 0
 SVCI = 0        /* TOP LOGICAL LINE */
 SVCT = 1        /* TOP LOGICAL LINE */
 SVC  = 1        /* TOP LOGICAL LINE */
 SVCB = 10       /* BOTTOM LOGICAL LINE */
 SUDT=DATE('U')
 SP79=COPIES(' ',79)
 XC = 0
 DN = 10         /* SCREEN SIZE */
 XIND = 0
 I = 0
DSPLOOP:
/* TRACE OFF */
 IF SVCI < 1 THEN SVCI = 1
  ELSE IF SVCI > MXCT THEN SVCI = MXCT + 1
 SVC = SVCI
 DO I = 0 TO 9
  TMPI = SVC + I
  IF TMPI > MXCT THEN T.TMPI = ''
  INTERPRET "MYDSP"I+1" = T."TMPI
  END
 MYAREA = ''
NORFRSH:
 SVC = SVCI
 ZCMD = ''
 STIM=TIME()
 IF MYVERB = '' THEN DO
  ZEDSMSG = ""
  ZEDLMSG = ""
  "ISPEXEC SETMSG MSG(ISRZ001)"
  END
 MYVERB=''
 CMD=''
 HSVCI = SVCI
 "ISPEXEC DISPLAY PANEL(REXXSRCD)"
 XC=RC
 /* TRACE ?I */
 DSEMSG = HDSEMSG
 MYVERB = MYVERB
 IF XC=8 THEN CMD = 'END'
 HCMD=CMD
 PARSE VAR CMD CMD REST
 SELECT
   WHEN CMD = 'END' THEN XIND = 1
   WHEN CMD = 'ABORT' THEN SIGNAL EXITRC4
   WHEN CMD = 'BYPASS' THEN SIGNAL EXITRC4
   WHEN CMD = 'CANCEL' THEN SIGNAL EXITRC4
   OTHERWISE NOP
   END
 IF CMD = '?' | CMD = 'HELP' THEN DO
  DSEMSG = VALCMD
  SIGNAL NORFRSH
  END
LSTPNL:
 IF CMD = 'RESET' THEN DO
   IF STORIND = 1 THEN DO
   INTERPRET MYVARO||"TOT = 0"
   "ISPEXEC VPUT ("MYVARO||"TOT) ASIS"
    STORIND=0
    END
   MXCT = 0
   I = 0
   SVCT = 1        /* TOP LOGICAL LINE */
   SVC  = 1        /* TOP LOGICAL LINE */
   SVCB = 10       /* BOTTOM LOGICAL LINE */
   DROP T.
   SIGNAL DSPLOOP
   END
 IF CMD = 'PASTEB' THEN CALL PSTIT
 IF CMD = 'COPYB' THEN CALL CPYIT
 NULLRUN=0
 NPI = 0
 DO I = 0 TO 9
  INTERPRET 'TMP = MYDSP'I+1
  IF TMP = '' THEN ITERATE
  T.SVC = TMP
  SVC = SVC + 1
  END
  IF MYAREA ^= '' THEN DO
   T.SVC = TMP
   SVC = SVC + 1
   END
 IF CMD = 'PASTEA' | CMD = 'PASTE' THEN CALL PSTIT
 IF CMD = 'COPYA' | CMD = 'COPY' THEN CALL CPYIT
 IF ABBREV('REXPNTN',CMD,4) = 1 THEN DO
   CALL REXPNT
   IF RESULT ^= 0 THEN SIGNAL NOPNT
  IF CMD = 'REXP' | CMD = 'REXPNT' THEN DO
   CALL JRPPNT 'JRPPNT'
   XC=RESULT
   IF XC^= 0 & XC <20 THEN SIGNAL NOPNT
   END
   ELSE DO
   CALL JRPPNT 'JRPPNT'
   XC=RESULT
   IF XC^= 0 & XC <20 THEN SIGNAL NOPNT
   END
  ZEDSMSG='PRINTED JRP'XC
  END
 IF CMD = 'GETAFOL' THEN DO
   IF REST \= '' THEN DO
    TMPVAR = WORD(REST,1)
    IF LENGTH(TMPVAR) < 9 THEN DO
     "ISPEXEC VGET ("TMPVAR") ASIS"
     IF RC = 0 THEN DO
      INTERPRET 'TMPLST = 'TMPVAR
      TMPCT = WORDS(TMPLST)
      DO I = 1 TO TMPCT
       TMP = WORD(TMPLST,I)
       T.SVC = TMP
       SVC = SVC + 1
      END
     END
    END
   ELSE ZEDSMSG='MISS AFOL NAME'
   END
  END
  IF CMD = 'RETV' THEN DO
   "ISPEXEC VGET ("MYVARO"TOT) ASIS"
   IF RC = 0 THEN DO
    INTERPRET "TMPCT = "MYVARO"TOT"
    DO I = 1 TO TMPCT
     "ISPEXEC VGET ("MYVARO||I") ASIS"
     INTERPRET "TMP= "MYVARO||I
     IF TMP = '' THEN ITERATE
     T.SVC = TMP
     SVC = SVC + 1
     END
    END
   END
  IF CMD = 'STOR' THEN DO
   IF MXCT < 1 THEN DO
    DSEMSG='NO SOURCE TO STOR IN 'MYVARO
    SIGNAL OUTGMAC
    END
   MYVARX = ''
   DO I = 1 TO MXCT
    INTERPRET MYVARO||I "= VALUE('T.I')"
    MYVARX=MYVARX||' '||MYVARO||I
    END
   INTERPRET MYVARO||"TOT = MXCT"
   "ISPEXEC VPUT ("MYVARO||"TOT) ASIS"
   IF RC = 0 THEN DO
   "ISPEXEC VPUT ("STRIP(MYVARX,'B')") ASIS"
    DSEMSG='SOURCE STOR IN 'MYVARO' 1 TO 'MXCT
    STORIND=1
    END
    ELSE DSEMSG='ERROR FOR STOR IN 'MYVARO'; NOTHING STORED'
   END
 IF WORD(CMD,1) = 'GETMAC' THEN DO
  IF WORDS(HCMD) > 1 THEN DO
   MY#EDT=WORD(HCMD,2)
   MY#EDTL=LENGTH(MY#EDT)
   IF MY#EDTL<1 | MY#EDTL>5 THEN DO
    DSEMSG="GETMAC VARIABLE NAME NOT 1-5 CHAR. RETRY"
    SIGNAL OUTGMAC
    END
   IF DATATYPE(SUBSTR(MY#EDT,1,1)) ^= 'CHAR' THEN DO
    DSEMSG="GETMAC VARIABLE NAME INVALID. RETRY"
    SIGNAL OUTGMAC
    END
   END
   ELSE MY#EDT='DOEDT'
  IF EXECSEL='DSNL2MAC' THEN DO
   DSEMSG="GETMAC RECURSION NOT ALLOWED"
   SIGNAL OUTGMAC
   END
  HDSEMSG1=DSEMSG
  DSEMSG='ENTER ISREDIT COMMANDS FOR DSNL2MAC MACRO'
  HEXECSEL=EXECSEL
  EXECSEL="DSNL2MAC"
  ADDRESS ISPEXEC "VPUT (DSEMSG EXECSEL) ASIS"
  CALL REXXSRC 'ISPF('MY#EDT')'
  RC=RESULT
  HEXECSEL=EXECSEL
  EXECSEL=HEXECSEL
  DSEMSG=HDSEMSG1
  ADDRESS ISPEXEC "VPUT (DSEMSG EXECSEL) ASIS"
  IF RC ^= 0 THEN DO
   DSEMSG="GETMAC FAILED. SORRY."
   SIGNAL OUTGMAC
   END
  END
OUTGMAC:
 IF MXCT < (SVC-1) THEN MXCT = SVC-1
 IF XIND = 1 THEN SIGNAL EXITRC0
  SELECT
   WHEN MYVERB = 'UP' THEN DO
    SVCI = SVCI-DN
    SIGNAL DSPLOOP
    END
   WHEN MYVERB = 'UP M' THEN DO
    SVCI = 1
    SIGNAL DSPLOOP
    END
   WHEN MYVERB = 'DOWN M' THEN DO
    SVCI = MXCT-DN+1
    SIGNAL DSPLOOP
    END
   WHEN MYVERB = 'DOWN' THEN DO
    SVCI = SVCI + DN
    IF SVCI > MXCT THEN SVCI = MXCT - DN + 1
    SIGNAL DSPLOOP
    END
   OTHERWISE DO
    IF SVCI = HSVCI THEN SVCI = SVC
    END
   END
  SIGNAL DSPLOOP
 EXITRC0:
  XC = 0
  MYVARX=''
  DO I = 1 TO MXCT
   IF FP > 0 THEN DO
    INTERPRET MYVARO||I" = VALUE('T.I')"
    MYVARX=MYVARX||' '||MYVARO||I
    END
   IF LP > 0 THEN DO
    QUEUE T.I
    END
   END
  IF FP > 0 THEN DO
   IF MXCT < 1 THEN SIGNAL EXITRC2
   INTERPRET MYVARO||"TOT = MXCT"
   "ISPEXEC VPUT ("MYVARO||"TOT) ASIS"
   IF RC ^= 0 THEN SIGNAL EXITRC8
   "ISPEXEC VPUT ("STRIP(MYVARX,'B')") ASIS"
   IF EXECSEL='DSNL2MAC' THEN DO
    IF POS('ISPF',SVVAR) ^= 1 THEN MYVARO='TRAC('MYVARO')'
    DSNL2MAC=MYVARO
    "ISPEXEC VPUT (DSNL2MAC) ASIS"
    END
   END
  SIGNAL WRITIT
 EXITRC2:
  XC = 2
  SIGNAL WRITIT
 EXITRC4:
  XC = 4
  SIGNAL WRITIT
 EXITRC8:
  XC = 8
  SIGNAL WRITIT
 EXITRC12:
  XC = 12
  SIGNAL WRITIT
WRITIT:
 "ISPEXEC REMPOP"
 RETURN XC
WRITMSG: PROCEDURE EXPOSE ZEDSMSG ZEDLMSG
 "ISPEXEC SETMSG MSG(ISRZ001)"
 XC = RC
 RETURN XC
PSTIT: PROCEDURE EXPOSE SVC T. XC SVCT REST MYVARO
  IF REST ^= '' THEN DO
   MYCN=STRIP(LEFT(MYCN,5),'T')
   IF REST = MYVARO THEN RETURN 12
   MYCN=REST
   POOL='ASIS'
   END
   ELSE DO
   MYCN='MYCN'
   POOL='PROFILE'
   END
  "ISPEXEC VGET ("MYCN"TOT) "POOL
  IF RC ^= 0 THEN RETURN 4
  INTERPRET "L="MYCN"TOT"
  IF L = 0 THEN RETURN 4
  DO I = 1 TO L
   INTERPRET "DVAL= "MYCN||I
   "ISPEXEC VGET ("VALUE('DVAL')") "POOL
   IF RC ^= 0 THEN ITERATE
   TMP=VALUE(DVAL)
   T.SVC = TMP
   SVC = SVC + 1
   END
  ZEDSMSG = "DATA PASTE"
  ZEDLMSG = "DATA PASTED TO VARIABLES"
 "ISPEXEC SETMSG MSG(ISRZ001)"
  RETURN 0
CPYIT: PROCEDURE EXPOSE SVC T. XC SVCT MYVARO
  TDS="MYVAROCD"
  TMB="MYVAROCM"
  "ISPEXEC VGET ("TDS") ASIS"
  IF RC ^= 0 THEN INTERPRET TDS"='ENTER.YOUR.CLIST.DSN'"
  INTERPRET "EDSN="TDS
  "ISPEXEC VGET ("TMB") ASIS"
  IF RC ^= 0 THEN INTERPRET TMB"='#MBR#'"
  INTERPRET "EMBR="TMB
  EXECSEL=MYVARO
  ADDRESS ISPEXEC "VPUT (EDSN EMBR EXECSEL DSEMSG) ASIS"
  CALL GDSNNMBR
  IF RESULT ^= 0 THEN RETURN 4
  ADDRESS ISPEXEC "VGET (EDSN EMBR) ASIS"
  EDSN=STRIP(EDSN,'T')
  EMBR=STRIP(EMBR,'T')
  INTERPRET TDS" = EDSN"
  INTERPRET TMB" = EMBR"
  "ISPEXEC VPUT ("TDS TMB") ASIS"
  CALL MALOC EDSN
  IF RC ^= 0 THEN RETURN 4
  EDSN=EDSN||'('||EMBR||')'
  ADDRESS TSO "ALLOC FI(RSDSN) DATASET('"EDSN"') SHR"
  ADDRESS TSO "EXECIO * DISKR RSDSN (STEM RSZ. FINIS"
  ADDRESS TSO "FREE FI(RSDSN)"
  IF RC ^= 0 THEN RETURN 4
  L=RSZ.0
  IF L = 0 THEN RETURN 4
  DO P = 1 TO L
   T.SVC = RSZ.P
   SVC = SVC + 1
   END
  ZEDSMSG = "MBR COPIED"
  ZEDLMSG = "MBR COPIED TO VARIABLES"
 "ISPEXEC SETMSG MSG(ISRZ001)"
  DROP RSZ.
  RETURN 0
REXPNT: PROCEDURE EXPOSE MXCT T. XC
 IF MXCT ^> 0 THEN RETURN 4
 DO I = 1 TO MXCT
  INTERPRET 'REXS'||I'= T.I'
  'ISPEXEC VPUT (REXS'I') ASIS'
  END
 MYCN = 'REXS'
 MYCNTOT = MXCT
  ZEDSMSG = "DATA PRINTED"
  ZEDLMSG = "DATA SENT TO PRINTER"
 "ISPEXEC SETMSG MSG(ISRZ001)"
 "ISPEXEC VPUT (MYCN MYCNTOT) ASIS"
 RETURN 0
###END REXXSRC
$$$BEG DSPAFOCD
)ATTR
/*.........1.........2.........3.........4.........5.........6 */
  # AREA(scrl) extend(on)
  + TYPE(TEXT) INTENS(LOW) SKIP(ON)
   TYPE(INPUT) INTENS(HIGH) COLOR(GREEN) JUST(ASIS)
  @ TYPE(&seln) INTENS(LOW) COLOR(GREEN) JUST(ASIS)
  $ TYPE(OUTPUT) INTENS(HIGH) CAPS(OFF) COLOR(red)
  { TYPE(OUTPUT) INTENS(HIGH) CAPS(OFF) COLOR(blue)
)BODY WINDOW(61,14)
{execsel +:ZCMD                         mysc+
$dsemsg
+Process: (Q)uiet msgbox(O)nly msgbox(A)ll (V)erbose:Z+
+Command ($Z   +) Autosave y/n:Z+ Enter CA Len: hycal +
{linkpmsg                                        @hyprog  +
{linktmsg                                        @Z   +
+Enter COMMAREA (? for help): (cmd: CLRCA RESCA CANCEL)
#myarea                                                     #
#                                                           #
)AREA MYAREA DEPTH(2)
f1                                                         +
f2                                                         +
f3                                                         +
f4                                                         +
f5                                                         +
f6                                                         +
f7                                                         +
f8                                                         +
f9                                                         +
f10                                                        +
f11                                                        +
f12                                                        +
f13                                                        +
f14                                                        +
f15                                                        +
f16                                                        +
f17                                                        +
f18                                                        +
f19                                                        +
f20
)INIT
 &zcmd = ''
 .ZVARS = '(hyfunc1,mycmd,autosave,hytranid)'
 .CURSOR = hycal
)PROC
 &cmd=&zcmd
 &myverb=&zverb
 VER (&hycal,NB,RANGE,0,32400)
 VER (&hyfunc1,LISTV,&valfunc1)
 VER (&autosave,LIST,Y,y,N,n)
)END
###END DSPAFOCD
$$$BEG AFOLPLAY
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA AFOLPLAY - SUBROUTINE TO AFOLIST. SEE AFOLIST           */
 /* CEMHELP AFOLPLAY - SUBROUTINE TO AFOLIST. SEE AFOLIST           */
 /* PLAY A SCRIPT FILE IN AFOLIST                                   */
 /* REQUIRED PARAMETERS FOR EXEC:                                   */
 /*  NONE.                                                          */
 /* OPTIONAL PARAMETERS FOR EXEC:                                   */
 /*        MYFUNC MYPLAY PRMS                                       */
 /*  PLAY THE SCRIPT FILE FOR EACH APPPLID                          */
 /*  ASSUME THAT THE VARIABLES AFOSCNN AND MYAPLID  HAVE BEEN       */
 /*         - WRITTEN AS ISPFVARS.                                  */
 /*         - READ THESE VARS, AND SET UP PARAMETER LIST TO CALL    */
 /*           EXCIS0                                                */
 /*         - ONE COMMAND PER CALL                                  */
 /*         - EACH COMMAND RETRUNS WITH A RESULT. WE ACCUMULATE     */
 /*           THE SERIES OF CALLS FOR EACH APPLID.                  */
 /*         - WE PRODUCE ONE MSGBOX DISPLAY WHICH SHOWS THE RESULT  */
 /*           OF THE COMMANDS PER APPLID                            */
 /*                                                                 */
 /*  PARAMETERS SENT TO EXCIS0, ARE FIRST GATHERED FROM PRMS,       */
 /*         - OR  FROM ISPF VARS. SOME PARMS HAVE DEFAULT VALUES.   */
 /*  MYFUNC - FIRST PARM IDENTIFIES THE OUTPUT PROCESS              */
 /*         - WE ARE USING MSGBOXALL TO SHIP US THE RESULT          */
 /*         - ONE OF MSGBOXONLY MSGBOXALL VERBOSE QUIET             */
 /*         - MSGBOXONLY DEFAULT                                    */
 /*  MYPLAY - '' OR 'PLAY'                                          */
 /*  PRMS   - CAN BE PROVIDED OR WRITTEN TO ISPFVARS AS NAMED       */
 /*  MYCMD  - DESIRED COMMAND PROCESSING OPTION                     */
 /*           ONE WE VALIDATE IT IS ONE OF THE FOLLOWING:           */
 /*           CEMT CEDA LINK                                        */
 /*         - IF YOU SEND A LINK COMMAND, THEN YOU MUST HAVE        */
 /*           INCLUDED A MYPROG(XXXXXXXX) VARIABLE  AND             */
 /*           OPTIONALY A MYTRANID(YYYY)                            */
 /*           OPTIONALY A MYCA(COMMAREA)                            */
 /*           OPTIONALY A MYCAL(NNN)                                */
 /*           AFTER LINK PROGRAM(XXXX), THE OTHER VARIABLES IN ANY  */
 /*           ORDER.                                                */
 /*   LINK MYPROG(UCEMPINQ) MYTRANID(UXXX) MYCAL(1016) MYCA(PING)   */
 /*                                                                 */
 /*  MYAPLID- WE GET THE APPLID LIST, AND THEN INVOKE THE SET OF    */
 /*           THAT WE HAVE EXTRACTED FROM THE ISPFVAR AFOSC 1 - 99  */
 /*           COMMAND VARIABLES                                     */
 /*         - WE HAVE COUNTED THE CURRENT NUMBER OF COMMANDS AND    */
 /*           SET THE AFOSCTOT ISPF VARIABLE TO THIS VALUE          */
 /*  MYTRANID - WE SEND THE DEFAULT UNLESS YOU REQUEST LINK         */
 /*                                                                 */
 /*  MYPROG - WE SEND THE DEFAULT UNLESS YOU REQUEST LINK           */
 /*                                                                 */
 /*  MYCA   - WE SEND THE DEFAULT UNLESS YOU REQUEST LINK           */
 /*                                                                 */
 /*  MYCAL  - WE SEND THE DEFAULT UNLESS YOU REQUEST LINK           */
 /*                                                                 */
 /*  ODSN - CAN BE 'DISPLAY' WHICH WILL DISPLAY UP TO 99 LINES      */
 /*       - A DATASET (NEW OR EXISTING) IF EXISTING, YOU ARE        */
 /*         PROMPTED TO ACCEPT REUSE. IT CAN BE A PDS(E) WITH MBR   */
 /*                                                                 */
 /*                                                                 */
 /* CEMHELP END                                                     */
 /*                                                                 */
 /*                                                                 */
  ADDRESS ISPEXEC
  "ISPEXEC CONTROL ERRORS RETURN"
 /*TRACE I */
  ARG MYFUNC MYPLAY PRMS
  VALFUNC = 'MSGBOXONLY MSGBOXALL VERBOSE QUIET'
  VALFUNCPLAY=VALFUNC||' PLAY'
  VALPRMS='MYCMD MYCA MYCAL MYPROG MYTRANID'
  DFTPVALS='PING . 0 UCEMPINQ CSMI'
  NPW=WORDS(VALPRMS)
  DO I = 1 TO NPW
   TMP = WORD(VALPRMS,I)
   TMPV = WORD(DFTPVALS,I)
   IF TMPV = '.' THEN TMPV = ''
    ELSE IF TMPV = '\.' THEN TMPV = '.'
   INTERPRET TMP"='"TMPV"'"
   END
  VALCMDS = 'PING CEMT CEDA LINK'
  X15='15'X
  XFF='FF'X
  MAX_CAL=32400
  DFT_CAL=4080
  PING_CAL=1008
  DFT_UCEMPIN'UCEMPINQ'
 /* SUBSTITUTE VARS - ALL MUST BE SAME LENGTH */
 /* SET THE FNDWDL TO THE LENGTH OF A SINGLE SUB VAR */
  BKSLH = ' \'
  FNDWDS='\@ \$ \! \\'  /* SUBSTITUTE \ APPLID JOBNAME */
  FNDWDL=2
  RWCT=WORDS(FNDWDS)
  SUBWDS='MYAPLID JOBN S#PARM BKSLH'
   DLM='(<{[='
   MDLM=')>}] '
   #DMM=LENGTH(DLM)
  IF MYFUNC = '' THEN DO
   MYFUNC = 'MSGBOXALL'
   MYPLAY = 'PLAY'
   SIGNAL USE_MBO
   END
  IF MYPLAY = '' THEN DO
   MYPLAY = 'PLAY'
   SIGNAL USE_MBO
   END
  IF PRMS ^= '' THEN H_PRMS = PRMS
/* TRACE I */
   IF PRM_RC > 4 THEN SIGNAL EXITRC4
USE_MBO:
   IF WORDPOS(MYFUNC,VALFUNC) = 0 THEN MYFUNC = 'MSGBOXALL'
   IF WORDPOS(MYPLAY,VALFUNCPLAY) = 0 THEN MYPLAY = 'PLAY'
   IF MYFUNC = 'QUIET' THEN DO
    IF ODSN = '' | ODSN = 'ODSN' THEN DO
     CALL GETUDSN 'AFOLIST'
     PULL ODSN
     END
    IF ODSN = '' THEN SIGNAL EXITRC10
    SIGNAL GOTFUNC
    END
 GOTFUNC:
   MYCA = 'PING'
   H_MYCA = MYCA
   MYCAL = PING_CAL
   H_MYCAL = MYCAL
   MYPROG = DFT_UCEMPIN
   H_MYPROG = MYPROG
   MYTRANID = 'CSMI'
   H_MYTRANID = MYTRANID
   'ISPEXEC VGET (AFOSCTOT) ASIS'
   IF RC > 0 | AFOSCTOT < 1 THEN SIGNAL EXITRC12
   SCRPTLST=''
   DO K = 1 TO AFOSCTOT
    SCRPTLST=SCRPTLST||'  AFOSC'||K
    END
   'ISPEXEC VGET ('SCRPTLST') ASIS'
   IF RC ^= 0 THEN SIGNAL EXITRC12
   DO K = 1 TO AFOSCTOT
    INTERPRET 'AFOSC.K =  AFOSC'||K
    END
   'ISPEXEC VGET (MYAPLID) ASIS'
   IF RC ^= 0 THEN SIGNAL EXITRC12
   H_APLID=MYAPLID
   I = 0
  BYPCT=0
  RGNCT=0
   DO WHILE(MYAPLID ^= '')
    PARSE VAR MYAPLID APL_TMP MYAPLID
    RGNCT=RGNCT + 1
    IF SUBSTR(APL_TMP,1,1) = '!' THEN DO
     BYPCT=BYPCT + 1
     ITERATE
     END
    I = I + 1
    APL_STM.I = APL_TMP
    END
   NAPLID = I
   IF NAPLID<1 THEN SIGNAL EXITRC12
   COMA=','
TSTAPLIDS:
 /* OK HERE WE GO */
   IF MYPLAY = 'MSGBOXALL' | MYPLAY = 'QUIET' THEN DO
    MSGLOCK='Y'
    MSGSTAT='CONTPOP'
    MSGBOXTX='STARTING: PROCESSING COMMAND FOR ALL APPLIDS...'
    ADDRESS ISPEXEC "VPUT (MSGBOXTX) ASIS"
    ADDRESS ISPEXEC "VPUT (MSGLOCK MSGSTAT) ASIS"
    CALL MSGBOX
    END
   J = 1          /* USE J FOR APPLID LIST */
   MXLNG = 0
   TOTLNG=0
TOPOFLOP:
   MYAPLID = APL_STM.J
   K = 0          /* USE K FOR COMMAND LIST */
TOPOFCMD:
    UU='AFOLPLAY'
   K = K + 1
   IF K > AFOSCTOT THEN SIGNAL DONE_CMDS
   H_CMD_STR = AFOSC.K
   MYCMD = WORD(H_CMD_STR,1)
   IF WORDPOS(MYCMD,VALCMDS) = 0 THEN SIGNAL TOPOFCMD
   H_CMD_STRL = DFT_CAL
   /* TRACE I */
   CALL SUBJOBN
   IF RESULT /= 0 THEN SIGNAL INVPARM
   MYCA = H_CMD_STR
   IF MYCMD = 'PING' THEN DO
    MYCAL = DFT_PING_CAL
    SIGNAL SETPROG
    END
   IF MYCMD = 'CEMT' | MYCMD = 'CEDA' THEN DO
    MYCAL = MAX_CAL
    SIGNAL SETPROG
    END
   IF MYCMD = 'LINK' THEN DO
 /* TRACE I */
    H_MYCA = MYCA
    H_MYCAL = MYCAL
    H_MYPROG = MYPROG
    H_MYTRANID = MYTRANID
    CALL CHKPRMS
 /* TRACE I */
    IF RESULT ^= 0 THEN SIGNAL BADLINK
    IF MYPROG = '' THEN SIGNAL INVPARM
    IF MYTRANID = '' THEN MYTRANID = 'CSMI'
     ELSE DO
     LTRID = LENGTH(MYTRANID)
     IF LTRID < 1 | LTRID > 4 THEN SIGNAL INVPARM
     END
    IF MYCAL = '' | MYCAL < 1 THEN DO
     IF MYCA = '' THEN MYCAL = 0
      ELSE MYCAL=LENGTH(MYCA)
      END
     END
    IF DATATYPE(MYCAL) ^= 'NUM' THEN SIGNAL BADCA
    IF MYCAL < 0 | MYCAL > 32400 THEN SIGNAL BADCA
    SIGNAL SET_H_VARS
    END
SETPROG:
   IF MYTRANID = '' THEN MYTRANID = 'CSMI'
   MYPROG='UCEMPINQ'
SET_H_VARS:
   L_CA = LENGTH(MYCA)
   IF DATATYPE(MYCAL) ^= 'NUM' THEN MYCAL = L_CA
   IF MYCAL < L_CA THEN MYCAL = L_CA
  "ISPEXEC VPUT (MYAPLID MYPROG MYCA MYCAL MYTRANID) ASIS"
   IF RC ^= 0 THEN SIGNAL CHK_ERR
   IF MYPLAY = 'MSGBOXALL' | MYPLAY = 'QUIET' THEN DO
    MSGBOXTX=MYFUNC||' '||MYCMD||'... PROCESSING >'||LEFT(MYAPLID,8)    T
    ADDRESS ISPEXEC "VPUT (MSGBOXTX) ASIS"
    CALL MSGBOX
    END
/* TRACE I */
   CALL EXCIS2 MYFUNC
   XC = RESULT
   IF XC = 4 THEN SIGNAL DONEIT
   TMP=XFF||LEFT(MYAPLID,9)||MYCMD||'-->'||XFF
   IF XC ^= 0 THEN TMP = TMP||'WARNING - CALL RETURNED 'XC||XFF
   "ISPEXEC VGET (MYCA ) ASIS"
   MYCA = STRIP(MYCA,'B')
   L_CA=LENGTH(MYCA)
   TOTLNG = TOTLNG + L_CA
   IF TOTLNG > 32400 THEN DO
    ERR=MYCMD' OR EARLIER COMMANDS PRODUCED EXCESSIVE LENGTH'
    SIGNAL DOERR
    END
   TMP=TMP||TRANSLATE(MYCA,XFF,X15)
   SIGNAL NXT_CMD
 BADCA:
  ERR=MYCMD' COMMAND: MISSING OR INVALID COMMAREA'
  SIGNAL DOERR
 BADLINK:
  SIGNAL DOERR
 INVLINK::
  ERR='LINK COMMAND: INVALID PROGRAM, COMMAREA OR TRANSID'
  SIGNAL DOERR
 DOERR:
  TMP=TMP||' EXEC ERROR:'XC||XFF||ERR
 EXITRC0:
 NXT_CMD:
  MYCA = H_MYCA
  MYCAL = H_MYCAL
  MYPROG = H_MYPROG
  MYTRANID = H_MYTRANID
  APL_STM.J = APL_STM.J||TMP
  SIGNAL TOPOFCMD
 DONE_CMDS:
   IF MYFUNC = 'VERBOSE' | MYFUNC = 'MSGBOXALL' THEN DO
    EXECSEL = MYAPLID
    "ISPEXEC VPUT (EXECSEL) ASIS"
    MYAREA=APL_STM.J
    MYCA = H_MYCA
    MYAREA#=XFF
    "ISPEXEC VPUT (MYAREA MYAREA#) ASIS"
/*  CALL EXPLDSPT */
    CALL DSPLYA
    END
 DONEIT:
   J = J + 1
   IF J <= NAPLID   THEN SIGNAL TOPOFLOP
/*        WE ARE DONE WITH ALL APPLIDS    */
   IF MYFUNC = 'VERBOSE' | MYFUNC = 'MSGBOXONLY' THEN RETURN 0
   IF MYFUNC = 'MSGBOXALL' & MYPLAY = 'PLAY' THEN RETURN 0
   TOTLNG = 0
   MSGSTAT='REMPOP'
   MSGBOXTX= '< FINISHED PROCESSING SELECTION LIST. WRITING RESULTS'
   ADDRESS ISPEXEC "VPUT (MSGSTAT MSGBOXTX) ASIS"
   CALL MSGBOX
   EXECSEL = 'AFOLPLAY'
   "ISPEXEC VPUT (EXECSEL) ASIS"
   MYAREA=''
   DO I = 1 TO NAPLID
/*  TOTLNG = TOTLNG + LENGTH(APL_STM.I)
    IF TOTLNG > MAX_CAL THEN DO
     MYAREA=MYAREA||FFX||'EXCESSIVE OUTPUT LENGTH TRUNCATED'
     LEAVE
     END    */
    MYAREA=MYAREA||XFF||APL_STM.I
    END
   MYAREA#=XFF
   "ISPEXEC VPUT (MYAREA MYAREA#) ASIS"
/*  CALL EXPLDSPT */
   CALL DSPLYA
   RETURN 0
/* MYFUNC = QUIET : WRITE OP TO ODSN */
DO_ODSN:
  IF MYFUNC ^= 'QUIET' THEN SAY MUFUNC 'IS NOT EXPECTED:EXPECT:QUIET'
  IF ODSN = '' THEN SIGNAL EXITRC10
  PARSE VAR ODSN TDSN '(' EMBR ')'
  EDSN = ODSN
  EXECSEL='AFOLPLAY'
  CALL MALOC TDSN
  XC=RESULT
  IF XC = 0 THEN SIGNAL CHK_OPFILE
  IF EMBR = '' THEN MYDSO='PS)'
   ELSE  MYDSO='PO) DSNTYPE(LIBRARY)'
  MODDSN = ''
  M=MXLNG+4
  DSEMSG = '(D) DEL/REALLOC,(A) ABORT'
  MODATTR="NEW BLKSIZE("M+4") DSORG("MYDSO" RECFM(V,B) SPACE(1,1)"||,
   "CYLINDER LRECL("M") CATALOG REUSE"
  "ISPEXEC VPUT (EDSN EXECSEL DSEMSG MODATTR MODDSN) ASIS"
  IF RC ^= 0 THEN SIGNAL EXITRC8
  CALL ALOCDSN
  XC = RESULT
  "ISPEXEC VGET (EDSN) ASIS"
  IF RC ^= 0 THEN RETURN 4
  SIGNAL DOWRITE
 CHK_OPFILE:
   EDSN=ODSN
   DSEMSG = 'DSN EXISTS: DSN MUST BE NEW'
   MYVERB = 'ABORT CANCEL'
   "ISPEXEC VPUT (EDSN) ASIS"
   "ISPEXEC VPUT (DSEMSG EXECSEL) ASIS"
   "ISPEXEC VPUT (MYVERB) ASIS"
   CALL DSNWIND
   XC = RESULT
   IF XC > 4 THEN SIGNAL EXITRC2
   ADDRESS ISPEXEC "VGET (EDSN) ASIS"
   IF RC ^= 0 THEN SIGNAL EXITRC8
   IF ODSN ^= EDSN THEN DO
    ODSN = EDSN
    SIGNAL DO_ODSN
    END
   ADDRESS ISPEXEC "VGET (MYVERB) ASIS"
   IF RC ^= 0 THEN SIGNAL EXITRC8
 /* SIMPLE TEST OF MYVERB */
   IF MYVERB ^= '' THEN DO
    IF MYVERB='ABORT' | MYVERB='CANCEL' THEN SIGNAL EXITRC20
    END
   SIGNAL CHK_OPFILE
 DOWRITE:
  IF XC = 0 THEN DO
   ADDRESS TSO "ALLOC FI(O) DA('"EDSN"') SHR REUSE"
   ADDRESS TSO "EXECIO "J" DISKW O (STEM APL_STM. FINIS"
   ADDRESS TSO "FREE FI(O)"
   CALL MSGBOX 'DATA SAVED TO 'EDSN
   RETURN 0
   END
  RETURN 24
 EXITRC4:
    XC=4
    SIGNAL FINIT
 BADLINK:
 EXITRC8:
    XC=8
    SIGNAL FINIT
 EXITRC10:
    XC=10
    SIGNAL FINIT
 INVPARM:
 EXITRC12:
    XC=10
    SIGNAL FINIT
 EXITRC20:
    XC=10
    SIGNAL FINIT
 FINIT:
  RETURN XC
 /* SUBROUTINE FOR LINK COMMAND. PARSE COMMAND INTO VARS *\
 |* SUBROUTINE FOR LINK COMMAND. PARSE COMMAND INTO VARS *|
 |* SUBROUTINE FOR LINK COMMAND. PARSE COMMAND INTO VARS *|
 |* SUBROUTINE FOR LINK COMMAND. PARSE COMMAND INTO VARS *|
 |* SUBROUTINE FOR LINK COMMAND. PARSE COMMAND INTO VARS *|
 \* SUBROUTINE FOR LINK COMMAND. PARSE COMMAND INTO VARS */
 CHKPRMS:
  PARSE VAR H_CMD_STR (MYCMD) PRMS
  IF PRMS = '' THEN RETURN 12
   ERR = ''
   I=0
   PRM_RC = 0
 PRMLOOP:
   IF PRMS = '' THEN SIGNAL DONEPRMS
   PRMX = ''
   PARSE VAR PRMS PRM PRMS
   IF PRM = '' THEN SIGNAL BADPARM
   PRM=PRM||' ' /* TACK ON A SPACE TO HELP FIND '=' END */
   L_PRM=LENGTH(PRM)
   FDLM = ''
   EDLM = ''
   DO I = 2 TO L_PRM
    PP=SUBSTR(PRM,I,1)
    CKPP=POS(PP,DLM)
    IF CKPP ^= 0 THEN DO
     FDLM=SUBSTR(DLM,CKPP,1)
     EDLM=SUBSTR(MDLM,CKPP,1)
     LEAVE
     END
    END
   IF FDLM = '' THEN SIGNAL BADPARM
   IF I >= L_PRM THEN SIGNAL BADPARM
   LP = LASTPOS(EDLM,PRM)
   IF LP = 0 THEN LP=L_PRM
    ELSE LP = LP - 1
   PRMVAL = SUBSTR(PRM,I+1,LP-I)
   PRM = SUBSTR(PRM,1,I-1)
   IF PP = '=' THEN SIGNAL GOTEQ
   IF PP = '<' THEN SIGNAL GOTBRKT
   SIGNAL GOTPARNT
GOTEQ:
   IF PRMVAL = '' THEN SIGNAL BADPARM
   L_PRM=LENGTH(PRMVAL)
   PP = SUBSTR(PRMVAL,1,1)
   CKPP=POS(PP,DLM)
   IF CKPP = 0 THEN DO
    SIGNAL GOT_PRMVAL
    END
   I = 1
   FDLM=SUBSTR(DLM,CKPP,1)
   EDLM=SUBSTR(MDLM,CKPP,1)
   LP = LASTPOS(EDLM,PRMVAL)
   IF LP = 0 THEN LP=L_PRM
    ELSE LP = LP - 1
   PRMVAL = SUBSTR(PRMVAL,I+1,LP-I)
   IF PP = '<' THEN SIGNAL GOTBRKT
   SIGNAL GOTPARNT
GOTPARNT:
   PARSE VAR PRMVAL . '<' TMPVAL '>'
   IF TMPVAL ^= '' THEN DO
    PRMVAL = TMPVAL
    SIGNAL GOTBRKT
    END
   SIGNAL GOT_SIMPLE
GOTBRKT:
   IF LENGTH(PRMVAL) > 8 THEN SIGNAL BADPARM
   "ISPEXEC VGET ("PRMVAL") ASIS"
   INTERPRET "PRMVAL = "PRMVAL
/* IF PRMVAL = '' THEN SIGNAL BADPARM */
   SIGNAL NXTPRMS
BADPARM:
    ERR = ERR||XFF||,
       'PARM:'PRM' IS NOT A EXPECTED PARAMETER. BYPASSING.'
    PRM_RC = 4
    SIGNAL NXTPRMS
GOT_SIMPLE:
GOT_PRMVAL:
   INTERPRET PRM "='"||PRMVAL||"'"
NXTPRMS:
   TRACE OFF
   SIGNAL PRMLOOP
DONEPRMS:
 RETURN PRM_RC
/* */
/* ROUTINE TO SUBSTITUTE JOB OR APPLID VALUE IN CA */
SUBJOBN:
/* JOB#PTR IS THE CURRENT JOBNAME FROM THE SUPPLIED LIST */
/* IF ZERO JOBNAMES WERE SUPPLIED, THEN WE CAN NOT PERFORM */
/*   THE $ SUBSTITUTION.                                 */
/* WE SHOULD NOT BE HERE IF THE JOB#PTR IS > NUMBER OF   */
/*   JOBNAMES PROVIDED IN THE JOBLIST ARGUMENT.          */
/* TRACE ?I */
  IF LENGTH(H_CMD_STR) < 1 THEN RETURN 0
  LOOPCT=100
  V=1
  X = OUTTRAP('JNL.')
  CALL CVTJN2RG MYAPLID
  X = OUTTRAP('OFF')
  IF WORD(JNL.1,1) = '!!!!!!!!' THEN RETURN 8
  JOBN=WORD(JNL.1,2)
  SUBCMD=STRIP(H_CMD_STR,'T')
  CURL=LENGTH(SUBCMD)
  /* NEW CODE V2 */
  /* TRACE I */
  S#APLID = MYAPLID
  IF LENGTH(S#APLID) < 7 THEN INTERPRET "T#PARM = 'S#"||S#APLID||"'"
    ELSE INTERPRET "T#PARM = 'S#"||SUBSTR(S#APLID,3)||"'"
  INTERPRET T#PARM " = S#VALUE"
  'ISPEXEC VGET ('T#PARM') ASIS'
  IF RC > 0 THEN S#PARM = MYAPLID
   ELSE INTERPRET 'S#PARM = 'T#PARM
     TRACE OFF
  /* NEW CODE V2 */
  CURP=1
  CURS=0
  NEWCMD=''
TOPOFQLOP:
  /* SUBCMD HAS THE COMMAND TO BE EXECUTED. PARSE THIS COMMAND *\
  |*  LINE MOVING RIGHT 1 POS AT A TIME, USEING SUBSTR TO GET  *|
  |*  A 2 CHAR VALUE, AND USE THIS AS THE NEEDLE TO LOOK FOR   *|
  |*  A MATCH IN THE FNDWDS LIST (SUBSTITUTION SYMBOLS).       *|
  \*  WHEN FOUND, USE THIS POS IN COMMAND TO PERF SUB          */
  JP = WORDPOS(SUBSTR(SUBCMD,CURP,FNDWDL,XFF),FNDWDS)
  IF JP = 0 THEN SIGNAL NXT_POS
/* TRACE I */
  SUBWD = WORD(SUBWDS,JP)
  INTERPRET 'REPWD = 'SUBWD
  IF CURP = 1 THEN DO
   NEWCMD = REPWD
   END
   ELSE DO
   IF CURS = 0 THEN NEWCMD = SUBSTR(SUBCMD,1,CURP - 1)
   NEWCMD=SUBSTR(NEWCMD,1)||REPWD
   END
  LOOPCT = LOOPCT - 1
  IF LOOPCT < 1 THEN RETURN 8

  CURP = CURP + FNDWDL
  CURS = CURP
  SIGNAL NXT_POS_AFTER_FND
NXT_POS:
  CURP=CURP + 1
NXT_POS_AFTER_FND:
  IF CURP <= CURL THEN SIGNAL TOPOFQLOP
  IF CURS < CURP THEN DO
   IF CURS = 0 THEN NEWCMD = SUBCMD
   ELSE NEWCMD=SUBSTR(NEWCMD,1)||SUBSTR(SUBCMD,CURS)
   END
  IF LENGTH(NEWCMD) > H_CMD_STRL THEN H_CMD_STR = SUBSTR(NEWCMD,1,H_CMD_STRL)
   ELSE H_CMD_STR = NEWCMD
  TRACE OFF
 RETURN 0
###END AFOLPLAY
$$$BEG TSTS#PRM
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA          -                                              */
 /* CEMHELP          - TSO BASE, RESTRICTED                         */
 /* CEMHELP          -                                              */
 /* CEMHELP END                                                     */
   ADDRESS ISPEXEC
   TRACE I
   SAY 'START TEST AFOS#PRM:'
   ACCUMSG = ''
   CALL AFOS#PRM
   XC = RESULT
   PULL ACCUMSG
   SAY XC
   SAY ACCUMSG
   IF XC > 0 THEN DO
    SAY 'NO PARMS RETURNED'
    SIGNAL FINIT
    END
   'ISPEXEC VGET (SSPARMCT,SSPRMLST) ASIS'
   IF RC > 0 THEN DO
    SAY 'VGET ERROR:' RC
    SAY SSPARMCT
    SAY SSPRMLST
    SIGNAL FINIT
    END
   WC = WORDS(SSPRMLST)
   IF WC \= SSPARMCT THEN DO
    SAY 'WC \= SSPARMCT???'
    SAY 'WC      :' WC
    SAY 'SSPARMCT:' SSPARMCT
    END
   DO I = 1 TO WC
    T#PARM= WORD(SSPRMLST,I)
    'ISPEXEC VGET ('T#PARM') ASIS'
    IF RC       = 0 THEN INTERPRET 'S#PARM = 'T#PARM
     ELSE S#PARM = 'ERROR RETRIEVING PARM:'T#PARM
    SAY T#PARM||':'||S#PARM
    END
   FINIT:
   SAY 'GOOD BYE'
   EXIT
###END TSTS#PRM
$$$BEG TSTPNL
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA          -                                              */
 /* CEMHELP          - TSO BASE, RESTRICTED                         */
 /* CEMHELP          -                                              */
 /* CEMHELP END                                                     */
   ADDRESS ISPEXEC
   TRACE I
   FFX='FF'X
   TRCCMD='TRACE OFF'
   "ISPEXEC CONTROL ERRORS RETURN"
   "ISPEXEC ADDPOP ROW(1) COLUMN(10)"
   IF RC ^= 0 THEN SIGNAL EXITRC24
   EXECSEL='DSPSDSF'
   ICNT=0
   KIXSRCH=''
   KIXSRCHC=0
   MDSN='TTED.TSK.P.TCEM.CLIST'
   "ISPEXEC LIBDEF ISPPLIB DATASET ID('"MDSN"') UNCOND"
   IF RC ^= 0 THEN SIGNAL EXITRC8
   DSEMSG='INITIAL VALUE FROM EXEC'
   SIGNAL DOIT
CLR_CA
   DSEMSG='CLEARED VALUE FROM EXEC'
   SIGNAL DOIT
RESET:
   DSEMSG='RESET   VALUE FROM EXEC'
   SIGNAL DOIT
RES_CA:
   DSEMSG='RESET CA VALUE FROM EXEC'
   SIGNAL DOIT
SET_ODSN:
   DSEMSG='SET ODSN VALUE FROM EXEC'
   SIGNAL DOIT
DOIT:
DISPP:
   "ISPEXEC DISPLAY PANEL(DSPSDSFD)"
   IF RC = 8 THEN SIGNAL DONEIT
   IF RC ^= 0 THEN SIGNAL EXITRC8
   IF ZCMD = 'HELP' | ZCMD = '?' THEN SIGNAL SHOWFMT
   IF ZCMD = 'RESET' THEN SIGNAL RESET
   IF ZCMD = 'RESCA' THEN SIGNAL RES_CA
   IF ZCMD = 'CLRCA' THEN SIGNAL CLR_CA
   IF ZCMD = 'SETODSN' THEN SIGNAL SET_ODSN
   IF ZCMD = 'CANCEL' THEN SIGNAL EXITRC8
   IF ZCMD = 'CANALL' THEN SIGNAL EXITRC20
   IF ZCMD = 'END' THEN SIGNAL DONEIT
   MCMD=ZCMD
   IF MCMD ^= '' THEN DO
    PARSE VAR MCMD FCMD RCMD
    IF FCMD = 'TRACE' THEN TRCCMD=MCMD
     ELSE "TSO MCMD"
    END
   INTERPRET TRCCMD
   IF RC = 0 THEN SIGNAL DISPP
   SIGNAL DISPP
SHOWFMT:
 MSGBOXTX=XFF||'THE CLRCA WILL RESET THE COMMAREA TO NULLS'||XFF||,
 'THE CLRCA WILL RESET THE COMMAREA TO NULLS'||XFF||,
 'THE RESCA WILL RESE THE CA BACK TO VALUE SHOWN AT FIRST ENTRY'||XFF||,
 'CANCEL WILL END ANY FRUTHER EXECUTION'||XFF||,
 'THE RESET REFRESHES THE CA BACK TO THE LAST ENTER KEY'||XFF||,
 'SETODSN IS USEFUL IF YOU WANT A SPECIFIC DSN NAME FOR QUIET'||XFF||,
 'CANCEL CANCEL THIS SINGLE SELECTION PROCESS'||XFF||,
 'CANALL CANCEL OUT OF A COMMAND PROCESS'||XFF||,
 'END AND '||XFF||,
 'PF3 PROCESSES THE REQUEST. NOTE, I DO NOT DO ANY SYNTAX CHECKING.'
 CALL MSGBOX MSGBOXTX
   SIGNAL DISPP
SET_ODSX:
   CALL GETUDSN 'AFOLIST'
   PULL ODSN
   EDSN=ODSN
   EXECSEL = 'DSPSDSF'
   DSEMSG = 'CHANGE OUTPUT DSN TARGET (OPTIONAL'
   MYVERB = 'CANCEL ABORT END'
   "ISPEXEC VPUT (EDSN) ASIS"
   "ISPEXEC VPUT (DSEMSG EXECSEL) ASIS"
   "ISPEXEC VPUT (MYVERB) ASIS"
   CALL DSNWIND
   XC = RESULT
   IF XC > 4 THEN SIGNAL RESET
   ADDRESS ISPEXEC "VGET (EDSN) ASIS"
   IF RC ^= 0 THEN SIGNAL RESET
   ODSN = EDSN
   ADDRESS ISPEXEC "VGET (MYVERB) ASIS"
   IF RC ^= 0 THEN SIGNAL RESET
   IF MYVERB ^= '' THEN DO
    IF MYVERB='ABORT' | MYVERB='CANCEL' THEN SIGNAL RESET
    END
DONEIT:
  SAY 'WE ARE DONEIT'
  DO I = 1 TO 9
   INTERPRET 'SAY SS'I
   END
JSTRET0:
 CMDIND = 0
 SIGNAL EXITIT
EXITRC8:
 CMDIND = 8
 SIGNAL EXITIT
EXITRC20:
 CMDIND = 20
 SIGNAL EXITIT
EXITRC24:
 CMDIND = 24
 SIGNAL EXITIT_
EXITIT:
 "ISPEXEC REMPOP"
EXITIT_:
 "ISPEXEC VPUT (CMDIND) ASIS"
 RETURN CMDIND
###END TSTPNL
$$$BEG KIXLSOCK
/* REXX */
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA LIXLSOCK - TSO BASE, RETURNS EZAC SOCKET FOR APPLID     */
 /* CEMHELP          - TSO BASE, REQUIRES TWO PARMS                 */
 /* CEMHELP          - APPLID AND REGIONS D,T,A,P                   */
 /* CEMHELP          - RETURNS THE EZAC SOCKET FROM THE CONFIG FILE */
 /* CEMHELP END                                                     */
 ADDRESS TSO

/*
QUERY THE CICS NATIVE TCP EZACONFG FILE AND REPORT ON THE RESPECTIVE
 ASSOCIATED SOCKET.
*/
address TSO
/* TRACE I */
ARG APPLID KIXTYP
IF APPLID = '' THEN SIGNAL EXITRC8
IF KIXTYP = '' THEN SIGNAL EXITRC8
IF KIXTYP = 'E' THEN KIXTYP='D'
DSN = 'TTE'||KIXTYP||'.TSK.B.'APPLID'.TCP.CONFIG'
RESP = SYSDSN("'"DSN"'")
IF RESP ^= 'OK' THEN SIGNAL EXITRC8
ADDRESS TSO "ALLOCATE FILE(VSAMFILE) DSNAME('"dsn"') SHR"
IF rc \= 0 THEN
  DO
    SAY 'Allocate failed for VSAMFILE with a return code of' rc
    EXIT rc
  END
CALL EXPLLDEF ISPLLIB TTEP.TSK.E.TCEM.PDSE UNCOND
rxvsam_result = RXVSAM('OPENINPUT','VSAMFILE','KSDS')
IF rxvsam_result ^= 0 THEN
  DO
    LOGMSG = 'OPENINPUT failed: '
    CALL log_errors
    SIGNAL close_and_exit
  END
/*1*/
MK=LEFT(APPLID,8)||'L'
INTERPRET "VR = RXVSAM('READGENERIC','VSAMFILE','"MK"','MY_REC')"
RXVSAM_RESULT=VR
IF rxvsam_result = 0 THEN
  DO
        IF SUBSTR(MY_REC,1,8) = LEFT(APPLID,8) THEN DO
         DSPSOCK=SUBSTR(MY_REC,17,2)
         LOGMSG = LEFT(APPLID,9)||'SOCKET>'C2D(DSPSOCK)'<'
         END
         ELSE DO
         LOGMSG = LEFT(MY_REC,1,8)||' !?! IS INVALID FOR THIS DSN'
         END
  END
ELSE
  DO
    LOGMSG = 'STARTBROWSE FOR 'APPLID' FAILED'
    call log_errors
    SIGNAL close_and_exit
  END

DONEALL:
close_and_exit: NOP
rxvsam_result = RXVSAM('CLOSE','VSAMFILE')
IF rxvsam_result ^= 0 THEN
  DO
    LOGMSG = LOGMSG||'!!FINAL CLOSE FAILED:'
    CALL log_errors
  END

write_log_and_exit: NOP

ADDRESS TSO "FREE FILE(VSAMFILE)"
SIGNAL FINIT
EXITRC8:
 LOGMSG = '!!! NO/INVALID PARMS PASSED'
finit:
mynest = sysvar(sysnest)
if sysvar(sysnest) = 'YES' then  RETURN LOGMSG
say logmsg
EXIT
/*1*/
log_errors: nop

LOGMSG =    '  Return msg -->  ' rxvsam_returnmsg
LOGMSG =    '  Error msg -->   ' rxvsam_vsamerrormsg

RETURN
sayit:
  say logmsg
  exit

###END KIXLSOCK
$$$BEG KI#LSOCK
 /* REXX */
 TRACE I
 ZBC = KIXLSOCK(CGE7 E)
 SAY 'ZBC:' ZBC
 SAY RESULT
###END KI#LSOCK
$$$BEG EXPLALOC
PROC 0
CONTROL PROMPT LIST CONLIST
   FREE ATTR(SYSPATTR)
   FREE FI(SYSPRINT SYSIN MYSPRINT)
   ATTR SYSPATTR LRECL(125) BLKSIZE(629) RECFM(V B A)
   SET &SYSPRO = 0
   IF &SYSDSN(TEMPOCAT.DATA) = OK THEN DO
    ALLOC FI(SYSPRINT) DA(TEMPOCAT.DATA) SHR
    END
    ELSE DO
   ALLOC FI(SYSPRINT) DA(TEMPOCAT.DATA) NEW USING(SYSPATTR) CYL SPACE(1)
    END
   ALLOC FI(MYSPRINT) SYSOUT LRECL(132) RECFM(F,B)
###END EXPLALOC
$$$BEG EXPLTIOT
/* REXX GET TASKNAME FROM TCB */
TRACE I
CVT = STORAGE(10,4) /* FLCCVT-PSA DATA AREA */
TCBP = STORAGE(D2X(C2D(CVT)),4) /* CVTTCBP */
TCB = STORAGE(D2X(C2D(TCBP)+4),4)
TIOT = STORAGE(D2X(C2D(TCB)+12),4) /* TCBTIO */
SAY STRIP(STORAGE(D2X(C2D(TIOT)),8)) /* TIOCNJOB */
/* MORE */
ASCB = C2D(STORAGE(224,4))
ASSB = C2D(STORAGE(D2X(ASCB+336),4))
JSAB = C2D(STORAGE(D2X(ASSB+168),4))
JBNM = STORAGE(D2X(JSAB+28),8)
JBID = STORAGE(D2X(JSAB+20),8)
USID = STORAGE(D2X(JSAB+44),8)
SAY 'JOBNAME='JBNM' JOBID='JBID' USERID='USID !
###END EXPLTIOT
$$$BEG GETDSN1
/* REXX *** OBTAIN INFORMATION OF DSN & VOLSERS FOR A GIVEN DD NAME
        >>> BASED ON CODE ORIGINALLY POSTED BY DOUG NADEL            */
SIGNAL ON SYNTAX NAME ERR
NUMERIC   DIGITS 31
ARG DDNM .   /* DDNAME TO BE INTERROGATED FROM EXEC STATEMENT        */
DDDSN   = GETDSN1(DDNM) /* CALL DDNAME INTEROGATION CODE             */
SAY " "
DO A = 1 TO WORDS(DDDSN) /* DISPLAY THE RESULTS                      */
  DDDTRAN = TRANSLATE(WORD(DDDSN,A),' ',',')
  LENDSN  = LENGTH(WORD(DDDTRAN,1))
  VOLSERS = STRIP(SUBSTR(DDDTRAN,LENDSN+2))
  SAY "DDNAME  = "STRIP(DDNM)", DSN "RIGHT(A,3)" = "WORD(DDDTRAN,1)
  SAY "VOLSERS = "VOLSERS
END
SAY " "
EXIT
/* PROCEDURE GETDSN1 - FIND DATASETS/VOLUMES ALLOCATED TO DDNAME     */
GETDSN1: PROCEDURE
ARG DDNAM .
DSNAM2 = ''
DDNAME=STRIP(LEFT(DDNAM,8))            /* MUST BE 8 LONG, PAD BLANKS */
TIOTPTR=24+PTR(12+PTR(PTR(PTR(16))))   /* GET DDNAME ARRAY           */
TIOELNGH=C2D(STG(TIOTPTR,1))           /* LENGTH OF 1ST ENTRY        */
KONKAT=0                               /* SET INDICATOR TO DEFAULT   */
FOUND=0                                /* SET INDICATOR TO DEFAULT   */
PARSE VALUE '' WITH RETVALUE           /* SET RETURN VALUES NULL     */
DO UNTIL TIOELNGH=0                    /* SCAN UNTIL DD FOUND        */
  TIOEDDNM=STRIP(STG(TIOTPTR+4,8))     /* GET DDNAME FROM TIOT       */
  IF FOUND THEN DO
     IF TIOEDDNM = '' THEN  CALL GETDSNDETAIL
     ELSE LEAVE
     END
  ELSE IF TIOEDDNM=DDNAME THEN DO
     FOUND=1
     CALL GETDSNDETAIL
     END
  TIOTPTR=TIOTPTR+TIOELNGH             /* GET NEXT ENTRY             */
  TIOELNGH=C2D(STG(TIOTPTR,1))         /* GET ENTRY LENGTH           */
  END
RETURN DSNAM2                          /* RETURN RESULT TO MAIN MOD  */
GETDSNDETAIL:
   KONKAT=KONKAT+1
   TIOELNGH=C2D(STG(TIOTPTR,1))        /* LENGTH OF NEXT ENTRY       */
   TIOEJFCB=STG(TIOTPTR+12,3)
   TIOELINK=STG(TIOTPTR+3,1)
   PARSE VALUE '' WITH LABEL VOLUMES DEVTYP DSNAME MEMBER VOLLIST
   SELECT
      WHEN BITAND(TIOELINK,'20'X)='20'X THEN DEVTYP='*TERMINAL'
      WHEN BITAND(TIOELINK,'02'X)='02'X THEN DEVTYP='*SYSOUT'
      OTHERWISE DO
         JFCB=SWAREQ(TIOEJFCB)           /*CONVERT SVA TO 31-BIT ADDR*/
         DSNAME=STRIP(STG(JFCB,44))      /*DSNAME JFCBDSNM           */
         MEMBER=STRIP(STG(JFCB+44,8))    /* MEMBER OR RELATIVE GDGNUM*/
         LABEL=STRIP(C2D(STG(JFCB+68,2)))
         IF BITAND(STG(JFCB+159,1),'04'X)='04'X THEN DO
            DEVTYP='*VIO'
            LABEL=0
            VOLUMES=''
            END
         ELSE DO
            VOLLIST=STRIP(STG(JFCB+118,30))
            TIOEJFCBX=STG(JFCB+149,3)
              /* JOB FILE CONTROL BLOCK EXTENSION */
            IF TIOEJFCBX<>'000000'X THEN DO
               JFCB=SWAREQ(TIOEJFCBX) /*CONVERT SVA TO 31-BIT ADDR*/
               DEVTYP=C2X(STG(JFCB+140,4))
               VOLLIST=VOLLIST||STRIP(STG(JFCB+4,90))
               PTRX=PTR(JFCB+172,4)
               DO WHILE PTRX<>0          /* GET NEXT EXTENSION */
                  VOLLIST=VOLLIST||STRIP(STG(PTRX+4,90))
                  PTRX=PTR(PTRX+172,4)
                  END
               END
            VOLLEN=LENGTH(VOLLIST)
            VOLUMES=SUBSTR(VOLLIST,1,6)
            DO I=7 TO VOLLEN BY 6
               VOLUMES=VOLUMES||","||SUBSTR(VOLLIST,I,6)
               END
            END
         END
   PARSE VALUE RETVALUE || ,
     DSNAME','STRIP(MEMBER)','VOLUMES','LABEL','DEVTYP';' ,
     WITH RETVALUE
     DDNAME = LEFT(DDNAME,8)
     DSNAME = LEFT(DSNAME,44)
     DEVTYP = LEFT(DEVTYP,8)
     LABEL  = RIGHT(LABEL,3)
     IF MEMBER = ' ' THEN
       DSNAM2 = DSNAM2 ||" "||STRIP(DSNAME)
     ELSE
       DSNAM2 = DSNAM2 ||" "||STRIP(DSNAME)||STRIP("("MEMBER")")
 END
DSNAM2 = DSNAM2||","||VOLUMES
RETURN DSNAM2
/*-------------------------------------------------------------------*/
PTR:  RETURN C2D(STORAGE(D2X(ARG(1)),4))         /* RETURN A POINTER */
/*-------------------------------------------------------------------*/
STG:  RETURN STORAGE(D2X(ARG(1)),ARG(2))         /* RETURN STORAGE   */
/*-------------------------------------------------------------------*/
SWAREQ:  PROCEDURE                /* COURTESY OF GILBERT SAINT-FLOUR */
IF RIGHT(C2X(ARG(1)),1) <> 'F' THEN    /* SWA=BELOW ?                */
  RETURN C2D(ARG(1))+16                /* YES, RETURN SVA+16         */
SVA = C2D(ARG(1))                      /* CONVERT TO DECIMAL         */
TCB = PTR(540)                         /* TCB PSATOLD                */
JSCB = PTR(TCB+180)                    /* JSCB TCBJSCB               */
QMPL = PTR(JSCB+244)                   /* QMPL JSCBQMPI              */
QMAT = PTR(QMPL+24)                    /* QMAT QMADD                 */
DO WHILE SVA>65536
  QMAT = PTR(QMAT+12)                  /* NEXT QMAT QMAT+12          */
  SVA=SVA-65536                        /* 010006F -> 000006F         */
  END
RETURN PTR(QMAT+SVA+1)+16
/** ERROR ROUTINE - SHOW LINE AND EXECUTE WITH TRACE I               */
ERR:
  SIGNAL OFF SYNTAX
  DROPBUF
  SAY "ERROR ROUTINE OUTPUT STARTING"
  SAY "ERROR ROUTINE OUTPUT STARTING"
  SAY "   "
  SAY RIGHT(SIGL,6) ">>>" SOURCELINE(SIGL)
  SAY "   "
  TRACE I
  INTERPRET SOURCELINE(SIGL)
###END GETDSN1
$$$BEG COPYDS
/* REXX */
/* CEMHELP BEGIN                                                     */
/* CEMHELA COPYDS   - DISPLAYS DATASETS ASSOCIATED WITH A REGION     */
/* CEMHELP COPYDS   - TSO BASE, PROMPTS USER FOR CICS REGION NAME,   */
/* CEMHELP          - OR SOME IDENTIFYING STRING WHICH THIS EXEC USES*/
/* CEMHELP          - CREATE A ISPF DIALOGE PANEL.  RETURNS THE FIRST*/
/* CEMHELP          - OCCURANCE OF THE ENTERED STRING AND FORMATS THE*/
/* CEMHELP          - SET OF LIBRARIES ASSICIATED WITH COPY.  PANEL  */
/* CEMHELP          - ALLOWS SELECTION OF LIBRARY VIA 'S' OR 'E' TO  */
/* CEMHELP          - ENTER EDIT ON LIBRARY, OR 'B' TO VIEW.         */
/* CEMHELP          - RETURN THE PANEL AFTER SELECTION(S) PROCESSED  */
/* CEMHELP          - FOR FUTHER INPUT. END AND PF3 TO EXIT.         */
/* CEMHELP END                                                       */
/*   TRACE I */
 ARG COPYSELN VQMODE
 CALL SAFO COPYSELN VQMODE
 LR=RESULT
 IF LR = 0 THEN SIGNAL OK1
 IF LR > 4 THEN SIGNAL EXITRC2
 SIGNAL NOTDON
 OK1:
 "ISPEXEC VGET (MYAFO MYSST MYCNTL) SHARED"
 IF MYAFO = '' THEN SIGNAL NOTDON
 CALL AFOFLD 'MYCPU MYAPLID MYTYP MYREL'
 PULL FLD#
  PS="#"
  PARSE VAR FLD# MYCPUL MYCPUB MYCPUE MYCPUM (PS),
                 MYAPLIDL MYAPLIDB MYAPLIDE MYAPLIDM (PS),
                 MYTYPL MYTYPB MYTYPE MYTYPM (PS),
                 MYRELL MYRELB MYRELE MYRELM (PS) .
  MYCPU=STRIP(SUBSTR(MYAFO,MYCPUB,MYCPUL),"B")
 "ISPEXEC VGET (CURCPU CURGRP) PROFILE"
 IF RC ^= 0 THEN DO
  CALL GETCPU1
  "ISPEXEC VGET (CURCPU CURGRP) PROFILE"
  END
CPUOK1:
 GRP=MYCPU||'SYS'
 CALL GETCPU1 GRP
 "ISPEXEC VGET (CVTDGRP) SHARED"
 IF RC ^= 0 THEN GRP = '????'
  ELSE GRP = CVTDGRP
 IF GRP = '???' THEN SIGNAL NOTCPU
 IF GRP^=CURGRP THEN SIGNAL NOTCPU
  MYAPLID=STRIP(SUBSTR(MYAFO,MYAPLIDB,MYAPLIDL),"B")
 APLIDQ='.'||MYAPLID
 MYTYP=SUBSTR(MYAFO,MYTYPB,MYTYPL)
 IF MYTYP = 'E' THEN MYTYP = 'D'
 MYREL=SUBSTR(MYAFO,MYRELB,MYRELL)
 RELQ='.R'||MYREL
 HLQ='TTE'||MYTYP||'.TSK'
 IF MYTYP = 'A' THEN CTYP='T'
  ELSE CTYP = MYTYP
 CTYPHLQ='TTE'||CTYP||'.TSK'
 MYCPDS1 = HLQ||'.F'||RELQ||APLIDQ||'.TABLE.SOURCE'
 MYCPDS2 = HLQ||'.F'||RELQ||APLIDQ||'.PARMLIB'
 MYCPDS3 = HLQ||'.F'||RELQ||APLIDQ||'.TABLELIB'
 MYCPDS4 = 'TTEP.TSK.F'||RELQ||'.COMMON.TABLE.SOURCE'
 MYCPDS5 = 'TTEP.TSK.F'||RELQ||'.COMMON.TABLELIB'
 MYCPDS6 = HLQ||'.F'||RELQ||APLIDQ||'.JCLLIB'
 MYCPDS7 = 'TTEP.TSK.G.PROD.SYSJCL'
 MYCPDS8 = 'TTEP.TSK.G.PROCLIB'
 MYCPDS9 = CTYPHLQ||'.F'||RELQ||'.LOADLIB'
 MYCPDS10 = HLQ||'.F'||RELQ||APLIDQ||'.SHUTDOWN'
 MYCPDS11= HLQ||'.J'||APLIDQ||'.STARTUP'
 MYCPDS12= HLQ||'.F'||RELQ||APLIDQ||'.TABLE.SOURCE.B'
 MYCPDS13= HLQ||'.F'||RELQ||APLIDQ||'.TABLE.SOURCE.S'
 MYCPDS14= HLQ||'.F'||RELQ||APLIDQ||'.PARMLIB.B'
 MYCPDS15= HLQ||'.F'||RELQ||APLIDQ||'.PARMLIB.S'
 MYCPDS16= HLQ||'.F'||RELQ||APLIDQ||'.CEE.LOADLIB'
 MYCPDS17='TTEP.TSK.P.CICS.QA.MIGRATE.JCLLIB'
 MYCPDS18='TTEP.TSK.P.CICS.QA.RESTORE.JCLLIB'
  A = 'MYCPDS'
  MYTYTOT = 18
  DSPLIT=''
  DO I = 1 TO MYTYTOT
   DSPLIT=DSPLIT||A||I||' '
   END
  DSPLIT=STRIP(DSPLIT,'T')
  MYTYP = A
 "ISPEXEC VPUT (MYTYP MYTYTOT "DSPLIT") ASIS"
DOAGN:
 CALL DSPINP MYTYP MYTYTOT
 EXIT
         EXITRC0:
          ZEDSMSG = 'EXPANSION OK'
          ZEDLMSG = 'EXPANSION FOR 'MYSST' COMPLETED SUCCESSFULLY'
          SIGNAL WRITIT
         EXITRC2:
          ZEDSMSG = 'CANCEL SPECIFIED'
          ZEDLMSG = 'CANCEL WAS SPECIFIED. PROCESS ABORTED.'
          SIGNAL WRITIT
         EXITRC4:
          ZEDSMSG = 'NO HELP AVAIL'
          ZEDLMSG = 'NO HELP AVAILABLE FOR THIS PANEL'
          SIGNAL WRITIT
         NOSITOR:
          ZEDSMSG = 'SIT UNAVAILABLE'
          ZEDLMSG = 'NO SIT AVAILABLE (WRONG CPU?)'
          SIGNAL WRITIT
         NOTCPU:
          ZEDSMSG = 'WRONG CPU'
          ZEDLMSG = 'WRONG CPU GROUP FOR EXPANSION'
          SIGNAL WRITIT
         NOTTBL:
          ZEDSMSG = 'TABLE 'BTS' NOT VALID'
          ZEDLMSG = 'NOT A VALID TABLE'
          SIGNAL WRITIT
         EXITRC8:
         NOTDON:
          ZEDSMSG = 'NOT PROCESSED'
          ZEDLMSG = 'AFOPER EXPAND CICS REGION DEFN NOT DONE'
         WRITIT:
          'ISPEXEC SETMSG MSG(ISRZ001)'
 EXIT
 * SJDA HOLDS TODAYS JUL DAY */
 * SCWD HOLDS TODAYS WEEK DAY NUMBER 0 I MON TO 6 IS FRI */
 * CURWK WILL RETURN TODAYS CURRENT WEEK BASED ON MON IS NEW WEEK */
FDAY: PROCEDURE EXPOSE SJDA SBDT CURWK
 RJDA=(SBDT-SJDA+1)//7
 CURWK=((SJDA+12)-RJDA)%7
 RETURN 0
###END COPYDS
$$$BEG XMLST2
/* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA          - RESTRICTED                                   */
 /* CEMHELP          - TSO BASE, RESTRICTED                         */
 /* CEMHELP END                                                     */
/*                                                                   */
/* WORKHOURSE ROUTINE FOR ALL XMIT AND BMT EXECS AND EDIT MACROS.    */
/*  EXEC EXPECTS TO RECEIVE A PARM LIST WHICH IDENTIFIES THE FOLLOWNG*/
/*   EXECSEL - INITIAL EXEC WHICH CALLS THIS ROUTINE                */
/*           - AND IS USED TO IDENTIFY THE TYPE OF PROCESSING, XMIT  */
/*           - OR BDT.                                               */
/*   INDSN   - SRC FOR THE DATA TRANSFER                             */
/*   RESP    - TARGET LIST OF RECEIVING COMPLEXES (OPTIONAL)         */
/*   MBRLST  - LIST OF MEMBER(S) TO TRANSFER      (OPTIONAL)         */
/*                                                                   */
/* EXEC REQUIRES ALL 4 SPECIFICATIONS. FIRST TWO ARE REQUIRED AS     */
/* PARM INPUT.  NEXT TWO WILL GET PROMPTS IF NOT PROVIDED ON THE     */
/* THE ARGUMENT INPUT.                                               */
/* THE EXEC WILL USE THE EXECSEL TO DECIDE ON WHETHER TO USE XMIT    */
/* OR BDT AS THE PROCESS.  IF THE INITIAL WAS XMBR OR BMBR, THEN     */
/* WE AUTOMATICALLY HAVE PROVIDED ALL 4 ARGUMENT SPECIFICATIONS.     */
/* SPECIFICALLY, THE INDSN AND MBRLST ARE KNOWN.  IF THE USER HAD    */
/* PROVIDED A TARGET COMPLEX, THEN NO PROMPTS REQUIRED. IF THE USER  */
/* DID NOT PROVIDE A COMPLEX, WE WILL INTERPRET THE RESP PARM AS     */
/* MISSING AND PROMPT THE USER.                                      */
/* THE XMLST, BMLST, AND JBDTL ALL WILL PROCESS THE RESP TARGET      */
/* AS PROVIDED OR PROMPT IF NECESSARY.  THEY WILL THEN PRESENT A     */
/* MEMBER LIST OF THE INDSN DS (IF IT IS DSORG PO).  YOU WILL SELECT */
/* AS MANY MEMBER AS REQUIRED.  PF3 TERMINATES THE SELECTION PROCESS */
/* AND THE EXEC TRANSFERS MEMBERS AS IMPLIED BY EXECSEL.             */
/* THE XMITS WILL OCCUR IN FORGROUND TSO AND YOU MUST RECEIVE THE    */
/* XMIT AT THE TARGET COMPLEXES.                                     */
/* THE BDT'S WILL SUBMIT JOBS TO BDT THE DATA ALONG WITH JCL TO      */
/* PROCESS THE RECEIVING OF THE BDT DATA.  THE JCL IS TAYLORED TO    */
/* DO A REPLACE IN AN EXISTING DSN, OR IF IMPLIED BY THE INITIAL     */
/* INVOKING EXEC (JBDTN JBDTLN BMLSTN), CREATES A NEW DSN AS THE     */
/* TARGET.                                                           */
/* -                                                                 */
/* MACROS                                                            */
/*         XMBR     - XMIT CURRENT MEMBER TO SELECTED GROUP(S)       */
/*         BMBR     - BDT CURRENT MEMBER TO SELECTED GROUP(S)        */
/*         BMBRL    - SELECT MBR FROM DSN (IN EDIT UPON) AND BDT     */
/*         XMBRL    - SELECT MBR FROM DSN (IN EDIT UPON) AND XMIT    */
/*         JBDTR    - JUMP BDT FOR DSN, REPLACE ALL TGT W/ ALL SRC   */
/*         JBDTN    - JUMP BDT FOR DSN, CREATE TGT WITH ALL SRC DSN  */
/*         JBDTL    - JUMP BDT, SEL MBR FROM JUMP DSN MBR LIST TO DES*/
/*      BDTMAC  ----- REAL EDIT MACRO USED FOR SUBMITTING BDT JCL    */
/* EXECS                                                             */
/*         XMLST    - SELECT MEMBERS OF PDS TO XMIT   TO SELECT GRPS */
/*         BMLST    - SELECT MEMBERS OF PDS TO BDT TO SELECT GRPS    */
/*         BMLSTN   - SELECT MEMBERS OF PDS TO BDT TO TGT (CREATE DSN*/
/*                                                                   */
/*  NODELIST BELOW COPIED FROM SYS1.PARMLIB(IKJTSO00)                */
/*  TRANSREC NODESMF((WNDMVS2,JSYS),(SHARED,BSYS),(EIS,M133),        */
/*     (EIS,P133),(EIS,RSYS),(EAST,SSYS),                            */
/*     (WNDMVS2,SSYS),(WNDMVS2,ZSYS),(WNDMVS2,DSYS),                 */
/*     (WNDMVSGW,ASYS),(WNDMVSGW,CSYS),(WNDMVS2,HSYS),               */
/*     (WNDTEST,XSYS),(WNDTEST,YSYS),(WNDMVS2,ESYS),                 */
/*     (WNDMVS2,FSYS),(WNDMVS3,GSYS),(WNDMVS3,ISYS),                 */
/*     (PVSTEST,USYS))                                               */
/*                                                                   */
/* SDSF /$D NODE,NAME                                                */
/* SDSF /$TNODE(*)                                                   */
/*  WILL ALSO PROVIDE A LIST OF ALL NJE TYPE JES NODES               */
/*  TCEM.ISPPROF                                                     */
 ATHN1LST='N2 CPCT EIS OMNI GRPV GRPT THORTON JSYS MSYS PSYS RSYS '||,
  'P133 M133'
 RTHN1LST='N2'
 AWND1LST='N15 W1 WND1 G1 GRP1 YSYS XSYS WNDTEST WNDDEV DEV'
 RWND1LST='N15'
 AWND2LST='N12 W2 WND2 G2 GRP2 DSYS ESYS FSYS HSYS SSYS EASTON'
 RWND2LST='N12'
 AWND3LST='N30 W3 HEALTHSOURCE WND3 G3 GRP3 GSYS ISYS'
 RWND3LST='N30'
 AY2KYLST='N19 Y2KY YSYS Y2KNODEY Y2KZ ZSYS Y2KNODEZ'
 RY2KYLST='N19'
 APVSVLST='N40 W4 PVSTEST WNDMVS4 VSYS USYS G4'
 RPVSVLST='N40'
 AWNDGWLST='N50 W5 ASYS CSYS WND5 GRP5 G5 GW GWTEST'
 RWNDGWLST='N50'
 AY2KWLST='N90 Y2KW WSYS Y2KNODEW'
 RY2KWLST='N90'
 AY2KULST='N95 Y2KU USYS Y2KNODEU'
 RY2KULST='N95'
 PRDLST='N15 N12 N50'
 /* PLXLST = 'ATHN1LST AWND1LST AWND2LST AWND3LST AY2KYLST AWNDGWLST '||,
        'AY2KWLST AY2KULST APVSVLST' */
 PLXLST = 'AWND1LST AWND2LST AWND3LST APVSVLST AWNDGWLST'
 NWDPLX=WORDS(PLXLST)
 XODELST=''
 ALST=''
 RLST=''
 DO I = 1 TO NWDPLX
  AWD=WORD(PLXLST,I)
  INTERPRET "NAWD = WORDS("AWD")"
  RWD='R'||SUBSTR(AWD,2)
  INTERPRET "RTMP = "RWD
  XODELST=XODELST||' '||RTMP
  INTERPRET RWD" = COPIES(RTMP||' ',NAWD)"
  INTERPRET "ALST=ALST||' '||"AWD
  INTERPRET "RLST=RLST||' '||"RWD
  END
 ALST=STRIP(ALST,'B')
 NAWD=WORDS(ALST)
 RLST=STRIP(RLST,'B')
 NRWD=WORDS(RLST)
 IF NAWD^=NRWD THEN DO
  MSGBOXTX='WARNING. INTERNAL ERROR. NUMBER OF ALIAS NODE NOT EQUAL '||,
   'TO NUMBER OF REAL NOTES.'||NAWD||' '||ALST||' '||NRWD||' '||RLST
  CALL MSGBOX MSGBOXTX
  END
 XODELST=STRIP(XODELST,'B')
 XJCL = 'TTED.TSK.P.TCEM.CNTL'
 ZMBR = 'BDTPDS'
 ARG EXECSEL INDSN RESP MBRLST
 /* XMSEL SET TO 0 TO USE BDT, SET TO 1 FOR XMIT */
 IF EXECSEL ^= '' THEN DO
   XMSG = EXECSEL
   SELECT
    WHEN EXECSEL = 'XMLST' THEN XMSEL = 1
    WHEN EXECSEL = 'XMBR' THEN XMSEL = 1
    WHEN EXECSEL = 'XMBRL' THEN XMSEL = 1
    OTHERWISE XMSEL = 0
    END
   END
   ELSE DO
   XMSEL = 0
   XMSG = 'XMLST2'
   SIGNAL DOPULL
   END
 IF INDSN ^= '' & INDSN ^= '?' THEN SIGNAL ARNDPULL
DOPULL:
 SAY 'ENTER PDS DSN OF BDT SOURCE (NO QUOTES)'
 PULL INDSN REST
 IF REST ^= '' THEN SIGNAL INVALRSP
 /* TRACE I */
ARNDPULL:
 IF INDSN = 'CLIST' THEN INDSN ='TTED.TSK.P.TCEM.CLIST'
 ELSE IF INDSN = 'EDITMAC' THEN INDSN ='TTED.TSK.P.TCEM.EDITMAC'
      ELSE IF INDSN = 'CNTL' THEN INDSN ='TTED.TSK.P.TCEM.CNTL'
           ELSE DO
            X=SYSDSN("'"INDSN"'")
            IF X ^= 'OK' THEN SIGNAL INVALRSP
            END
 X=LISTDSI("'"INDSN"'") DIRECTORY
 INDSO = SYSDSORG
 INDST = SYSDSSMS
BYP:
 GRP=''
 ADDRESS ISPEXEC "VGET (CURCPU CURGRP) PROFILE"
 IF RC ^= 0 THEN DO
  CALL GETCPU1
  ADDRESS ISPEXEC "VGET (CURCPU CURGRP) PROFILE"
  END
 GRP=CURGRP
 SELECT;
 WHEN GRP = 'GRP1' THEN GRP='N15'
 WHEN GRP = 'GRP2' THEN GRP='N12'
 WHEN GRP = 'GRPV' THEN GRP='N2'
 WHEN GRP = 'GRPZ' THEN GRP='N19'
 WHEN GRP = 'GRP3' THEN GRP='N30'
 WHEN GRP = 'GRP4' THEN GRP='N40'
 WHEN GRP = 'GRP5' THEN GRP='N50'
 WHEN GRP = 'GY2W' THEN GRP='N90'
 OTHERWISE GRP='???'
 END
 IF RESP^='' & RESP^='?' & RESP^='#' THEN SIGNAL ARNDNODE
 SAY 'ENTER BDT TARGET NODE/S (SEPARATED BY /)'
 SAY XODELST||'  OR ALL OR PROD'
 PULL RESP
 IF RESP = '' THEN SIGNAL INVALRSP
ARNDNODE:
 IF RESP = 'ALL' | RESP='PROD' THEN DO
  IF RESP='ALL' THEN NODELST=XODELST
   ELSE NODELST=PRDLST
  PARSE VAR NODELST L1 (GRP) L2
  NODELST=L1||' '||L2
  NNODE=WORDS(NODELST)
  SIGNAL DOIT
  END
 NODELST=''
 REST = TRANSLATE(RESP,'  ',',/')
 NNODE=WORDS(REST)
 DO I = 1 TO NNODE
  NODEWD=WORD(REST,I)
  NAWD=WORDPOS(NODEWD,ALST)
  IF NAWD = 0 THEN SIGNAL INVALRSP
  RESP=WORD(RLST,NAWD)
  IF WORDPOS(RESP,NODELST) ^= 0 THEN ITERATE
  IF RESP^=GRP THEN NODELST=NODELST||RESP||' '
  END
DOIT:
 I = 0
 SAY NODELST
 IF INDSO = 'PS' THEN DO
  ZMBR = 'BDTSEQ'
  SIGNAL ARNDMBRS
  END
  ELSE IF INDSO ^= 'PO' THEN SIGNAL INVDSO
 IF SUBSTR(EXECSEL,1,4) = 'JBDT' THEN DO
  IF SUBSTR(EXECSEL,5) ^= 'L' THEN SIGNAL ARNDMBRS
  END
 IF EXECSEL = 'BMBR' | EXECSEL = 'XMBR' THEN DO
  I=WORDS(MBRLST)
  SIGNAL ARNDMBRS
  END
 TMBR=' '
 XNF = ''
 "ISPEXEC LMINIT DATAID("INF") DATASET('"INDSN"') ENQ(SHRW)"
 "ISPEXEC LMOPEN DATAID("INF") ORG(DORG) OPTION(OUTPUT)"
 LASTRC = 0
 XNF=INF
 DO WHILE(LASTRC=0)
  "ISPEXEC LMMDISP DATAID("INF") OPTION(DISPLAY) STATS(YES) TOP("TMBR")"
  LASTRC = RC
  IF LASTRC = 12 THEN SIGNAL NOTPDS
  IF LASTRC = 8 THEN SIGNAL TSTMBRS
  IF LASTRC ^= 0 THEN SIGNAL INVALRSP
  DO WHILE(LASTRC = 0)
   TMBR=STRIP(ZLMEMBER,'T')
   I = I + 1
   MBRLST =MBRLST||' '||TMBR
   "ISPEXEC LMMDISP DATAID("INF") OPTION(GET)"
   LASTRC = RC
   END
  LASTRC=0
  END
TSTMBRS:
 IF I = 0 THEN SIGNAL NOMBRS
ARNDMBRS:
 SELMBRN = I
 SUID=SYSVAR(SYSUID)
 SUIDL=LENGTH(SUID)
 SUID=SUBSTR(SUID,SUIDL-3,4)
 IF SUID='TMJS' THEN SUID='TMSJ'
 IF XMSEL = 0 THEN DO
  "ISPEXEC VPUT (EXECSEL SELMBRN SUID INDSN) ASIS"
  IF RC ^= 0 THEN SIGNAL INVALRSP
  IF SELMBRN > 0 THEN DO
   DO I = 1 TO SELMBRN
    INTERPRET "SELMBR"I" = WORD(MBRLST,I)"
    "ISPEXEC VPUT (SELMBR"I") ASIS"
    IF RC ^= 0 THEN SIGNAL INVALRSP
    END
   END
  END
 NNODE=WORDS(NODELST)
 "ISPEXEC VGET (HJCLIND) ASIS"
 IF RC ^= 0 THEN DO
  IF SUBSTR(INDSN,11,6) = '.TCEM.' & SELMBRN > 0 THEN HJCLIND='NOHOLD'
   ELSE HJCLIND = 'HOLD'
  CALL HJCL HJCLIND
  END
 /* TRACE ?I */
 DO I = 1 TO NNODE
  RESP = WORD(NODELST,I)
  IF XMSEL = 0 THEN DO
   NODE=RESP
   "ISPEXEC VPUT (NODE) ASIS"
   "ISPEXEC EDIT DATASET('"XJCL"("ZMBR")') MACRO(BDTMAC)"
   "ISPEXEC VGET (EDTRC) ASIS"
   IF EDTRC ^= 0 THEN SIGNAL CLSFLE
   END
   ELSE DO
   RESP=RESP'.'SUID
   ADDRESS TSO
   IF INDSO = 'PS' THEN,
   "XMIT "RESP" DA('"INDSN"') NONOTIFY"
   ELSE,
   "XMIT "RESP" DA('"INDSN"') MEMBERS("STRIP(MBRLST,'L')") NONOTIFY"
   ADDRESS ISPEXEC
   END
  END
 IF INDSO = 'PS' | SYSRECFM = 'U' | SYSRECFM = '?' THEN SIGNAL NOCLSFLE
 IF SELMBRN = 0 THEN SIGNAL NOCLSFLE
 ZEDSMSG = 'SELCT MBRS 'XMSG
 ZEDLMSG = 'SELECTED MEMBERS WERE 'XMSG
 IF EXECSEL = 'BMBR' THEN DO
  "ISPEXEC LMINIT DATAID("INF") DATASET('"INDSN"') ENQ(SHRW)"
  "ISPEXEC LMOPEN DATAID("INF") ORG(DORG) OPTION(OUTPUT)"
  END
 SJDT = DATE(JULIAN)
 SCDT = DATE()
 STIM = TIME()
 SUSR = SYSVAR(SYSUID)
 SA='/*'
 I=SA SJDT 'LAST BDTED' SCDT 'AT' STIM 'BY' SUSR COPIES(' ',60)
 I=SUBSTR(I,1,80)
 "ISPEXEC LMPUT DATAID("INF") MODE(INVAR) DATALOC(I) DATALEN(80)"
 I=SA SJDT 'TO NODES' NODELST COPIES(' ',60)
 I=SUBSTR(I,1,80)
 "ISPEXEC LMPUT DATAID("INF") MODE(INVAR) DATALOC(I) DATALEN(80)"
 DO WHILE(LENGTH(MBRLST) > 62)
  I=SA SJDT SUBSTR(MBRLST,1,62) COPIES(' ',60)
  I=SUBSTR(I,1,80)
  "ISPEXEC LMPUT DATAID("INF") MODE(INVAR) DATALOC(I) DATALEN(80)"
  MBRLST=SUBSTR(MBRLST,63)
  END
 I=SA SJDT SUBSTR(MBRLST,1,62) COPIES(' ',60)
 I=SUBSTR(I,1,80)
 "ISPEXEC LMPUT DATAID("INF") MODE(INVAR) DATALOC(I) DATALEN(80)"
 "ISPEXEC LMMREP DATAID("INF") MEMBER(XMLSTMOD)"
 SIGNAL CLSFLE
NOMBRS:
 ZEDSMSG = 'NO MBRS SELECT'
 ZEDLMSG = 'NO MEMBERS WERE SELECTED FOR 'XMSG
 SIGNAL CLSFLE
EDTERR:
 ZEDSMSG = XMSG' SUB FAILURE'
 ZEDLMSG = XMSG' JOB SUBMIT FAILED. RC = 'EDTRC
 SIGNAL CLSFLE
CLSFLE:
 "ISPEXEC LMCLOSE DATAID("INF")"
 "ISPEXEC LMFREE DATAID("INF")"
 XNF = ''
 SIGNAL WRITIT
NOCLSFLE:
 ZEDSMSG = XMSG' PROCESSED'
 ZEDLMSG = XMSG' WAS PROCESSED AS REQUESTED'
 SIGNAL WRITIT
NOTPDS:
 ZEDSMSG = 'DATASET NOT PDS'
 ZEDLMSG = 'DATASET SELECTED WAS NOT A PDS'
 SIGNAL WRITIT
INVDSO:
 ZEDSMSG = 'INV DS ORG'
 ZEDLMSG = 'DATASET ORGANIZATION INVALID FOR THIS EXEC.'
 SIGNAL WRITIT
INVALRSP:
 ZEDSMSG = XMSG' ERROR'
 ZEDLMSG = 'INVALID DSN, SYNTAX OR OTHER ERROR'
WRITIT:
IF XNF ^= '' THEN DO
 "ISPEXEC LMCLOSE DATAID("INF")"
 "ISPEXEC LMFREE DATAID("INF")"
 END
 "ISPEXEC SETMSG MSG(ISRZ000)"
 EXIT
###END XMLST2
$$$BEG CMNEW
 /* REXX */
  ARG EXPNM PRM
  SUID = SYSVAR(SYSUID)
  SELECT
   WHEN SUID = 'TCEM' THEN DO
    "EX 'TTED.TSK.P.TCEM.CLIST(SPCAT)'"
    END
   WHEN SUID = 'TJCC' THEN DO
    "EX 'TTED.TSK.P.TCEM.CLIST(SPCAT)'"
    END
   WHEN SUID = 'TCXS' THEN DO
    "EX 'TTED.TSK.P.TCEM.CLIST(SPCAT)'"
    END
   WHEN SUID = 'TDND' THEN DO
    "EX 'TTED.TSK.P.TCEM.CLIST(SPCAT)'"
    END
   OTHERWISE DO
    "EX 'TTED.TSK.P.TCEM.CLIST(REXXINIT)'"
    END
   END
  IF RC > 0 THEN SIGNAL EXITRC8
  IF LENGTH(EXPNM) = 0 THEN SIGNAL ONLYINIT
  LP=LENGTH(PRM)
  IF LP = 0 THEN SIGNAL NOPRM
  IF LP < 4 THEN SIGNAL NOPFX
  IF SUBSTR(PRM,1,4) = 'PRM(' THEN DO
   IF SUBSTR(PRM,LP,1) ^= ')' THEN SIGNAL BADPARM
   PRM = SUBSTR(PRM,5,LP-5)
   END
 NOPFX:
   "EX 'TTED.TSK.P.TCEM.CLIST("EXPNM")' '"PRM"'"
   EXIT
 NOPRM:
   "EX 'TTED.TSK.P.TCEM.CLIST("EXPNM")'"
   EXIT
 EXITRC8:
  SAY 'ENVIRONMENT COULD NOT BE ESTABLISHED. SORRY.'
   EXIT
ONLYINIT:
  SAY 'CEM ENVIRONMENT INITIALIZATION COMPLETED. NO COMMAND REQUESTED'
  EXIT
###END CMNEW
$$$BEG IBMMKDIR
/* REXX */
/*                                                                 */
/*                                                                 */
/* this was created using the ctg mkdir version at V920            */
/* cics and cicspa use similar routines                            */
/* generally:                                                      */
/*   code is the same (but you should check code for match)        */
/*   dir list is different for each product - cut and paste the    */
/*        new list into this version                               */
/*   idir install directory overridden by $root parm               */
/*        if you provide the $root on invokation, then idir is moot*/
/*        if you provide ! as $root on invokation, then idir       */
/*         is now used as the $root - so change it accordingly     */
/*   $root logic was added to insure it is valid                   */
/*   you need to have filesystems mounted                          */
/*                                                                 */
/*                                                                 */
/*                                                        tcem
* c920-20160304-1318 install_zos/jcl/CTGMKDIR, ctg_antz, c920-bsf
*
* altered for cigna stds
*  parameter must be specifiec and cannot be root '/' or '.' rel
*  parameter can be '!' for a default
*  otherwise length must be greater than 3 (min_l var setting below)
* insure that you have the new zfs file mounted at
* /smpe_zone/cicstg/t920sys or whatever the new version USS sys
********************************************************************
* Licensed Materials - Property of IBM
*
* "Restricted Materials of IBM"
*
* 5655-Y20
*
* (C) Copyright IBM Corp. 2012, 2014
*
* US Government Users Restricted Rights - Use, duplication or
* disclosure restricted by GSA ADP Schedule Contract with
* IBM Corp.
*
* Status: Version 9 Release 2
*/
/********************************************************************/
/*                                                                  */
/* This REXX exec will create the necessary directories             */
/*                                                                  */
/********************************************************************/


 min_l = 27        /* /smpe_zones/cicstg/t920sys/ is minimal length */
/*  you can provide the $root on invokation or change the idir      */
/*    below and use '!' on invokation to ise the idir value         */
/*  idir is 'install directory' which includes our cigna tvvvsss    */
/*           t is 'target' (not r for release)                      */
/*           vvv is the product version                             */
/*           sss is sys or put                                      */
parse arg $root .

/* if you invoke with the '!' value, you get the following target dir */

idir='/smpe_zones/cicstg/t920sys/'
/*
*  generally: new versions will specify a different set of directories
*             as listed via the dirs variable. this var should be
*             updated.
*             you should make sure functional logic has stayed the same
*             from release to release. make changes as needed.
*/
dirs=,
     '',
     'IBM' '775',
     'bin' '755',
     'bin/resource' '755',
     'classes' '755',
     'deployable' '755',
     'msgs' '755',
     'samples' '755',
     'samples/configuration' '755',
     'samples/java' '755',
     'samples/java/com' '755',
     'samples/java/com/ibm' '755',
     'samples/java/com/ibm/ctg' '755',
     'samples/java/com/ibm/ctg/samples' '755',
     'samples/java/com/ibm/ctg/samples/eci' '755',
     'samples/java/com/ibm/ctg/samples/esi' '755',
     'samples/java/com/ibm/ctg/samples/ha' '755',
     'samples/java/com/ibm/ctg/samples/intercept' '755',
     'samples/java/com/ibm/ctg/samples/jee' '755',
     'samples/java/com/ibm/ctg/samples/requestexit' '755',
     'samples/java/com/ibm/ctg/samples/requestexit/threadedmonit',
     ||'or' '755',
     'samples/java/com/ibm/ctg/samples/security' '755',
     'samples/java/com/ibm/ctg/samples/stats' '755',
     'samples/scenarios' '755',
     'samples/scenarios/sc01' '755',
     'samples/scenarios/sc02' '755',
     'samples/scenarios/sc03' '755',
     'samples/scenarios/sc04' '755',
     'samples/scenarios/sc05' '755',
     'samples/scenarios/sc08' '755',
     'samples/scenarios/sc11' '755',
     'samples/scenarios/sc12' '755',
     'samples/server' '755',
     'wlp' '755',
     'wlp/IBM' '755',
     ''
do a = 1 to words(dirs) by 2
  a1 = a +1
  m = right(a,8) '-----' word(dirs,a) '-----' word(dirs,a1)
  say m
end /* a */

  /* trace ?i */
 If $root = '!' then do
    $root = idir
    say 'Using the defualt dir>'||$root||'< press enter to continue or'
    say '  press ATTN or PA1 to halt and abort'
    pull ans
    say 'ok... continue...'
    signal arndroot
    end
 If  $root = '' | $root = '/' or $root = '//' or,
     $root = '.' or $root = '..' or $root='../' then do
  say 'Nope! You need a valid target directory>'||$root||'<'
  exit
  end
 If  length($root) < min_l then do
  say 'Nope! You need a valid target directory.'
  say 'length of this dir>'||$root||'< is less than min>'||min_l||'<'
  exit
  end

/****************************************************************/
/*     Beginning of main procedure:                             */
/****************************************************************/

arndroot:
 say 'Beginning of main procedure:'

firstchar = Substr($root,1,1)
If firstchar ^= '/' then
 Do
  say 'Directory name does NOT begin with a "/".'
  say 'Please correct and resubmit.'
  Exit 12
 End
If Substr($root,length($root),1) ^= '/' then do
  say 'Directory >'||$root||'< is being appended with "/"'
  $root = $root||'/'
  say 'Directory >'||$root||'< was appended with "/"'
 End

if syscalls(on)>4 then
 Do
  say 'syscalls(on) failure'
  say 'Initialization failure. Please correct and resubmit.'
  Exit 12
 End

$rc= '0'

SINDEX.=0

flag1="OFF"
flag2="OFF"
flag3="OFF"
flag4="OFF"
flag7="OFF"

 say 'The EXEC to create the directories has begun.'
 say 'It will run for a couple of minutes.'

call saym 1, 'The EXEC ran at ' TIME() ' on ' DATE()
call saym 1, '                   '

address syscall 'getuid'
myuid=retval
address syscall 'geteuid'
myeuid=retval
privflag=0                         /* Change the Effective UID to  */
If myeuid ^= 0 then                /* be 0 since invoker should    */
  Do                               /* be part of the BPX.SUPERUSER */
   address syscall 'seteuid 0'     /* facility class               */
   privflag=1
  End

address syscall 'access' $root F_OK

If (rc=0 & retval^=0) | rc^= 0 then
  Do
   If errno = 6F then           /* EACCESS */
    Do
    call saym 1, 'Do not have appropriate permission to' $root
    call saym 1, '                                 '
    call saym 1, 'Please get appropriate permission to this directory',
                 'and resubmit.'
    call saym 1, '                                 '
    End
   Else
    Do
    call saym 1, 'Directory' $root 'does not exist.'
    call saym 1, '                                 '
    call saym 1, 'Please create this directory and resubmit.'
    call saym 1, '                                 '
    End
   $rc=12
   End
 Else    /* rc and retval are 0 */
  Do
   flag1="ON"
   call saym 2, 'Created the following directories:'
   call saym 2, '=================================='

   call saym 3, 'Following directories already exist:'
   call saym 3, '===================================='

   call saym 4, 'Problems creating the following directories:'
   call saym 4, '============================================'

   call saym 5, '  '

   call saym 6, '  '

   trace ?i
   do while dirs<>''
     parse var dirs dir perm dirs
     call syscall0 mkdir $root || strip(dir) strip(perm)
     end
     trace ?i

  /* call syscall0 mkdir '/var/cicstg' '777' */

 /*
 ************************************************************
 * @ @ @                                                    *
 *    Start of where you put other commands you may need    *
 *** make un comment below **********************************
 **

 $filename = $root || 'usr/lib/symbol'
 call syscall2 unlink $filename

 $linkname = $root || 'usr/lib/terminfo'
 call syscall3 symlink '../share/lib/terminfo' $linkname

 ** and then make comment here
 ************************************************************
 * @ @ @                                                    *
 *    End of where you put other commands you may need      *
 ************************************************************
 */

  End

If privflag=1 then
  address syscall 'seteuid' myuid

 say 'The EXEC has completed with Return Code' $rc
 say 'Check the SYSOUT held OUTPUT for further details.'


'ALLOC FI(BPXOUT) SYSOUT HOLD REUSE'

 call saym 1, 'This EXEC completed with Return Code' $rc
 call saym 1, '                 '

 If flag2 = 'OFF' then
  Do
   call saym 2, 'None. No directories were created.'
   call saym 2, '                                  '
  End
 Else
   call saym 2, '                                  '

 If flag3 = 'OFF' then
  Do
   call saym 3, 'None. No existing directories.'
   call saym 3, '                  '
  End
 Else
   call saym 3, '                                  '

 If flag4 = 'OFF' then
  Do
   call saym 4, 'No problems while creating the directories.'
   call saym 4, '                                 '
  End
 Else
   call saym 4, '                                  '

 If flag7 = 'OFF' then
   call saym 7, 'End of EXEC.'
 Else
  Do
   call saym 7, '                                  '
   call saym 7, 'Please refer to the OS/390 UNIX Messages and Codes',
                'book to interpret'
   call saym 7, 'the Return and Reason Codes.'
   call saym 7, 'Please correct and resubmit.'
  End

If flag1 = 'OFF' then
  'EXECIO' SINDEX.1 'DISKW BPXOUT (STEM STEM.1. FINIS'
Else
 Do
  'EXECIO' SINDEX.1 'DISKW BPXOUT (STEM STEM.1.'
  'EXECIO' SINDEX.2 'DISKW BPXOUT (STEM STEM.2.'
  'EXECIO' SINDEX.3 'DISKW BPXOUT (STEM STEM.3.'
  'EXECIO' SINDEX.4 'DISKW BPXOUT (STEM STEM.4.'
  'EXECIO' SINDEX.5 'DISKW BPXOUT (STEM STEM.5.'
  'EXECIO' SINDEX.6 'DISKW BPXOUT (STEM STEM.6.'
  'EXECIO' SINDEX.7 'DISKW BPXOUT (STEM STEM.7. FINIS'
 End
'FREE FI(BPXOUT)'

Exit $rc


  /********************************/
  /*  Subroutine for mkdir calls  */
  /********************************/

syscall0:
 parse arg cmd
 address syscall cmd
 parse arg . path permbits

 If (rc=0 & retval^=0) | rc^= 0 then
  Do
   If errno = 75 then           /* EEXIST */
    Do
     flag3 = 'ON'
     call saym 3, path
     address syscall 'chmod' path permbits
    End
   Else
    If errno ^= 75 then
     Do
      flag4 = 'ON'
      flag7 = 'ON'
      call saym 4, path
      call saym 4,'  Not created. RC='errno '   RSN='errnojr
      $rc = '12'
     End
  End
 Else
  Do
   flag2 = 'ON'
   call saym 2, path
  End
Return

  /*********************************/
  /*  Subroutine for unlink calls  */
  /*********************************/

syscall2:
 parse arg cmd
 address syscall cmd
 parse arg . link

 If (rc=0 & retval^=0) | rc^= 0 then
  Do
   If errno ^= 81 then           /* NOT ENOENT */
     Do
      flag7 = 'ON'
      call saym 6, 'Could not delete' link
      call saym 6, '  RC='errno '   RSN='errnojr
      $rc = '12'
     End
  End
Return

  /**********************************/
  /*  Subroutine for symlink calls  */
  /**********************************/

syscall3:
 parse arg cmd
 address syscall cmd
 parse arg . path link

 If (rc=0 & retval^=0) | rc^= 0 then
  Do
   If errno = 75 then           /* EEXIST */
     Do
      address syscall 'readlink' link 'linkbuf'
      If linkbuf ^= path then
       Do
        flag7 = 'ON'
        call saym 5, 'The symlink defined by' link
        call saym 5, '  already exists, but names a different file.'
        $rc = '12'
       End
     End
   Else
     Do
      flag7 = 'ON'
      call saym 5, 'Could not create symlink' link
      call saym 5, '  RC='errno '   RSN='errnojr
      $rc = '12'
     End
  End
Return

  /*****************************************/
  /*  Subroutine to add messages to STEMS  */
  /*****************************************/

saym:
 parse arg s,msg
 SINDEX.s=SINDEX.s+1
 ix=SINDEX.s
 STEM.s.ix=msg
Return
###END IBMMKDIR
$$$BEG RFWD
/* REXX */
/* CEMHELP BEGIN                                                     */
/* CEMHELA RFWD     - DISPLAY LIST OF WORDS FROM FWD MAC             */
/* CEMHELP RFWD     - TSO BASE, DISPLAYS THE CONTENTS OF THE ISPF    */
/* CEMHELP          - PROFILE VAR FWDLIST. THIS VAR COLLECTS         */
/* CEMHELP          - THE LAST 30 WORDS SEARCH WITH FWD.             */
/* CEMHELP END                                                       */
 CALL ISRVAR 'FWDLIST'
###END RFWD
$$$BEG TSTPARSC
/* REXX */
/* TRACE ?i */
PARSE SOURCE . . EXECNAME .
say EXECNAME
 x=outtrap(mm.,,'NOCONCAT')
 'PROFILE'
 If Pos(NOMSGID,mm.1) > 0 then num = '3'
 Else num = '4'
call syscalls 'ON'
 $root='/shared_products/cicstsd/'
   TRACE ?i
address syscall 'getuid'
myuid=retval
address syscall 'geteuid'
myeuid=retval
privflag=0                         /* Change the Effective UID to  */
If myeuid <> 0 then                /* be 0 since invoker should    */
  Do                               /* be part of the BPX.SUPERUSER */
   address syscall 'seteuid 0'     /* facility class               */
   privflag=1
  End

/*
address syscall 'readdir / root.'
do i=1 to root.0
say root.i
end
*/
address syscall access $root F_OK
say 'RC:'rc':'
say 'RETVAL:'retval':'
exit
If (rc=0 & retval<>0) | rc<> 0 then
 Do
  If errno = 6F then           /* EACCESS */
   Do
    say 'Do not have appropriate permission to' $root
    say '                                 '
    say 'Please get appropriate permission to this directory',
               'and resubmit.'
    say
    Exit 12
   End
  Else
   Do
    say 'Directory' $root 'does not exist.'
    say
    say 'Please create this directory and resubmit.'
    say
    Exit 12
   End
  $rc= '12'
 End
exit
###END TSTPARSC
$$$BEG TSTCPU
/* REXX */
TRACE ?i
PARSE SOURCE . . EXECNAME .
say EXECNAME
/* This is the main REXX program */
'%GETCPU1'
j=1;k=6;m=9
a ='j k m'
call test
 a = mvsvar('sysclone')
 a = mvsvar('sysplex')
 ADDRESS TSO EXEC "'TTED.TSK.P.TCEM.CLIST(GETCPU1)'"
 ADDRESS ISPEXEC 'VGET (CURCPU,CURGRP,CURCPUG) PROFILE'
 SAY CURCPU
 SAY CURGRP
 SAY CURCPUG
 pull
 tmp = ''
 if wordpos(tmp,'aaa bbb ccc') = 0 then say "nothing"
 tmp = ' abc   | def   '
 parse var tmp tmp1 '|' tmp2
 ltmp=length(strip(tmp1,'t'))
 ltmp=length(strip(tmp2,'t'))
 CALL ISPQRY
 MYCC=RC
 If MYRC = 0 then
 Do
 say "ISPF services are available"
 End
 Else
 If RC = 20 then
 Do
 say "ISPF services are NOT available"
 End
 Else
 Do
 say "ISPF Services Query RC Undefined"
 End
 ADDRESS ISPEXEC "VGET (CURCPU CURGRP) PROFILE"
 IF RC ^= 0 THEN DO
  CALL GETCPU1
  ADDRESS ISPEXEC "VGET (CURCPU CURGRP) PROFILE"
  END
 GRP=CURGRP
 X = SYSCPUS('CPUS.')
      SAY '0, IF FUNCTION PERFORMED OKAY: ' X
      SAY 'NUMBER OF ON-LINE CPUS IS ' CPUS.0
      DO I = 1 TO CPUS.0
        SAY 'CPU' I ' HAS CPU INFO ' CPUS.I
      END
TRACE R
 X=XRANGE('I','J')
 SAY C2X(X)
 D=DATE('B')
 D=DATE('B','20011125','S')
 D=DATE('C')
 D=DATE('D')
 D=DATE('E')
 D=DATE('J')
 D=DATE('M')
 D=DATE('N')
 D=DATE('O')
 D=DATE('S')
 D=DATE('U')
 D=DATE('W')
 D=DATE(,'20020609','S')
 D=DATE('N','1438','C')
 D=DATE('U','25 May 2001')
/*  D=DATE('U','25 MAY 2001') CAUSES ERROR BECAUSE MAY IS NOT May */
 G = TIME()
 G=TIME('E')
 G=TIME('C')
 G=TIME('H')
 G=TIME('L')
 G=TIME('M')
 G=TIME('N')
 G=TIME('S')
 MYRND= RANDOM(1,9999,G)
 TRACE OFF
 RPCNT = 1
 DO 50
  MYRND=RANDOM(1,99999)
  IF RPCNT < 4 THEN DO
   SAY COPIES(MYRND,RPCNT)
   RPCNT = RPCNT + 1
   END
   ELSE DO
   SAY COPIES(MYRND,4)
   RPCNT = 1
   END
  END
 TRACE ?R
 G=TIME('E')
 EXIT
 /* PARSE VALUE TIME() WITH HOURS ':' MINS ':' SECS */
 PARSE UPPER  EXTERNAL A
 SAY A ' IS ' DATATYPE(A)
 PARSE NUMERIC B
 SAY B ' IS ' DATATYPE(B)
 PUSH 'I2AB'
 PARSE PULL C
 SAY C ' IS ' DATATYPE(C)
 PUSH 'I2AB'
 PARSE UPPER  EXTERNAL D
 PARSE PULL E
 SAY D ' IS ' DATATYPE(D)
 SAY E ' IS ' DATATYPE(E)
 PARSE SOURCE F
 SAY F ' IS ' DATATYPE(F)
 exit
/* This is a subroutine     */
test: procedure expose (a)   /* Exposes A, J, K, and M     */
  say a j k m                /* Displays "j k m 1 6 9"     */
  interpret 'say a' a
  return
###END TSTCPU
$$$BEG EXPLARGS
 /* REXX */
 TRACE ?I
 J='K'
 K='CABD(XXX,EEE,YYY'
 INTERPRET J "= '"K"'"
 INTERPRET "J = '"K"'"
 A=SYMBOL(J)
 A=SYMBOL('J')
 INTERPRET 'M = 'J
 INTERPRET "A=SYMBOL("'M'")"
 INTERPRET "A=SYMBOL("M")"
 EQLIT='='
 ANS = ''
 DO FOREVER
  SAY 'ENTER K=V PAIR'
  PULL ANS
  IF ANS = '' THEN LEAVE
  PARSE VAR ANS P1 (EQLIT) P2
  SYMB_P1=SYMBOL(P1)
  SAY 'SYMBOL P1:' SYMB_P1
  INTERPRET 'SYMB_P1=SYMBOL('P1')'
  SAY 'SYMBOL P1:' SYMB_P1
  SYMB_P1=SYMBOL('P1')
  SAY 'SYMBOL P1:' SYMB_P1
  INTERPRET P1 '= P2'
  INTERPRET 'SAY P1 'P1
  END
 TRACE I
 PARSE UPPER ARG A
 IF A = '' THEN DO
  PULL A
  END
 SAY A
 I = 0
 A1 = TRANSLATE(A,' ',',')
 DO WHILE (A1 \= '')
  PARSE VAR A1 B A1
  SAY B
  SAY A1
  END
  EXIT
 DO WHILE (A \= '')
  PARSE VAR A B A
  I = I +1
  ST.I=B
  SAY A B
  END
 DO J = 1 TO I
  SAY ST.J
  END
 S4DDN = ''
 JOBNM = ''
 SRPL4MBR = ''
 LASTCC = 0
 NARGS=ARG()
 IF NARGS >= 1 THEN DO
  S4DDN= ARG(1)
  UPPER S4DDN
  S4DDN = TRANSLATE(S4DDN,' ',',')
  NWDS = WORDS(S4DDN)
  IF NWDS > 1 THEN DO
   TMP = S4DDN
   S4DDN = WORD(TMP,1)
   S4DDN = STRIP(TRANSLATE(S4DDN,'  ',"'"||'"'),'B')
   IF NWDS >= 2 THEN DO
    JOBNM = WORD(TMP,2)
    JOBNM = STRIP(TRANSLATE(JOBNM,'  ',"'"||'"'),'B')
    END
   IF NWDS >= 3 THEN DO
    SRPL4MBR = WORD(TMP,3)
    SRPL4MBR= STRIP(TRANSLATE(SRPL4MBR,'  ',"'"||'"'),'B')
    END
   END
  END
  ELSE SIGNAL DONPRMS
 IF NARGS >= 2 THEN DO
  JOBNM= ARG(2)
  JOBNM = TRANSLATE(JOBNM,'  ',"'"||'"')
  UPPER JOBNM
  END
 IF NARGS >= 3 THEN DO
  SRPL4MBR= ARG(3)
  SRPL4MBR= TRANSLATE(SRPL4MBR,'  ',"'"||'"')
  UPPER SRPL4MBR
  END
 IF LENGTH(S4DDN) < 1 THEN DO
  S4DDN='DFHRPL'
  SIGNAL DFLTRPL
  END
 IF LENGTH(S4DDN) > 8 THEN SIGNAL EXITRC8
 IF DATATYPE(SUBSTR(S4DDN,1,1)) ^= 'CHAR' THEN EXITRC8
 "ISPEXEC VGET (CALDNM) SHARED"
 IF RC ^= 0 THEN SIGNAL DFLTRPL
 IF CALDNM = JOBNM THEN SIGNAL ALRDCALD
DONPRMS:
EXITRC8:
DFLTRPL:
ALRDCALD:
 PUSH "THIS IS A TEST" 2
TRACE OFF

###END EXPLARGS
$$$BEG ISRVAR
 /* REXX */
 ARG OURVAR
 UPPER OURVAR
 IF OURVAR = '' THEN OURVAR = 'EDTVARS'
 ADDRESS ISPEXEC
 "ISPEXEC VGET ("OURVAR") PROFILE"
 IF RC ^= 0 THEN SIGNAL EXITRC8
 INTERPRET "CALL MSGBOX "OURVAR
 EXIT
###END ISRVAR
$$$BEG TRXCNCP
/*  REXX   */
TRACE I
RX_CNC_CH_NM='MY_CNC_CH_NM'
RX_CNC_CN_NM='MY_CNC_CN_NM'
RX_CNC_CHARDATA='THIS SHOULD BE DATA'
SAY 'RX_CNC_CH_NM SENT TO COBOL PROGRAM IS:' RX_CNC_CH_NM
SAY 'RX_CNC_CN_NM SENT TO COBOL PROGRAM IS:' RX_CNC_CN_NM
SAY 'RX_CNC_CHARDATA SENT TO COBOL PROGRAM IS:' RX_CNC_CHARDATA
/*    CALL COBOL PROGRAM   */
ADDRESS TSO
/*ALLOC FI(SYSOUT) DA(*) SHR REUSE' */
/* "CALL 'TTED.TSK.P.TCEM.LOADLIB(EXPLPGM3)' 'TVAR1,TVAR2'" */
/* CALL DOES NOT INITIALIZE THE ENVIRONMENT BLOCK */
/*"CALL 'TTEP.TSK.E.TCEM.PDSE(RXVARS)' 'TVAR1,TVAR2'" */
"CALL 'TTEP.TSK.E.TCEM.PDSE(RXCNCPUT)' 'RX_CNC_CH_NM,RX_CNC_CN_NM,"||,
  "RX_CNC_CHARDATA'"
IF RC <> 0 THEN SAY 'NON ZERO RETURN CODE' RC
SAY
SAY 'RX_CNC_CH_NM=' RX_CNC_CH_NM
SAY 'RX_CNC_CN_NM=' RX_CNC_CN_NM
SAY 'RX_CNC_CHARDATA=' RX_CNC_CHARDATA
###END TRXCNCP
$$$BEG PNTCOBVR
 /* REXX */
 /* CEMHELP PNTCOBVR - TSO CRE  MBR CVTING COB VAR TO DISPLAY FLDS  */
 /* CEMHELA PNTCOBVR - TAKE AN REXX ARG, SPECIFYING A COBOL COPYBOOK*/
 /* CEMHELP - AND PARSE EACH LINE. FOR LINES WITH PIC CLAUSE, CREATE*/
 /* CEMHELP - COBOL STATEMENTS WHICH:                               */
 /* CEMHELP - TAKE THE VAR FLD NAME, TO IDENTIFY THE FLD ON OP      */
 /* CEMHELP - USING THE PIC DEFINITION                              */
 /* CEMHELP -   GRAB THE LEN IDENTIFER AND ADD TO OP VAR            */
 /* CEMHELP -   THEN ACTUALLY MOVE THE FLD VALUE TO THE OP VAR      */
 /* CEMHELP -   CONVERTING COMP-5 BINARY DATA TO DISPLAYABLE        */
 /* CEMHELP - WHEN CONTAINER IS FOUND, IDENTIFY IT AND PRINT        */
 /* CEMHELP - THE CONTAINER NAME AS IT APPEARS                      */
 /* CEMHELP          -                                              */
 /* CEMHELP END                                                     */
 /* #EXIT TTED.TSK.D.TCEM.COB(VBSMF202) */
 ADDRESS TSO
/* "ALLOC FI(I) DA('TTED.TSK.P.TCEM.CNTL(CGXXCOLD)') SHR REUSE"  */
/*TRACE ?I */
  ARG EDSN
  IF EDSN = '' THEN DO
   SAY '* FAILED TO PROVIDE THE INPUT COPYBOOK MEMBER. GOOD BYE.'
   SIGNAL EXITRC8
   END
  "FREE FI(I)"
  "ALLOC FI(I) DA('"EDSN"') SHR"
  "EXECIO * DISKR I (STEM JCL. FINIS"
  "FREE FI(I)"
   REST = ''
   OCT = 0
   ASK7=COPIES(' ',6)||'*'
   SP13=COPIES(' ',13)
   SP15=COPIES(' ',15)
   SP18=COPIES(' ',18)
  DO I = 1 TO JCL.0
   IF SUBSTR(JCL.I,7,1) \= ' ' THEN ITERATE
   TMP = STRIP(SUBSTR(JCL.I,7,65),'B')
   IF TMP = '' THEN ITERATE
   IF WORD(TMP,1) = '01' THEN DO
    OCT = OCT + 1
    OP.OCT = ASK7||'  '||WORD(TMP,2)
    SAY 'LEVEL:01: FOUND:'||OP.OCT
    ITERATE
    END
   PARSE VAR TMP LV VARNM . 'PIC' REST
   VARNM = STRIP(VARNM,'B')
   IF SUBSTR(VARNM,LENGTH(VARNM),1) = '.' THEN DO
    OCT = OCT + 1
    OP.OCT = ASK7||'  '||WORD(TMP,2)
    SAY 'LEVEL:'LV': FOUND:'||OP.OCT
    ITERATE
    END
   UP_VARNM = VARNM
   UPPER UP_VARNM
   IF UP_VARNM = 'FILLER' THEN ITERATE
   VARNML = LENGTH(VARNM)
   DO WHILE VARNML > 28
    SAY 'VARIABLE NAME LENGTH GT 28:'VARNM
    SAY 'ENTER SMALLER NAME:'
    VARNMT = VARNM
    PULL VARNMT
    VARNMTL = LENGTH(VARNMT)
    IF VARNMTL < 1 | VARNMTL > 28 THEN DO
     SAY VARNMT ':LENGTH INVALID. TRY AGAIN'
     ITERATE
     END
    VARNM = VARNMT
    VARNML = VARNMTL
    UP_VARNM = VARNM
    UPPER UP_VARNM
    SAY '!!! MAKE CHANGES TO COPYBOOK(S) FOR ALTERED NAME!!!'
    END
   S_VARNM = VARNM
/* VARNM = LEFT(VARNM,30) */
   PARSE VAR REST PICTYP '(' PICLNG ')' REST
   IF PICTYP = 'X' THEN DO
       PICTYPE = 'STRING'
       CALL DO_STRING
       END
    ELSE DO
     IF PICTYP = 'S9' | PICTYPE = '9' THEN DO
       PICTYPE = 'NUMERIC'
       CALL DO_NUM
       END
      ELSE PICTYPE = 'UNKNOWN'
    END
   SAY VARNM LEFT(PICTYPE,10) RIGHT(PICLNG,3) '::' REST
   REST = ''
   END
   SAY 'FINISHED:'OCT' RECORDS CREATED'
   IF OCT < 1 THEN DO
    SAY 'NO COBOL STATEMENTS CAPTURED. ENDING'
    RETURN
    END
  "FREE FI(O)"
  ODSN='TTEP.TSK.P.TCEM.NOTES(PNTCOBV5)'
  SAY 'WRITTING COBOL STATEMENTS TO:'ODSN
  "ALLOC FI(O) DA('"ODSN"') SHR"
  "EXECIO * DISKW O (STEM OP. FINIS"
  "FREE FI(I)"
  RETURN
 DO_NUM:
   FP = POS('-NUM',UP_VARNM)
   IF FP > 0 THEN DO
    UP_VARNM = OVERLAY('-CNT',UP_VARNM,FP,4)
    END
   FP = POS('-CN-CNT',UP_VARNM)
   IF FP > 0 THEN DO
 /*TRACE ?I */
    OCT = OCT + 1
    OP.OCT = ASK7||"  CONTAINER BEGIN"
    OCT = OCT + 1
    OP.OCT = SP13||"MOVE VBSMF4Q2-CN-CNT-SPEC-LIT TO FMT-VAR."
    OCT = OCT + 1
    OP.OCT = SP15||"PERFORM FMT-COB-FLD-BYPASS THRU FMT-COB-FLD-XIT."
    END
   OCT = OCT + 1
   OP.OCT = SP13||"MOVE "||S_VARNM
   IF VARNML < 24 THEN DO
    OP.OCT = OP.OCT||" TO D-"||UP_VARNM||"."
    END
    ELSE DO
    OCT = OCT + 1
    OP.OCT = SP18||" TO D-"||UP_VARNM||"."
    END
   OCT = OCT + 1
   OP.OCT = SP15||"MOVE '"||S_VARNM||"' TO FMT-FLD-NM."
   OCT = OCT + 1
   OP.OCT = SP15||"MOVE D-"||UP_VARNM||" TO FMT-VAR-LNG."
   OCT = OCT + 1
   OP.OCT = SP15||"MOVE VBSMF4Q2-CNT-SPEC-LIT TO FMT-VAR."
   OCT = OCT + 1
   OP.OCT = SP15||"PERFORM FMT-COB-FLD-BYPASS THRU FMT-COB-FLD-XIT."
   TRACE OFF
   RETURN
 DO_STRING:
   CN_IND=0
   IF VARNML > 5 THEN DO
    TMP_T = SUBSTR(UP_VARNM,VARNML-4,)
    IF TMP_T = '-CONT' THEN DO
     S_VARNM = SUBSTR(S_VARNM,1,VARNML-5)||'-CN'
     UP_VARNM = S_VARNM
     UPPER UP_VARNM
     VARNML = LENGTH(UP_VARNM)
     CN_IND=1
     OCT = OCT + 1
     OP.OCT = ASK7
     OCT = OCT + 1
     OP.OCT = SP13||"MOVE VBSMF4Q2-CNNM-SPEC-LIT  TO FMT-VAR."
     OCT = OCT + 1
     OP.OCT = SP15||"PERFORM FMT-COB-FLD-BYPASS THRU FMT-COB-FLD-XIT."
     END
    END
   OCT = OCT + 1
   OP.OCT = SP13||"MOVE "||S_VARNM
   IF VARNML < 24 THEN DO
    OP.OCT = OP.OCT||" TO S-"||UP_VARNM||"."
    END
    ELSE DO
    OCT = OCT + 1
    OP.OCT = SP18||" TO S-"||UP_VARNM||"."
    END
   OCT = OCT + 1
   OP.OCT = SP15||"MOVE '"||S_VARNM||"' TO FMT-FLD-NM."
   IF CN_IND = 1 THEN DO
     OCT = OCT + 1
     OP.OCT = SP15||"MOVE LENGTH OF "||S_VARNM||" TO TRIM-FLD-LNG."
     OCT = OCT + 1
     OP.OCT = SP15||"STRING VBSMF4Q2-CNNM-SPEC-LIT"
     OCT = OCT + 1
     OP.OCT = SP15||" DELIMITED BY SPACE,"
     OCT = OCT + 1
     OP.OCT = SP15||" '<'  DELIMITED BY SIZE,"
     OCT = OCT + 1
     OP.OCT = SP15||" "||S_VARNM||" DELIMITED BY SIZE,"
     OCT = OCT + 1
     OP.OCT = SP15||" '>'  DELIMITED BY SIZE,"
     OCT = OCT + 1
     OP.OCT = SP15||" INTO FMT-VAR"
     OCT = OCT + 1
     OP.OCT = SP15||" END-STRING."
     OCT = OCT + 1
     OP.OCT = SP15||"PERFORM FMT-COB-FLD-BYPASS THRU FMT-COB-FLD-XIT."
     OCT = OCT + 1
     OP.OCT = ASK7||"  CONTAINER END"
     END
     ELSE DO
     OCT = OCT + 1
     OP.OCT = SP15||"SET TRIM-FLD-PTR TO ADDRESS OF S-"||UP_VARNM||"."
     OCT = OCT + 1
     OP.OCT = SP15||"MOVE LENGTH OF S-"||UP_VARNM||" TO TRIM-FLD-LNG."
     OCT = OCT + 1
     OP.OCT = SP15||"PERFORM FMT-COB-FLD THRU FMT-COB-FLD-XIT."
     END
   RETURN
###END PNTCOBVR
$$$BEG MAKEIEBZ
 /* REXX */
 /* CEMHELP BEGIN                                                     */
 /* CEMHELA MAKEIEBZ - CREATE IEBCOPY JOB BASED ON SOURCE DSN LIST    */
 /* CEMHELP MAKEIEBZ - CREATE IEBCOPY JOB BASED ON LIST OF SOURCE DSN.*/
 /* CEMHELP          - YOU PROVIDE A LIST OF DSN IN A DS AND THIS     */
 /* CEMHELP          - EXEC WILL CREATE JCL OUTPUT WHICH YOU CAN THEN */
 /* CEMHELP          - EDIT TO FINAL REQUIREMENTS.  EXEC EXPECTS THE  */
 /* CEMHELP          - TARGETS TO EXIST. TARGET WILL HAVE ZERODIR     */
 /* CEMHELP          - STATEMENT GENERATED FOR IT.                    */
 /* CEMHELP          - INTENT IS TO ALLOW COPY OF CICS DSN FROM A SYS */
 /* CEMHELP          -  TO A PUT.LEVEL.                               */
 /* CEMHELP          - ARGS:                                          */
 /* CEMHELP          - IDSNLIST<DSN.OF.INPUT.LIST(MBRLIST)>           */
 /* CEMHELP          - ODSNLIST<DSN.OF.OUTPUT.JCL(MBRJCL)>            */
 /* CEMHELP          -  EACH DSN MUST EXIST                           */
 /* CEMHELP          -  MBRLIST MUST EXIST                            */
 /* CEMHELP          -  MBRJCL IS CREATED OR OVERWRITTEN              */
 /* CEMHELP          - DSQMOD#(AAAA,ZZZZ)                             */
 /* CEMHELP          -  WITHIN EACH DSN IN THE MBRLIST                */
 /* CEMHELP          -  WHICH SPECIFIES THE SOURCE DSN TO BE COPIED   */
 /* CEMHELP          -  FOR EACH AAAA FOUND IN THE DSNAME, THE ZZZZ   */
 /* CEMHELP          -  IS REPLACED IN THE TARGET                     */
 /* CEMHELP          - YOU CAN SPECIFY 1 TO 6 UNIQUE MODS             */
 /* CEMHELP          -  WHERE EACH DSQMOD1-6 IS APPLIED IN THE NUMERIC*/
 /* CEMHELP          -  ORDER (NOT ORDER OF ARGS IN COMMAND)          */
 /* CEMHELP          - ONCE TARGET DSN IS FINALIZED, THEN             */
 /* CEMHELP          - JCL IS CREATED:                                */
 /* CEMHELP          - //I# DD DISP=SHR,DSN=MBRLIST.DSN.#             */
 /* CEMHELP          - //O# DD DISP=SHR,DSN=MBRLIST.DSN.#.WITH.ZZZZ   */
 /* CEMHELP          - AND SYSIN COMMANDS                             */
 /* CEMHELP          -   ZERODIR OUTDD=O#                             */
 /* CEMHELP          -   COPYMOD OUTDD=O#                             */
 /* CEMHELP          -           INDD=((I#,R))                        */
 /* CEMHELP          - WHEN ALL DSN IN MBRLIST PROCESSED, THE TWO SETS*/
 /* CEMHELP          -  OF JCL ARE COMBINED AND WRITTEN TO THE        */
 /* CEMHELP          -  ODSNLIST(MBRJCL)                              */
 /* CEMHELP END                                                       */
  ADDRESS ISPEXEC
  SUID = SYSVAR(SYSUID)
  ARG PRMS
  IF PRMS = '' THEN DO
   SAY 'ERROR. EXPECTING ARGS TO DRIVE THIS EXEC.'
   SAY ' USE TSO CEM CEMHELP MAKEIEBZ'
   SAY ' TO VIEW THE INSTRUCTIONS FOR THIS EXEC. BYE'
   EXIT 20
   END
   VALPRMS='IDSNLIST ODSNLIST DSQMOD1 DSQMOD2 DSQMOD3 '||,
   'DSQMOD4 DSQMOD5 DSQMOD6'
   NPW=WORDS(VALPRMS)
   DO I = 1 TO NPW
    TMP = WORD(VALPRMS,I)
    INTERPRET TMP' = ""'
    END
   PASSCT=0
   DO WHILE(PRMS ^= '')
    PARSE VAR PRMS PRM PRMS
    IF POS('<',PRM) ^= 0 THEN DO
     PARSE VAR PRM PRM '<' PRMVAL '>' REST
     END
     ELSE DO
     PARSE VAR PRM PRM '(' PRMVAL ')' REST
     END
    IF WORDS(PRM) ^= 1 THEN DO
     SAY 'PRM:'PRM' HAS NONE OR MULTIPLE VALUES.GOTTA ABORT.'
     EXIT 24
     END
    IF REST ^= '' THEN DO
     SAY 'PRM:'PRM': HAS REST:'REST':'
     END
    IF WORDPOS(PRM,VALPRMS) = 0 THEN DO
     SAY 'PRM:'PRM' WAS NOT A VALID PARM. ASSUME ERROR. ABORT.'
     EXIT 28
     END
    PASSCT = PASSCT + 1
    IF PASSCT > NPW THEN SIGNAL INVALPRM
    IARG.PASSCT = PRM
    IVARG.PASSCT = PRMVAL
    PRMS=STRIP(PRMS,'B')
    END
  IF PASSCT = 0 THEN DO
   SAY 'YOU PASSED ZERO ARGS. GOODBYE'
   EXIT 16
   END
  DO I = 1 TO PASSCT
   TKEY=IARG.I
   TVAL=IVARG.I
   IF TKEY ^= 'IDSNLIST' & TKEY ^= 'ODSNLIST' THEN DO
   TVAL = TRANSLATE(TVAL,'   ',';:,')
   IF WORDS(TVAL) ^= 2 THEN DO
    SAY 'DSQMOD:'TKEY': HAS INVALID SUBSTITUTIONS:'TVAL':'
    EXIT 8
    END
   END
   INTERPRET TKEY'="'TVAL'"'
   END
  IF IDSNLIST = '' | ODSNLIST = '' | DSQMOD1 = '' THEN DO
   SAY 'EXPECTING REQUIRED ARGS:'
   SAY ' IDSNLIST:'IDSNLIST':'
   SAY ' ODSNLIST:'ODSNLIST':'
   SAY ' DSQMOD1::'DSQMOD1':'
   SAY 'ONE OR MORE IS EMPTY. GOODBYE'
   EXIT 16
   END
  PARSE VAR IDSNLIST EDSN '(' EMBR ')' .
  PARSE VAR ODSNLIST ODSN '(' OMBR ')' .
  EXECSEL = 'MAKEIEBZ'
  "ISPEXEC VPUT (EDSN EMBR EXECSEL) ASIS"
  IF RC ^= 0 THEN SIGNAL EXITRC8
/*  "ISPEXEC ADDPOP ROW(3) COLUMN(10)" */
  IF RC ^= 0 THEN SIGNAL EXITRC8
  DSEMSG = 'ENTER DSN LIST SRCDSN AND MBR'
 SRCLOOP:
  "ISPEXEC VPUT (DSEMSG) ASIS"
  IF RC ^= 0 THEN SIGNAL EXITRC8
  CALL GDSNNMBR
  IF RESULT ^= 0 THEN SIGNAL CANCEL8
  CALL VLDTTGT
 /*   0 IF THE DSN IS VALID AND EXISTS                                */
 /*   4 IF THE DSN IS VALID BUT IS UNAVAILABLE (HMIGR???)             */
 /*   8 IF DSN PASSED IS INVALID OR EXEC ERROR                        */
 /*  12 IF DSN DOES NOT EXIST                                         */
 /*  16 IF ATTN RTN WAS ENTERED                                       */
  XC = RC
  IF XC = 0 THEN SIGNAL TSTMBR
  IF XC > 12 THEN SIGNAL CANCEL8
  DSEMSG = 'DSN INAVLID OR IN ERROR. RETRY'
  SIGNAL SRCLOOP
 TSTMBR:
  "ISPEXEC VGET (EDSN EMBR) ASIS"
  IF EMBR = '' THEN DO
   TMBR = ''
   SIGNAL DOALOC
   END
  TMBR = '('||STRIP(EMBR,'B')||')'
  IF SYSDSN("'"EDSN||TMBR"'") ^= 'OK' THEN DO
   DSEMSG = 'MBR IS NOT FOUND. RETRY'
   SIGNAL SRCLOOP
   END
 DOALOC:
  /* "ISPEXEC REMPOP" */
  ADDRESS TSO
  "ALLOC FI(INLST) DA('"EDSN||TMBR"') SHR"
  "EXECIO * DISKR INLST (STEM MBRL. FINIS"
  "FREE FI(INLST)"
  ADDRESS TSO
  I = 1
  OP.1 = '//IEBCSTP  EXEC  PGM=IEBCOPY,REGION=0K'
  OP.2 = '//SYSPRINT DD SYSOUT=*'
  OP.3 = '//SYSUT3   DD  DISP=NEW,UNIT=SYSDA,SPACE=(CYL,(3))'
  OP.4 = '//SYSUT4   DD  DISP=NEW,UNIT=SYSDA,SPACE=(CYL,(3))'
  O = 4
  QP.1 = '//SYSIN    DD  *'
  Q = 1
  SUBLIST=''
  DO J = 1 TO 6
   INTERPRET 'TMP2 = DSQMOD'J
   IF TMP2 = '' THEN ITERATE
   SUBLIST=SUBLIST||'DSQMOD'J'=('TMP2') '
   END
 TOPOFLOP:
  OURDSN = STRIP(WORD(MBRL.I,1),'B')
  GOTONE=0
  DO J = 1 TO 6
   INTERPRET 'TMP2 = DSQMOD'J
   IF TMP2 = '' THEN ITERATE
   W1 = WORD(TMP2,1)
   W2 = WORD(TMP2,2)
   W1L = LENGTH(W1)
   W1POS = POS(W1,OURDSN)
   IF W1POS = 0 THEN ITERATE
   GOTONE = GOTONE + 1
   W1POSEND = W1POS + W1L
   IF W1POS = 1 THEN DO
    NEWDSN = W2||SUBSTR(OURDSN,W1POSEND)
    END
    ELSE DO
    NEWDSN = SUBSTR(OURDSN,1,W1POS - 1)||W2||SUBSTR(OURDSN,W1POSEND)
    END
   END
  IF GOTONE = 0 THEN DO
   SAY 'ERROR?: SRC LIST DSN:'OURDSN
   SAY ' DOES NOT CONTAIN ANY DSN QUALIFIER SUBSTITUTIONS:'
   SAY SUBLIST
   SIGNAL BOTOFLST
   END
  ILNE = '//I'||I||' DD DISP=SHR,DSN='OURDSN
  OLNE = '//O'||I||' DD DISP=SHR,DSN='NEWDSN
  O = O + 1
  OP.O = ILNE
  O = O + 1
  OP.O = OLNE
  Q = Q + 1
  QP.Q = '  ZERODIR OUTDD=O'||I
  Q = Q + 1
  QP.Q = '  C I=((I'I',R)),O=O'I
  I = I + 1
  IF I ^> MBRL.0 THEN SIGNAL TOPOFLOP
/* OUT OF LOOP HERE */
/*TRACE ?I  */
  IF O < 5 THEN DO
   SAY 'DID NOT ENCOUNTER ANY DATA TO PROCESS. GOODBYE'
   EXIT 12
   END
  DO I = 1 TO Q
   O = O + 1
   OP.O = QP.I
   END
  O=O+1
  OP.O = '/*'
  SAY 'DO YOU WANT TO PREVIEW THE DATA TO BE WRITTEN?Y/N'
 TOPQLOOP:
  PULL ANS
  UPPER ANS
  IF ANS ^= 'Y' & ANS ^= 'N' THEN DO
   SAY 'EITHER Y TO PREVIEW, OR N TO SKIP PREVIEW'
   SIGNAL TOPQLOOP
   END
  IF ANS = 'Y' THEN DO J = 1 TO O
   SAY OP.J
   END
  SAY 'DO YOU WANT TO SAVE THIS OUTPUT?Y/N'
 TOPWLOOP:
  PULL ANS
  UPPER ANS
  IF ANS ^= 'Y' & ANS ^= 'N' THEN DO
   SAY 'EITHER Y TO SAVE, OR N TO ABORT'
   SIGNAL TOPWLOOP
   END
  IF ANS = 'N' THEN DO
   SAY 'SELECTED NOT TO SAVE. GOODBYE.'
   EXIT 4
   END
  EDSN = ODSN
  EMBR = OMBR
  "ISPEXEC VPUT (EDSN EMBR) ASIS"
  IF RC ^= 0 THEN SIGNAL EXITRC8
 /* "ISPEXEC ADDPOP ROW(3) COLUMN(10)" */
  IF RC ^= 0 THEN SIGNAL EXITRC8
  DSEMSG = 'ENTER TGT DSN(MBR) FOR IEBC JCL'
 TGTLOOP:
  SVDISP = 'MOD REP'
  "ISPEXEC VPUT (DSEMSG SVDISP) ASIS"
  IF RC ^= 0 THEN SIGNAL DSPOPX8
  CALL GDSNOMBR
  IF RESULT ^= 0 THEN SIGNAL CANCEL8
  "ISPEXEC VGET (EDSN EMBR SVDISP) ASIS"
  IF RC ^= 0 THEN SIGNAL DSPOPX8
  IF SVDISP ^= 'MOD' & SVDISP ^= 'REP' THEN SIGNAL TGTLOOP
  IF EMBR = '' THEN DO
   TMBR = ''
   SIGNAL OP2TGT
   END
   ELSE  TMBR = '('||STRIP(EMBR,'B')||')'
  IF SVDISP = 'MOD' THEN DO
   IF SYSDSN("'"EDSN||TMBR"'") ^= 'OK' THEN SVDISP = 'REP'
   END
 OP2TGT:
/*  "ISPEXEC REMPOP" */
  OPT.0 = 0
  ADDRESS TSO
  IF SVDISP = 'MOD' THEN DO
   "ALLOC FI(M) DA('"EDSN||TMBR"') SHR"
   "EXECIO * DISKR I (STEM OPT. FINIS"
   "FREE FI(I)"
   END
  J = OPT.0
  DO I = 1 TO O
   J = J+1
   OPT.J = OP.I
   END
  OPT.0 = J
  "ALLOC FI(O) DA('"EDSN||TMBR"') SHR"
  "EXECIO * DISKW O (STEM OPT. FINIS"
  XC = RC
  "FREE FI(O)"
  IF XC ^= 0 THEN SIGNAL EXITRC8
  ADDRESS ISPEXEC "EDIT DATASET('"EDSN||TMBR"')"
   RETURN 0
 DSKOPX8:
 /* "ISPEXEC REMPOP" */
  DO I = 1 TO N
   SAY OP.I
   END
 BOTOFLST:
 CANCEL8:
 /* "ISPEXEC REMPOP" */
  SAY 'CANCEL, ABORT OR ERROR OCCURRED. RC = 8'
  RETURN 8
 NOTCPU:
  RETURN 4
 EXITRC2:
  RETURN 2
 EXITRC4:
  RETURN 4
 EXITRC8:
  RETURN 8
###END MAKEIEBZ
$$$BEG OCOPY
 /* REXX */
  trace ?i
  address tso
SIGNAL ON ERROR NAME ERROR
"ALLOCATE FILE(pdsin) DATASET('TUKD.TSK.D520PUT.CICS.ADFHENV') SHR"
"ALLOCATE FILE(ussout) PATH('/shared_products/cicstsd/r520put/JVMProfiles')"
"OCOPY INDD(pdsin) OUTDD(ussout) TEXT"
error:
"FREE FILE(pdsin)"
"FREE FILE(ussout)"
###END OCOPY
$$$BEG JRPSET
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA JRPSET   - ISPF BASE, USED TO SET UP DEFAULT JRP DEST   */
 /* CEMHELP JRPSET   - ISPF BASE, USED TO ESTABLISH JRP PRINTER     */
 /* CEMHELP          - DESTINATION SETS. THE NOTE AREA WILL SHOW    */
 /* CEMHELP          - ALL OF YOUR ESTABLISHED JRP OBJECTS AND  THE */
 /* CEMHELP          - ASSOCIATED DESTINATION. YOU CAN ADD NEW JRP  */
 /* CEMHELP          - DESTINATIONS TO A PREVIOUSLY DEFINED OBJECT, */
 /* CEMHELP          - AND/OR YOU CAN SET ADDITIONAL OBJECTS TO THE */
 /* CEMHELP          - EXISTING DESTINATIONS.                       */
 /* CEMHELP END                                                     */
  ARG SETPNT REST
  FFX='FF'X
  ADDRESS ISPEXEC
  'ISPEXEC CONTROL ERRORS RETURN'
  IF SETPNT ^= '' THEN DO
   IF SETPNT = '?' THEN SIGNAL DOGET
   IF SETPNT = 'F' THEN SIGNAL DOFORCE
   FP = POS('=',SETPNT)
   IF FP = 0 THEN DO
    IF REST = '' THEN SIGNAL GETSPEC
    PDEF=REST
    END
    ELSE PARSE VAR SETPNT SETPNT '=' PDEF
   IF LENGTH(SETPNT) > 8 THEN SIGNAL FAILADD
   IF LENGTH(P4DEF) < 3 THEN SIGNAL FAILADD
   END
 DOGET:
  'ISPEXEC VGET (JRPDESTS) PROFILE'
  IF RC = 0 THEN SIGNAL GOTDSTR
 DOFORCE:
  SUID=SYSVAR(SYSUID)
  IF SUID = 'TCEM' THEN SIGNAL SETDFTS
  IF SETPNT = '' THEN SIGNAL NONESET
  IF SETPNT = '?' THEN SIGNAL SHOWFMT
 SETDFTS:
  /* CURRENT SET OF KNOWN PRINTER DESTINATIONS */
  TRACE I
  JRP4181='JRP4182 176 WIC02A03M.LANDSCAPE10'  /* 3WS 2FL    */
  JRP4182='JRP4182 246 WIC02A03M.LANDSCAPE16'   /* 3WS 2FL    */
  JRP4563='JRP4563 80 WDC01008.PORTRAIT10'   /* DN BY MQS' */
  JRP4564='JRP4564 132 WDC01008.LANDSCAPE10' /* DN BY MQS' */
  JRP4565='JRP4565 255 WDC01008.LANDSCAPE16' /* DN BY MQS' */
  JRP4555='JRP4555 80 WDC10101.PORTRAIT104'  /* DN BY MVS' */
  JRP4556='JRP4556 132 WDC10101.LANDSCAPE10' /* DN BY MVS' */
  JRP4557='JRP4557 255 WDC10101.LANDSCAPE16' /* DN BY MVS' */
  /* CURRENT DEFAULTS FOR CEM */
  JRPPNT = 'JRP4181 80'
  JRPPNTN= 'JRP4181 80'
  JRPPNTC= 'JRP4181 176'
  JRPPNTW= 'JRP4182 246'
  /* CURRENT DEFAULTS FOR CEM */
  JRPDESTS='JRPPNT JRPPNTN JRPPNTC JRPPNTW '||,
  'JRP4181 JRP4182'
  'ISPEXEC VPUT (JRPDESTS) PROFILE'
  TRACE OFF
  IF RC ^= 0 THEN SIGNAL FAILADD
  'ISPEXEC VPUT ('JRPDESTS') PROFILE'
  IF RC ^= 0 THEN SIGNAL FAILADD
 GOTDSTR:
  IF SETPNT = '' THEN RETURN 0
  MYAREA=JRPDESTS
  CALL MSGBOX MYAREA
  RETURN 0
 GETSPEC:
  'ISPEXEC VGET ('SETPNT') PROFILE'
  IF RC ^= 0 THEN RETURN 8
  INTERPRET 'RETPNT = 'SETPNT
  PUSH RETPNT
  RETURN 0
 SHOWFMT:
  MYAREA=FFX||'JRPSET ?'||FFX||'JRPSET JRPNAME=PNTSERV.LANDORPORT##'
  CALL MSGBOX MYAREA
  RETURN 4
 NONESET:
  RETURN 8
 FAILADD:
  RETURN 12
###END JRPSET
$$$BEG EXCIS0$
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA EXCIS0   - SUBROUTINE TO AFOLIST. SEE AFOLIST           */
 /* CEMHELP EXCIS0   - SUBROUTINE TO AFOLIST. SEE AFOLIST           */
 /* CEMHELP          -                                              */
 /* CEMHELP END                                                     */
 /*                                                                 */
 /* REQUIRED PARAMETERS:                                            */
 /*  MYFUNC - FIRST PARM IDENTIFIES THE OUTPUT PROCESS              */
 /*         - SEE VAR VALFUNC                                       */
 /*  MYCMD  - DESIRED COMMAND PROCESSING OPTION                     */
 /*           SEE VAR VALPRMS                                       */
 /*  MYAPLID() - TARGET APPLID(S) EXPECTED AS COMMA DELM LIST       */
 /*  ODSN   - IF QUIET, IDENTIFIES THE TARGET DSN TO COLLECT THE    */
 /*           RESULTS                                               */
 /*                                                                 */
 /*  PARMS MUST BE IN THE FORMAT                                    */
 /*   ACTUAL LITERAL (SEE VALPRMS FOR LIST) EXPL: MYAPLID           */
 /*     MYAPLID=XXXX   SINGLE CHOICE                                */
 /*            =(XXXX YYYY ....) MULTIPLE CHOICES                   */
 /*            (XXXX YYYY ....) MULTIPLE CHOICES                    */
 /*            =<IIII> IDENTIFIES AN ISPFVAR NAME                   */
 /*            <IIII>                                               */
 /*    IIII ISPFVAR NAME - IS THE ACTUAL NAME OF AN ISPFVAR         */
 /*            WHICH WILL BE VGET. THE CONTENTS OF THAT VAR         */
 /*            WILL BE USED AS A LIST                               */
 /*                                                                 */
 /*  MYCMD   CAN NOT BE A LIST. IT IS USED TO DEFINE A SINGLE       */
 /*          COMMAND, TO BE USED WITH THE APPLID LIST               */
 /*          IF MYCMD IS LIST, CEMT, OR CEDA THEN YOU MUST          */
 /*          PROVIDE A MYCA AND MYCAL VARIABLE                      */
 /*                                                                 */
 /*  MYTRANID(T) THE NAME OF THE TRANS ID TO USE  IF MYCMD IS LINK  */
 /*          PASSED IN AN ISPF VAR AND THE T IS THE VARIABLE NAME   */
 /*                                                                 */
 /*  MYPROG(P) THE NAME OF THE PROGRAM TO LINK TO IF MYCMD IS LINK  */
 /*          PASSED IN AN ISPF VAR AND THE P IS THE VARIABLE NAME   */
 /*                                                                 */
 /*  MYCA<X> THE COMMAREA  ASSOCIATED WITH THE COMMAND MUST BE      */
 /*          PASSED IN AN ISPF VAR AND THE X IS THE VARIABLE NAME   */
 /*                                                                 */
 /*  MYCAL<Y> SPEFICIES THE NAME OF THE ISPF VAR, WHICH DEFINES THE */
 /*          DESIRED COMMAREA LENGTH (0 - 32400)                    */
 /*          PASSED IN AN ISPF VAR AND THE Y IS THE VARIABLE NAME   */
 /*                                                                 */
 /*  ODSN - CAN BE 'DISPLAY' WHICH WILL DISPLAY UP TO 99 LINES      */
 /*       - A DATASET (NEW OR EXISTING) IF EXISTING, YOU ARE        */
 /*         PROMPTED TO ACCEPT REUSE. IT CAN BE A PDS(E) WITH MBR   */
 /*                                                                 */
 /*                                                                 */
 /*                                                                 */
 /*                                                                 */
  ADDRESS ISPEXEC
  /* TRACE I */
  "ISPEXEC CONTROL ERRORS RETURN"
  ARG MYFUNC PRMS
  IF MYFUNC = '' THEN SIGNAL BADFUNC
  VALFUNC='QUIET MSGBOXONLY MSGBOXALL VERBOSE'
  VALPRMS='MYCMD MYAPLID ODSN MYCA MYCAL MYPROG MYTRANID'
  VALCMDS = 'PING CEMT CEDA LINK'
  DFTPVALS='PING . .'
  IF PRMS ^= '' THEN DO
   NPW=WORDS(VALPRMS)
   DO I = 1 TO NPW
    TMP = WORD(VALPRMS,I)
    TMPV = WORD(DFTPVALS,I)
    IF TMPV = '.' THEN TMPV = ''
     ELSE IF TMPV = '\.' THEN TMPV = '.'
    INTERPRET TMP"='"TMPV"'"
    END
   END
   X15='15'X
   XFF='FF'X
   ERRMSG = ''
   I=0
   PRM_RC = 0
   DLM='(<{[='
   MDLM=')>}] '
   #DMM=LENGTH(DLM)
PRMLOOP:
   IF PRMS = '' THEN SIGNAL DONEPRMS
   PRMX = ''
   PARSE VAR PRMS PRM PRMS
   IF PRM = '' THEN SIGNAL EXITRC8
   PRM=PRM||' ' /* TACK ON A SPACE TO HELP FIND '=' END */
   L_PRM=LENGTH(PRM)
   FDLM = ''
   EDLM = ''
   DO I = 2 TO L_PRM
    PP=SUBSTR(PRM,I,1)
    CKPP=POS(PP,DLM)
    IF CKPP ^= 0 THEN DO
     FDLM=SUBSTR(DLM,CKPP,1)
     EDLM=SUBSTR(MDLM,CKPP,1)
     LEAVE
     END
    END
   IF FDLM = '' THEN SIGNAL BADPARM
   IF I >= L_PRM THEN SIGNAL BADPARM
   LP = LASTPOS(EDLM,PRM)
   IF LP = 0 THEN LP=L_PRM
    ELSE LP = LP - 1
   PRMVAL = SUBSTR(PRM,I+1,LP-I)
   PRM = SUBSTR(PRM,1,I-1)
   IF PP = '=' THEN SIGNAL GOTEQ
   IF PP = '<' THEN SIGNAL GOTBRKT
   SIGNAL GOTPARNT
GOTEQ:
   IF PRMVAL = '' THEN SIGNAL BADPARM
   L_PRM=LENGTH(PRMVAL)
   PP = SUBSTR(PRMVAL,1,1)
   CKPP=POS(PP,DLM)
   IF CKPP = 0 THEN DO
    SIGNAL GOT_PRMVAL
    END
   I = 1
   FDLM=SUBSTR(DLM,CKPP,1)
   EDLM=SUBSTR(MDLM,CKPP,1)
   LP = LASTPOS(EDLM,PRMVAL)
   IF LP = 0 THEN LP=L_PRM
    ELSE LP = LP - 1
   PRMVAL = SUBSTR(PRMVAL,I+1,LP-I)
   IF PP = '<' THEN SIGNAL GOTBRKT
   SIGNAL GOTPARNT
GOTPARNT:
   PARSE VAR PRMVAL . '<' TMPVAL '>'
   IF TMPVAL ^= '' THEN DO
    PRMVAL = TMPVAL
    SIGNAL GOTBRKT
    END
   SIGNAL GOT_SIMPLE
GOTBRKT:
   IF LENGTH(PRMVAL) > 8 THEN SIGNAL BADPARM
   "ISPEXEC VGET ("PRMVAL") ASIS"
   INTERPRET "PRMVAL = "PRMVAL
/* IF PRMVAL = '' THEN SIGNAL BADPARM */
   SIGNAL NXTPRMS
BADPARM:
    ERRMSG = ERRMSG||XFF||,
       'PARM:'PRM' IS NOT A EXPECTED PARAMETER. BYPASSING.'
    PRM_RC = 4
    SIGNAL      NXTPRMS
GOT_SIMPLE:
GOT_PRMVAL:
   INTERPRET PRM "='"||PRMVAL||"'"
NXTPRMS:
/* TRACE OFF */
   SIGNAL PRMLOOP
DONEPRMS:
/* TRACE I */
   IF PRM_RC > 4 THEN SIGNAL EXITRC4
   IF MYFUNC = '' THEN SIGNAL EXITRC8
   IF MYFUNC = 'QUIET' THEN DO
    IF ODSN = '' | ODSN = 'ODSN' THEN DO
     CALL GETUDSN 'AFOLIST'
     PULL ODSN
     END
    IF ODSN = '' THEN SIGNAL EXITRC10
    SIGNAL GOTFUNC
    END
   IF MYFUNC = 'MSGBOXONLY' THEN SIGNAL GOTFUNC
   IF MYFUNC = 'MSGBOXALL' THEN SIGNAL GOTFUNC
   IF MYFUNC = 'VERBOSE' THEN SIGNAL GOTFUNC
   SIGNAL EXITRC8
 GOTFUNC:
   IF WORDPOS(MYCMD,VALCMDS) = 0 THEN SIGNAL EXITRC12
   "ISPEXEC VGET (AUTOSAVE) ASIS"
   IF RC \= 0 THEN AUTOSAVE = 'N'
   IF MYCMD = 'PING' THEN DO
    MYCA = 'PING'
    MYCAL = 1080
    SIGNAL SETPROG
    END
   IF MYCA = '' & MYCMD \= 'LINK' THEN SIGNAL BADCA
   IF MYCAL = '' THEN MYCAL = LENGTH(MYCA)
   IF DATATYPE(MYCAL) ^= 'NUM' THEN SIGNAL BADCA
   IF MYCAL < 0 | MYCAL > 32400 THEN SIGNAL BADCA
   IF MYCMD = 'LINK' THEN DO
    IF MYPROG = '' THEN SIGNAL BADLINK
    IF MYTRANID = '' THEN MYTRANID = 'CSMI'
     ELSE DO
     LTRID = LENGTH(MYTRANID)
     IF LTRID < 1 | LTRID > 4 THEN SIGNAL BADLINK
     END
    SIGNAL SET_H_VARS
    END
SETPROG:
   IF MYTRANID = '' THEN MYTRANID = 'CSMI'
   MYPROG='UCEMPINN'
SET_H_VARS:
   L_CA = LENGTH(MYCA)
   IF MYCAL < L_CA THEN MYCAL = L_CA
   H_MYCA = MYCA
   H_MYCAL = MYCAL
   H_MYPROG = MYPROG
   H_MYTRANID = MYTRANID
   TOTLNG=0
TSTAPLIDS:
   I = 0
   COMA=','
   IF MYAPLID = '' THEN SIGNAL EXITRC16
   DO WHILE(MYAPLID ^= '')
    I = I + 1
    PARSE VAR MYAPLID APL_STM.I MYAPLID
 TRACE OFF
    END
   APL_STM.0 = I
   H_I = I
   JOBLS='N'
   "ISPEXEC VGET (AFOJOBLS AFOAPLLS) SHARED"
   IF RC = 0 THEN JOBLS='Y'
   REPWDS='\@ \$ \! \\'  /* SUBSTITUTE \ APPLID JOBNAME */
   RW_CT = WORDS(REPWDS)
 /* OK HERE WE GO */
   IF MYFUNC = 'MSGBOXALL' | MYFUNC = 'QUIET' THEN DO
    MSGLOCK='Y'
    MSGSTAT='CONTPOP'
    MSGBOXTX='STARTING: PROCESSING ALL APPLIDS...'
    ADDRESS ISPEXEC "VPUT (MSGBOXTX) ASIS"
    ADDRESS ISPEXEC "VPUT (MSGLOCK MSGSTAT) ASIS"
    CALL MSGBOX
    END
   J = 0
   MXLNG = 132
TOPOFLOP:
   /* TRACE I */
   J = J + 1
   IF J > I THEN SIGNAL DONEIT
   MYAPLID = APL_STM.J
   MYCA = H_MYCA
   MYCAL = H_MYCAL
   IF JOBLS = 'Y' THEN DO
    APLPOS=WORDPOS(MYAPLID,AFOAPLLS)
    IF APLPOS = 0 THEN SIGNAL NOSUB_CA
    JOBNM=WORD(AFOJOBLS,APLPOS)
    SUBWDS= MYAPLID||' '||JOBNM||' '||MYAPLID||' \'
    DO K = 1 TO RW_CT
     TMPCAL=LENGTH(MYCA)
     SWD = WORD(REPWDS,K)
     RWD = WORD(SUBWDS,K)
     WP = 999
     DO UNTIL WP = 0
      WP = POS(SWD,MYCA)
      IF WP > 0 THEN DO
       IF WP = 1 THEN DO
        MYCA=RWD||SUBSTR(MYCA,WP+2)
        END
        ELSE DO
        IF WP = TMPCAL - 1 THEN ,
         MYCA=SUBSTR(MYCA,1,WP-1)||RWD
         ELSE ,
         MYCA=SUBSTR(MYCA,1,WP-1)||RWD||SUBSTR(MYCA,WP+2)
        END
       TMPCAL=LENGTH(MYCA)
       END
      END
    IF TMPCAL > 32767 THEN DO
     TMPCAL = 32767
     MYCA=SUBST(MYCA,1,32767)
     END
    IF TMPCAL > H_MYCAL THEN DO
     MYCAL=TMPCAL
     END
    END
NOSUB_CA:
   MYPROG = H_MYPROG
   MYTRANID = H_MYTRANID
  "ISPEXEC VPUT (MYAPLID MYPROG MYCA MYCAL MYTRANID) ASIS"
   IF RC ^= 0 THEN SIGNAL CHK_ERR
   IF MYFUNC = 'MSGBOXALL' | MYFUNC = 'QUIET' THEN DO
    MSGBOXTX=MYFUNC||' '||MYCMD||'... PROCESSING >'||MYAPLID            T
    ADDRESS ISPEXEC "VPUT (MSGBOXTX) ASIS"
    CALL MSGBOX
    END
   CALL EXCIS2 MYFUNC
   XC = RESULT
   IF XC = 4 THEN SIGNAL DONEIT
   IF MYFUNC = 'MSGBOXALL' | MYFUNC = 'QUIET' THEN DO
    /* TRACE ?I */
    TMP=XFF||LEFT(MYAPLID,8)||'-->'||XFF
    IF XC ^= 0 THEN TMP = TMP||'WARNING - CALL RETURNED 'XC||XFF
    "ISPEXEC VGET (MYCA) ASIS"
    MYCA = STRIP(MYCA,'B')
    APL_STM.J = TMP||TRANSLATE(MYCA,XFF,X15)
    IF AUTOSAVE = 'N' THEN SIGNAL CHK_CAL
    "ISPEXEC VGET (DSPLYADS) ASIS"
    IF RC \= 0 THEN DO
     ZEDSMSG = 'AUTOSAVE DSN BAD'
     ZEDLMSG = 'AUTOSAVE FOR REGION 'MYAPLID' DSN BAD'
     'ISPEXEC SETMSG MSG(ISRZ000)'
     APL_STM.J ='AUTOSAVE FAIL:DSN BAD:'MYAPLID||XFF||APL_STM.J
     SIGNAL CHK_CAL
     END
    PARSE VAR DSPLYADS EDSN '(' EMBR ')'
    TDSN = EDSN
   /* DO THE AUTOSAVE ACTION */
    H_MYAREA=APL_STM.J
    L = 0
    DO WHILE H_MYAREA \= ''
     L = L + 1
     PARSE VAR H_MYAREA MYA.L (XFF) H_MYAREA
     WL=LENGTH(MYA.L)
     IF WL > MXLNG THEN MXLNG = WL
     TRACE OFF
     END
    /* TRACE ?I */
    MYA.0 = L
    EMBR=MYAPLID
    M# = MYA.0
    MYSTM='MYA.'
    CALL SAVIT
    DROP MYA.
    IF XC \= 0 THEN DO
     ZEDSMSG = 'AUTOSAVE FAILED.'
     ZEDLMSG = 'AUTOSAVE FOR REGION 'MYAPLID' FAILED.'
     'ISPEXEC SETMSG MSG(ISRZ000)'
     APL_STM.J ='AUTOSAVE FAIL:SAVIT:'MYAPLID||XFF||APL_STM.J
     END
     ELSE DO
     ZEDSMSG = 'AUTOSAVE SUCCESS'
     ZEDLMSG = 'AUTOSAVE FOR REGION 'MYAPLID' SUCCESSFUL.'
     'ISPEXEC SETMSG MSG(ISRZ000)'
     APL_STM.J ='AUTOSAVE SUCCESSFUL:'MYAPLID
     END
    END
 CHK_CAL:
    L_CA=LENGTH(APL_STM.J)
    TOTLNG=TOTLNG+L_CA
    IF L_CA > 32400 THEN SIGNAL TOOMUCH
 GO_NEXT:
    SIGNAL TOPOFLOP
 DONEIT:
   IF MYFUNC = 'VERBOSE' | MYFUNC = 'MSGBOXONLY' THEN SIGNAL EXITRC0
   J = H_I
   IF MYFUNC = 'MSGBOXALL' THEN DO
    MSGSTAT='REMPOP'
    MSGBOXTX= '< FINISHED PROCESSING SELECTION LIST. WRITING RESULTS'
    ADDRESS ISPEXEC "VPUT (MSGSTAT MSGBOXTX) ASIS"
    CALL MSGBOX
    EXECSEL = 'MSGBOXAL'
    "ISPEXEC VPUT (EXECSEL) ASIS"
    MYAREA=''
    DO I = 1 TO J
     MYAREA=MYAREA||XFF||APL_STM.I
     END
    MYCA = H_MYCA
    MYAREA#=XFF
    MYAREA='PROCESSED 'J' REGIONS. FINISHED AT 'DATE('U')||' '||,
           TIME()||XFF||'TO:'||DSPLYADS||XFF||MYAREA
    M$L=LENGTH(MYAREA)
    IF M$L > 32400 THEN DO
     MYAREA='!!OVERFLOW: PARTIAL RESULT RETURNED!!'||,
      SUBSTR(MYAREA,1,32400-38)
     END
    "ISPEXEC VPUT (MYAREA MYAREA#) ASIS"
    CALL DSPLYA
    RETURN 0
    END
/* MYFUNC = QUIET : WRITE OP TO ODSN */
DO_ODSN:
  IF MYFUNC ^= 'QUIET' THEN SAY MUFUNC 'IS NOT EXPECTED:EXPECT:QUIET'
  IF ODSN = '' THEN SIGNAL EXITRC10
  MYSTM='APL_STM.'
  PARSE VAR ODSN TDSN '(' EMBR ')'
  EDSN = ODSN
SAVIT:
  EXECSEL='EXCIS0'
  DSPVAL='SHR REUSE'
  CALL MALOC TDSN
  XC=RESULT
  IF XC = 0 THEN SIGNAL CHKORG
  IF EMBR = '' THEN MYDSO='PS)'
   ELSE DO
    MYDSO='PO) DSNTYPE(LIBRARY)'
   END
  MODDSN = ''
  M=MXLNG+4
  DSEMSG = '(D) DEL/REALLOC,(A) ABORT'
  MODATTR="NEW BLKSIZE("M+4") DSORG("MYDSO" RECFM(V,B) SPACE(1,1)"||,
   "CYLINDER LRECL("M") CATALOG REUSE"
  "ISPEXEC VPUT (EDSN EXECSEL DSEMSG MODATTR MODDSN) ASIS"
  IF RC ^= 0 THEN SIGNAL EXITRC8
  CALL ALOCDSN
  XC = RESULT
  "ISPEXEC VGET (EDSN) ASIS"
  IF RC ^= 0 THEN RETURN 4
  SIGNAL DOWRITE
 CHKORG:
   XC=LISTDSI("'"TDSN"'" DIRECTORY NORECALL)
   MYDSO=SYSDSORG
   IF EMBR \= '' THEN DO
    IF MYDSO = 'PS' THEN SIGNAL BADOPDSNORG
    END
    ELSE DO
    IF MYDSO = PO THEN SIGNAL BADOPDSNORG
    IF AUTOSAVE = 'Y' THEN DSPVAL='MOD'
    END
  DOWRITE:
   /* TRACE ?I */
   DSPLYADS=EDSN
    IF EMBR \= '' THEN EDSN=EDSN||'('||EMBR||')'
   "ISPEXEC VPUT (DSPLYADS EMBR) ASIS"
   ADDRESS TSO "ALLOC FI(O) DA('"EDSN"') "DSPVAL
   ADDRESS TSO "EXECIO "M#" DISKW O (STEM "MYSTM" FINIS"
   ADDRESS TSO "FREE FI(O)"
   RETURN 0
BADOPDSNORG:
   CALL MSGBOX 'SAVE TO DSN DSORG INCONSISTENT WITH EXISTING DSN'
   RETURN 4
  END
 BADCA:
    ERR=MYCMD' COMMAND: MISSING COMMAREA'
    SIGNAL DOERR
 BADLINK::
    ERR='LINK  COMMAND: INVALID PROGRAM, COMMAREA OR TRANSID'
    SIGNAL DOERR
 BADPARM:
    ERR=TMP
    SIGNAL DOERR
 EXITRC4:
    ERR='PARAMETER ERROR:'||PRM_RC
    SIGNAL DOERR
 EXITRC8:
    ERR='NO VALID FUNCTION REQUESTED'
    SIGNAL DOERR
 EXITRC10:
    ERR='FUNCTION:QUIET, BUT NO OUTPUT DESTINATION PROVIDED.'
    SIGNAL DOERR
 EXITRC12:
 EXITRC16:
 EXITRC20:
 EXITRC0:
 DOERR:
 RETURN XC
###END EXCIS0$
$$$BEG EXPLSUPC
/* ReXX */                                                              00010000
 MAIN_PROCESSING:                                                       00020000
   ADDRESS ISREDIT "MACRO"                                              00030000
   ADDRESS TSO                                                          00040000
"ALLOC FI(OUTDD) DA('TTED.TSK.S.TCEM.EXPLSUPC.RESULTS') MOD REUSE",     00050000
  " SPACE(100,100) DSORG(PS) RECFM(F,B) LRECL(80) BLKSIZE(800)"         00060000
"ALLOC FI(NEWDD) DS('"PDSNAME"("MEMNAME")') SHR REUSE"                  00070000
"ALLOC FI(SYSIN) DUMMY SHR REUSE"                                       00080000
STRING = '00665'                                                        00090000
QUEUE "SRCHFOR '"STRING"'"                                              00100000
"EXECIO" QUEUED() "DISKW SYSIN(FINIS"                                   00110000
PARMS = "SRCHCMP,' '"                                                   00120000
                                                                        00130000
ADDRESS ISPEXEC "SELECT PGM(ISRSUPC) PARM("PARMS")"                     00140000
IF RC /= 0 THEN                                                         00150000
   SAY "RULE FOUND IN PROGRAM" MEMNAME                                  00160000
FREE FI(OUTDD SYSIN NEWDD)                                              00170000
###END EXPLSUPC
$$$BEG SDMPGDG
/* REXX */
/* CEMHELP BEGIN                                                     */
/* CEMHELA SDMPGDG  - BRWSE SDMP GDG LIST, ALOC TARGET, SUB JOB COPY */
/* CEMHELP SDMPGDG  - TSO OR ISPF, USED TO SUBMIT A BATCH JOB TO     */
/* CEMHELP          - COPY A SYSMDUMP FROM TAPE GDG TO A DS.  YOU    */
/* CEMHELP          - ARE PROMPTED FOR A CPU (FOR A LIST OF AVAILABLE*/
/* CEMHELP          - DUMPS). YOU ARE PROMPTED FOR DSN QUALIFIER   */
/* CEMHELP          - WHICH WILL BE THE TARGET DS. THE GDG VALUE     */
/* CEMHELP          - IS EITHER B TO BROWSE THE MVS DSN FOR LIST OF  */
/* CEMHELP          - DUMPS BY CPU, OF THE 4 DIGIT GDG NUMBER. THIS  */
/* CEMHELP          - EXEC PRE-ALLOCATES THE TARGET DSN.  YOU CAN    */
/* CEMHELP          - SPECIFY THE PRIMARY AND SECONDARY CYLINDER     */
/* CEMHELP          - QUANTITIES.  YOU ALSO NEED AN APPLID OR SOME   */
/* CEMHELP          - OTHER UNIQUE QUALIFIER. JOB IS SUBMITTED FOR U.*/
/* CEMHELP          - IF ISPF NOT AVAILABLE, YOU GET TSO PROMPTS.    */
/* CEMHELP END                                                       */
  IF SYSVAR(SYSISPF) = 'ACTIVE' THEN ISPFIND = 1
   ELSE ISPFIND = 0
  DFTPRI=2500
  DFTSEC=50
  PRI=DFTPRI
  SEC=DFTSEC
  ATTR0="INPUT"
  ATTCO="GREEN"
  CALL GETCPU1
  IF ISPFIND = 0 THEN DO
   PULL CURCPU CURGRP CURCPUG
   SIGNAL DOTSO
   END
   "ISPEXEC ADDPOP ROW(7) COLUMN(10)"
  ADDRESS ISPEXEC
  "ISPEXEC VGET (CURCPU,CURGRP,CURCPUG) PROFILE"
  DSEMSG = ''
  CPUSEL=CURCPU
  GDGV='B'
  KIXAPPL=''
 TOPOFLOP:
  CMD = ''
  "ISPEXEC DISPLAY PANEL(SDMPGDGD)"
  IF RC = 8 THEN SIGNAL CANCEL8
  IF ABBREV('CANCEL',CMD,3) = 1 THEN SIGNAL CANCEL8
  DSEMSG = ''
  IF CMD ^= '' THEN DO
   ADDRESS TSO CMD
   CMD = ''
   ZCMD = ''
   END
  IF CPUSEL = '' THEN SIGNAL BADCPU
  IF POS(CPUSEL,CURCPUG) = 0 THEN SIGNAL BADCPU
  IGDG='TTAT.TSM.S'||CPUSEL||'.DUMPDATA'
  IF SYSDSN("'"IGDG"'") ^= 'OK' THEN DO
   DSEMSG='DSN BAD '||IGDG
   SIGNAL TOPOFLOP
   END
  IF GDGV = 'B' THEN DO
   "ISPEXEC REMPOP"
   "ISPEXEC BROWSE DATASET ('"IGDG"')"
   "ISPEXEC ADDPOP ROW(7) COLUMN(10)"
   DSEMSG='ENTER THE GDGV, SPACE INFO, OR CAN (PF3)'
   SIGNAL TOPOFLOP
   END
  IF DATATYPE(GDGV) ^= 'NUM' THEN DO
   DSEMSG='GDG VALUE MUST BE NUMERIC,(B)ROWSE'
   SIGNAL TOPOFLOP
   END
  GDGV='000'GDGV
  GDGV=SUBSTR(GDGV,LENGTH(GDGV)-3,4)
  IF PRI = 0 THEN DO
   DSEMSG='PRI SPACE ALOC CAN NOT BE 0'
   SIGNAL TOPOFLOP
   END
  IF KIXAPPL = '' | DATATYPE(SUBSTR(KIXAPPL,1,1)) ^= 'CHAR' THEN DO
   DSEMSG='CICS APPLID IS REQUIRED!'
   SIGNAL TOPOFLOP
   END
  SIGNAL DOALOC
BADCPU:
   DSEMSG='CPU REQUIRED, NOT VALID FOR THIS COMPLEX'
   SIGNAL TOPOFLOP
 DOTSO:
  SAY "ENTER THE CPU CHARACTER, OR '' TO EXIT"
  PULL CPUSEL
  IF LENGTH(CPUSEL) ^=1 THEN SIGNAL EXITRC4
  IF DATATYPE(CPUSEL) ^= 'CHAR' THEN SIGNAL EXITRC8
  IGDG='TTAT.TSM.S'||CPUSEL||'.DUMPDATA'
  IF SYSDSN("'"IGDG"'") = 'OK' THEN SIGNAL REPETE
  SAY 'CPU CHARACTER NOT VALID OR DSN NOT AVAILABLE ON THIS CPU'
  ADDRESS TSO
  "CPU"
  SIGNAL EXITRC8
 REPETE:
  IF ISPFIND = 1 THEN SIGNAL TOPOFLOP
  GDGV=''
  SAY "ENTER B IF YOU WISH TO BROWSE"
  SAY IGDG" FOR THE GDG,"
  SAY " OR ENTER A 4 DIGIT GDG NUMBER"
  SAY " OR ENTER X TO ABORT"
  PULL RESP
  IF LENGTH(RESP) ^= 1 THEN SIGNAL TESTGDG
  IF DATATYPE(RESP) = 'NUM' THEN SIGNAL TESTGDG
  "ISPEXEC BROWSE DATASET('"IGDG"')"
  SAY 'OK, TIME TO DECIDE...'
  SIGNAL REPETE
 TESTGDG:
  IF DATATYPE(RESP) ^= 'NUM' THEN SIGNAL EXITRC4
  RESP='000'RESP
  GDGV=SUBSTR(RESP,LENGTH(RESP)-3,4)
  SAY 'TARGET IPCS DUMP DATASET WILL BE NAME FORMAT:'
  SAY 'TTEP.TSK.J.KIXAPPL.DDATE.TTIME'
  SAY 'WHERE:'
  SAY '      KIXAPPL IS THE CICS APPLID NAME'
  SAY '      DDATE IS THE "D"DATE'
  SAY '      TTIME IS THE "T"TIME'
  SAY 'YOU WILL BE PROMPTED FOR THE KIXAPPL QUALIFIER AND SPACE PARMS'
  SAY ' '
  SAY 'ENTER CICS COPY NAME'
  KIXAPPL=''
  PULL KIXAPPL
  CLN=LENGTH(KIXAPPL)
  IF CLN=0 THEN SIGNAL EXITRC4
  IF CLN>8 THEN SIGNAL EXITRC8
  IF DATATYPE(KIXAPPL) ^= 'CHAR' THEN SIGNAL EXITRC8
 DOALOC:
  CALL GETUDSN KIXAPPL
  PULL EDSN
  FP=POS(KIXAPPL,EDSN)
  MYSDSN='TTEP.TSK.J.'||SUBSTR(EDSN,FP)
  IF ISPFIND = 1 THEN DO
   ATTR0 = "OUTPUT"
   ATTCO = "RED"
   DSEMSG = "DSN>"||MYSDSN||'<'
   "ISPEXEC DISPLAY PANEL(SDMPGDGD)"
   IF RC = 8 THEN SIGNAL CANCEL8
   SIGNAL DOALOC1
   END
  SAY 'FULL DATASET IS '
  SAY MYSDSN
  SAY 'OK, USING==> 'MYSDSN
 USEIT:
  ADDRESS TSO
  IF SYSDSN("'"MYSDSN"'") ^= 'OK' THEN SIGNAL GOALOC
  "LISTD '"MYSDSN"'"
  SAY 'TARGET DSN ' MYSDSN
  SAY ' STILL EXISTS. ENTER Y TO REUSE,'
  SAY '               ENTER X TO ABORT,'
  RESP='X'
  PULL RESP
  IF RESP^='Y' THEN SIGNAL EXITRC4
  SAY 'REUSE SELECTED...DELETING 'MYSDSN
  "DELETE '"MYSDSN"'"
GOALOC:
 SAY 'ALLOCATION SPACE DEFAULT IS ('DFTPRI','DFTSEC') RELEASE'
 SAY 'SPECIFY ALTERNATIVE PRIMARY SPACE VALUE, OR ENTER TO USE 'DFTPRI
 PULL PRI
 IF PRI = '' THEN PRI=DFTPRI
 ELSE DO
  IF (DATATYPE(PRI) ^= 'NUM') | (PRI < 1) THEN DO
   SAY 'PRIMARY SPACE MUST BE POSITIVE NUMERIC VALUE'
   PRI=600
   SIGNAL GOALOC
   END
   END
 SEC = 5
DOALOC1:
 SIGNAL ON ERROR NAME DOREVISE
 XPRM="NEW BLKSIZE(4160) DSORG(PS) RECFM(F) SPACE("PRI","SEC")"||,
  " CYLINDERS LRECL(4160) CATALOG RELEASE"
 IF ISPFIND = 1  & CMD = 'R' THEN DO
  CMD = ''
  SIGNAL DOREVISE
  END
DOALOC2:
 ADDRESS TSO "ALLOC FI(ALCSDSF) DA('"MYSDSN"') "XPRM
 IF RC ^= 0 THEN SIGNAL EXITRC12
 ADDRESS TSO "FREE FI(ALCSDSF)"
 SIGNAL OFF ERROR
 GDGV=CPUSEL||GDGV
 ADDRESS ISPEXEC
 "ISPEXEC VPUT (MYSDSN GDGV) ASIS"
 "ISPEXEC EDIT DATASET('TTED.TSK.P.TCEM.CNTL(SDMPGDG)') MACRO(MYSDGMAC)"
 IF RC > 4 THEN SIGNAL EXITRC8
 EXITRC0:
  IF ISPFIND = 1 THEN  SIGNAL EXITIT
  SAY 'EXEC ENDING.'
  SIGNAL EXITIT
 DOREVISE:
  IF ISPFIND = 1 THEN DO
   SIGNAL OFF ERROR
   DSEMSG='ENTER ALTERNATE DSN'
   MYVERB='ABORT CANCEL'
    EDSN = MYSDSN
    ADDRESS ISPEXEC 'VPUT (MYVERB DSEMSG EDSN) ASIS'
    CALL DSNWIND
    XC = RESULT
    ADDRESS ISPEXEC 'VGET (EDSN MYVERB) ASIS'
    IF RC ^= 0 THEN SIGNAL EXITRC8
    IF MYVERB = 'ABORT' | MYVERB = 'CANCEL' THEN SIGNAL EXITRC8
    IF XC > 4 THEN SIGNAL EXITRC8
   MYSDSN=EDSN
   SIGNAL DOALOC2
   END
  SIGNAL EXITRC8
 EXITRC4:
  SAY 'ABORT SELECTED. BYE'
  SIGNAL EXITIT
 EXITRC8:
  SAY 'ERROR CONDITION OR INVALID SELECTION CAUSES EXEC ABORT'
  SIGNAL EXITIT
 EXITRC12:
  SAY 'ALLOCATION ERROR. DATASET COULD NOT BE ALLOCATED. ABORT EXEC'
  SIGNAL EXITIT
 CANCEL8:
  SAY "CANCEL OR PF3, ABORTING PROCESS"
  SIGNAL EXITIT
 EXITIT:
  IF ISPFIND = 1 THEN  "ISPEXEC REMPOP"
  EXIT
###END SDMPGDG
$$$BEG EXPLSDSF
/* REXX*/                                                               00010000
/* example to use rex to issue sdsf xdc (print job to ds) */            00011000
rc=isfcalls("ON")                                                       00020000
isfowner = 'D96CLW1'                                                    00030000
isffilter = 'JNAME EQ DEALLOC'                                          00040000
Address SDSF 'ISFEXEC ST'                                               00050000
Do ix=1 to jobid.0                                                      00060000
isfprtdsname = 'MY.DATASET.NAME'                                        00070000
isfprtmember = jobid.ix                                                 00080000
isfprtdisp = 'OLD'                                                      00090000
Address SDSF "ISFACT ST TOKEN('"token.ix"') PARM(NP XDC)"               00100000
If rc>0 Then                                                            00101001
Do                                                                      00102001
Say 'RC='rc isfmsg                                                      00103001
Do jx=1 to isfmsg2.0                                                    00104001
Say isfmsg2.jx                                                          00105001
End                                                                     00106001
End                                                                     00107001
End                                                                     00110000
rc=isfcalls("OFF")                                                      00120000
###END EXPLSDSF
$$$BEG FSATEST
  /* REXX */
  TRACE I
  M='TTED.TSK.FILESRCS.R400M00.CLIST'
 "ALTLIB DISPLAY"
 "ALLOC FI(SYSUPROC) "||,
   "DA('"M"') SHR REUSE"
 "ALTLIB ACTIVATE USER(CLIST)"
 "ALTLIB DISPLAY"
 ADDRESS ISPEXEC
 "ISPEXEC SELECT CMD(FSAFRAME) NEWAPPL(FRCS) PASSLIB"
/*      */
PROC 0 PGM() CP() PARM() SKEL()                                         00010000
 /* COPY FROM  PROD.CICS.ISPCLIB(FSAFRAME) AS OF 20140108 */
 /* IF &SYSUID = TJCC OR &SYSUID = TCEM THEN + */
 IF &SYSUID = TCEM THEN +
      CONTROL MSG SYMLIST CONLIST LIST NOFLUSH
      ELSE CONTROL NOMSG NOSYMLIST NOCONLIST NOLIST NOFLUSH             00170600
/* R400M02 CHANGES FOR VERSION MOD M02   */
/* REPLACE 'PROD.CICS.ISPCLIB(FSAFRAME)' */
WRITE STARTING FSAFRAME USING R400M02 MODIFICATIONS
ATTN +                                                                  00020100
 DO                                                                     00020200
 WRITE ATTN KEY PRESSED. ABORTING EXECUTION.                            00020300
 RETURN CODE(20)                                                        00020400
 END                                                                    00020500
ERROR +                                                                 00020600
 DO                                                                     00020700
 WRITE ERROR IN EXECUTION. ENDING.                                      00020800
 GOTO EXIT16                                                            00020400
 END                                                                    00021000
/*    CHANGE THIS BEFORE MIGRATION !!!!!!!!!!!!! */
/*  MAINTAIN CURRENT RELEASES. FIRST IS DEFAULT  */
SET FSARELS=&STR(R360M03,R400M00,R400M02)
/*    CHANGE THIS BEFORE MIGRATION !!!!!!!!!!!!! */
SET FSARELSS= &STR()                                                    00170400
SET WGETRESP=0                                                          00170000
SET SETONCE=0                                                           00170000
SET FSACPU = &STR()                                                     00170100
SET FSACPUU= &STR()                                                     00170200
SET FSATYPP= &STR()                                                     00170300
SET FSAKSEL= &STR()                                                     00170400
SET FILESTEP=&STR()
SET FILESTP0=&STR()
SET GTBJCLIN=&STR()     /* ADDED 2003/03/20 R400M02 */
                        /*  TO SET THE SKELPDS VAR TO CORRECT VER  */
SET FSALIAS =&STR()
SET JCSPRM =&STR()
SET JCSSEC =&STR()
ISPEXEC CONTROL ERRORS RETURN                                           00170410
ISPEXEC VPUT (SETONCE FSARELS FILESTEP FILESTP0 FSALIAS) SHARED         00170500
ISPEXEC VPUT (JCSPRM JCSSEC) SHARED                                     00170500
ISPEXEC VPUT (WGETRESP FSACPU FSACPUU FSATYPP FSARELSS FSAKSEL) ASIS    00170500
/* IF &SYSUID = TCEM THEN  SET &MYISPC=TTED.TSK.FILESRCS.R400M00.CLIST*/
/*    ELSE SET MYISPC=PROD.CICS.ISPCLIB */                              00170600
SET MYISPC=PROD.CICS.ISPCLIB                                            00170600
EXEC '&MYISPC(FSAGETEV)'                                                00170600
/* WRITE &LASTCC */                                                     00170610
ISPEXEC VGET (WGETRESP FSACPU FSACPUU FSATYPP FSARELSS FSAKSEL) ASIS    00170500
IF &LASTCC > 0 THEN DO                                                  00170800
      WRITE ERRORS RETRIEVING FSA FRAME ISPF VARS RC(24)                00170900
      EXIT CODE(24)                                                     00171000
      END                                                               00171100
ISPEXEC VGET (FILESTEP FILESTP0 FSALIAS) SHARED                         00170500
IF &LASTCC > 0 THEN DO                                                  00170800
      WRITE ERRORS RETRIEVING FSA FRAME ISPF VARS RC(23)                00170900
      EXIT CODE(23)                                                     00171000
      END                                                               00171100
IF (&FSALIAS EQ &STR()) THEN DO
        SET FSALIAS=TTEP.TSK.F.TSK.FILESRCS.&FSARELSS
      END
SET FNDSTR = &SYSINDEX(FILESRCS,&FSALIAS)
IF FNDSTR ^= 0 THEN DO
 SET FSALIAS = &SUBSTR(1:(&FNDSTR+8),&FSALIAS)&FSARELSS
 END
SET FSACLIST=&FSALIAS..JCLLIB
ISPEXEC VPUT (FSACLIST) ASIS
LISTDSI '&FSACLIST' NODIR NORECALL
IF (&LASTCC NE 0) THEN DO
      WRITE INVAL FSA CLIST LIB MISSING FOR &FSARELSS                   00170900
      EXIT CODE(22)                                                     00171000
      END                                                               00171100
EXEC '&FSACLIST(TESTREL)'                                               00170600
/* EXEC 'TTED.TSK.FILESRCS.R400M00.JCLLIB(TESTREL)' */                  00170600
ISPEXEC VGET (TESTREL#) ASIS                                            00170700
  IF &LASTCC ^= 0 THEN DO
      WRITE CALL TO TESTREL RETURNED ERROR CODE &LASTCC                 00170900
      EXIT CODE(21)                                                     00171000
      END                                                               00171100
IF (&FSARELSS NE &TESTREL#) THEN DO
      WRITE INVAL REL END &FSARELSS NE &TESTREL#                        00170900
      EXIT CODE(21)                                                     00171000
      END                                                               00171100
  ISPEXEC VGET (FSALIBS)
  IF &LASTCC ^= 0 THEN DO
      WRITE CALL TO TESTREL FAILED ISPF VARS FSALIBS                    00170900
      EXIT CODE(21)                                                     00171000
      END                                                               00171100
  WRITE FSALIBS:: &FSALIBS
  ISPEXEC VGET (&FSALIBS)
  SET FSALIBS = &FSALIBS&STR( )
  SET FSALNG = &LENGTH(&STR(&FSALIBS))
  SET SPPOS = 1
  DO WHILE (&SPPOS < &FSALNG)
   SET FPOS = &SPPOS
   SET SPPOS = &SYSINDEX(&STR( ),&FSALIBS,&FPOS)
   IF SPPOS = 0 THEN SET SPPOS = &FSALNG
   SET TMPLNG = &SPPOS - 1
   SET MYTMP = &SUBSTR(&FPOS:&TMPLNG,&FSALIBS)
   SET MZTMP = &&&MYTMP
   WRITE &MYTMP &MZTMP
   SET SPPOS = &SPPOS + 1
   END
WRITE &WGETRESP &FSACPU &FSACPUU &FSATYPP &FSARELSS                     00171110
IF (&WGETRESP NE 0) THEN DO
      WRITE RESP CANCEL RC>&WGETRESP.<                                  00170900
      EXIT CODE(&WGETRESP)                                              00171000
      END                                                               00171100
/* SET GTBJCLIN=&FSALIAS..SKELPDS  */
/* ISPEXEC VPUT (GTBJCLIN) ASIS    */
/*  IF THE RELEASE IS R360M03, THEN BYPASS THE FOLLOWING */
IF &FSARELSX NE R360M03 THEN DO
 IF (&FSALIAS EQ &STR()) THEN DO
  SET FSALIAS=TTED.TSK.FILESRCS.&FSARELSS
  SET FILESTEP=&FSALIAS..LOADLIB
  SET FILESTP0=&FILESTEP.&FSACPUU
  END
/* SET FSAPANEL=&ISPPLIB */
 ISPEXEC VPUT (FSALIAS FILESTEP FILESTP0) SHARED
 FREE FI(SYSUPROC)
 ALLOC FI(SYSUPROC) DA('&FSACLIST') SHR
 ALTLIB ACTIVATE USER(CLIST)
 SET MDSN=&FSAPANEL
 ISPEXEC LIBDEF ISPPLIB DATASET ID('&MDSN') UNCOND STACK
 IF (&LASTCC NE 0) THEN DO
      WRITE ISPPLIB LIBDEF FAILED                                       00170900
      EXIT CODE(20)                                                     00171000
      END                                                               00171100
 ISPEXEC SELECT PANEL(RCSPRIME)
 END
 ELSE DO                                                                00171100
 /* R360M03 LOGIC HERE */
 ISPEXEC SELECT PANEL(RCSPRIME)
 END
/*                                                       */
/*                                                       */
/* *** RUN THIS FOR ALL RELEASES                         */
/* ISPEXEC SELECT PANEL(RCSPRIME) NEWAPPL(FRCS) PASSLIB  */
/*                                                       */
/*  IF THE RELEASE IS R360M03, THEN BYPASS THE FOLLOWING */
IF &FSARELSS NE R360M03 THEN DO
 ALTLIB DEACTIVATE USER(CLIST)
 FREE FI(SYSUPROC)
 END
ISPEXEC LIBDEF ISPLLIB
ISPEXEC LIBDEF ISPMLIB
ISPEXEC LIBDEF ISPSLIB
ISPEXEC LIBDEF ISPTLIB
ISPEXEC LIBDEF ISPPLIB
FREE F(RCSTABLE)                                      /* CHANGE 1 */
FREE F(FSLOAD)
FREE F(FSTLIB)
FREE F(FSMLIB)
FREE F(FSPLIB)
FREE F(FSSLIB)
FREE F(JCSPRIME)
FREE F(JCSECOND)
 EXIT CODE(&LASTCC)
/*                                                       */
EXIT16:+
EXIT CODE(16)                                                           00171200
*/
###END FSATEST
$$$BEG EXPLGCPU
  /* REXX */
  TRACE I
  ADDRESS TSO
  SC = MVSVAR('SYSCLONE')
  SN = MVSVAR('SYSNAME')
  SP = MVSVAR('SYSPLEX')
  OMVS='OMVS'
  SD = MVSVAR('SYMDEF','OMVS')
  'GETKREL ???'
  PULL EO
  'GETCPU1 <PUSH>'
  PULL CURGRP CURCPUG
  'GETCPU1 <'SC'>'
  PULL CURGRP CURCPUG
  ADDRESS ISPEXEC
  'GETCPU1 <PUSH>'
  PULL CURGRP CURCPUG
  ADDRESS TSO 'GETCPU1 <PUSH>'
  PULL CURGRP CURCPUG
  CALL GETCPU1 '<PUSH>'
  PULL CURGRP CURCPUG
  CURCPU=''         /* RETURNS 1 CHAR CPU */
  CURGRP=''         /* RETURNS GRPX 4 CHAR PLEX PREFIX */
  CURCPUG=''        /* RETURNS GRPX CLUSTER OF ASSOCIATED CPUS */
  CALL GETCPU1
  "ISPEXEC VGET (CURCPU,CURGRP,CURCPUG) PROFILE"
  SAY CURCPU CURGRP CURCPUG
 ADDRESS ISPEXEC
  CURCPU=''         /* RETURNS 1 CHAR CPU */
  CURGRP=''         /* RETURNS GRPX 4 CHAR PLEX PREFIX */
  CURCPUG=''        /* RETURNS GRPX CLUSTER OF ASSOCIATED CPUS */
  "ISPEXEC VPUT (CURCPU,CURGRP,CURCPUG) PROFILE"
  CALL GETCPU1
 "ISPEXEC  VGET (CURCPU CURGRP CURCPUG) PROFILE"
 XC=RC
 SAY CURCPU CURGRP CURCPUG
 IF XC ^= 0 THEN DO
  CALL GETCPU1
  ADDRESS ISPEXEC "VGET (CURCPU CURGRP CURCPUG) PROFILE"
  END
 IF CURGRP = '????' THEN SIGNAL NOTCPU
 SAY 'OR'
 GRP = 'I'
 CALL CVTCPU
 EXIT
NOTCPU:
 SAY GRP ' IS NOT FOUND AS A CPUGRP'
 CVTCPU: PROCEDURE EXPOSE GRP
  CALL GETCPU1 GRP
  IF RESULT ^= 0 THEN GRP='???'
   ELSE DO
    ADDRESS ISPEXEC 'VGET (CVTDGRP) ASIS'
    IF RC ^= 0 THEN GRP='???'
     ELSE GRP=CVTDGRP
    END
   RETURN 0
###END EXPLGCPU
$$$BEG FSAGETE$
  /* REXX */
  /* REPLACE 'PROD.CICS.ISPCLIB(FSAGETEV)' */
  SIGNAL ON HALT NAME ATTNEXIT
  ADDRESS TSO
 /* IF SYSVAR(SYSUID) = 'TCEM' | SYSVAR(SYSUID) = 'TJCC' THEN TRACE I */
  IF SYSVAR(SYSUID) = 'TCEM' THEN TRACE I
   A = 'TTED.TSK.P.TCEM.CLIST'
  "ALLOC FI(SYSUPROC) DA('"A"') SHR REUSE"
  "ALTLIB ACTIVATE USER(CLIST)"
  CALL GETKREL '???'
  PULL KIXRELN KIXRSTR
  IF KIXRELN = '' | KIXRSTR = '' THEN DO
   XC=19
   SIGNAL BADSTRT
   END
  KIXRSEL=WORD(KIXRSTR,1)
  IF KIXRELN > 1 THEN DO
   ATTRTYP = 'INPUT'
   ATTRSKP = 'OFF'
   END
   ELSE DO
   ATTRTYP = 'OUTPUT'
   ATTRSKP = 'ON'
   END
  ADDRESS ISPEXEC
 "ISPEXEC VGET (WGETRESP FSACPU FSACPUU FSATYPP FSARELSS FSAKSEL) ASIS"
 "ISPEXEC VGET (FSTABL) SHARED"
 "ISPEXEC VGET (FSARELS FILESTEP FILESTP0 FSALIAS JCSPRM JCSSEC) SHARED"
  IF RC > 0 THEN DO
   XC=20
   SIGNAL BADSTRT
   END
  WGETRESP = 16
  CALL GETCPU1
  "ISPEXEC VGET (CURCPU CURGRP CURCPUG) PROFILE"
  IF RC ^= 0 THEN DO
   XC=20
   SIGNAL BADCPUG
   END
  IF CURGRP = '????' THEN SIGNAL NOTCPU
  FSACPU=CURCPU
  FSACPUG=''
  FL=LENGTH(CURCPUG)
  DO I = FL TO 1 BY -1
   FSACPUG=','||SUBSTR(CURCPUG,I,1)||FSACPUG
   END
  SUDT=DATE('U')
  STIM=TIME()
  FSACPUG=SUBSTR(FSACPUG,2)
  FSATYP='D,T,A,P'
  FSACPUU=''
  FSATYPP=''
  FSARELSS=''
  FSAKSEL=''
  EXECSEL='WGETENV'
  DSEMSG = 'ENTER ALL INFORMATION OR CANCEL'
  IF SYSVAR(SYSUID) = 'TCEM' THEN DO
    MYISPP='TTED.TSK.FILESRCS.R400M00.CLIST'
    END
    ELSE DO
    MYISPP='PROD.CICS.ISPPLIB'
    END
  "ISPEXEC LIBDEF ISPPLIB DATASET ID('"MYISPP"') STACK"
   IF RC ^= 0 THEN SIGNAL EXITRC4
  "ISPEXEC ADDPOP ROW(1) COLUMN(10)"
  'ISPEXEC DISPLAY PANEL(FSAGETED)'
  XC = RC
  'ISPEXEC REMPOP'
  "ISPEXEC LIBDEF ISPPLIB DATASET ID()"
   IF RC ^= 0 THEN SIGNAL EXITRC4
  IF ZCMD = 'CANCEL' | ZCMD = 'ABORT' THEN SIGNAL CANIT
  IF XC ^= 0 THEN SIGNAL EXITRC4
  FSAKSEL=SUBSTR(KIXRSEL,1,2)
  IF FSATYPP = 'D' THEN FSACTYP='D'
   ELSE FSACTYP='P'
  MYJCL='S'||FSAKSEL||FSACTYP||'ARCH'
  CALL JCLSYMX MYJCL
  PULL JCLDATA
  HJCLDATA=JCLDATA
  FNDSW=0  /* THIS MUST EQUAL 3, ONE FOR EACH SYMBOL */
           /* ARCH, JCSP, JCSS                       */
  HLDLN=LENGTH(HJCLDATA)
 TOPOFLOP:
   IF HJCLDATA = '' THEN SIGNAL FINIT
   PARSE VAR HJCLDATA SYMN '\' SYMD '\' HJCLDATA
   IF LENGTH(HJCLDATA) = HLDLN THEN SIGNAL SYMBERR
   HLDLN=LENGTH(HJCLDATA)
   IF SYMN = 'ARCH' THEN DO
    FILESTEP=SYMD
    FSALIAS=SUBSTR(SYMD,1,(LASTPOS('.',SYMD)-1))
    IF SUBSTR(SYMD,1,4) = 'TTED' THEN DO
     FSTABL=SUBSTR(SYMD,1,(LASTPOS('.',SYMD)-1))
     END
     ELSE DO
    FSTABL=SUBSTR(SYMD,1,9)||'P'||SUBSTR(SYMD,11,(LASTPOS('.',SYMD)-11))
     END
    FNDSW=FNDSW+1
    SIGNAL TOPOFLOP
    END
   IF SYMN = 'JCSP' THEN DO
    SYMD=OVERLAY(FSACPUU,SYMD,LENGTH(SYMD),1)
    JCSPRM=SYMD
    FNDSW=FNDSW+1
    SIGNAL TOPOFLOP
    END
   IF SYMN = 'JCSS' THEN DO
    SYMD=OVERLAY(FSACPUU,SYMD,LENGTH(SYMD),1)
    JCSSEC=SYMD
    FNDSW=FNDSW+1
    SIGNAL TOPOFLOP
    END
   SIGNAL TOPOFLOP
 CHKDONE:
   IF FNDSW ^= 4 THEN SIGNAL ARCHERR
 FINIT:
   ZEDSMSG = 'EXIT RC 0'
   ZEDLMSG = 'EXIT WITH RC 0'
   XC = 0
   WGETRESP = 0
   SIGNAL WRITIT
  ARCHERR:
   ZEDSMSG = 'ARCH ERROR! RC 14'
   ZEDLMSG = 'ARCH ERROR. JCL NOT FOUND. RC 14'
   WGETRESP = 14
   XC = 14
   SIGNAL WRITIT
  SYMBERR:
   ZEDSMSG = 'SET ERROR! RC 14'
   ZEDLMSG = 'SET MEMBER  ERROR. JCL NOT FOUND. RC 14'
   WGETRESP = 14
   XC = 14
   SIGNAL WRITIT
  CANIT:
   ZEDSMSG = 'CANCEL RC8'
   ZEDLMSG = 'EXIT WITH CANCEL, RC 8'
   WGETRESP = 8
   XC = 8
   SIGNAL WRITIT
  ATTNEXIT:
   ZEDSMSG = 'ATTN RC20'
   ZEDLMSG = 'EXIT WITH ATTN, RC 20'
   WGETRESP = 20
   XC = 20
   SIGNAL WRITIT
  EXITRC4:
   ZEDSMSG = 'EXIT RC 4'
   ZEDLMSG = 'EXIT WITH RC 4'
   WGETRESP = 4
   XC = 4
   SIGNAL WRITIT
  BADSTRT:
   ZEDSMSG = 'EXIT RC 'XC
   ZEDLMSG = 'EXIT WITH RC 'XC
   WGETRESP = XC
  "ALTLIB RESET"
   SIGNAL WRITIT
 BADCPUG:
   ZEDSMSG = 'CPUG UNKNOWN'
   ZEDLMSG = 'CPU GROUP UNKNOWN: ABORTED'
   WGETRESP = 12
   XC = 12
   SIGNAL WRITIT
 NOTCPU:
   ZEDSMSG = 'CPU UNKNOWN'
   ZEDLMSG = 'CPU IS UNKNOWN: ABORTED'
   WGETRESP = 12
   XC = 12
 WRITIT:
   'ISPEXEC SETMSG MSG(ISRZ000)'
 "ISPEXEC VPUT (WGETRESP FSACPU FSACPUU FSATYPP FSARELSS FSAKSEL) ASIS"
 "ISPEXEC VPUT (FSTABL) SHARED"
 "ISPEXEC VPUT (FSACTYP FILESTEP FILESTP0 FSALIAS JCSPRM JCSSEC) SHARED"
   IF RC ^= 0 THEN RETURN 20
   RETURN XC
###END FSAGETE$
$$$BEG GETCPU1
/* REXX */
/* USE GETCPU1 <PUSH>                                       *\
|*     IN ORDER TO INDICATE THAT TSO PUSH STACK IS EXPECTED *|
\*     AS THE RETURN METHOD, NOT ISPF VARS                  */
/* TRACE I */
/* TRACE ?I*/
 ARG GRP
 IF SYSVAR(SYSISPF) = 'ACTIVE' THEN ISPFIND = 1
  ELSE ISPFIND = 0
MYPLEX = SUBSTR(MVSVAR('SYSPLEX'),1,4)
MYCCPU = MVSVAR('SYSNAME')
ARGIND=0
IF GRP \= '' THEN DO
 IF SUBSTR(GRP,1,1) = '<' THEN DO
  ISPFIND=0
  PARSE VAR GRP TMP '<' GRP '>' .
  IF TMP^='' THEN GRP=TMP
  IF GRP = '' THEN  ARGIND=0
   ELSE DO
    IF GRP = 'PUSH' THEN GRP=MYCCPU
    ARGIND=1
    END
  END
  ELSE ARGIND=1
 IF LENGTH(GRP) = 1 THEN GRP=GRP||'SYS'
 END
 IF ARGIND = 0 THEN GRP=MYCCPU
CURCPU=''
 SELECT;
  WHEN GRP = 'CSYS' THEN DO
                         CURGRP='GRP5'
                         SIGNAL OKCPU
                         END
  WHEN GRP = 'ASYS' THEN DO
                         CURGRP='GRP5'
                         SIGNAL OKCPU
                         END
  WHEN GRP = 'ESYS' THEN DO
                         CURGRP='GRP2'
                         SIGNAL OKCPU
                         END
  WHEN GRP = 'DSYS' THEN DO
                         CURGRP='GRP2'
                         SIGNAL OKCPU
                         END
  WHEN GRP = 'GSYS' THEN DO
                         CURGRP='GRP3'
                         SIGNAL OKCPU
                         END
  WHEN GRP = 'HSYS' THEN DO
                         CURGRP='GRP2'
                         SIGNAL OKCPU
                         END
  WHEN GRP = 'ISYS' THEN DO
                         CURGRP='GRP3'
                         SIGNAL OKCPU
                         END
  WHEN GRP = 'SSYS' THEN DO
                         CURGRP='GRP2'
                         SIGNAL OKCPU
                         END
  WHEN GRP = 'USYS' THEN DO
                         CURGRP='GRP4'
                         SIGNAL OKCPU
                         END
  WHEN GRP = 'VSYS' THEN DO
                         CURGRP='GRP4'
                         SIGNAL OKCPU
                         END
  WHEN GRP = 'JSYS' THEN DO
                         CURGRP='GRP2'
                         SIGNAL OKCPU
                         END
  WHEN GRP = 'PSYS' THEN DO
                         CURGRP='GRPV'
                         SIGNAL OKCPU
                         END
  WHEN GRP = 'P133' THEN DO
                         CURGRP='GRPV'
                         CURCPU = 'PSYS'
                         SIGNAL OKCPU
                         END
  WHEN GRP = 'MSYS' THEN DO
                         CURGRP='GRPV'
                         SIGNAL OKCPU
                         END
  WHEN GRP = 'M133' THEN DO
                         CURGRP='GRPV'
                         CURCPU = 'MSYS'
                         SIGNAL OKCPU
                         END
  WHEN GRP = 'RSYS' THEN DO
                         CURGRP='GRPV'
                         SIGNAL OKCPU
                         END
  WHEN GRP = 'R133' THEN DO
                         CURGRP='GRPV'
                         CURCPU = 'RSYS'
                         SIGNAL OKCPU
                         END
  WHEN GRP = 'GRP1' | GRP = '1SYS' THEN DO
                         CURGRP='GRP1'
                         SIGNAL OKCPU
                         END
  WHEN GRP = 'GRP2' | GRP = '2SYS' THEN DO
                         CURGRP='GRP2'
                         SIGNAL OKCPU
                         END
  WHEN GRP = 'GRP3' | GRP = '3SYS' THEN DO
                         CURGRP='GRP3'
                         SIGNAL OKCPU
                         END
  WHEN GRP = 'GRP4' | GRP = '4SYS' THEN DO
                         CURGRP='GRP4'
                         SIGNAL OKCPU
                         END
  WHEN GRP = 'GRP5' | GRP = '5SYS' THEN DO
                         CURGRP='GRP5'
                         SIGNAL OKCPU
                         END
  WHEN GRP = 'GRPV' | GRP = 'GRPT' THEN DO
                         CURGRP='GRPV'
                         SIGNAL OKCPU
                         END
  WHEN GRP = 'CPCT' THEN DO
                         CURGRP='GRPV'
                         SIGNAL OKCPU
                         END
  WHEN GRP = 'GY2V' THEN DO
                         CURGRP='GY2V'
                         SIGNAL OKCPU
                         END
  WHEN GRP = 'GY2W' THEN DO
                         CURGRP='GY2W'
                         SIGNAL OKCPU
                         END
  WHEN GRP = 'WSYS' THEN DO
                         CURGRP='GY2W'
                         SIGNAL OKCPU
                         END
  WHEN GRP = 'TSYS' THEN DO
                         CURGRP='GRP2'
                         SIGNAL OKCPU
                         END
  WHEN GRP = 'FSYS' THEN DO
                         CURGRP='GRP2'
                         SIGNAL OKCPU
                         END
  WHEN GRP = 'XSYS' THEN DO
                         CURGRP='GRP1'
                         SIGNAL OKCPU
                         END
  WHEN GRP = 'YSYS' THEN DO
                         CURGRP='GRP1'
                         SIGNAL OKCPU
                         END
  WHEN GRP = 'ZSYS' THEN DO
                         CURGRP='GRP2'
                         SIGNAL OKCPU
                         END
  WHEN GRP = '15A6' THEN DO
                         CURGRP='GRP2'
                         CURCPU = 'TSYS'
                         SIGNAL OKCPU
                         END
  WHEN GRP = '16A6' THEN DO
                         CURGRP='GRP2'
                         CURCPU = 'TSYS'
                         SIGNAL OKCPU
                         END
  WHEN GRP = 'K390' THEN DO
                         CURGRP='GRPV'
                         CURCPU = 'KSYS'
                         SIGNAL OKCPU
                         END
  OTHERWISE CURGRP='????'
  END
OKCPU:
 SELECT
 WHEN CURGRP = 'GRP1' THEN CURCPUG = 'XY'
 WHEN CURGRP = 'GRP2' THEN CURCPUG = 'DEFHJSZ'
 WHEN CURGRP = 'GRP3' THEN CURCPUG = 'GI'
 WHEN CURGRP = 'GRP4' THEN CURCPUG = 'UV'
 WHEN CURGRP = 'GRP5' THEN CURCPUG = 'AC'
 WHEN CURGRP = 'GRPV' THEN CURCPUG = 'JMPR'
 WHEN CURGRP = 'GY2W' THEN CURCPUG = 'W'
 OTHERWISE CURCPUG = ''
 END
 /* TRACE I */
 CURCPU=SUBSTR(MYCCPU,1,1)
 IF ARGIND = 0 THEN DO
  IF ISPFIND = 1 THEN,
  "ISPEXEC VPUT (CURCPU,CURGRP,CURCPUG) PROFILE"
   ELSE PUSH CURCPU CURGRP CURCPUG
  END
 ELSE DO
  CVTDGRP = CURGRP
  CVTDGRPC= CURCPUG
  IF ISPFIND = 1 THEN,
   "ISPEXEC VPUT (CVTDGRP CVTDGRPC) SHARED"
   ELSE PUSH CVTDGRP CVTDGRPC
  END
RETURN 0
###END GETCPU1
$$$BEG OSHELL
/* REXX */
parse arg shellcmd
username =,
TRANSLATE(userid(),'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVW
/********************************************************************/
/* Free STDERR just in case it was left allocated                   */
/********************************************************************/
/*                                                                  */
msgs = msg('OFF')
"FREE DDNAME(STDERR)"
/********************************************************************/
"ALLOCATE FILE(STDOUT) PATH('/tmp/"username"."time('L')".IBM') ",
"PATHOPTS(OWRONLY,OCREAT,OEXCL,OTRUNC) PATHMODE(SIRWXU)",
"PATHDISP(DELETE,DELETE)"
IF RC = 0 Then
  DO
    "FREE DDNAME(STDOUT)"
    "ALLOCATE FILE(STDOUT) PATH('/tmp/"username"."time('L')".IBM') ",
    "PATHOPTS(OWRONLY,OCREAT,OEXCL,OTRUNC) PATHMODE(SIRWXU)",
    "PATHDISP(DELETE,DELETE)"
    IF RC = 0 Then
      DO
        msgs = msg(msgs)
        /* Allocate must have failed */
        Say ' This REXX exec failed to allocate STDOUT.'
        Say ' This REXX exec did not run shell command ' shellcmd
        RETURN
      END
  END
msgs = msg(msgs)
"BPXBATCH SH "shellcmd
IF RC = 0 Then
   DO
     Say ' RC = ' RC
     Say ' '
   END
IF RC > 255 Then
   DO
     Say ' Exit Status = ' RC/256
     Say ' '
   END
IF (RC = 254) & (RC = 255) THEN
   DO
     "ALLOCATE FILE(out1) DA(*) LRECL(255) RECFM(F) REUSE"
     "OCOPY indd(STDOUT) outdd(out1) TEXT PATHOPTS(OVERRIDE)"
     "FREE DDNAME(out1)"
   END
"FREE DDNAME(STDOUT)"
###END OSHELL
$$$BEG FAIDSRCH
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA FAIDSRCH - PERFORM FILEAID SEARCH ON SOURCE DATASET     */
 /* CEMHELP FAIDSRCH - TSO BASE, EXEC REQUIRES TWO PARMS AND HAS    */
 /* CEMHELP          - OPTIONAL THIRD PARM.  FIRST PARM MUST BE THE */
 /* CEMHELP          - SOURCE DSN TO BE SEARCHED.  THE SECOND PARM  */
 /* CEMHELP          - MUST BE THE SEARCH FOR STRING IN FORMAT:     */
 /* CEMHELP          - "STR" OR 'STR' OR STR WILL DEFAULT CHAR SRCH */
 /* CEMHELP          - C"STR" C'STR' WILL DO CHAR SEARCH (REMEMBER  */
 /* CEMHELP          -   FILEAID SYNTAX FOR IF=( PARAMETER)         */
 /* CEMHELP          - X"STR" X'STR' WILL DO CHAR SEARCH (REMEMBER  */
 /* CEMHELP          -   FILEAID SYNTAX FOR IF=( PARAMETER)         */
 /* CEMHELP          - ANY OF ABOVE CAN BE ENCAPSULATED IN A PAIR   */
 /* CEMHELP          -   OF <S4STR> BRACKETS                        */
 /* CEMHELP          - OR <> DENOTES THAT A SRCHSTR ISPF VARIABLE   */
 /* CEMHELP          -   WILL CONTAIN THE ACTUAL SEARCH STRING.     */
 /* CEMHELP          - THE OPTIONAL THIRD PARM SPECIFIES WHAT TO DO */
 /* CEMHELP          - WITH THE RESULTS.  IF THE FIELD IS OMITTED,  */
 /* CEMHELP          - THEN THE RESULT IS DISPLAYED ON A PANEL.     */
 /* CEMHELP          - THE PANEL CONTAINS THE INTERPRETED RESULTS   */
 /* CEMHELP          - OF THE SEARCH.  THE ACTUAL SYSPRINT FROM     */
 /* CEMHELP          - FILEAID IS UNIQUE AND IS AVAILABLE TO YOU    */
 /* CEMHELP          - UNTIL THE EXEC FINISHES (THEN DSN DELETED).  */
 /* CEMHELP          - THE SECOND FORM FOR THE THIRD PARM IS TO     */
 /* CEMHELP          - PROVIDE A DSN TO RECEIVE THE FILEAID SYSPRINT*/
 /* CEMHELP          - FOR YOUR OWN USE.  THE DSN WILL BE DELETED/  */
 /* CEMHELP          - CREATED AS REQUIRED. USER CAN USE THE DSN    */
 /* CEMHELP          - AS THEY DETERMINE.                           */
 /* CEMHELP          - THE FINAL FORM FOR THE THIRD PARM ALLOWS YOU */
 /* CEMHELP          - TO SPECIFY THAT ONLY A LIST OF WORDS BE PASSD*/
 /* CEMHELP          - BACK TO YOU.  THE FORMAT IS A LEGAL 1 - 8    */
 /* CEMHELP          - CHAR VARIABLE NAME.  IF YOUR SECOND PARM HAD */
 /* CEMHELP          - PASSED A REXX ARG, THEN THE RESULTS ARE      */
 /* CEMHELP          - RETURNED TO YOU AS A 'PULL'ABLE VARIABLE. THE*/
 /* CEMHELP          - NAME YOU PROVIDED IS REALLY ONLY A INDICATOR */
 /* CEMHELP          - TO PASS A REXX VAR.  IF THE SECOND PARM WAS  */
 /* CEMHELP          - IN THE <> FORMAT SPECIFYING A SEARCH STRING  */
 /* CEMHELP          - WAS IN THE SRCHSTR ISPF VARIABLE, THEN THE   */
 /* CEMHELP          - RESULTANT MEMBER LIST WILL BE RETURNED TO YOU*/
 /* CEMHELP          - VIA A ISPF VARIABLE NAMED BY THE THIRD PARM. */
 /* CEMHELP          - VALID RETURN CODES ARE:                      */
 /* CEMHELP          -  0 EVERY THING OK                            */
 /* CEMHELP          -  8 INVALID PARM                              */
 /* CEMHELP          -  12 SEVERE ERROR ENCOUNTERED                 */
 /* CEMHELP END                                                     */
 /* TTED.TSK.P.TCEM.CNTL */
  ARG SRCHSRC REST
  IF SRCHSRC = '' THEN RETURN 8
  IF REST = '' THEN RETURN 8
  ISPFIND=0
  /* SS1 WILL CONTAIN BOTH SEARCH ARG AND TGTDSN IF NOT WRAPPED IN *\
  |* <..> THE SRCHSTR AND TGTDSN WILL BE NULL.                     *|
  |* IF THE SS1 IS NULL THEN CHECK FOR SRCHSTR IN ISPF VAR IN THE  *|
  |* <..>  IF THE SRCHSTR TURNS OUT TO BE NULL, THEN WE DEFUALT THE*|
  |* ISPF SRCHSTR VAR TO SRCHSTR.  VGET THE SRCHSTR.               *|
  |* VARIABLE TGTDSN WILL INDICATE WHAT TO DO WITH THE OUTPUT:     *|
  |* IF OMITTED, THEN ASSUME THAT THE FAID RESULT IS TO BE DISPLAYD*|
  |*  BACK TO THE TERMINAL AS A MEMBER LIST OF HITS.               *|
  |* IF THE TGTDSN IS NOT NULL:                                    *|
  |* IF THE TGTDSN IS ENCLOSED IN <..> THEN TAKE THE CONTENTS BETWN*|
  |*  <> BRKTS,  AND USE IT AS A ISPFVAR NAME TO VGET THE TGTDSN.  *|
  |*  NOTE-MUST BE VALID 1-8 ISPFVAR NAME, OR EXEC WILL ABORT.     *|
  |*  NOTE-YOU CANNOT USE THE ISPFVAR FORMAT FOR TGTDSN, UNLESS THE*|
  |*       SRCHSTR IS ALSO IN ISPFVAR FORMAT. UNPREDITABLE RESULTS *|
  |*       WILL OCCUR IF NOT IN THIS ORDER.                        *|
  |*  NOTE-ONCE THE TGTDSN IS SUCCESSFULLY, VGET, WE THEN SUBJECT  *|
  |*       IT TO THE SAME QUERY AS IF IT WAS PASSED IN AS A REXX   *|
  |*       VAR. SEE BELOW.                                         *|
  |* IF THE TGTDSN IS NOT ENCLOSED IN <..> THEN IT IS A REXX VAR.  *|
  |* GET THE VAR LENGTH:  IF THE LENGTH IS GT 8 THE SEE NEXT.      *|
  |*  IF NOT GT 8  THEN ASSUME THAT VALUE IS TO BE USED AS AN      *|
  |*  INDICATOR THAT THE USER WANTS ONLY THE MEMBER LIST TO BE     *|
  |*  RETURNED AS A PUSHED VAR OR IN THE ISPFVAR (AS DETERMINED    *|
  |*  ABOVE).                                                      *|
  |* IF THE TGTDSN IS GT 8 THEN ASSUME THAT THE USER IS INDICATING *|
  |*  THAT THE COMPLETE FAID RESULTS SHOULD BE RETURNED TO THE USER*|
  |*  IN THE TGTDSN, FOR THEIR USE.                                *|
  |*  NOTE-THIS DSN WILL BE DELETED/CREATED AS REQUIRED.           *|
  \*                                                               */
  TMPVAR=''
  PARSE VAR REST SS1 '<' SRCHSTR '>' TGTDSN
  IF SS1 = '' THEN DO
   ISPFIND=1
   IF SRCHSTR = '' THEN SRCHSTR='FAIDSRCH'
   SS1VAL=SRCHSTR
   ADDRESS ISPEXEC "VGET ("SS1VAL") ASIS"
   IF RC ^= 0 THEN RETURN 8
   INTERPRET 'SRCHSTR='SS1VAL
   IF SRCHSTR = '' THEN RETURN 8
   IF TGTDSN='' THEN SIGNAL NOTGT
   PARSE VAR TGTDSN TGTDSN '<' TMPDSN '>'
   IF TGTDSN ^= '' THEN SIGNAL NOTGT
   ADDRESS ISPEXEC "VGET ("TMPDSN") ASIS"
   INTERPRET 'TMPVAR='TMPDSN
   IF TMPVAR='!LIST!' THEN TGTDSN=''
   ELSE TGTDSN = TMPVAR
   END
   ELSE SRCHSTR=SS1
 NOTGT:
 /* HERE SS1 IS NOT NULL */
  SS=SRCHSTR
  SS1=SUBSTR(SS,1,1)
  SSP=1
  IF SS1='"' THEN SIGNAL FNENDA
  IF SS1="'" THEN SIGNAL FNENDB
  SS1=SUBSTR(SS,1,2)
  SS1CAP=SS1
  UPPER SS1CAP
  SSP=2
  IF SS1CAP='C"' THEN SIGNAL FNENDA
  IF SS1CAP="C'" THEN SIGNAL FNENDB
  IF SS1CAP='X"' THEN SIGNAL FNENDA
  IF SS1CAP="X'" THEN SIGNAL FNENDB
  /* IF WE ARE HERE THAN SEARCH ARE IN SS1 IS NOT WRAPPED IN ' OR " *\
  |* SO WE ASSUME THAT SEARCH ARG IS ONE WORD.  THEN SS1 CAN CONTAIN*|
  |* EITHER 1 OR 2 WORDS (FIRST IS SEARCH ARG) AND OPTIONAL SECOND  *|
  \* IS THE TGTDSN VALUE.                                           */
  NW=WORDS(SS)
  IF NW=0 THEN RETURN 8
  SS1=''
  SSN=''
  SSP=0
  IF NW=1 THEN DO
   SRCHSTR=WORD(SS,1)
   TGTDSN=''
   SIGNAL DONESTR
   END
  TGTDSN=WORD(SS,NW)
  SRCHSTR=DELWORD(SRCHSTR,NW)
  SIGNAL DONESTR
 FNENDA:
  SSN='"'
  SIGNAL FNEND
 FNENDB:
  SSN="'"
  SIGNAL FNEND
 FNEND:
  SSLP=LASTPOS(SSN,SS)
  IF SSLP = 0 THEN RETURN 8
  SSL=LENGTH(SS)
  IF SSL = SSLP THEN DO
   TGTDSN=''
   SRCHSTR=SS
   SIGNAL DONESTR
   END
  TGTDSN=STRIP(SUBSTR(SS,SSLP+1),'B')
  SRCHSTR=SUBSTR(SS,1,SSLP)
 CHK4TGT:
  IF WORDS(TGTDSN) ^= 1 THEN RETURN 8
 DONESTR:
  QDT=''
  LSS=LENGTH(SRCHSRC)
  FPP=POS('(',SRCHSRC)
  DTFP=DATATYPE(SUBSTR(SRCHSRC,1,1))
  IF DTFP^='CHAR' THEN EXITRC8
  IF LSS<9 & FPP=0 THEN SIGNAL USEDDN
  F4C=SUBSTR(SRCHSRC,1,4)
  IF F4C='DDN(' | F4C='DSN(' THEN DO
   LPP=LASTPOS(')',SRCHSRC)
   IF LPP=0 | LPP < FPP THEN RETURN 8
   SRCHSRC=SUBSTR(SRCHSRC,4,LPP-5)
   IF SRCHSRC='' THEN RETURN 8
   IF F4C='DDN' THEN SIGNAL USEDDN
   END
  XC=LISTDSI("'"SRCHSRC"'" NODIRECTORY NORECALL)
  IF XC ^= 0 THEN RETURN 12
  "ALLOC FI(DD01) DA('"SRCHSRC"') SHR REUSE"
  IF RC ^= 0 THEN RETURN 12
  SIGNAL DOIT
 USEDDN:
  "ALLOC FI(DD01) DDNAME("SRCHSRC"') SHR REUSE"
  XC=LISTDSI(DD01 FILE NODIRECTORY NORECALL)
  IF XC ^= 0 THEN RETURN 12
 DOIT:
  TGTDSN=STRIP(TGTDSN,'B')
  IF DATATYPE(SUBSTR(TGTDSN,1,1)) ^= 'CHAR' THEN RETURN 8
  SUID=SYSVAR(SYSUID)
  LTD=LENGTH(TGTDSN)
  EDSN='FAIDSRCH.SYSIN'
  CALL GETUDSN EDSN
  IF RESULT ^= 0 THEN RETURN 12
  PULL EDSN
  IF LTD < 9 THEN DO
   PSP=POS('SYSIN',EDSN)
   ODSN=SUBSTR(EDSN,1,PSP-1)||'SYSPRINT'||SUBSTR(EDSN,PSP+5)
   END
   ELSE ODSN='%NQA%('||TGTDSN||')'
  MODDSN = ''
  DSEMSG = '(R) REUSE,(D) DEL/REALLOC,(A) ABORT'
  MODATTR="NEW BLKSIZE(80) DSORG(PS) RECFM(F,B) SPACE(1,1)"||,
   "CYLINDERS LRECL(80) CATALOG REUSE"
  ADDRESS ISPEXEC "VPUT (EDSN DSEMSG MODATTR MODDSN) ASIS"
  IF RC ^= 0 THEN RETURN 12
  CALL ALOCDSN
  IF RESULT = 8 THEN RETURN 12
  IF RESULT ^= 0 THEN RETURN 12
  ADDRESS ISPEXEC "VGET (EDSN) ASIS"
  TDSN=EDSN
  EDSN=ODSN
  ADDRESS ISPEXEC "VPUT (EDSN) ASIS"
  IF RC ^= 0 THEN RETURN 12
  CALL ALOCDSN
  IF RESULT = 8 THEN RETURN 12
  IF RESULT ^= 0 THEN RETURN 12
  ADDRESS ISPEXEC "VGET (EDSN) ASIS"
  ODSN=EDSN
  EDSN=TDSN
  SINDSN=EDSN
  SPTDSN=ODSN
  TRPT:
  HSS=''
   SCT=0
   IF SS1 = '' THEN DO
    SRCHSTR=TRANSLATE(SRCHSTR,' ',',')
    NW=WORDS(SRCHSTR)
    IF NW = 0 THEN RETURN 8
    DO I = 1 TO NW
     TWD=WORD(SRCHSTR,I)
     UPPER TWD
     SSV.I=TWD
     END
    SCT=NW
    SIGNAL ARNDSST
    END
   DO WHILE (SRCHSTR ^= '')
    BP=POS(SS1,SRCHSTR)
    IF BP = 0 THEN RETURN 8
    LP=POS(SSN,SRCHSTR,BP+SSP)
    IF LP = 0 THEN RETURN 8
    TMP=SUBSTR(SRCHSTR,1,1)
    UPPER TMP
    SCT=SCT+1
    SSV.SCT=TMP||SUBSTR(SRCHSTR,BP+1,LP-1)
    SRCHSTR=SUBSTR(SRCHSTR,LP+1)
    END
ARNDSST:
  IF SCT = 0 THEN RETURN 8
  OPCT=0
  DO I = 1 TO SCT
   SRCHSTR=SSV.I
   SPSS=SUBSTR(SRCHSTR,1,2)
   UPPER SPSS
   IF (SPSS="C'"|SPSS='C"'|SPSS="X'") THEN DO
    SPSSL=SUBSTR(SRCHSTR,LENGTH(SRCHSTR),1)
    IF SUBSTR(SRCHSTR,LENGTH(SRCHSTR),1)=SPSS1 THEN NOP
    END
    ELSE SRCHSTR="C'"||SRCHSTR||"'"
   HSS=HSS||' '||SRCHSTR
   OPCT=OPCT+1
   OP.OPCT="$$DD01 L  IF=(01,00,"SRCHSTR"),OUT=0"
   END
  OP.0=OPCT
  "ALLOC FI(SYSPRINT) DA('"ODSN"') SHR REUSE"
  FAIDODSN=ODSN
  'ISPEXEC VPUT (FAIDODSN) ASIS'
  "ALLOC FI(SYSIN) DA('"EDSN"') SHR REUSE"
  "EXECIO * DISKW SYSIN (STEM OP. FINIS"
  MYPLEX = SUBSTR(MVSVAR('SYSPLEX'),1,4)
  ADDRESS LINKMVS "FILEAID"
/*IF MYPLEX = 'GRP5' THEN "CALL 'SYS2.TSP.RFILEAID.LINKLIB(FILEAID)'"
   ELSE "CALL 'SYS2.TSP.RFILEAID.LINKLIB(FILEAID)'" */
   XC=RC
   IF XC > 5 THEN SIGNAL DODELT
  IF LTD>8 THEN SIGNAL ARNDDSP
  "EXECIO * DISKR SYSPRINT (STEM SP. FINIS"
  IF LTD > 9 THEN FS=' '
   ELSE FS='FF'X
  RASK=''
  I = 1
  J = 1
  MYPFX.J=''
  MYA.J=''
  FNDIND=0
 DOAGN:
 /* TRACE ?I */
  MYPFX.J=FS||'*** SEARCH ARGUMENT >'SSV.J'< '
  HSSWD=WORD(HSS,J)
  FNDLST=''
  DO I = I TO SP.0
   PARSE VAR SP.I '****MEMBER' REST '*' RASK
   IF REST ^= '' THEN DO
    MYA.J=MYA.J||FS||STRIP(REST,'B')
    END
    ELSE DO
    IF SUBSTR(SP.I,2,21) = 'ABOVE FUNCTION ENDED ' THEN LEAVE
    END
   END
  IF MYA.J='' THEN DO
   MYPFX.J = MYPFX.J||'WAS NOT FOUND'
   MYA.J= '-'
   END
   ELSE DO
   FNDIND = FNDIND + 1
   FNDLST=TRANSLATE(MYA.J,',',FS)
   FNDLST=SUBSTR(FNDLST,2)
   MYPFX.J = MYPFX.J||'RETURNED:'
   END
  J=J+1
  IF J > SCT THEN SIGNAL OUTOFLOP
  MYPFX.J=''
  MYA.J= ''
  I = I+1
  IF I > SP.0 THEN SIGNAL OUTOFLOP
  SIGNAL DOAGN
 OUTOFLOP:
  MYAREA=''
  MYATMP=''
  IF LTD > 0 THEN  SIGNAL ARNDDSP
  IF TMPVAR = '!LIST!' THEN DO
/* INTERPRET TMPDSN' = "'FNDLST'"' */
   INTERPRET TMPDSN' = FNDLST'
   ADDRESS ISPEXEC "VPUT ("TMPDSN") ASIS"
   SIGNAL DODELT
   END
  IF FNDIND=0 THEN DO
   FFX='FF'X
   MSGLOCK='C'
   MSGSTAT='FULLPOP'
   MSGANS=''
   MSGBOXTX=' SEARCH FOR STRING >'HSS'< WAS NOT FOUND IN THE '||,
    'SOURCE DSN 'SRCHSRC
   "ISPEXEC VPUT (MSGLOCK MSGSTAT MSGANS MSGBOXTX) ASIS"
   CALL MSGBOX
   END
   ELSE DO
   DO J = 1 TO SCT
    MYAREA=MYAREA||MYPFX.J||MYA.J
    END
   MYATMP=MYATMP||FS||'*** FILEAID SEARCH FINISHED'
   MYSFX=FS||'***    SOURCE DSN>'SRCHSRC'<'
   MYAREA=MYAREA||MYATMP||MYSFX||FS||'**FULL OUTPUT DSN>'ODSN'<'
   MYAREA#=FS
   ADDRESS ISPEXEC "VPUT (MYAREA# MYAREA) ASIS"
   CALL DSPLYA
   END
   SIGNAL DODELT
 ARNDDSP:
   IF ISPFIND = 0  THEN DO
    IF LTD > 8 THEN SIGNAL DODELT
    DO J = 1 TO SCT
     PARSE VAR MYPFX.J . '>' SARG '<' .
     SARG=FS||'*>'||SARG||'<'
     MYAREA=MYAREA||SARG||MYA.J
     END
    PUSH MYAREA
    SIGNAL DODELT
    END
   INTERPRET "DROP "SS1VAL
   IF LTD > 8 THEN SIGNAL DODELT
   INTERPRET TG1VAL"='"MYAREA"'"
   ADDRESS ISPEXEC "VPUT ("TG1VAL") ASIS"
   XC=RC
 DODELT:
   "FREE FI(SYSIN SYSPRINT DD01)"
   IF LTD < 9 THEN "DELETE '"SPTDSN"'"
   "DELETE '"SINDSN"'"
   RETURN XC
###END FAIDSRCH
$$$BEG EXCIS1
/* REXX */
/*----------------- SAMPLE1 REXX EXEC -------------------------------*\
|* PLEASE RUN THE TSOLIB COMMAND FROM NATIVE TSO                     *|
|*  (GO BACK TO READY)> CEM EXCITSLB
|*  (NOW RUN...)      > CICLOGON
|*                                                                   *|
|* THIS EXEC USES THE EXCI LINK INTERFACE TO EXECUTE A CICS PROGRAM  *|
|*                                                                   *|
|* "CA1DCALL "PROGRAM("PROGRAM_NAME")" ,                              *|
|*              "APPLID("VTAM_APPLID")" ,                            *|
|*              "USERID("USER_ID")" ,                                *|
|*              "COMMAREA(CA_NAME)" ,           /* OPTIONAL */       *|
|*              "LENGTH("CA_LENGTH")" ,         /* OPTIONAL */       *|
|*              "DATALENGTH("COMMAREA_DLEN")" , /* OPTIONAL */       *|
|*              "TRANSID("TRANS_ID")"           /* OPTIONAL */       *|
|* PROGRAM_NAME  - CONTAINS THE NAME OF THE CICS PROGRAM TO EXECUT   *|
|*                 FOLLOWING THE NAMING CONVENTIONS FOR CICS PROGR   *|
|*                                                                   *|
|* VTAM_APPLID   - CONTAINS THE VTAM APPLID FOR THE CICS REGION WH   *|
|*                 IS TO RECEIVE THE REQUEST.                        *|
|*                                                                   *|
|* USER_ID       - CONTAINS THE CICS USERID UNDER WHICH THE CICS     *|
|*                 PROGRAM WILL EXECUTE.  THIS USERID MUST BE        *|
|*                 VALIDATED PRIOR TO CALLING THE CICS PROGRAM BEC   *|
|*                 THERE IS NO ABILITY TO PASS A PASSWORD TO CICS.   *|
|*                                                                   *|
|* CA_NAME       - IS THE NAME OF THE REXX VARIABLE THAT CONTAINS    *|
|*                 COMMAREA CONTENTS.  (BE SURE TO WATCH THE '"' T   *|
|*                 AVOID THE REXX VARIABLE SUBSTITUTION. IF COMMAR   *|
|*                 NOT SPECIFIED, THEN LENGTH AND DATALENGTH ARE     *|
|*                 IGNORED IF SPECIFIED.                             *|
|*                                                                   *|
|* CA_LENGTH     - CONTAINS THE LENGTH OF THE COMMAREA TO BE USED    *|
|*                 THE EXCI.  THIS LENGTH CANNOT EXCEED 32768. IF    *|
|*                 VALUE IS NOT SUPPLIED BUT THE CA_NAME IS SPECIF   *|
|*                 THEN THE LENGTH OF THE REXX VARIABLE IS USED.     *|
|*                                                                   *|
|* COMMAREA_DLEN - CONTAINS THE LENGTH OF THE DATA TO BE PASSED IN   *|
|*                 COMMAREA.  THIS LENGTH MUST NOT BE LARGER THAN    *|
|*                 LENGTH OF THE COMMAREA. IF THIS VALUE IS NOT      *|
|*                 SUPPLIED BUT LENGTH IS SPECIFIED, THEN LENGTH I   *|
|*                 USED.  IF LENGTH IS NOT SPECIFIED THEN THE LENG   *|
|*                 THE CA_NAME REXX VARIABLE CONTENTS IS USED.       *|
|*                                                                   *|
|* TRANS_ID      - CONTAINS THE NAME OF A TRANSACTION TO BE USED F   *|
|*                 THE MIRROR FUNCTION.  IF NOT ENTERED THE DEFAUL   *|
|*                 MIRROR TRANSACTION, CSMI IS USED.                 *|
\*-------------------------------------------------------------------*/
ADDRESS TSO
ARG APPLID_NAME UID_NAME
IF APPLID_NAME = '' THEN APPLID_NAME='CGE7'
IF UID_NAME = '' THEN UID_NAME='TCEM'
PROGRAM_NAME = 'UCEMPINN'
COMMAREA_NAME= 'C_A'
C_A = 'PING'
COMMAREA_DLEN = LENGTH(C_A)
C_A = 'CEMT INQ,CONN'
COMMAREA_DLEN = LENGTH(C_A)
C_A = 'CEDA EXPAND GROUP(CEM)'
COMMAREA_DLEN = LENGTH(C_A)
C_A = C_A||COPIES(' ',4096-COMMAREA_DLEN)
COMMAREA_LEN = LENGTH(C_A)
/* APPLID_NAME='CGE7' */
USER_ID=SYSVAR(SYSUID)
TR_ID='CSMI'
PARM = "'PROGRAM("PROGRAM_NAME")','COMMAREA(C_A)',"||,
       "'TRANSID("TR_ID")',"||,
       "'LENGTH(COMMAREA_LEN)','APPLID("APPLID_NAME")'"
P1 = "PROGRAM("PROGRAM_NAME")"
P2 = "COMMAREA(C_A)"
P3 = "LENGTH("COMMAREA_LEN")"
P4 = "APPLID("APPLID_NAME")"
P5 = "TRANSID("TR_ID")"
P6 = "DATALENGTH(4)"
P7 = "USERID("USER_ID")"
EXCI_RESP='--'
EXCI_RESP2='##'
EXCI_ABCODE='____'
EXCI_MESSAGE='-'
SAY 'COMMAREA CONTENTS BEFORE LINK ARE:' COMMAREA
SAY
SAY 'CALLING CICSLINK WITH PARAMETERS:'
PARM1 = PARM
DO UNTIL PARM1 = ''
  PARSE VAR PARM1 PART ',' PARM1
  SAY '   ' PART
  END
SAY 'PRESS ENTER TO CONTINUE OR PA1 TO INTERUPT'
PULL
 MDDN = 'ISPLLIB'
 MDSN = "'TTEP.TSK.E.TCEM.PDSE'"
 "ISPEXEC LIBDEF "MDDN" DATASET ID("MDSN") UNCOND"
 IF RC ^= 0 THEN SIGNAL DONIT
 /* "ISPEXEC SELECT PGM(ISPLLS) SCRNAME(LIBDEF)" */
/* NEXT 2 WORK - ALL ARGS ARE COMBINED INTO ONE RX ARG */
/* RXVARS_RESULT = CA1DLINK('P1','P2','P3','P4','P5') */
/* CALL CA1DLINK 'P1','P2','P3','P4','P5' */
/* THIS WORKS - EACH ARG IS SEPARATE IN RX ARG TABLE */
/* INTERPRET "CALL CA1DLINK '"P1"','"P2"','"P3"','"P4"','"P5"'" */
/* CALL EXCICOBL */
TRACE ?I
   ADDRESS TSO "CALL 'TTEP.TSK.E.TCEM.PDSE(DFH0CXC)' "||,
    "'"APPLID_NAME","UID_NAME"'"
/* XX=CA1DLINK('PROGRAM' ,
             'APPLID' ,
             'COMMAREA' ,
             'LENGTH' ,
             'DATALENGTH' ,
             'TRANSID'      ) */
/* XX=CA1DLINK('PROGRAM(UCEMPINN)' ,
             'APPLID(CGE5)' ,
             'COMMAREA(COMMAREA)' ,
             'LENGTH(1080)' ,
             'DATALENGTH(4)' ,
             'TRANSID(UTST)') */
TRACE OFF
SAY 'MAIN EXEC - RESULT VARIABLE CONTENTS:' RESULT
SAY
SAY 'EXCI_RESP IS:' EXCI_RESP
SAY 'EXCI_RESP2 IS:' EXCI_RESP2
SAY 'EXCI_ABCODE IS:' EXCI_ABCODE
SAY 'EXCI_MESSAGE LENGTH IS:' LENGTH(EXCI_MESSAGE)
SAY 'EXCI_MESSAGE IS:' EXCI_MESSAGE
SAY
SAY 'COMMAREA CONTENTS AFTER LINK ARE:'
O_C_A_LEN=LENGTH(C_A)
SAY 'LENGTH IS:' O_C_A_LEN
IND = 0
X15='15'X
C_A=STRIP(C_A,'T')
N_C_A_LEN=LENGTH(C_A)
SAY ' STRIPPED 'O_C_A_LEN-N_C_A_LEN' SPACES AT END OF COMMAREA'
DO WHILE(C_A ^= '')
 PARSE VAR C_A TMP (X15) C_A
 SAY TMP
 END
/* SAY '<'||C_A||">" */
DONIT:
EXIT
###END EXCIS1
$$$BEG EXPLZMSG
/* REXX */
TRACE ?I
ADDRESS ISPEXEC
 "ISPEXEC CONTROL ERRORS RETURN"
SIGNAL EXITBIGMSG
 EXITRC4:
  ZEDSMSG = 'DSN INVALID'
  ZEDLMSG = 'DSN PROVIDED IS INVALID'
  SIGNAL WRITIT
 EXITBIGMSG:
  ZEDSMSG = 'BIG INVALID'
  ZEDLMSG = 'THIS IS A TEST MESSAGE TO SEE HOW BIG THE LMSG CAN BE '||,
            'BEFORE IT COMPLAINS. E TO SEE HOW BIG THE LMSG CAN BE '||,
            'BEFORE IT COMPLAINS. E TO SEE HOW BIG THE LMSG CAN BE '||,
            'BEFORE IT COMPLAINS. E TO SEE HOW BIG THE LMSG CAN BE '||,
            'BEFORE IT COMPLAINS. E TO SEE HOW BIG THE LMSG CAN BE '||,
            'BEFORE IT COMPLAINS. E TO SEE HOW BIG THE LMSG CAN BE '
 WRITIT:
  'ISPEXEC SETMSG MSG(ISRZ000)'
###END EXPLZMSG
$$$BEG CIXXRUN
/* REXX */
 /* TRACE ?I */
 ADDRESS ISPEXEC
 "ISPEXEC CONTROL ERRORS RETURN"
 ARG EXECSEL KIXAPPL ASMMBR ACTN
 IF EXECSEL = '' THEN DO
  CALL MSGBOX 'INVALID CALL TO CIXXRUN.  CEMHELP CIXXRUN FOR SPEC'||,
   'IFICS.  PRESS PF3 TO END'
  EXIT
  END
 DSEMSG = ''
 "ISPEXEC VPUT (EXECSEL DSEMSG) ASIS"
 IF EXECSEL='RDXRUN' THEN ASMMBR = ASMMBR||' '||ACTN
 IF ACTN ^= 'BROWSE' THEN ACTN='EDIT'
  ELSE ACTN='VIEW'
 EDTRC=4
 CALL SAFO KIXAPPL
 IF RESULT ^= 0 THEN SIGNAL EXITRC4
 "ISPEXEC VGET (MYAFO) ASIS"
 IF RC ^= 0 THEN SIGNAL EXITRC4
  PS="#"
  CALL AFOFLD 'MYAPLID MYTYP MYREL MYCPU'
  PULL FLD#
  PARSE VAR FLD# MYAPLIDL MYAPLIDB MYAPLIDE MYAPLIDM (PS),
                 MYTYPL MYTYPB MYTYPE MYTYPM (PS),
                 MYRELL MYRELB MYRELE MYRELM (PS),
                 MYCPUL MYCPUB MYCPUE MYCPUM .
  MYAPLID=STRIP(SUBSTR(MYAFO,MYAPLIDB,MYAPLIDL),"B")
 IF MYAPLID = '' THEN SIGNAL EXITRC4
 CIXXAPL=MYAPLID
 "ISPEXEC VPUT (CIXXAPL) ASIS"
  MYTYP=SUBSTR(MYAFO,MYTYPB,MYTYPL)
  MYREL=STRIP(SUBSTR(MYAFO,MYRELB,MYRELL),"B")
  MYCPU=STRIP(SUBSTR(MYAFO,MYCPUB,MYCPUL),"B")
 IF MYTYP = 'E' THEN MYTYP='D'
  "ISPEXEC VGET (CURCPU CURGRP CURCPUG) PROFILE"
 IF RC ^= 0 THEN DO
  CALL GETCPU1
  "ISPEXEC VGET (CURCPU CURGRP CURCPUG) PROFILE"
  END
 IF CURGRP = '????' THEN SIGNAL EXITRC4
 A=CURCPU
 B=CURGRP
 KIXCPUG=CURCPUG
 IF POS(MYCPU,KIXCPUG) = 0 THEN SIGNAL NOTONPLEX
 KIXCPU=MYCPU
 KIXGRP=KIXCPU||'SYS'
 CALL GETCPU1 KIXGRP
 "ISPEXEC VGET (CVTDGRP CVTDGRPC) ASIS"
 IF POS(KIXCPU,CVTDGRPC) = 0 THEN SIGNAL EXITRC4
 PARSE VAR EXECSEL EXECSEL '.' LIBSEL
 ASMDSN='TTE'MYTYP'.TSK.F.R'MYREL'.'MYAPLID
 IF EXECSEL='ASMTAB' THEN DO
  ASMDSN=ASMDSN||'.TABLE.SOURCE'
  IF ASMMBR^='' & ASMMBR^='*' THEN,
   ASMDSN=ASMDSN||'('||STRIP(ASMMBR,'B')||')'
  "ISPEXEC "ACTN" DATASET('"ASMDSN"')"
  EXIT
  END
 IF EXECSEL='ECPY' THEN DO
  IF LIBSEL = '' THEN SIGNAL ECPYERR
  ASMDSN=ASMDSN||'.'||LIBSEL
  IF ASMMBR^='' & ASMMBR^='*' THEN,
   ASMDSN=ASMDSN||'('||STRIP(ASMMBR,'B')||')'
  "ISPEXEC "ACTN" DATASET('"ASMDSN"')"
  IF RC>8 THEN SAY "ERROR "RC
  EXIT
  END
 ASMSTOP = 0
 SUID=SYSVAR(SYSUID)
 EDTRC = 4
 ASMDSN=ASMDSN||'.JCLLIB'
 EDSN='TTED.TSK.P.TCEM.CNTL('SUID||SUBSTR(EXECSEL,1,4)')'
 "ISPEXEC VPUT (EXECSEL ASMDSN ASMMBR ACTN ASMSTOP) ASIS"
 IF RC ^= 0 THEN SIGNAL EXITRC8
 "ISPEXEC "ACTN" DATASET('"EDSN"') MACRO(CIXXMAC)"
  XC = RC
  IF SUID='TCEM' THEN DO
  "ISPEXEC "ACTN" DATASET('"EDSN"') MACRO(MYAUTSAV)"
   END
  IF XC > 8 THEN SIGNAL EXITRC12
  "ISPEXEC VGET (EDTRC) ASIS"
  IF RC ^= 0 THEN SIGNAL EXITRC12
  IF EDTRC > 4 THEN SIGNAL EXITRC12
  IF ASMSTOP = 0 THEN "ISREDIT CURSOR = "ROW" 0"
EXITRC0:
 ZEDSMSG = EXECSEL' OK'
 ZEDLMSG = 'EXEC 'EXECSEL' FINISHED MACRO ACTIVITY.'
 SIGNAL WRITIT
EXITRC4:
 ZEDSMSG = 'INVALID DSN/MBR'
 ZEDLMSG = 'INVALID DSN OR MEMBER SOURCE. NO ATTEMPT AT JCL'
 SIGNAL WRITIT
EXITRC8:
 ZEDSMSG = 'SYM VAR ERRORS'
 ZEDLMSG = 'DSN/MBR SYMBOLIC VARS COULD NOT BE SAVED. NO ATTEMPT AT JCL'
 SIGNAL WRITIT
EXITRC10:
 ZEDSMSG = 'SKEL ERROR'
 ZEDLMSG = EXECSEL' SKELETON NOT BE SAVED FOR PROCESSING. NO SUBMIT'
 SIGNAL WRITIT
EXITRC12:
 ZEDSMSG = 'SUB ERROR'
 ZEDLMSG = 'SUBMIT PROCESS INDICATES A NON ZERO RETURN CODE'
 SIGNAL WRITIT
NOTONPLEX:
 ZEDSMSG = 'WRONG SYSPLEX'
 ZEDLMSG = 'REGION 'KIXAPPL' ON CPU:'MYCPU||,
                  ' IS NOT ON THIS SYSPLEX:'KIXCPUG
 SIGNAL WRITIT
ECPYERR:
   CALL MSGBOX 'INVALID CALL TO ECPY. REQUIRED DSN SUFFIX MISSING.'||,
    'VALID: TABLE.SOURE(TS) PARMLIB(P) JCLLIB(J) FSACDS(F)        '||,
    'PRESS PF3 TO END.'
   EXIT
WRITIT:
 "ISPEXEC SETMSG MSG(ISRZ000)"
DONEIN:
 IF EDTRC = 0 THEN "ISREDIT END"
  ELSE RETURN 0
###END CIXXRUN
$$$BEG $CVT330
/* REXX */
 /* REXX */
 ADDRESS ISPEXEC
 "ISPEXEC CONTROL ERRORS RETURN"
 /* MAKE CHANGES HERE */
 EXECSEL='$CVT330'
 $CVTDSN='TTED.TSK.INITIAL.R330.DOC'
 $CVTBASE='TTED.TSK.INITIAL.R330.DOC'
 MSGTXT='$CVT330 STARTED AT 'TIME()
 KIXCTS2=,
'F1ABEND  F1ABND   F1ABNDFX F1ABND33 '||,
'F1CICS   F1CICS17 F1CICS21 '||,
'F1DADPLS F1DADS   F1DAD31  F1DBUG '||,
'F1PLAY   F1PLAYFX F1RDO    F1SDF    F1SUPOPT '||,
'F1XPED   F2CICS21 F2DAD31  F2DBUG   '||,
'F2PLAY   F2TRADP  F3CICS21 F3DAD31'
 /* MAKE CHANGES HERE END */
 "ISPEXEC VPUT (EXECSEL) ASIS"
 TRACE I
 CALL PNCAT
 CALL HJCL 'HOLD'
 CALL REGSEL1
 IF RESULT ^= 0 THEN DO
  CALL MSGBOX 'INVALID REGION. CICS REGION MUST BE FOUND ON AFO '||,
   'CONTROL FILE. ABORT IN SETUP PHASE.'
  EXIT
  END
 $CVTSUID=SYSVAR(SYSUID)
 FFX = 'FF'X
 "ISPEXEC VGET (MYAFO MYCNTL) ASIS"
 IF MYAFO = '' THEN SIGNAL NOTDON
 SUID=SYSVAR(SYSUID)
 $CVTACTN = 'REVIEW/SUBMIT'
 KIXAPPL=STRIP(SUBSTR(MYAFO,2,8),'T')
 KIXJOBM=STRIP(SUBSTR(MYAFO,38,8),'T')
 KIXJOBN=STRIP(SUBSTR(MYAFO,47,8),'T')
 KIXFSAN=STRIP(SUBSTR(MYCNTL,12,4),'T')
 KIXUP=STRIP(SUBSTR(MYAFO,20,8),'T')
 KIXEMER=STRIP(SUBSTR(MYAFO,56,8),'T')
 KIXCOLD=KIXJOBM
 KIXDOWN=STRIP(SUBSTR(MYAFO,74,8),'T')
 KIXCA7=STRIP(SUBSTR(MYAFO,92,8),'T')
 KIXVERFY=STRIP(SUBSTR(MYAFO,110,8),'T')
 KIXJRNL=STRIP(SUBSTR(MYAFO,128,8),'T')
 KIXBTCH=STRIP(SUBSTR(MYAFO,146,8),'T')
 KIXCPU=SUBSTR(MYAFO,203,1)
 KIXREL=SUBSTR(MYAFO,206,3)
 KIXTYP=SUBSTR(MYAFO,182,1)
 IF KIXTYP = 'E' THEN KIXTYP = 'D'
 CALL FNJCLOR KIXJOBM 'SUFX'
 PULL KSFX
 IF KSFX = '' THEN DO
  KSFX='UNKW'
  END
 KSFXRDR=KSFX||'RDR'
 KSFXBTCH=KSFX||'BTCH'
 DSHLQ='TTE'||KIXTYP
 /* CHANGES HERE IF REQUIRED */
 TYP='INXX$CVT('KIXTYP')'
 KIX$REL='330'
 IF KIXREL=KIX$REL THEN DO
  CALL MSGBOX 'ERROR. AFOPER RELEASE SAYS 'KIXREL' IS THE SAME AS '||,
  KIX$REL' AND IS INVALID.  DO NOT CHANGE AFOPER UNTIL ALL OUR WORK '||,
  'IS COMPLETED.'
  EXIT
  END
 REL1='INXX$CVT(3)'
 APPLID='INXX$CVT('KIXAPPL')'
 /* CHANGES ABOVE IF REQUIRED */
 "ISPEXEC VPUT (TYP REL1 APPLID) ASIS"
 CALL EXPDJCLM INXX$CVT
 PULL TMPJCL
 "ISPEXEC VGET (ARCHCDS FRCODE FRLIB CTYP ENV) ASIS"
 FSACDS=ARCHCDS
 PARSE VAR ENV SYMMBR '(' KIX$PDO ')'
 PARSE VAR KIX$PDO '.' KIX$ENV
 KIXJCLL=DSHLQ'.TSK.F.R'KIXREL'.'KIXAPPL'.JCLLIB'
 PARSE VAR CTYP SYMMBR '(' KIX$CTYP ')'
 PARSE VAR FRLIB SYMMBR '(' KIX$LL ')'
 FRLIB=KIX$LL
 PARSE VAR FRCODE SYMMBR '(' FRCODE ')'
 IF SYSDSN("'"KIXJCLL"'") ^= 'OK' THEN DO
  MSGTXT=MSGTXT||FFX||'R212 JCLLIB DOES NOT EXIST. CREATING IT...'
  EDSN = KIXJCLL
  DSEMSG = '(R) REUSE,(D) DEL/REALLOC,(A) ABORT'
  MODDSN=''
  MODATTR="NEW BLKSIZE(4000) DSORG(PO) "||,
   "RECFM(F,B) SPACE(1,1) DIR(9) "||,
   "TRACK LRECL(80) CATALOG REUSE"
  ADDRESS ISPEXEC "VPUT (EDSN EXECSEL DSEMSG MODATTR MODDSN) ASIS"
  IF RC ^= 0 THEN SIGNAL JCL212
  CALL ALOCDSN
  XC = RESULT
  IF XC = 8 THEN SIGNAL JCL212
  IF XC ^= 0 THEN SIGNAL JCL212
  END
 KIX$JCLL=DSHLQ'.TSK.F.R'KIX$REL'.'KIXAPPL'.JCLLIB'
 KIX$PRML=DSHLQ'.TSK.F.R'KIX$REL'.'KIXAPPL'.PARMLIB'
 KIXPRML=DSHLQ'.TSK.F.R'KIXREL'.'KIXAPPL'.PARMLIB'
 KIX$TS=DSHLQ'.TSK.F.R'KIX$REL'.'KIXAPPL'.TABLE.SOURCE'
 KIXTS=DSHLQ'.TSK.F.R'KIXREL'.'KIXAPPL'.TABLE.SOURCE'
 KIX$TL=DSHLQ'.TSK.F.R'KIX$REL'.'KIXAPPL'.TABLELIB'
 KIXTL=DSHLQ'.TSK.F.R'KIXREL'.'KIXAPPL'.TABLELIB'
 KIXAX=DSHLQ'.TSK.J.'KIXAPPL'.AUXTRACE'
 KIXBX=DSHLQ'.TSK.J.'KIXAPPL'.BUXTRACE'
 KIX$FCT='$$'
 STATSJOB='OPTD001P'
 PARSE VAR FSACDS SYMTMP '(' R330FSA ')'
 $CVTTGT=DSHLQ'.TSK.S.R'KIXREL'.'KIXAPPL'.RDOXTRK'
 CALL GETCPU1
 "ISPEXEC VGET (CURGRP) ASIS"
 IF CURGRP='GRP1' | CURGRP='GY2Y' THEN DO
  SELECT
  WHEN KIXTYP='D' THEN KIX$SIT='D1'
  WHEN KIXTYP='T' THEN KIX$SIT='T5'
  WHEN KIXTYP='A' THEN KIX$SIT='A5'
  WHEN KIXTYP='P' THEN KIX$SIT='P4'
  OTHERWISE KIX$SIT='XX'
  END
  SIGNAL GOTSIT
  END
 IF CURGRP='GRP2' | CURGRP='GY2W' THEN DO
  SELECT
  WHEN KIXTYP='D' THEN KIX$SIT='DP'
  WHEN KIXTYP='T' THEN KIX$SIT='TP'
  WHEN KIXTYP='A' THEN KIX$SIT='AP'
  WHEN KIXTYP='P' THEN KIX$SIT='PP'
  OTHERWISE KIX$SIT='XX'
  END
  SIGNAL GOTSIT
  END
 IF CURGRP='GRPV' | CURGRP='GY2V' THEN DO
  SELECT
  WHEN KIXTYP='D' THEN KIX$SIT='D1'
  WHEN KIXTYP='T' THEN KIX$SIT='T1'
  WHEN KIXTYP='A' THEN KIX$SIT='A1'
  WHEN KIXTYP='P' THEN KIX$SIT='P1'
  OTHERWISE KIX$SIT='XX'
  END
  SIGNAL GOTSIT
  END
GOTSIT:
 KIX$REL1=SUBSTR(KIX$REL,1,1)
 KIXREL1=SUBSTR(KIXREL,1,1)
 CVT$DNT=DATE('N') TIME('N')
 CVTVPUT = "KIXAPPL KIXJOBN KIXCPU KIXREL KIX$REL KIX$ENV "||,
  "KIX$FCT KSFX KSFXRDR KSFXBTCH KIXTS KIXFSAN R330FSA KIXPRML "||,
  "KIXTYP DSHLQ SUID KIX$JCLL $CVTBASE $CVTTGT KIX$PRML KIX$TS "||,
  "KIXUP KIXEMER KIXCOLD KIXDOWN KIXVERFY KIXJRNL KIXCA7 KIXBTCH "||,
  "STATSJOB KIX$SIT KIXJCLL $CVTACTN KIX$CTYP KIX$LL CVT$DNT "||,
  "KIX$REL1 KIXREL1 KIX$PDO KIXCTS2"
 "ISPEXEC VPUT (CVTVPUT) ASIS"
 IF RC ^= 0 THEN SIGNAL NOTDON
 "ISPEXEC VPUT ("CVTVPUT") ASIS"
 IF RC ^= 0 THEN SIGNAL NOTDON
 JCLDSN=$CVTDSN||'($CVTJC)'
 IF SYSDSN("'"JCLDSN"'") ^= 'OK' THEN SIGNAL NOJOBC
 "ISPEXEC EDIT DATASET ('"JCLDSN"') MACRO($CVTMKJC)"
 "ISPEXEC VGET (EDTRC) ASIS"
 IF EDTRC ^= 0 THEN JCSTR='JOBCARD COULD NOT BE INITIALIZED.'
  ELSE JCSTR='JOBCARD INFORMATION IN MEMORY VARIABLES'
 MSGTXT=MSGTXT||FFX||JCSTR||FFX,
   '$CVT330 VARIABLES INITIALIZED. CONTINUE PROCESSING.'
 IF SYSDSN("'"KIX$JCLL"'") ^= 'OK' THEN DO
  OP.1 = '//IEBCSTP  EXEC  PGM=IEBCOPY,REGION=0K'
  OP.2 = '//SYSPRINT DD SYSOUT=*'
  N=2
  Q=0
  MSGTXT=MSGTXT||FFX||'CREATE JCL FOR 'KIX$JCLL'.'
  CALL MAKEIEBJ '1('KIXJCLL')' KIX$JCLL
  XC = RESULT
  PULL RETVAL
  IF XC ^= 0 THEN MSGTXT=MSGTXT||' RETURNED RC='XC
   ELSE CALL CREJCL
  MSGTXT=MSGTXT||FFX||'CREATE JCL FOR 'KIX$PRML'.'
  CALL MAKEIEBJ '2('KIXPRML')' KIX$PRML
  XC = RESULT
  PULL RETVAL
  IF XC ^= 0 THEN MSGTXT=MSGTXT||' RETURNED RC='XC
   ELSE CALL CREJCL
  MSGTXT=MSGTXT||FFX||'CREATE JCL FOR 'KIX$PRML'.S.'
  CALL MAKEIEBJ '3('KIXPRML'.S('KIX$PRML'.S))'
  XC = RESULT
  PULL RETVAL
  IF XC ^= 0 THEN MSGTXT=MSGTXT||' RETURNED RC='XC
   ELSE CALL CREJCL
  MSGTXT=MSGTXT||FFX||'CREATE JCL FOR 'KIX$PRML'.B.'
  CALL MAKEIEBJ '4('KIXPRML'.B('KIX$PRML'.B))'
  XC = RESULT
  PULL RETVAL
  IF XC ^= 0 THEN MSGTXT=MSGTXT||' RETURNED RC='XC
   ELSE CALL CREJCL
  MSGTXT=MSGTXT||FFX||'CREATE JCL FOR 'KIX$TS'.'
  CALL MAKEIEBJ '5('KIXTS')' KIX$TS
  XC = RESULT
  PULL RETVAL
  IF XC ^= 0 THEN MSGTXT=MSGTXT||' RETURNED RC='XC
   ELSE CALL CREJCL
  KIXTLL='(AUTOTERM AUTOSTAT CCATGLOB UFHINITT)'
  CALL MAKEIEBJ '6('KIXTL')' KIX$TL KIXTLL
  XC = RESULT
  PULL RETVAL
  IF XC ^= 0 THEN MSGTXT=MSGTXT||' RETURNED RC='XC
   ELSE CALL CREJCL
  IF N>2 THEN DO
   N=N+1
   OP.N='//SYSIN DD *'
   DO I = 1 TO Q
    N=N+1
    OP.N=PP.I
    END
   N=N+1
   OP.N='/*'
  MSGTXT=MSGTXT||FFX||'CREATE JCL FOR 'KIXBX'.'
  N=N+1
  OP.N = '//IEFALC   EXEC  PGM=IEFBR14,REGION=0K'
  N=N+1
  OP.N = '//SYSPRINT DD SYSOUT=*'
  CALL MAKEIEBJ KIXAX'('KIXBX')'
  XC = RESULT
  PULL RETVAL
  IF XC ^= 0 THEN MSGTXT=MSGTXT||' RETURNED RC='XC
   ELSE CALL CREJCL
   ADDRESS TSO
   KIXJCLLM=KIXJCLL"($CVTJCL)"
   "ALLOC FI(O) DA('"KIXJCLLM"') SHR REUSE"
   "EXECIO * DISKW O (STEM OP. FINIS"
   "FREE FI(O)"
   MSGTXT=MSGTXT||FFX||'JCL SAVED TO 'KIXJCLLM'.'
   ADDRESS ISPEXEC
   ZEDSMSG = 'REVIEW/SUBMIT'
   ZEDLMSG = 'REVIEW, SUBMIT, THEN SAVE JCL.'
   'ISPEXEC SETMSG MSG(ISRZ000)'
   "ISREDIT DATASET ('"KIXJCLLM"') MACRO($CVTIJC)"
   END
  SIGNAL MAREA
  END
 SIGNAL BYPJCL
JCL212:
 MSGTXT='$CVT330 ABORTED. 'KIXJCLL' IS NOT FOUND AND IS REQUIRED '||,
  'FOR EXECUTION OF THIS PROCESS. ALLOCATE IT AND RETRY.'
 SIGNAL MBOX
NOTDON:
 MSGTXT='$CVT330 ERROR. VARIABLES NOT INITIALIZED. ABORT PROCESSING'
 SIGNAL MBOX
BYPJCL:
 MSGTXT=MSGTXT||FFX||KIX$JCLL' ALREADY EXISTS.'
 SIGNAL MAREA
MBOX:
 MSGTXT=MSGTXT||FFX||' PRESS PF3 TO CONTINUE.'
 CALL MSGBOX MSGTXT
 EXIT
MAREA:
 MYAREA=MSGTXT||FFX||'YOU CAN SEND THIS LOG TO JRPPNT  WITH CMD PMBR'||,
  FFX||'PRESS PF3 TO END'
 MYAREA#=FFX
 "ISPEXEC VPUT (MYAREA MYAREA#) ASIS"
 CALL DSPLYA
 EXIT
CREJCL: PROCEDURE EXPOSE RETVAL N OP. Q PP.
  PARSE VAR RETVAL '%S(' SJCL ')%T(' TJCL ')%Y(' SYIN
  IF SJCL=''|TJCL='' THEN DO
   SAY 'CREJCL ERROR SRCDSN>'SJCL'< TGTDSN>'TDSN'<'
   RETURN 8
   END
  DO WHILE(SJCL^='')
   N=N+1
   FP=POS('//',SJCL,2)
   IF FP=0 THEN FP=LENGTH(SJCL)+1
   OP.N=SUBSTR(SJCL,1,FP-1)
   SJCL=SUBSTR(SJCL,FP)
   END
  DO WHILE(TJCL^='')
   N=N+1
   FP=POS('//',TJCL,2)
   IF FP=0 THEN FP=LENGTH(TJCL)+1
   OP.N=SUBSTR(TJCL,1,FP-1)
   TJCL=SUBSTR(TJCL,FP)
   END
  LP=LASTPOS(')',SYIN)
  IF LP>1 THEN SYIN=SUBSTR(SYIN,1,LP-1)
   ELSE SYIN=''
  DO WHILE(SYIN^='')
   Q=Q+1
   FP=POS(' SELECT MEMBER=',SYIN,2)
   IF FP=0 THEN FP=LENGTH(SYIN)+1
   PP.Q=SUBSTR(SYIN,1,FP-1)
   SYIN=SUBSTR(SYIN,FP)
   END
  RETURN 0
###END $CVT330
$$$BEG $$
//*
TTED.TSK.INITIAL.R330.DOC
//TCEMXXXT JOB (T,KIC,CIC2050,4,WD32),'C MACK',
// MSGCLASS=T,MSGLEVEL=(1,1),CLASS=4,NOTIFY=TCEM
//*JOBPARM L=9999,T=1540
//* $ACFJ219 ACF2 ACTIVE WNDMVS1
//* PARM POSITIONAL COMPARE,LISTING,OUTDD,BROWSE,SYSIN,DELDD,PROCESS
//COMP1     EXEC  PGM=ISRSUPC,PARM=('DELTAL,LINECMP,WIDE')
//NEWDD  DD   DISP=SHR,DSN=TTET.TSK.S.TCEM.NFUTSYX.CGAB
//OLDDD  DD   DISP=SHR,DSN=TTET.TSK.S.TCEM.NFUTSYX.CGTJ
//OUTDD  DD   DISP=(NEW,PASS,DELETE),UNIT=SYSDA,
//       DCB=(RECFM=FBA,LRECL=204,BLKSIZE=4080,DSORG=PS),
//       SPACE=(TRK,(1,1)),
//       DSN=&&S1
//SYSIN   DD   DUMMY
//COMP2     EXEC  PGM=ISRSUPC,PARM=('DELTAL,LINECMP,WIDE')
//NEWDD  DD   DISP=SHR,DSN=TTET.TSK.S.TCEM.NFUTSYX.CGAB
//OLDDD  DD   DISP=SHR,DSN=TTET.TSK.S.TCEM.NFUTSYX.GPDAA01
//OUTDD  DD   DISP=(NEW,PASS,DELETE),UNIT=SYSDA,
//       DCB=(RECFM=FBA,LRECL=204,BLKSIZE=4080,DSORG=PS),
//       SPACE=(TRK,(1,1)),
//       DSN=&&S2
//SYSIN   DD   DUMMY
//COMP3     EXEC  PGM=ISRSUPC,PARM=('DELTAL,LINECMP,WIDE')
//NEWDD  DD   DISP=SHR,DSN=TTET.TSK.S.TCEM.NFUTSYX.CGAB
//OLDDD  DD   DISP=SHR,DSN=TTET.TSK.S.TCEM.NFUTSYX.GPDAP01
//OUTDD  DD   DISP=(NEW,PASS,DELETE),UNIT=SYSDA,
//       DCB=(RECFM=FBA,LRECL=204,BLKSIZE=4080,DSORG=PS),
//       SPACE=(TRK,(1,1)),
//       DSN=&&S3
//SYSIN   DD   DUMMY
//COMP4     EXEC  PGM=ISRSUPC,PARM=('DELTAL,LINECMP,WIDE')
//NEWDD  DD   DISP=SHR,DSN=TTET.TSK.S.TCEM.NFUTSYX.CGAB
//OLDDD  DD   DISP=SHR,DSN=TTET.TSK.S.TCEM.NFUTSYX.T1A1
//OUTDD  DD   DISP=(NEW,PASS,DELETE),UNIT=SYSDA,
//       DCB=(RECFM=FBA,LRECL=204,BLKSIZE=4080,DSORG=PS),
//       SPACE=(TRK,(1,1)),
//       DSN=&&S4
//SYSIN   DD   DUMMY
//COMP5     EXEC  PGM=ISRSUPC,PARM=('DELTAL,LINECMP,WIDE')
//NEWDD  DD   DISP=SHR,DSN=TTET.TSK.S.TCEM.NFUTSYX.CGAB
//OLDDD  DD   DISP=SHR,DSN=TTET.TSK.S.TCEM.NFUTSYX.T1P2
//OUTDD  DD   DISP=(NEW,PASS,DELETE),UNIT=SYSDA,
//       DCB=(RECFM=FBA,LRECL=204,BLKSIZE=4080,DSORG=PS),
//       SPACE=(TRK,(1,1)),
//       DSN=&&S5
//SYSIN   DD   DUMMY
//COMP6     EXEC  PGM=ISRSUPC,PARM=('DELTAL,LINECMP,WIDE')
//NEWDD  DD   DISP=SHR,DSN=TTET.TSK.S.TCEM.NFUTSYX.CGTJ
//OLDDD  DD   DISP=SHR,DSN=TTET.TSK.S.TCEM.NFUTSYX.GPDAA01
//OUTDD  DD   DISP=(NEW,PASS,DELETE),UNIT=SYSDA,
//       DCB=(RECFM=FBA,LRECL=204,BLKSIZE=4080,DSORG=PS),
//       SPACE=(TRK,(1,1)),
//       DSN=&&S6
//SYSIN   DD   DUMMY
//COMP7     EXEC  PGM=ISRSUPC,PARM=('DELTAL,LINECMP,WIDE')
//NEWDD  DD   DISP=SHR,DSN=TTET.TSK.S.TCEM.NFUTSYX.CGTJ
//OLDDD  DD   DISP=SHR,DSN=TTET.TSK.S.TCEM.NFUTSYX.GPDAP01
//OUTDD  DD   DISP=(NEW,PASS,DELETE),UNIT=SYSDA,
//       DCB=(RECFM=FBA,LRECL=204,BLKSIZE=4080,DSORG=PS),
//       SPACE=(TRK,(1,1)),
//       DSN=&&S7
//SYSIN   DD   DUMMY
//COMP8     EXEC  PGM=ISRSUPC,PARM=('DELTAL,LINECMP,WIDE')
//NEWDD  DD   DISP=SHR,DSN=TTET.TSK.S.TCEM.NFUTSYX.CGTJ
//OLDDD  DD   DISP=SHR,DSN=TTET.TSK.S.TCEM.NFUTSYX.T1A1
//OUTDD  DD   DISP=(NEW,PASS,DELETE),UNIT=SYSDA,
//       DCB=(RECFM=FBA,LRECL=204,BLKSIZE=4080,DSORG=PS),
//       SPACE=(TRK,(1,1)),
//       DSN=&&S8
//SYSIN   DD   DUMMY
//COMP9     EXEC  PGM=ISRSUPC,PARM=('DELTAL,LINECMP,WIDE')
//NEWDD  DD   DISP=SHR,DSN=TTET.TSK.S.TCEM.NFUTSYX.CGTJ
//OLDDD  DD   DISP=SHR,DSN=TTET.TSK.S.TCEM.NFUTSYX.T1P2
//OUTDD  DD   DISP=(NEW,PASS,DELETE),UNIT=SYSDA,
//       DCB=(RECFM=FBA,LRECL=204,BLKSIZE=4080,DSORG=PS),
//       SPACE=(TRK,(1,1)),
//       DSN=&&S9
//SYSIN   DD   DUMMY
//COMP10    EXEC  PGM=ISRSUPC,PARM=('DELTAL,LINECMP,WIDE')
//NEWDD  DD   DISP=SHR,DSN=TTET.TSK.S.TCEM.NFUTSYX.GPDAA01
//OLDDD  DD   DISP=SHR,DSN=TTET.TSK.S.TCEM.NFUTSYX.GPDAP01
//OUTDD  DD   DISP=(NEW,PASS,DELETE),UNIT=SYSDA,
//       DCB=(RECFM=FBA,LRECL=204,BLKSIZE=4080,DSORG=PS),
//       SPACE=(TRK,(1,1)),
//       DSN=&&S10
//SYSIN   DD   DUMMY
//COMP11    EXEC  PGM=ISRSUPC,PARM=('DELTAL,LINECMP,WIDE')
//NEWDD  DD   DISP=SHR,DSN=TTET.TSK.S.TCEM.NFUTSYX.GPDAA01
//OLDDD  DD   DISP=SHR,DSN=TTET.TSK.S.TCEM.NFUTSYX.T1A1
//OUTDD  DD   DISP=(NEW,PASS,DELETE),UNIT=SYSDA,
//       DCB=(RECFM=FBA,LRECL=204,BLKSIZE=4080,DSORG=PS),
//       SPACE=(TRK,(1,1)),
//       DSN=&&S11
//SYSIN   DD   DUMMY
//COMP12    EXEC  PGM=ISRSUPC,PARM=('DELTAL,LINECMP,WIDE')
//NEWDD  DD   DISP=SHR,DSN=TTET.TSK.S.TCEM.NFUTSYX.GPDAA01
//OLDDD  DD   DISP=SHR,DSN=TTET.TSK.S.TCEM.NFUTSYX.T1P2
//OUTDD  DD   DISP=(NEW,PASS,DELETE),UNIT=SYSDA,
//       DCB=(RECFM=FBA,LRECL=204,BLKSIZE=4080,DSORG=PS),
//       SPACE=(TRK,(1,1)),
//       DSN=&&S12
//SYSIN   DD   DUMMY
//COMP13    EXEC  PGM=ISRSUPC,PARM=('DELTAL,LINECMP,WIDE')
//NEWDD  DD   DISP=SHR,DSN=TTET.TSK.S.TCEM.NFUTSYX.GPDAP01
//OLDDD  DD   DISP=SHR,DSN=TTET.TSK.S.TCEM.NFUTSYX.T1A1
//OUTDD  DD   DISP=(NEW,PASS,DELETE),UNIT=SYSDA,
//       DCB=(RECFM=FBA,LRECL=204,BLKSIZE=4080,DSORG=PS),
//       SPACE=(TRK,(1,1)),
//       DSN=&&S13
//SYSIN   DD   DUMMY
//COMP14    EXEC  PGM=ISRSUPC,PARM=('DELTAL,LINECMP,WIDE')
//NEWDD  DD   DISP=SHR,DSN=TTET.TSK.S.TCEM.NFUTSYX.GPDAP01
//OLDDD  DD   DISP=SHR,DSN=TTET.TSK.S.TCEM.NFUTSYX.T1P2
//OUTDD  DD   DISP=(NEW,PASS,DELETE),UNIT=SYSDA,
//       DCB=(RECFM=FBA,LRECL=204,BLKSIZE=4080,DSORG=PS),
//       SPACE=(TRK,(1,1)),
//       DSN=&&S14
//SYSIN   DD   DUMMY
//COMP15    EXEC  PGM=ISRSUPC,PARM=('DELTAL,LINECMP,WIDE')
//NEWDD  DD   DISP=SHR,DSN=TTET.TSK.S.TCEM.NFUTSYX.T1A1
//OLDDD  DD   DISP=SHR,DSN=TTET.TSK.S.TCEM.NFUTSYX.T1P2
//OUTDD  DD   DISP=(NEW,PASS,DELETE),UNIT=SYSDA,
//       DCB=(RECFM=FBA,LRECL=204,BLKSIZE=4080,DSORG=PS),
//       SPACE=(TRK,(1,1)),
//       DSN=&&S15
//SYSIN   DD   DUMMY
//STEPACUM EXEC PGM=IEBGENER,REGION=0K
//SYSPRINT DD SYSOUT=*
//SYSIN    DD DUMMY
//SYSUT2   DD DISP=(NEW,CATLG,CATLG),UNIT=DISK,
//         DCB=(RECFM=FBA,LRECL=204,BLKSIZE=4080,DSORG=PS),
//         SPACE=(TRK,(60,1),RLSE),
//         DSN=TTET.TSK.S.TCEM.NFUTSYX
//SYSUT1 DD DISP=(OLD,DELETE,DELETE),DSN=&&S1
//       DD DISP=(OLD,DELETE,DELETE),DSN=&&S2
//       DD DISP=(OLD,DELETE,DELETE),DSN=&&S3
//       DD DISP=(OLD,DELETE,DELETE),DSN=&&S4
//       DD DISP=(OLD,DELETE,DELETE),DSN=&&S5
//       DD DISP=(OLD,DELETE,DELETE),DSN=&&S6
//       DD DISP=(OLD,DELETE,DELETE),DSN=&&S7
//       DD DISP=(OLD,DELETE,DELETE),DSN=&&S8
//       DD DISP=(OLD,DELETE,DELETE),DSN=&&S9
//       DD DISP=(OLD,DELETE,DELETE),DSN=&&S10
//       DD DISP=(OLD,DELETE,DELETE),DSN=&&S11
//       DD DISP=(OLD,DELETE,DELETE),DSN=&&S12
//       DD DISP=(OLD,DELETE,DELETE),DSN=&&S13
//       DD DISP=(OLD,DELETE,DELETE),DSN=&&S14
//       DD DISP=(OLD,DELETE,DELETE),DSN=&&S15
###END $$
$$$BEG TSTUNKWN
/*********************************************\
|*                                           *|
|* CREATE SRC LINE STEM ARRAY                *|
|* S.A.B  S IS THE BASE NAME                 *|
|*        A IS THE LINE #                    *|
|*        B ARE THE COMPONENTS OF THE LINE   *|
|*          WHERE                            *|
|*    A STATIC VAR WILL NOT BEGIN WITH       *|
|*      FNDWDS LIST                          *|
|*    A DYN VAR HAS ONLY ONE OF FND VARS     *|
|*      AND BE OF LENGTH 1                   *|
|*                                           *|
\*********************************************/
  S# = 1
  A# = 0
  B# = 0
TOPSRCLOP:
  SUBCMD=STRIP(SRC.SRC#PTR,'B')
  SCL=LENGTH(SUBCMD)
  Q = 1
  J = 0
TOPFNDWDS:
  SWD=WORD(FMDWDS,Q)
TOPFNDWLP:
  IF LENGTH(SUBCMD) < 1 THEN SIGNAL DONFNDLP
  JP = POS(SWD,SUBCMD)
  J=J+1
  IF JP>0 THEN DO
   IF JP = 1 THEN DO
    SC.J = SWD
    IF LENGTH(SUBCMD) > 1 THEN SUBCMD=SUBSTR(SUBCMD,2)
     ELSE SIGNAL DONFNDLP
   END
   ELSE DO
    SC.J = SUBSTR(SUBCMD,1,JP-1)
    J=J+1
    SC.J = SWD
    IF JP < LENGTH(SUBCMD) THEN SUBCMD=SUBSTR(SUBCMD,JP+1)
     ELSE SIGNAL DONFNDLP
   END
  ELSE DO
  SC.J = SUBCMD
  SIGNAL DONFNDLP
  END
 SIGNAL TOPFNDWLP
DONFNDLP:
 IF J = 0 THEN SIGNAL SRC_EMPTY
 DO K = 1 TO J
  TMP=SC.K
  IF TMP = SWD THEN DO
    CALL SUBJOBN
    IF RESULT /= 0 THEN SIGNAL BADJOB
    END
   REALSRC.SRC#PTR=SUBCMD
   END
###END TSTUNKWN
$$$BEG MAKEIEBC
 /* REXX */
 /* CEMHELP BEGIN                                                     */
 /* CEMHELA MAKEIEBC - CREATE IEBCOPY JOB BASED ON SOURCE DSN LIST    */
 /* CEMHELP MAKEIEBC - CREATE IEBCOPY JOB BASED ON LIST OF SOURCE DSN.*/
 /* CEMHELP          - YOU PROVIDE A LIST OF DSN IN A DS AND THIS     */
 /* CEMHELP          - EXEC WILL CREATE JCL OUTPUT WHICH YOU CAN THEN */
 /* CEMHELP          - EDIT TO FINAL REQUIREMENTS.  EXEC EXPECTS THE  */
 /* CEMHELP          - TARGETS TO BE NEWLY CREATED.  SOME ADJUSTMENT  */
 /* CEMHELP          - WILL BE MADE TO OVER OR UNDER ALLOCATION OF THE*/
 /* CEMHELP          - SOURCE DSN.  ULTIMATELY, YOU CAN EDIT THE FINAL*/
 /* CEMHELP          - JCL BEFORE SAVING AND SUBMITTING TO JES.       */
 /* CEMHELP END                                                       */
  ADDRESS ISPEXEC
  SUID = SYSVAR(SYSUID)
  IF SUID = 'TCEM' THEN DO
   EDSN = 'TTEP.TSK.P.TCEM.NOTES'
   EMBR = 'DSNLISTA'
   ODSN = 'TTEP.TSK.P.TCEM.NOTES'
   OMBR = 'KIX510'
   END
   ELSE DO
   EDSN = SUID||'.SOURCE.DSNLIST'
   EMBR = '%MEMBER%'
   ODSN = SUID||'.TARGET.IEBCJCL'
   OMBR = '%MEMBER%'
   END
  EXECSEL = 'MAKEIEBC'
  "ISPEXEC VPUT (EDSN EMBR EXECSEL) ASIS"
  IF RC ^= 0 THEN SIGNAL EXITRC8
/*  "ISPEXEC ADDPOP ROW(3) COLUMN(10)" */
  IF RC ^= 0 THEN SIGNAL EXITRC8
  DSEMSG = 'ENTER DSN LIST SRCDSN AND MBR'
 SRCLOOP:
  "ISPEXEC VPUT (DSEMSG) ASIS"
  IF RC ^= 0 THEN SIGNAL EXITRC8
  CALL GDSNNMBR
  IF RESULT ^= 0 THEN SIGNAL CANCEL8
  CALL VLDTTGT
 /*   0 IF THE DSN IS VALID AND EXISTS                                */
 /*   4 IF THE DSN IS VALID BUT IS UNAVAILABLE (HMIGR???)             */
 /*   8 IF DSN PASSED IS INVALID OR EXEC ERROR                        */
 /*  12 IF DSN DOES NOT EXIST                                         */
 /*  16 IF ATTN RTN WAS ENTERED                                       */
  XC = RC
  IF XC = 0 THEN SIGNAL TSTMBR
  IF XC > 12 THEN SIGNAL CANCEL8
  DSEMSG = 'DSN INAVLID OR IN ERROR. RETRY'
  SIGNAL SRCLOOP
 TSTMBR:
  "ISPEXEC VGET (EDSN EMBR) ASIS"
  IF EMBR = '' THEN DO
   TMBR = ''
   SIGNAL DOALOC
   END
  TMBR = '('||STRIP(EMBR,'B')||')'
  IF SYSDSN("'"EDSN||TMBR"'") ^= 'OK' THEN DO
   DSEMSG = 'MBR IS NOT FOUND. RETRY'
   SIGNAL SRCLOOP
   END
 DOALOC:
  /* "ISPEXEC REMPOP" */
  ADDRESS TSO
  "ALLOC FI(INLST) DA('"EDSN||TMBR"') SHR"
  "EXECIO * DISKR INLST (STEM MBRL. FINIS"
  "FREE FI(INLST)"
  COMA = ','
  DSHLQ = 'TTET'
  ADDRESS TSO
  I = 1
  N = 2
  OP.1 = '//IEBCSTP  EXEC  PGM=IEBCOPY,REGION=0K'
  OP.2 = '//SYSPRINT DD SYSOUT=*'
  P = 0
 TOPOFLOP:
  OURDSN = STRIP(WORD(MBRL.I,1),'B')
  NDSHLQ = POS('.',OURDSN)
  NEWDSN = DSHLQ||SUBSTR(OURDSN,NDSHLQ)
  CALL MALOC OURDSN
  IF RESULT ^= 0 THEN DO
   LSFX = '//* '
   ELNE = '//* SRC DSN IS IN ERROR'
   SIGNAL BYPLDI
   END
  CALL MALOC NEWDSN
  IF RESULT ^= 12 THEN DO
   LSFX = '//**'
   ELNE = '//* TGT DSN IS IN ERROR'
   SIGNAL BYPLDI
   END
  X=LISTDSI("'"OURDSN"'" DIRECTORY)
  LSFX = '//'
  MYDSO=SYSDSORG
  MYRECFM=SYSRECFM
  MYLRECL=SYSLRECL
  MYBLKSZ=SYSBLKSIZE
  MYADBLK=SYSADIRBLK
  MYUDBLK=SYSUDIRBLK
  MYALLOC=SYSALLOC
  MYUSED=SYSUSED
  ELNE = ''
  IF MYUSED > SYSPRIMARY THEN DO
   ELNE = '//* U='MYUSED' A='SYSPRIMARY
   MYALOC = MYUSED
   END
   ELSE DO
   MYALOC = SYSPRIMARY
   END
  IF SYSUNITS = 'CYLINDER' THEN MYUNITS = 'CYL'
   ELSE IF SYSUNITS = 'TRACK' THEN MYUNITS = 'TRK'
    ELSE IF SYSUNITS = 'BLOCK' THEN MYUNITS = MYBLKSZ
  MYSEC=SYSSECONDS
  MYEXT=SYSEXTENTS
  IF MYUDBLK='' | MYADBLK = '' THEN DO
   ELNE = ELNE||'//* NOT SEQUENTIAL. BYPASS'
   SIGNAL BYPLDI
   END
  PCTDBLK = (MYUDBLK/MYADBLK)
  IF PCTDBLK > 0.90 THEN DO
   ELNE = ELNE||'//* UDB='MYUDBLK' ADB='MYADBLK
   MYADBLK = MYADBLK + TRUNC(MYADBLK*.10,0)
   END
   ELSE DO
    IF PCTDBLK < 0.50 THEN DO
     ELNE = ELNE||'//* UDB='MYUDBLK' ADB='MYADBLK
     MYADBLK = MYADBLK - TRUNC(MYADBLK*.40,0)
     END
    END
 BYPLDI:
  P=P+1
  IF ELNE ^= '' THEN DO
   N=N+1
   OP.N = ELNE
   END
  N=N+1
  OP.N = LSFX'I'P'  DD DSN='OURDSN',DISP=SHR'
  N=N+1
  OP.N = LSFX'O'P'  DD DSN='NEWDSN','
  IF LSFX = '//* ' THEN SIGNAL BYPATTR
  N=N+1
  OP.N = LSFX'   DISP=(NEW,CATLG),UNIT=DISK,'
  N=N+1
  OP.N =LSFX'   DCB=(RECFM='MYRECFM',BLKSIZE='MYBLKSZ',LRECL='MYLRECL||,
     ',DSORG='MYDSO'),'
  N=N+1
  OP.N = LSFX'   SPACE=('MYUNITS',('MYALOC','MYSEC','MYADBLK'),,CONTIG)'
 IF LSFX = '//' THEN DO
  PP.P = ' C I=I'P',O=O'P
  END
 BYPATTR:
  I = I+1
  IF I ^> MBRL.0 THEN SIGNAL TOPOFLOP
/* OUT OF LOOP HERE */
  N=N+1
  OP.N = '//SYSIN DD *'
  DO J = 1 TO P
   IF SUBSTR(PP.J,1,4) ^= ' C I' THEN ITERATE
   N = N+1
   OP.N = PP.J
   END
  N=N+1
  OP.N = '/*'
  EDSN = ODSN
  EMBR = OMBR
  "ISPEXEC VPUT (EDSN EMBR) ASIS"
  IF RC ^= 0 THEN SIGNAL EXITRC8
 /* "ISPEXEC ADDPOP ROW(3) COLUMN(10)" */
  IF RC ^= 0 THEN SIGNAL EXITRC8
  DSEMSG = 'ENTER TGT DSN(MBR) FOR IEBC JCL'
 TGTLOOP:
  SVDISP = 'MOD REP'
  "ISPEXEC VPUT (DSEMSG SVDISP) ASIS"
  IF RC ^= 0 THEN SIGNAL DSPOPX8
  CALL GDSNOMBR
  IF RESULT ^= 0 THEN SIGNAL CANCEL8
  "ISPEXEC VGET (EDSN EMBR SVDISP) ASIS"
  IF RC ^= 0 THEN SIGNAL DSPOPX8
  IF SVDISP ^= 'MOD' & SVDISP ^= 'REP' THEN SIGNAL TGTLOOP
  IF EMBR = '' THEN DO
   TMBR = ''
   SIGNAL OP2TGT
   END
   ELSE  TMBR = '('||STRIP(EMBR,'B')||')'
  IF SVDISP = 'MOD' THEN DO
   IF SYSDSN("'"EDSN||TMBR"'") ^= 'OK' THEN SVDISP = 'REP'
   END
 OP2TGT:
/*  "ISPEXEC REMPOP" */
  ADDRESS TSO
  OPTN = 0
  IF SVDISP = 'MOD' THEN DO
   "ALLOC FI(M) DA('"EDSN||TMBR"') SHR"
   "EXECIO * DISKR I (STEM OPT. FINIS"
   "FREE FI(I)"
   OPTN=OPT.0
   END
  J = OPTN
  DO I = 1 TO N
   J = J+1
   OPT.J = OP.I
   END
  OPT.0 = J
  "ALLOC FI(O) DA('"EDSN||TMBR"') SHR"
  "EXECIO * DISKW O (STEM OPT. FINIS"
  XC = RC
  "FREE FI(O)"
  IF XC ^= 0 THEN SIGNAL EXITRC8
  ADDRESS ISPEXEC "EDIT DATASET('"EDSN||TMBR"')"
   RETURN 0
 DSKOPX8:
 /* "ISPEXEC REMPOP" */
  DO I = 1 TO N
   SAY OP.I
   END
 CANCEL8:
 /* "ISPEXEC REMPOP" */
  SAY 'CANCEL, ABORT OR ERROR OCCURRED. RC = 8'
  RETURN 8
 NOTCPU:
  RETURN 4
 EXITRC2:
  RETURN 2
 EXITRC4:
  RETURN 4
 EXITRC8:
  RETURN 8
###END MAKEIEBC
$$$BEG EXPLLDSI
 /* REXX */
 /*TRACE I */
   TRACE ?I
 ARG OURDSN
 UPPER OURDSN
 IF OURDSN = '' THEN SIGNAL NOCLONE
 IF LENGTH(OURDSN) < 9 THEN DO
  IF DATATYPE(SUBSTR(OURDSN,1,1)) ^= 'CHAR' THEN SIGNAL NOCLONE
  INTERPRET "XC=LISTDSI("OURDSN" FILE DIRECTORY NORECALL)"
  END
  ELSE DO
  XC=LISTDSI("'"OURDSN"'" DIRECTORY NORECALL)
  END
 RETSTR=''
 IF XC ^= 0 THEN SIGNAL NOCLONE
 MYCDT = SYSCREATE
 RETSTR=RETSTR||'SYSCREATE('||SYSCREATE||') '
 MYREFDT = SYSREFDATE
 RETSTR=RETSTR||'SYSREFDATE('||SYSREFDATE||') '
 MYVOL=SYSVOLUME
 RETSTR=RETSTR||'SYSVOLUME('||SYSREFDATE||') '
 TRACE I
 MYDSO=SYSDSORG
 RETSTR=RETSTR||'SYSDSORG('||SYSDSORG||') '
 MYDSSM=SYSDSSMS
 RETSTR=RETSTR||'SYSDSSMS('||SYSDSSMS||') '
 MYRECFM=SYSRECFM
 RETSTR=RETSTR||'SYSRECFM('||SYSRECFM||') '
 MYLRECL=SYSLRECL
 RETSTR=RETSTR||'SYSLRECL('||SYSLRECL||') '
 MYBLKSZ=SYSBLKSIZE
 RETSTR=RETSTR||'SYSBLKSIZE('||SYSBLKSIZE||') '
 MYMEM=SYSMEMBERS
 RETSTR=RETSTR||'SYSMEMBERS('||SYSMEMBERS||') '
 MYADBLK=SYSADIRBLK
 RETSTR=RETSTR||'SYSADIRBLK('||SYSADIRBLK||') '
 MYUDBLK=SYSUDIRBLK
 RETSTR=RETSTR||'SYSUDIRBLK('||SYSUDIRBLK||') '
 MYALLOC=SYSALLOC
 RETSTR=RETSTR||'SYSALLOC('||SYSALLOC||') '
 MYUSED=SYSUSED
 RETSTR=RETSTR||'SYSUSED('||SYSUSED||') '
 MYUNITS=SYSUNITS
 RETSTR=RETSTR||'SYSUNITS('||SYSUNITS||') '
 MYEXT=SYSEXTENTS
 RETSTR=RETSTR||'SYSEXTENTS('||SYSEXTENTS||') '
 MYPRI=SYSPRIMARY
 RETSTR=RETSTR||'SYSPRIMARY('||SYSPRIMARY||') '
 MYSEC=SYSSECONDS
 RETSTR=RETSTR||'SYSSECONDS('||SYSSECONDS||') '
 MYTPC=SYSTRKSCYL
 RETSTR=RETSTR||'SYSTRKSCYL('||SYSTRKSCYL||') '
 TRACE OFF
 MYBPT=SYSBLKSTRK
 RETSTR=RETSTR||'SYSBLKSTRK('||SYSBLKSTRK||') '
 MYSYSR1 = SYSMSGLVL1
 RETSTR=RETSTR||'SYSMSGLVL1('||SYSMSGLVL1||') '
 MYSYSR2 = SYSMSGLVL2
 RETSTR=RETSTR||'SYSMSGLVL2('||SYSMSGLVL2||') '
 MYSYSR  = SYSREASON
 RETSTR=RETSTR||'SYSREASON('||SYSREASON||')'
 PUSH RETSTR
 RETURN 0
NOCLONE:
 RETURN 4
###END EXPLLDSI
$$$BEG RXVTESTK
/* REXX */

/*
Exec to test various RXVSAM functions with a KSDS.  Assumes the KSDS
has already been defined by exec RXVSETR
*/
address TSO
trace ?i
ARG user
IF user = '' THEN user = SYSVAR(SYSUID)

dsn = user || '.VSAMKSDS'
log# = 1                    /* log record number */

/*
ADDRESS TSO "ALLOCATE FILE(SNAPDBUG) DSNAME('ZMXW009.SNAPDBUG') MOD"
IF rc \= 0 THEN
  DO
    SAY 'Allocate failed for SNAPDBUG with a return code of' rc
    EXIT rc
  END
*/

ADDRESS TSO "ALLOCATE FILE(VSAMFILE) DSNAME('"dsn"') SHR"
IF rc \= 0 THEN
  DO
    SAY 'Allocate failed for VSAMFILE with a return code of' rc
    EXIT rc
  END

CALL EXPLLDEF ISPLLIB TTEP.TSK.E.TCEM.PDSE UNCOND
rxvsam_result = RXVSAM('OPENOUTPUT','VSAMFILE','KSDS')
IF rxvsam_result /= 0 THEN
  DO
    log.log# = 'OPENOUTPUT failed: '
    log# = log# + 1
    CALL log_errors
    SIGNAL close_and_exit
  END

SAY '   ... working' TIME('N')
/*1*/
chartab = 'abcdefghijklmnopqrst'
recs_written = 0
now = DATE('W') DATE('N') TIME('N')
DO i = 1 to 20
  char = SUBSTR(chartab,i,1)
  fillchar = COPIES(char,4)
  key = 'KEY:' || fillchar
  rec_body = 'Record#' i 'was created: ' now
  every5 = i // 5
  IF every5 = 0 THEN
    DO
      fillchar = COPIES('+',50)
      rec_body = rec_body 'LONG (100 bytes) RECORD' fillchar
      rec_body = LEFT(rec_body,92)
    END
  ELSE
    DO
      rec_body = LEFT(rec_body,32)
    END
  my_rec = key || rec_body
  rxvsam_result = RXVSAM('WRITE','VSAMFILE',,'MY_REC')
  IF rxvsam_result = 0 THEN
    DO
      recs_written = recs_written + 1
    END
  ELSE
    DO
      log.log# = 'WRITE failed attempting to write record #' i ':'
      log# = log# + 1
      CALL log_errors
      SIGNAL close_and_exit
    END
END

log.log# =  recs_written 'records written successfully to' dsn
log# = log# + 1

rxvsam_result = RXVSAM('CLOSE','VSAMFILE')
IF rxvsam_result /= 0 THEN
  DO
    log.log# =  'CLOSE (after WRITE loop) failed:'
    log# = log# + 1
    CALL log_errors
    SIGNAL write_log_and_exit
  END

log.log# = 'CLOSE after writing records was successful'
log# = log# + 1
SAY '   ... continuing' TIME('N')

rxvsam_result = RXVSAM('OPENINPUT','VSAMFILE','KSDS')
IF rxvsam_result /= 0 THEN
  DO
    log.log# = 'OPENINPUT failed: '
    log# = log# + 1
    CALL log_errors
    SIGNAL close_and_exit
  END
/*1*/
rxvsam_result = RXVSAM('READNEXT','VSAMFILE',,'MY_REC')
IF rxvsam_result = 0 THEN
  DO
    log.log# = '1st record:'
    log# = log# + 1
    log.log# = '    ' my_rec
    log# = log# + 1
  END
ELSE
  DO
    log.log# = 'First READNEXT failed:'
    log# = log# + 1
    call log_errors
    SIGNAL close_and_exit
  END

recs_read = 1
DO i = 1 to 5
  rxvsam_result = RXVSAM('READNEXT','VSAMFILE',,'MY_REC')
    IF rxvsam_result = 0 THEN
      DO
        recs_read = recs_read + 1
        ITERATE
      END
    ELSE
      DO
        log.log# = 'READNEXT (within loop) failed:'
        log# = log# + 1
        call log_errors
        SIGNAL close_and_exit
      END
END

log.log# = 'Last record read in READNEXT loop:'
log# = log# + 1
log.log# = '    ' my_rec
log# = log# + 1
log.log# = recs_read 'records read for READNEXT test'
log# = log# + 1
SAY '   ... continuing' TIME('N')

/*1*/
rxvsam_result = RXVSAM('READLAST','VSAMFILE',,'MY_REC')
IF rxvsam_result = 0 THEN
  DO
    log.log# = 'Last record:'
    log# = log# + 1
    log.log# = '    ' my_rec
    log# = log# + 1
  END
ELSE
  DO
    log.log# = 'READLAST failed:'
    log# = log# + 1
    call log_errors
    SIGNAL close_and_exit
  END

rxvsam_result = RXVSAM('STARTBWD','VSAMFILE','KEY:pppp','MY_REC')
IF rxvsam_result = 0 THEN
  DO
    log.log# = 'STARTBWD from key "KEY:pppp" was successful'
    log# = log# + 1
  END
ELSE
  DO
    log.log# = 'STARTBWD failed:'
    log# = log# + 1
    call log_errors
    SIGNAL close_and_exit
  END

recs_read = 0
DO 3
  rxvsam_result = RXVSAM('READPREV','VSAMFILE',,'MY_REC')
    IF rxvsam_result = 0 THEN
      DO
        recs_read = recs_read + 1
        ITERATE
      END
    ELSE
      DO
        log.log# = 'READPREV failed:'
        log# = log# + 1
        call log_errors
        SIGNAL close_and_exit
      END
END

log.log# = 'Last record read in READPREV loop:'
log# = log# + 1
log.log# = '    ' my_rec
log# = log# + 1
log.log# = recs_read 'records read for READPREV test'
log# = log# + 1
SAY '   ... continuing' TIME('N')

/*1*/
rxvsam_result = RXVSAM('STARTFWD','VSAMFILE','KEY:cccc','MY_REC')
IF rxvsam_result = 0 THEN
  DO
    log.log# = 'STARTFWD from key "KEY:cccc" was successful'
    log# = log# + 1
  END
ELSE
  DO
    log.log# = 'STARTFWD failed:'
    log# = log# + 1
    call log_errors
    SIGNAL close_and_exit
  END

recs_read = 0
DO 3
  rxvsam_result = RXVSAM('READNEXT','VSAMFILE',,'MY_REC')
    IF rxvsam_result = 0 THEN
      DO
        recs_read = recs_read + 1
        ITERATE
      END
    ELSE
      DO
        log.log# = 'READNEXT (after STARTFWD) failed:'
        log# = log# + 1
        call log_errors
        SIGNAL close_and_exit
      END
END

log.log# = 'Last record read in READNEXT loop:'
log# = log# + 1
log.log# = '    ' my_rec
log# = log# + 1
log.log# = recs_read 'records read for READNEXT (after STARTFWD) test'
log# = log# + 1

rxvsam_result = RXVSAM('CLOSE','VSAMFILE')
IF rxvsam_result /= 0 THEN
  DO
    log.log# =  'CLOSE (after READ tests) failed:'
    log# = log# + 1
    CALL log_errors
    SIGNAL write_log_and_exit
  END

log.log# = 'CLOSE after read tests was successful'
log# = log# + 1
SAY '   ... continuing' TIME('N')
/*1*/

rxvsam_result = RXVSAM('OPENIO','VSAMFILE','KSDS')
IF rxvsam_result /= 0 THEN
  DO
    log.log# = 'OPENIO failed: '
    log# = log# + 1
    CALL log_errors
    SIGNAL close_and_exit
  END

rxvsam_result = RXVSAM('READ','VSAMFILE','KEY:mmmm','MY_REC')
IF rxvsam_result /= 0 THEN
  DO
    log.log# = 'READ for "KEY:mmmm" failed:'
    log# = log# + 1
    CALL log_errors
    SIGNAL close_and_exit
  END

rxvsam_result = RXVSAM('DELETE','VSAMFILE','KEY:mmmm','MY_REC')
IF rxvsam_result /= 0 THEN
  DO
    log.log# = 'DELETE for "KEY:mmmm" failed:'
    log# = log# + 1
    CALL log_errors
    SIGNAL close_and_exit
  END

log.log# = 'Record "KEY:mmmm" successfully erased via READ + DELETE'
log# = log# + 1

SAY '   ... continuing' TIME('N')
/*1*/

rxvsam_result = RXVSAM('READ','VSAMFILE','KEY:bbbb','MY_REC')
IF rxvsam_result /= 0 THEN
  DO
    log.log# = 'Read of "KEY:bbbb" failed:'
    log# = log# + 1
    CALL log_errors
    SIGNAL close_and_exit
  END

my_rec = SUBSTR(my_rec,1,55) 'was updated at' TIME('N')
my_rec = LEFT(my_rec,80)
rxvsam_result = RXVSAM('REWRITE','VSAMFILE','KEY:bbbb','MY_REC')
IF rxvsam_result /= 0 THEN
  DO
    log.log# = 'REWRITE of "KEY:bbbb" failed:'
    log# = log# + 1
    CALL log_errors
    SIGNAL close_and_exit
  END

log.log# = 'Update of "KEY:bbbb" via READ + REWRITE was successful'
log# = log# + 1

rxvsam_result = RXVSAM('CLOSE','VSAMFILE')
IF rxvsam_result /= 0 THEN
  DO
    log.log# =  'CLOSE (after I-O tests) failed:'
    log# = log# + 1
    CALL log_errors
    SIGNAL write_log_and_exit
  END
SAY '   ... continuing' TIME('N')
/*1*/
rxvsam_result = RXVSAM('OPENOUTPUT','VSAMFILE','KSDS')
IF rxvsam_result /= 0 THEN
  DO
    log.log# =  'Final OPENOUTPUT failed:'
    log# = log# + 1
    CALL log_errors
    SIGNAL write_log_and_exit
  END

my_rec = 'KEY:ffaa was added via WRITE at' TIME('N')
my_rec = LEFT(my_rec,40)
rxvsam_result = RXVSAM('WRITE','VSAMFILE','KEY:ffaa','MY_REC')
IF rxvsam_result /= 0 THEN
  DO
    log.log# = 'WRITE of "KEY:ffaa" failed:'
    log# = log# + 1
    CALL log_errors
    SIGNAL close_and_exit
  END

log.log# = 'WRITE of "KEY:ffaa" was successful'
log# = log# + 1

SAY '   ... finishing' TIME('N')

/*1*/

close_and_exit: NOP
rxvsam_result = RXVSAM('CLOSE','VSAMFILE')
IF rxvsam_result /= 0 THEN
  DO
    log.log# =  'Final CLOSE failed:'
    log# = log# + 1
    CALL log_errors
  END

write_log_and_exit: NOP
log.log# = '   ... End of LOG'
SAY 'Display log? (Y/N)'
PULL answer
IF answer = 'Y' THEN
  DO i = 1 TO log#
    SAY log.i
  END

ADDRESS TSO "FREE FILE(VSAMFILE)"
/*
ADDRESS TSO "FREE FILE(SNAPDBUG)"
*/

EXIT
/*1*/
log_errors: nop

log.log# =  '  Return msg -->  ' rxvsam_returnmsg
log# = log# + 1
log.log# =  '  Error msg -->   ' rxvsam_vsamerrormsg
log# = log# + 1

RETURN


###END RXVTESTK
$$$BEG RXVSET
/* REXX */

/*
This exec will set up an ESDS VSAM file for use by the other execs that
test the RXVSAM function.
*/

address tso
trace ?i
ARG user
IF user = '' THEN user = SYSVAR(SYSUID)
/*
SAY 'Please enter a 6 character volume id for definition of an ESDS'
PARSE UPPER PULL vol
IF LENGTH(vol) \= 6 THEN
  DO
    SAY vol 'is not 6 characters'
    EXIT 8
  END
*/
dsn = user || '.VSAMESDS'

address TSO "DELETE '"dsn"' PURGE"   /* ignore r.c. */

address TSO "DEFINE CLUSTER (NAME('"dsn"') NONINDEXED RECSZ(80 80) ",
    "REUSE SHAREOPTIONS(2 3)) ",
    "DATA (NAME('"dsn".DATA')  CYLINDERS(1 1))"

SAY "Return code after ESDS DEFINE was" rc

/*
This exec will set up a KSDS VSAM file for use by the other execs that
test the RXVSAM function.
*/

ARG user
IF user = '' THEN user = SYSVAR(sysuid)
/*
SAY 'Please enter a 6 character volume id for definition of an ESDS'
PARSE UPPER PULL vol
IF LENGTH(vol) \= 6 THEN
  DO
    SAY vol 'is not 6 characters'
    EXIT 8
  END
*/
dsn = user || '.VSAMKSDS'

address TSO "DELETE '"dsn"' PURGE"   /* ignore r.c. */

address TSO "DEFINE CLUSTER (NAME('"dsn"') INDEXED RECSZ(40 200) ",
    "KEYS(8 0) REUSE  SHAREOPTIONS(2 3)) ",
    "DATA (NAME('"dsn".DATA')  CYLINDERS(3 1))",
    "INDEX (NAME('"dsn".INDEX')  TRACKS(2 1))"

SAY "Return code after KSDS DEFINE was" rc

/*
This exec will set up an RRDS VSAM file for use by the other execs that
test the RXVSAM function.
*/

ARG user
IF user = '' THEN user = SYSVAR(sysuid)
/*
SAY 'Please enter a 6 character volume id for definition of an RRDS'
PARSE UPPER PULL vol
IF LENGTH(vol) \= 6 THEN
  DO
    SAY vol 'is not 6 characters'
    EXIT 8
  END
*/
dsn = user || '.VSAMRRDS'

address TSO "DELETE '"dsn"' PURGE"   /* ignore r.c. */

address TSO "DEFINE CLUSTER (NAME('"dsn"') NUMBERED RECSZ(80 80) ",
    "REUSE  SHAREOPTIONS(2 3)) ",
    "DATA (NAME('"dsn".DATA') CYLINDERS(3 1))"

SAY "Return code after RRDS DEFINE was" rc

exit

###END RXVSET
$$$BEG EXCIS0A
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA EXCIS0   - SUBROUTINE TO AFOLIST. SEE AFOLIST           */
 /* CEMHELP EXCIS0   - SUBROUTINE TO AFOLIST. SEE AFOLIST           */
 /* CEMHELP          -                                              */
 /* CEMHELP END                                                     */
 /*                                                                 */
 /* REQUIRED PARAMETERS:                                            */
 /*  MYFUNC - FIRST PARM IDENTIFIES THE OUTPUT PROCESS              */
 /*         - SEE VAR VALFUNC                                       */
 /*  MYCMD  - DESIRED COMMAND PROCESSING OPTION                     */
 /*           SEE VAR VALPRMS                                       */
 /*  MYAPLID() - TARGET APPLID(S) EXPECTED AS COMMA DELM LIST       */
 /*  ODSN   - IF QUIET, IDENTIFIES THE TARGET DSN TO COLLECT THE    */
 /*           RESULTS                                               */
 /*                                                                 */
 /*  PARMS MUST BE IN THE FORMAT                                    */
 /*   ACTUAL LITERAL (SEE VALPRMS FOR LIST) EXPL: MYAPLID           */
 /*     MYAPLID=XXXX   SINGLE CHOICE                                */
 /*            =(XXXX YYYY ....) MULTIPLE CHOICES                   */
 /*            (XXXX YYYY ....) MULTIPLE CHOICES                    */
 /*            =<IIII> IDENTIFIES AN ISPFVAR NAME                   */
 /*            <IIII>                                               */
 /*    IIII ISPFVAR NAME - IS THE ACTUAL NAME OF AN ISPFVAR         */
 /*            WHICH WILL BE VGET. THE CONTENTS OF THAT VAR         */
 /*            WILL BE USED AS A LIST                               */
 /*                                                                 */
 /*  MYCMD   CAN NOT BE A LIST. IT IS USED TO DEFINE A SINGLE       */
 /*          COMMAND, TO BE USED WITH THE APPLID LIST               */
 /*          IF MYCMD IS LIST, CEMT, OR CEDA THEN YOU MUST          */
 /*          PROVIDE A MYCA AND MYCAL VARIABLE                      */
 /*                                                                 */
 /*  MYTRANID(T) THE NAME OF THE TRANS ID TO USE  IF MYCMD IS LINK  */
 /*          PASSED IN AN ISPF VAR AND THE T IS THE VARIABLE NAME   */
 /*                                                                 */
 /*  MYPROG(P) THE NAME OF THE PROGRAM TO LINK TO IF MYCMD IS LINK  */
 /*          PASSED IN AN ISPF VAR AND THE P IS THE VARIABLE NAME   */
 /*                                                                 */
 /*  MYCA<X> THE COMMAREA  ASSOCIATED WITH THE COMMAND MUST BE      */
 /*          PASSED IN AN ISPF VAR AND THE X IS THE VARIABLE NAME   */
 /*                                                                 */
 /*  MYCAL<Y> SPEFICIES THE NAME OF THE ISPF VAR, WHICH DEFINES THE */
 /*          DESIRED COMMAREA LENGTH (0 - 32400)                    */
 /*          PASSED IN AN ISPF VAR AND THE Y IS THE VARIABLE NAME   */
 /*                                                                 */
 /*  ODSN - CAN BE 'DISPLAY' WHICH WILL DISPLAY UP TO 99 LINES      */
 /*       - A DATASET (NEW OR EXISTING) IF EXISTING, YOU ARE        */
 /*         PROMPTED TO ACCEPT REUSE. IT CAN BE A PDS(E) WITH MBR   */
 /*                                                                 */
 /*                                                                 */
 /*                                                                 */
 /*                                                                 */
  ADDRESS ISPEXEC
  "ISPEXEC CONTROL ERRORS RETURN"
  ARG MYFUNC PRMS
  IF MYFUNC = '' THEN SIGNAL BADFUNC
  VALFUNC = 'MSGBOXONLY MSGBOXALL VERBOSE QUIET'
  VALPRMS='MYCMD MYAPLID ODSN MYCA MYCAL MYPROG MYTRANID'
  VALCMDS = 'PING CEMT CEDA LINK'
  DFTPVALS='PING . .'
  IF PRMS ^= '' THEN DO
   NPW=WORDS(VALPRMS)
   DO I = 1 TO NPW
    TMP = WORD(VALPRMS,I)
    TMPV = WORD(DFTPVALS,I)
    IF TMPV = '.' THEN TMPV = ''
     ELSE IF TMPV = '\.' THEN TMPV = '.'
    INTERPRET TMP"='"TMPV"'"
    END
   END
   X15='15'X
   XFF='FF'X
   ERRMSG = ''
   I=0
   PRM_RC = 0
   DLM='(<{[='
   MDLM=')>}] '
   #DMM=LENGTH(DLM)
PRMLOOP:
   IF PRMS = '' THEN SIGNAL DONEPRMS
   PRMX = ''
   PARSE VAR PRMS PRM PRMS
   IF PRM = '' THEN SIGNAL EXITRC8
   PRM=PRM||' ' /* TACK ON A SPACE TO HELP FIND '=' END */
   L_PRM=LENGTH(PRM)
   FDLM = ''
   EDLM = ''
   DO I = 2 TO L_PRM
    PP=SUBSTR(PRM,I,1)
    CKPP=POS(PP,DLM)
    IF CKPP ^= 0 THEN DO
     FDLM=SUBSTR(DLM,CKPP,1)
     EDLM=SUBSTR(MDLM,CKPP,1)
     LEAVE
     END
    END
   IF FDLM = '' THEN SIGNAL BADPARM
   IF I >= L_PRM THEN SIGNAL BADPARM
   LP = LASTPOS(EDLM,PRM)
   IF LP = 0 THEN LP=L_PRM
    ELSE LP = LP - 1
   PRMVAL = SUBSTR(PRM,I+1,LP-I)
   PRM = SUBSTR(PRM,1,I-1)
   IF PP = '=' THEN SIGNAL GOTEQ
   IF PP = '<' THEN SIGNAL GOTBRKT
   SIGNAL GOTPARNT
GOTEQ:
   IF PRMVAL = '' THEN SIGNAL BADPARM
   L_PRM=LENGTH(PRMVAL)
   PP = SUBSTR(PRMVAL,1,1)
   CKPP=POS(PP,DLM)
   IF CKPP = 0 THEN DO
    SIGNAL GOT_PRMVAL
    END
   I = 1
   FDLM=SUBSTR(DLM,CKPP,1)
   EDLM=SUBSTR(MDLM,CKPP,1)
   LP = LASTPOS(EDLM,PRMVAL)
   IF LP = 0 THEN LP=L_PRM
    ELSE LP = LP - 1
   PRMVAL = SUBSTR(PRMVAL,I+1,LP-I)
   IF PP = '<' THEN SIGNAL GOTBRKT
   SIGNAL GOTPARNT
GOTPARNT:
   PARSE VAR PRMVAL . '<' TMPVAL '>'
   IF TMPVAL ^= '' THEN DO
    PRMVAL = TMPVAL
    SIGNAL GOTBRKT
    END
   SIGNAL GOT_SIMPLE
GOTBRKT:
   IF LENGTH(PRMVAL) > 8 THEN SIGNAL BADPARM
   "ISPEXEC VGET ("PRMVAL") ASIS"
   INTERPRET "PRMVAL = "PRMVAL
/* IF PRMVAL = '' THEN SIGNAL BADPARM */
   SIGNAL NXTPRMS
BADPARM:
    ERRMSG = ERRMSG||XFF||,
       'PARM:'PRM' IS NOT A EXPECTED PARAMETER. BYPASSING.'
    PRM_RC = 4
    SIGNAL      NXTPRMS
GOT_SIMPLE:
GOT_PRMVAL:
   INTERPRET PRM "='"||PRMVAL||"'"
NXTPRMS:
   TRACE OFF
   SIGNAL PRMLOOP
DONEPRMS:
/* TRACE I */
   IF PRM_RC > 4 THEN SIGNAL EXITRC4
   IF MYFUNC = '' THEN SIGNAL EXITRC8
   IF MYFUNC = 'QUIET' THEN DO
    IF ODSN = '' | ODSN = 'ODSN' THEN DO
     CALL GETUDSN 'AFOLIST'
     PULL ODSN
     END
    IF ODSN = '' THEN SIGNAL EXITRC10
    SIGNAL GOTFUNC
    END
   IF MYFUNC = 'MSGBOXONLY' THEN SIGNAL GOTFUNC
   IF MYFUNC = 'MSGBOXALL' THEN SIGNAL GOTFUNC
   IF MYFUNC = 'VERBOSE' THEN SIGNAL GOTFUNC
   SIGNAL EXITRC8
 GOTFUNC:
   IF WORDPOS(MYCMD,VALCMDS) = 0 THEN SIGNAL EXITRC12
   IF MYCMD = 'PING' THEN DO
    MYCA = 'PING'
    MYCAL = 1080
    SIGNAL SETPROG
    END
   IF MYCA = '' THEN SIGNAL BADCA
   IF MYCAL = '' THEN SIGNAL BADCA
   IF DATATYPE(MYCAL) ^= 'NUM' THEN SIGNAL BADCA
   IF MYCAL < 0 | MYCAL > 32400 THEN SIGNAL BADCA
   IF MYCMD = 'LINK' THEN DO
    IF MYPROG = '' THEN SIGNAL BADLINK
    IF MYTRANID = '' THEN MYTRANID = 'CSMI'
     ELSE DO
     LTRID = LENGTH(MYTRANID)
     IF LTRID < 1 | LTRID > 4 THEN SIGNAL BADLINK
     END
    SIGNAL SET_H_VARS
    END
SETPROG:
   IF MYTRANID = '' THEN MYTRANID = 'CSMI'
   MYPROG='UCEMPINN'
SET_H_VARS:
   L_CA = LENGTH(MYCA)
   IF MYCAL < L_CA THEN MYCAL = L_CA
   H_MYCA = MYCA
   H_MYCAL = MYCAL
   H_MYPROG = MYPROG
   H_MYTRANID = MYTRANID
   TOTLNG=0
TSTAPLIDS:
   I = 0
   COMA=','
   IF MYAPLID = '' THEN SIGNAL EXITRC16
   SAY 'EXCIS0A:MYAPLID:'MYAPLID
   DO WHILE(MYAPLID ^= '')
    I = I + 1
    PARSE VAR MYAPLID APL_STM.I MYAPLID
    SAY 'EXCIS0A:APPLID:'APL_STM.I
 TRACE OFF
    END
 /* OK HERE WE GO */
   IF MYFUNC = 'MSGBOXALL' | MYFUNC = 'QUIET' THEN DO
    MSGLOCK='Y'
    MSGSTAT='CONTPOP'
    MSGBOXTX='STARTING: PROCESSING ALL APPLIDS...'
    ADDRESS ISPEXEC "VPUT (MSGBOXTX) ASIS"
    ADDRESS ISPEXEC "VPUT (MSGLOCK MSGSTAT) ASIS"
    CALL MSGBOX
    END
   H_I = I
   J = 0
   MXLNG = 0
TOPOFLOP:
   J = J + 1
   IF J > I THEN SIGNAL DONEIT
   MYAPLID = APL_STM.J
   MYCA = H_MYCA
   MYCAL = H_MYCAL
   MYPROG = H_MYPROG
   MYTRANID = H_MYTRANID
  "ISPEXEC VPUT (MYAPLID MYPROG MYCA MYCAL MYTRANID) ASIS"
   IF RC ^= 0 THEN SIGNAL CHK_ERR
   IF MYFUNC = 'MSGBOXALL' | MYFUNC = 'QUIET' THEN DO
    MSGBOXTX=MYFUNC||' '||MYCMD||'... PROCESSING >'||LEFT(MYAPLID,8)    T
    ADDRESS ISPEXEC "VPUT (MSGBOXTX) ASIS"
    CALL MSGBOX
    END
   SAY 'EXCIS0A:CALL J='J' OF 'I':EXCIS2A WITH:'MYFUNC MYAPLID
   CALL EXCIS2A MYFUNC
   XC = RESULT
   SAY 'EXCIS0A:RETURN  FROM EXCIS2A RC:'XC
   IF XC = 4 THEN SIGNAL DONEIT
   IF MYFUNC = 'MSGBOXALL' | MYFUNC = 'QUIET' THEN DO
    TMP=XFF||LEFT(MYAPLID,8)||'-->'||XFF
    IF XC ^= 0 THEN TMP = TMP||'WARNING - CALL RETURNED 'XC||XFF
    "ISPEXEC VGET (MYCA) ASIS"
    MYCA = STRIP(MYCA,'B')
    APL_STM.J = TMP||TRANSLATE(MYCA,XFF,X15)
    L_CA=LENGTH(MYCA)
    TOTLNG=TOTLNG+L_CA
    IF L_CA > 32400 THEN SIGNAL TOOMUCH
    IF L_CA > MXLNG THEN MXLNG = L_CA
    END
   SIGNAL TOPOFLOP
 DONEIT:
   IF MYFUNC = 'VERBOSE' | MYFUNC = 'MSGBOXONLY' THEN SIGNAL EXITRC0
   J = H_I
   IF MYFUNC = 'MSGBOXALL' THEN DO
    MSGSTAT='REMPOP'
    MSGBOXTX= '< FINISHED PROCESSING SELECTION LIST. WRITING RESULTS'
    ADDRESS ISPEXEC "VPUT (MSGSTAT MSGBOXTX) ASIS"
    CALL MSGBOX
    EXECSEL = MYAPLID
    "ISPEXEC VPUT (EXECSEL) ASIS"
    MYAREA=''
    DO I = 1 TO J
     MYAREA=MYAREA||XFF||APL_STM.I
     END
    MYCA = H_MYCA
    MYAREA#=XFF
    "ISPEXEC VPUT (MYCA MYAREA MYAREA#) ASIS"
/*  CALL EXPLDSPT */
    CALL DSPLYA
    SAY 'FINISHED ALL PROCESSING'
    RETURN 0
    END
/* MYFUNC = QUIET : WRITE OP TO ODSN */
DO_ODSN:
  IF MYFUNC ^= 'QUIET' THEN SAY MUFUNC 'IS NOT EXPECTED:EXPECT:QUIET'
  IF ODSN = '' THEN SIGNAL EXITRC10
  PARSE VAR ODSN TDSN '(' EMBR ')'
  EDSN = ODSN
  EXECSEL='EXCIS0'
  CALL MALOC TDSN
  XC=RESULT
  IF XC = 0 THEN SIGNAL CHK_OPFILE
  IF EMBR = '' THEN MYDSO='PS)'
   ELSE  MYDSO='PO) DSNTYPE(LIBRARY)'
  MODDSN = ''
  M=MXLNG+4
  DSEMSG = '(D) DEL/REALLOC,(A) ABORT'
  MODATTR="NEW BLKSIZE("M+4") DSORG("MYDSO" RECFM(V,B) SPACE(1,1)"||,
   "CYLINDER LRECL("M") CATALOG REUSE"
  "ISPEXEC VPUT (EDSN EXECSEL DSEMSG MODATTR MODDSN) ASIS"
  IF RC ^= 0 THEN SIGNAL EXITRC8
  CALL ALOCDSN
  XC = RESULT
  "ISPEXEC VGET (EDSN) ASIS"
  IF RC ^= 0 THEN RETURN 4
  SIGNAL DOWRITE
 CHK_OPFILE:
   EDSN=ODSN
   DSEMSG = 'DSN EXISTS: DSN MUST BE NEW'
   MYVERB = 'ABORT CANCEL'
   "ISPEXEC VPUT (EDSN) ASIS"
   "ISPEXEC VPUT (DSEMSG EXECSEL) ASIS"
   "ISPEXEC VPUT (MYVERB) ASIS"
   CALL DSNWIND
   XC = RESULT
   IF XC > 4 THEN SIGNAL EXITRC2
   ADDRESS ISPEXEC "VGET (EDSN) ASIS"
   IF RC ^= 0 THEN SIGNAL EXITRC8
   IF ODSN ^= EDSN THEN DO
    ODSN = EDSN
    SIGNAL DO_ODSN
    END
   ADDRESS ISPEXEC "VGET (MYVERB) ASIS"
   IF RC ^= 0 THEN SIGNAL EXITRC8
 /* SIMPLE TEST OF MYVERB */
   IF MYVERB ^= '' THEN DO
    IF MYVERB='ABORT' | MYVERB='CANCEL' THEN SIGNAL EXITRC20
    END
   SIGNAL CHK_OPFILE
 DOWRITE:
  IF XC = 0 THEN DO
   ADDRESS TSO "ALLOC FI(O) DA('"EDSN"') SHR REUSE"
   ADDRESS TSO "EXECIO "J" DISKW O (STEM APL_STM. FINIS"
   ADDRESS TSO "FREE FI(O)"
   CALL MSGBOX 'DATA SAVED TO 'EDSN
   RETURN 0
  END
  RETURN XC
    END
   RETURN XC
 BADCA:
    ERR=MYCMD' COMMAND: MISSING COMMAREA'
    SIGNAL DOERR
 BADLINK::
    ERR='LINK  COMMAND: INVALID PROGRAM, COMMAREA OR TRANSID'
    SIGNAL DOERR
 BADPARM:
    ERR=TMP
    SIGNAL DOERR
 EXITRC4:
    ERR='PARAMETER ERROR:'||PRM_RC
    SIGNAL DOERR
 EXITRC8:
    ERR='NO VALID FUNCTION REQUESTED'
    SIGNAL DOERR
 EXITRC10:
    ERR='FUNCTION:QUIET, BUT NO OUTPUT DESTINATION PROVIDED.'
    SIGNAL DOERR
 EXITRC12:
 EXITRC16:
 EXITRC20:
 EXITRC0:
 DOERR:
 RETURN XC
###END EXCIS0A
$$$BEG DSPLYTBL
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA          -                                              */
 /* CEMHELP          - TSO BASE, RESTRICTED                         */
 /* CEMHELP          -                                              */
 /* CEMHELP END                                                     */
  ADDRESS ISPEXEC
  'ISPEXEC CONTROL ERRORS RETURN'
  "ISPEXEC VGET (EXECSEL) ASIS"
  IF RC ^= 0 THEN DO
   EXECSEL = 'DSPLYA'
   "ISPEXEC VPUT (EXECSEL) ASIS"
   END
  "ISPEXEC VGET (MYAREA#) ASIS"
  IF RC ^= 0 THEN SIGNAL NOPOOL
  IF LENGTH(MYAREA#) ^= 1 THEN SIGNAL NOPOOL
  SEP=MYAREA#
  "ISPEXEC VGET (MYAREA) ASIS"
  IF RC ^= 0 THEN SIGNAL NOPOOL
  I = 0
  HL_MYAREA = 0
  DO WHILE(MYAREA ^= '')
   PARSE VAR MYAREA TMP (SEP) MYAREA
   TL = LENGTH(TMP)
   IF TL > MXLNG THEN MXLNG = TL
   I = I+1
   IP.I = TMP
   END
 TRACE I
  IF I = 0 THEN SIGNAL NOPOOL
  IPCT=I
  SUID=SYSVAR(SYSUID)
  SDT=DATE('U')
  ICT=IP.0
  FDS=1
  AMT='HALF'
  ACTION='S'
  SIGNAL OFF ERROR
  ADDRESS ISPEXEC
  "ISPEXEC CONTROL ERRORS RETURN"
  MDSN='TTED.TSK.D.TCEM.ISPPLIB'
  "ISPEXEC LIBDEF ISPPLIB DATASET ID('"MDSN"') STACK"
  IF RC ^= 0 THEN DO
    MSGTXT='ERROR ON LIBDEF ISPPLIB::'MDSN
    SIGNAL SHOWMBOX
    END
  "ISPEXEC TBCREATE EXPLDSP "||,
    "NAMES(FA) NOWRITE REPLACE"
   IF RC > 4 THEN DO
   MSGTXT ='COULD NOT CREATE THE EXPLDSP FOR TEMP HOLD OF DSN LIST'
   SIGNAL SHOWMBOX
   END
  DO I = 1 TO IPCT
   FA = IP.I
   "ISPEXEC TBADD EXPLDSP"
   IF I > 5 THEN TRACE OFF
   END
  TRACE I
  EXECSEL='EXPLDSP'
  "ISPEXEC TBTOP EXPLDSP"
  "ISPEXEC VPUT (EXECSEL) ASIS"
  CANSTR='CANCEL ABORT'
  DONSTR=' SAVE EXIT DONE'
  CMDSTR=CANSTR||DONSTR
  PROCLST='S,C'
  MCMD=''
  UPDTIND=0
 TOPOFLOP:
  "ISPEXEC TBDISPL EXPLDSP PANEL(EXPLDSPD) ROWID(MDROW#) POSITION(MYCRP)"
  XC = RC
  IF XC > 8 THEN DO
   MSGTXT ='SEVERE ERROR FROM TBDISPL FUNCTION.  ABORT.'
   SIGNAL SHOWMBOX
   END
  IF WORDPOS(MCMD,CMDSTR) = 0 THEN SIGNAL TOPOFLOP
  IF WORDPOS(MCMD,CANSTR) ^=  0 THEN DO
   MSGTXT='COMMAND:'MCMD' SIGNALS ABORT'
   SIGNAL SHOWMBOX
   END
  IF WORDPOS(MCMD,DONSTR) ^= 0 THEN SIGNAL OKDOIT
  MSGTXT='UNKNOWN COMMAND:'MCMD' SIGNALS ABORT'
  SIGNAL SHOWMBOX
/*PROCESS COMMANDS */
/*LOOP TO TOPOFLOP UNTIL SAVE COMMAND */
 OKDOIT:
   IF MCMD = 'SAVE' THEN DO
    CALL SAVIT
    IF RESULT = 0 THEN DO
     ZEDSMSG = 'DATA SAVED'
     ZEDLMSG = 'DATASET SAVED AS DIRECTED'
     END
     ELSE DO
     ZEDSMSG = 'DATA NOT SAVED'
     ZEDLMSG = 'ERROR OCCURRED, OR ABORT SELECTED. NOTHING SAVED'
     END
    MCMD = ''
    "ISPEXEC SETMSG MSG(ISRZ001)"
    SIGNAL REDSPLY
    END
   IF MCMD = 'CUT' | MCMD = 'CUTA' THEN DO
    IF RESP ^= '' THEN CUTV=RESP
     ELSE CUTV='DSPA'
    IF MCMD='CUT' THEN DO
     CUTCNT=0
     END
    CALL CUTIT
    IF RESULT = 0 THEN DO
     ZEDSMSG = 'DATA 'MCMD
     ZEDLMSG = 'DATA 'MCMD' AS DIRECTED'
     END
     ELSE DO
     ZEDSMSG = 'DATA NOT 'MCMD
     ZEDLMSG = 'ERROR OCCURRED, DATA WAS NOT 'MCMD
     END
    MCMD = ''
    "ISPEXEC SETMSG MSG(ISRZ001)"
    SIGNAL REDSPLY
    END
   IF MCMD='OS2PW' | ABBREV('OS2PNTN',MCMD,4) = 1 |,
      MCMD='PMBRW' | ABBREV('PMBRN',MCMD,4) = 1 THEN DO
    CALL OS2PNT
    XC=RESULT
    IF XC=0 THEN DO
     IF MCMD = 'OS2PW' | MCMD='PMBRW' THEN DO
      CALL JRPPNT 'JRPPNTW'
      XC=RESULT
      END
      ELSE DO
      IF MCMD='PMBRC' THEN CALL JRPPNT 'JRPPNTC'
       ELSE CALL JRPPNT 'JRPPNT'
      XC=RESULT
      END
     END
    IF XC = 0 | XC > 20 THEN DO
     ZEDSMSG = 'DATA PRINTED 'XC
     ZEDLMSG = 'DATASET PRINTED AS DIRECTED TO JRP'XC
     END
     ELSE DO
     ZEDSMSG = 'DATA NOT PRINTED'
     ZEDLMSG = 'ERROR OCCURRED, OR ABORT SELECTED. NOTHING PRINTED.'
     END
    MCMD = ''
    "ISPEXEC SETMSG MSG(ISRZ001)"
    SIGNAL REDSPLY
    END
   IF MCMD = 'PFAPNT'| MCMD='PFAEDIT' THEN DO
    'ISPEXEC VGET (EXECSEL FAIDODSN) ASIS'
    IF EXECSEL = 'PFA' & FAIDODSN ^= '' THEN DO
     IF FAIDODSN = '' | FAIDODSN = 'FAIDODSN' THEN RESULT=4
      ELSE DO
       IF MCMD='PFAPNT' THEN JRPPNT 'JRPPNT' FAIDODSN
       IF MCMD='PFAEDIT' THEN ,
        "ISPEXEC EDIT DATASET ('"FAIDODSN"')"
       END
      END
     IF RESULT = 0 THEN DO
      ZEDSMSG = 'FAID PRINTED'
      ZEDLMSG = 'DATASET PRINTED AS DIRECTED'
      END
      ELSE DO
      ZEDSMSG = 'DATASET NOT PRINTED'
      ZEDLMSG = 'FAID DATASET COULD NOT BE PRINTED.'
      END
    MCMD = ''
    "ISPEXEC SETMSG MSG(ISRZ001)"
    SIGNAL REDSPLY
    END
   MSGTXT='FINISHED WRITTING FILE 'EDSN
   XC = 0
 NOPOOL:
  XC = 8
  ZEDSMSG = "NO POOLED DATA"
  ZEDLMSG = "NO DATA PREVIOUSLY POOLED FOR RECALL"
  SIGNAL WRITIT
  WRITIT:
  "ISPEXEC SETMSG MSG(ISRZ001)"
  RETURN XC
SHOWMBOX:
   SAY MSGTXT
   RETURN XC
 SAVIT: PROCEDURE EXPOSE MYA. MXLNG EXECSEL CMD
  /* TRACE ?I */
  "ISPEXEC VGET (DSPLYADS EMBR) ASIS"
  IF RC \= 0 THEN DO
   EDSN=SYSVAR(SYSUID)'.'EXECSEL'.DATA'
   EMBR=''
   END
   ELSE EDSN=DSPLYADS
  DSEMSG='ENTER TARGET DSN (NO MBR)'
  MYAT='INPUT'
  "ISPEXEC VPUT (EDSN EMBR DSEMSG MYAT) ASIS"
  CALL GDSNNMBR
  IF RESULT = 8 THEN RETURN 8
  "ISPEXEC VGET (EDSN EMBR) ASIS"
  IF RC ^= 0 THEN RETURN
  EMBR=STRIP(EMBR,'B')
  XMBR = ''
  /* DSN COULD HAVE BEEN SPECIFIED AS DSN(MBR)
     OR THE DSN AND MBR INPUT IN PANEL FIELDS,
     OR (CONFUSED) BOTH (IN WHICH CASE WE TAKE THE DSN(MBR)
     FORMATED BECAUSE WE FIGURE IT WAS INTENTIONAL).
  */
  PARSE VAR EDSN EDSN '(' XMBR ')'
  TDSN=EDSN
  IF XMBR \= '' THEN EMBR = XMBR
  IF EMBR = '$' THEN EMBR = EXECSEL
  /* SIMPLE CHECK TO INSURE DSN NOT MIGRATED */
  CALL MALOC TDSN
  XC=RESULT
  IF XC = 0 THEN SIGNAL CHKORG
  IF EMBR = '' THEN MYDSO='PS)'
   ELSE  MYDSO='PO) DSNTYPE(LIBRARY)'
  MODDSN = ''
  IF MXLNG < 128 THEN MXLNG = 128
  M=MXLNG+4
  DSEMSG = '(D) DEL/REALLOC,(A) ABORT'
  MODATTR="NEW BLKSIZE("M+4") DSORG("MYDSO" RECFM(V,B) SPACE(1,1)"||,
   "CYLINDER LRECL("M") CATALOG REUSE"
  EDSN = TDSN
  ADDRESS ISPEXEC "VPUT (EDSN EXECSEL DSEMSG MODATTR MODDSN) ASIS"
  IF RC ^= 0 THEN SIGNAL EXITRC8
  CALL ALOCDSN
  XC = RESULT
  "ISPEXEC VGET (EDSN) ASIS"
  IF RC ^= 0 THEN RETURN 4
  SIGNAL DOWRITE
 CHKORG:
  XC=LISTDSI("'"TDSN"'" DIRECTORY NORECALL)
  MYDSO=SYSDSORG
  IF EMBR \= '' THEN DO
   IF MYDSO = 'PS' THEN SIGNAL BADOPDSNORG
   END
   ELSE DO
   IF MYDSO = PO THEN SIGNAL BADOPDSNORG
   END
 DOWRITE:
  /* TRACE ?I */
  DSPLYADS=EDSN
  "ISPEXEC VPUT (DSPLYADS EMBR) ASIS"
  IF EMBR \= '' THEN EDSN=TDSN||'('||EMBR||')'
  IF XC = 0 THEN DO
   M# = MYA.0
   MSTM='MYA.'
   IF CMD = 'MOD' | CMD = 'APPEND' THEN DSPVAL='MOD'
    ELSE DSPVAL='SHR REUSE'
   IF EMBR \= '' THEN DO
    IF DSPVAL = 'MOD' THEN DO
     DSPVAL='SHR REUSE'
     ADDRESS TSO "ALLOC FI(I) DA('"EDSN"') "DSPVAL
     ADDRESS TSO "EXECIO * DISKR I (STEM MYB. FINIS"
     ADDRESS TSO "FREE FI(I)"
     MSTM='MYB.'
     MB#=MYB.0
     DO I = 1 TO M#
      MB#=MB# + 1
      MYB.MB#=MYA.I
      END
     M#=MB#
     END
    END
   ADDRESS TSO "ALLOC FI(O) DA('"EDSN"') "DSPVAL
   ADDRESS TSO "EXECIO "M#" DISKW O (STEM "MSTM" FINIS"
   ADDRESS TSO "FREE FI(O)"
   CALL MSGBOX 'DATA SAVED TO 'EDSN
   RETURN 0
  END
  RETURN XC
BADOPDSNORG:
   CALL MSGBOX 'SAVE TO DSN DSORG INCONSISTENT WITH EXISTING DSN'
   RETURN 4
OS2PNT: PROCEDURE EXPOSE SVC MYA. XC
 IF SVC ^> 0 THEN RETURN 4
 DO I = 1 TO SVC
  INTERPRET 'OS2C'||I'= MYA.I'
  'ISPEXEC VPUT (OS2C'I') ASIS'
  END
 MYCN = 'OS2C'
 OS2CTOT = SVC
  ZEDSMSG = "DATA PRINTED"
  ZEDLMSG = "DATA SENT TO PRINTER"
 "ISPEXEC SETMSG MSG(ISRZ001)"
 "ISPEXEC VPUT (MYCN OS2CTOT) ASIS"
 RETURN 0
CUTIT: PROCEDURE EXPOSE SVC MYA. CUTV CUTCNT XC
 IF SVC ^> 0 THEN RETURN 4
 CVSTR=''
 DO I = 1 TO SVC
  CUTCNT=CUTCNT+1
  INTERPRET CUTV||CUTCNT'= MYA.I'
  'ISPEXEC VPUT ('CUTV||CUTCNT') ASIS'
  END
  INTERPRET CUTV'TOT = CUTCNT'
 'ISPEXEC VPUT ('CUTV'TOT) ASIS'
 RETURN 0
###END DSPLYTBL
$$$BEG DSPLY1B
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA          -                                              */
 /* CEMHELP          - TSO BASE, RESTRICTED                         */
 /* CEMHELP          -                                              */
 /* CEMHELP END                                                     */
  XC = 0
  ARG MYTYP MYTYTOT
   IF MYTYTOT = '' THEN DO
    ADDRESS ISPEXEC
    "ISPEXEC VGET (EXECSEL) ASIS"
    IF RC ^= 0 THEN DO
     EXECSEL='DSPLY1B'
     "ISPEXEC VPUT (EXECSEL) ASIS"
     END
    "ISPEXEC VGET (MYTYP MYTYTOT) ASIS"
    IF RC ^= 0 THEN SIGNAL NOPOOL
    END
   IF MYTYTOT ^> 0 THEN SIGNAL NOPOOL
   A = VALUE(MYTYP)
OUTOFBLD:
   SIGNAL ON HALT NAME FREEIT
   LCRP=0
   ADDRESS ISPEXEC
   "ISPEXEC CONTROL ERRORS RETURN"
   "ISPEXEC TBCREATE DSPLYTBL "||,
     "NAMES(MYD2) NOWRITE REPLACE"
    IF RC > 4 THEN DO
    MSGTXT ='COULD NOT CREATE THE DISPLAY TABLE'
    SIGNAL SHOWMBOX
    END
    MXLNG=0
   DO I = 1 TO MYTYTOT
    INTERPRET '"ISPEXEC VGET ('A||I') ASIS"'
    INTERPRET 'MYD2='A||I
    MYA.I=MYD2
    TLG=LENGTH(MYD2)
    IF TLG > MXLNG THEN MXLNG = TLG
    "ISPEXEC TBADD DSPLYTBL"
    END
   SVC=MYTYTOT
   "ISPEXEC TBTOP DSPLYTBL"
   CROW=0
 TOPOFLOP:
  "ISPEXEC TBTOP DSPLYTBL"
  "ISPEXEC TBSKIP DSPLYTBL NUMBER("CROW")"
 REDSPLY:
  "ISPEXEC TBDISPL DSPLYTBL PANEL(MYDSPAD2)"
  XC = RC
  IF XC > 8 THEN DO
   MSGTXT ='SEVERE ERROR FROM TBDISPL FUNCTION.  ABORT.'
   SIGNAL SHOWMBOX
   END
  IF CROW > 0 THEN CROW=CROW+0
 CKXC:
  CMD = ZCMD
  ZCMD = ''
  IF CMD = '' THEN SIGNAL CKPF8
  IF WORDPOS(CMD,CANSTR) ^= 0 THEN SIGNAL CANIT
  IF CMD='TCEMTRAI' THEN DO
   TRACE I
   SIGNAL REDSPLY
   END
  IF CMD='TCEMTRAO' THEN DO
   TRACE OFF
   SIGNAL REDSPLY
   END
  IF CMD='OS2PW' | ABBREV('OS2PNTN',CMD,4) = 1 |,
     CMD='PMBRW' | ABBREV('PMBRN',CMD,4) = 1 THEN DO
   CALL OS2PNT
   XC=RESULT
   IF XC=0 THEN DO
    IF CMD = 'OS2PW' | CMD='PMBRW' THEN DO
     CALL JRPPNT 'JRPPNTW'
     XC=RESULT
     END
     ELSE DO
     IF CMD='PMBRC' THEN CALL JRPPNT 'JRPPNTC'
      ELSE DO
       IF MXLNG > 80 THEN DDEST = 'JRPPNTC'
        ELSE DDEST = 'JRPPNT'
       CALL JRPPNT DDEST
       END
     XC=RESULT
     END
    XC = 0
    SIGNAL REDSPLY
    END
   END
  "ISPEXEC CONTROL DISPLAY SAVE"
   IF CMD = 'SAVE' THEN DO
    CALL SAVIT
    IF RESULT = 0 THEN DO
     ZEDSMSG = 'DATA SAVED'
     ZEDLMSG = 'DATASET SAVED AS DIRECTED'
     END
     ELSE DO
     ZEDSMSG = 'DATA NOT SAVED'
     ZEDLMSG = 'ERROR OCCURRED, OR ABORT SELECTED. NOTHING SAVED'
     END
    END
    ELSE '"'ZCMD'"'
   "ISPEXEC CONTROL DISPLAY RESTORE"
 CKPF8:
   IF XC = 8 THEN SIGNAL DONEALL
   IF XC ^= 0 THEN DO
    MSGTXT='ILLOGICAL VALUE FOR XC 'XC'. ABORT.'
    SIGNAL SHOWMBOX
    END
   SIGNAL TOPOFLOP
 DONEALL:
   RETURN 0
  CANIT:
   MSGTXT ='CANCEL/ABORT WAS COMMANDED.'
   SIGNAL SHOWMBOX
  NOPOOL:
   MSGTXT ='NO POOLED DATA TO DISPLAY.'
   SIGNAL SHOWMBOX
  FREEIT:
   MSGTXT='ATTENTION ROUTINE ENTERED. NOTHING SAVED.'
  SHOWMBOX:
   CALL MSGBOX MSGTXT
   RETURN XC
SIGNAL ON ERROR NAME ERROR
SIGNAL ON SYNTAX NAME SYNTAX
SIGNAL ON FAILURE NAME FAILURE
SIGNAL ON HALT NAME HALT
ERROR:
    XC=RC
    SAY 'REXX ERROR 'XC' ON LINE 'SIGL':'
    SAY 'REXX:- APPLICATION RETURNED AN ERRORLEVEL' XC
    SIGNAL START
SYNTAX:
    XC=RC
    SAY 'REXX ERROR 'XC' ON LINE 'SIGL':'ERRORTEXT(XC)
    SAY 'REXX:- ERROR' XC':' ERRORTEXT(XC)
    SIGNAL START
FAILURE:
    XC=RC
    SAY 'REXX ERROR 'XC' ON LINE 'SIGL':'
    IF XC = -3 THEN,
       SAY 'REXX:- PROGRAM NOT FOUND'
    ELSE IF XC = -8 THEN,
       SAY 'REXX:- INSUFFICIENT MEMORY FOR PROGRAM'
    ELSE,
       SAY 'REXX:- RETURN CODE' XC
    SIGNAL START
HALT:
    XC=RC
    SAY 'REXX:- CTRL-BREAK INTEXCEPTED'
START:
  XC=RC
SIGNAL ON HALT NAME XITIT
  SAY 'REXX ERROR 'XC' ON LINE 'SIGL':'ERRORTEXT(XC)
DO WHILE (1)
 SAY 'ENTER A VALID REXX COMMAND EXCEPT INTERPRET'
 PULL RESP
 IF WORD(RESP,1) = 'INTERPRET' THEN DO
  SAY 'DO NOT ENTER A INTERPRET COMMAND. RETRY'
  ITERATE
  END
 INTERPRET RESP
 END
 XITIT:
    PULL
    EXIT
 SAVIT: PROCEDURE EXPOSE MYA. MXLNG EXECSEL CMD
  /* TRACE ?I */
  "ISPEXEC VGET (DSPLYADS EMBR) ASIS"
  IF RC \= 0 THEN DO
   EDSN=SYSVAR(SYSUID)'.'EXECSEL'.DATA'
   EMBR=''
   END
   ELSE EDSN=DSPLYADS
  DSEMSG='ENTER TARGET DSN (NO MBR)'
  MYAT='INPUT'
  "ISPEXEC VPUT (EDSN EMBR DSEMSG MYAT) ASIS"
  CALL GDSNNMBR
  IF RESULT = 8 THEN RETURN 8
  "ISPEXEC VGET (EDSN EMBR) ASIS"
  IF RC ^= 0 THEN RETURN
  EMBR=STRIP(EMBR,'B')
  XMBR = ''
  /* DSN COULD HAVE BEEN SPECIFIED AS DSN(MBR)
     OR THE DSN AND MBR INPUT IN PANEL FIELDS,
     OR (CONFUSED) BOTH (IN WHICH CASE WE TAKE THE DSN(MBR)
     FORMATED BECAUSE WE FIGURE IT WAS INTENTIONAL).
  */
  PARSE VAR EDSN EDSN '(' XMBR ')'
  TDSN=EDSN
  IF XMBR \= '' THEN EMBR = XMBR
  IF EMBR = '$' THEN EMBR = EXECSEL
  /* SIMPLE CHECK TO INSURE DSN NOT MIGRATED */
  CALL MALOC TDSN
  XC=RESULT
  IF XC = 0 THEN SIGNAL CHKORG
  IF EMBR = '' THEN MYDSO='PS)'
   ELSE  MYDSO='PO) DSNTYPE(LIBRARY)'
  MODDSN = ''
  IF MXLNG < 128 THEN MXLNG = 128
  M=MXLNG+4
  DSEMSG = '(D) DEL/REALLOC,(A) ABORT'
  MODATTR="NEW BLKSIZE("M+4") DSORG("MYDSO" RECFM(V,B) SPACE(1,1)"||,
   "CYLINDER LRECL("M") CATALOG REUSE"
  EDSN = TDSN
  ADDRESS ISPEXEC "VPUT (EDSN EXECSEL DSEMSG MODATTR MODDSN) ASIS"
  IF RC ^= 0 THEN SIGNAL EXITRC8
  CALL ALOCDSN
  XC = RESULT
  "ISPEXEC VGET (EDSN) ASIS"
  IF RC ^= 0 THEN RETURN 4
  SIGNAL DOWRITE
 CHKORG:
  XC=LISTDSI("'"TDSN"'" DIRECTORY NORECALL)
  MYDSO=SYSDSORG
  IF EMBR \= '' THEN DO
   IF MYDSO = 'PS' THEN SIGNAL BADOPDSNORG
   END
   ELSE DO
   IF MYDSO = PO THEN SIGNAL BADOPDSNORG
   END
 DOWRITE:
  /* TRACE ?I */
  DSPLYADS=EDSN
  "ISPEXEC VPUT (DSPLYADS EMBR) ASIS"
  IF EMBR \= '' THEN EDSN=TDSN||'('||EMBR||')'
  IF XC = 0 THEN DO
   M# = MYA.0
   MSTM='MYA.'
   IF CMD = 'MOD' | CMD = 'APPEND' THEN DSPVAL='MOD'
    ELSE DSPVAL='SHR REUSE'
   IF EMBR \= '' THEN DO
    IF DSPVAL = 'MOD' THEN DO
     DSPVAL='SHR REUSE'
     ADDRESS TSO "ALLOC FI(I) DA('"EDSN"') "DSPVAL
     ADDRESS TSO "EXECIO * DISKR I (STEM MYB. FINIS"
     ADDRESS TSO "FREE FI(I)"
     MSTM='MYB.'
     MB#=MYB.0
     DO I = 1 TO M#
      MB#=MB# + 1
      MYB.MB#=MYA.I
      END
     M#=MB#
     END
    END
   ADDRESS TSO "ALLOC FI(O) DA('"EDSN"') "DSPVAL
   ADDRESS TSO "EXECIO "M#" DISKW O (STEM "MSTM" FINIS"
   ADDRESS TSO "FREE FI(O)"
   CALL MSGBOX 'DATA SAVED TO 'EDSN
   RETURN 0
  END
  RETURN XC
BADOPDSNORG:
   CALL MSGBOX 'SAVE TO DSN DSORG INCONSISTENT WITH EXISTING DSN'
   RETURN 4
OS2PNT: PROCEDURE EXPOSE MYTYP SVC
 IF SVC ^> 0 THEN RETURN 4
 MYCN=MYTYP
 "ISPEXEC VPUT (MYCN) ASIS"
  ZEDSMSG = "DATA PRINTED"
  ZEDLMSG = "DATA SENT TO PRINTER"
 "ISPEXEC SETMSG MSG(ISRZ001)"
 RETURN 0
###END DSPLY1B
$$$BEG EALCPDSE
/* REXX */
 TRACE ?I
 SUID=SYSVAR(SYSUID)
 ODSN='TTED.TSK.D.'SUID'.TSTPDSE'
 EDSN = ODSN
 EXECSEL = 'ALOCPDSE'
 DSEMSG = '(R) REUSE,(D) DEL/REALLOC,(A) ABORT'
 MODATTR="NEW BLKSIZE(600) DSORG(PO) DSNTYPE(LIBRARY) "||,
  "RECFM(F,B) SPACE(1,1)"||,
  "CYLINDER LRECL(120) CATALOG REUSE"
 ADDRESS ISPEXEC "VPUT (EDSN EXECSEL DSEMSG MODATTR) ASIS"
 IF RC ^= 0 THEN SIGNAL EXITRC8
 CALL ALOCDSN
 XC = RESULT
 IF XC = 8 THEN SIGNAL CANCEL8
 IF XC ^= 0 THEN SIGNAL EXITRC8
 DOALOC:
 "ALLOC FI(FAPRINT) DA('"ODSN"') SHR REUSE"
 END
###END EALCPDSE
$$$BEG EXPLSAVT
 SAVIT: PROCEDURE EXPOSE MYA. MXLNG EXECSEL CMD AUTOSAVE
  /* TRACE ?I */
  "ISPEXEC VGET (DSPLYADS EMBR) ASIS"
  IF RC \= 0 THEN DO
   EDSN=SYSVAR(SYSUID)'.'EXECSEL'.DATA'
   EMBR=''
   END
   ELSE EDSN=DSPLYADS
  IF AUTOSAVE = 'Y' THEN DO
   EDSN=DSPLYADS
   EMBR='$'
   TDSN=EDSN
   SIGNAL DO_AS
   END
  DSEMSG='ENTER TARGET DSN (NO MBR)'
  MYAT='INPUT'
  "ISPEXEC VPUT (EDSN EMBR DSEMSG MYAT) ASIS"
  CALL GDSNNMBR
  IF RESULT = 8 THEN RETURN 8
  "ISPEXEC VGET (EDSN EMBR) ASIS"
  IF RC ^= 0 THEN RETURN
  EMBR=STRIP(EMBR,'B')
  XMBR = ''
  /* DSN COULD HAVE BEEN SPECIFIED AS DSN(MBR)
     OR THE DSN AND MBR INPUT IN PANEL FIELDS,
     OR (CONFUSED) BOTH (IN WHICH CASE WE TAKE THE DSN(MBR)
     FORMATED BECAUSE WE FIGURE IT WAS INTENTIONAL).
  */
  PARSE VAR EDSN EDSN '(' XMBR ')'
  TDSN=EDSN
  IF XMBR \= '' THEN EMBR = XMBR
DO_AS:
  IF EMBR = '$' THEN EMBR = EXECSEL
  /* SIMPLE CHECK TO INSURE DSN NOT MIGRATED */
  CALL MALOC TDSN
  XC=RESULT
  IF XC = 0 THEN SIGNAL CHKORG
  IF EMBR = '' THEN MYDSO='PS)'
   ELSE MYDSO='PO) DIR(1)'
  MODDSN = ''
  IF MXLNG < 128 THEN MXLNG = 128
  M=MXLNG+4
  DSEMSG = '(D) DEL/REALLOC,(A) ABORT'
  MODATTR="NEW BLKSIZE("M+4") DSORG("MYDSO" RECFM(V,B) SPACE(1,1)"||,
   "CYLINDER LRECL("M") CATALOG REUSE"
  EDSN = TDSN
  ADDRESS ISPEXEC "VPUT (EDSN EXECSEL DSEMSG MODATTR MODDSN) ASIS"
  IF RC ^= 0 THEN SIGNAL EXITRC8
  CALL ALOCDSN
  XC = RESULT
  "ISPEXEC VGET (EDSN) ASIS"
  IF RC ^= 0 THEN RETURN 4
  SIGNAL DOWRITE
 CHKORG:
  XC=LISTDSI("'"TDSN"'" DIRECTORY NORECALL)
  MYDSO=SYSDSORG
  IF EMBR \= '' THEN DO
   IF MYDSO = 'PS' THEN SIGNAL BADOPDSNORG
   END
   ELSE DO
   IF MYDSO = PO THEN SIGNAL BADOPDSNORG
   IF AUTOSAVE = 'Y' THEN DSPVAL=MOD
   END
 DOWRITE:
  /* TRACE ?I */
  DSPLYADS=EDSN
  "ISPEXEC VPUT (DSPLYADS EMBR) ASIS"
  IF EMBR \= '' THEN EDSN=TDSN||'('||EMBR||')'
  IF XC = 0 THEN DO
   M# = MYA.0
   MSTM='MYA.'
   IF CMD = 'MOD' | CMD = 'APPEND' THEN DSPVAL='MOD'
    ELSE DSPVAL='SHR REUSE'
   IF EMBR \= '' THEN DO
    IF DSPVAL = 'MOD' THEN DO
     DSPVAL='SHR REUSE'
     ADDRESS TSO "ALLOC FI(I) DA('"EDSN"') "DSPVAL
     ADDRESS TSO "EXECIO * DISKR I (STEM MYB. FINIS"
     ADDRESS TSO "FREE FI(I)"
     MSTM='MYB.'
     MB#=MYB.0
     DO I = 1 TO M#
      MB#=MB# + 1
      MYB.MB#=MYA.I
      END
     M#=MB#
     END
    END
   ADDRESS TSO "ALLOC FI(O) DA('"EDSN"') "DSPVAL
   ADDRESS TSO "EXECIO "M#" DISKW O (STEM "MSTM" FINIS"
   ADDRESS TSO "FREE FI(O)"
   AUTOSAVE = 'N'
   CALL MSGBOX 'DATA SAVED TO 'EDSN
   RETURN 0
  END
  RETURN XC
BADOPDSNORG:
   CALL MSGBOX 'SAVE TO DSN DSORG INCONSISTENT WITH EXISTING DSN'
   RETURN 4
###END EXPLSAVT
$$$BEG S4MBR
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA          -                                              */
 /* CEMHELP          - TSO BASE, RESTRICTED                         */
 /* CEMHELP          -                                              */
 /* CEMHELP END                                                     */
 ADDRESS TSO
 D1='TTED.TSK.G.R320.APARLIB'
 D2='TTED.TSK.F.R320.CGE7.TABLELIB'
 D3='TTED.TSK.F.R320.SYS.LOADLIB'
 D4='TTED.TSK.G.R320.SYS.LOADLIB1'
 D5='TTED.TSK.G.R320.SYS.SDFJAUTH'
 D6='TTED.TSK.G.R320.ALOADLIB'
 D7='TTED.TSK.F.R320.COMMON.TABLELIB'
 D8='TTED.TSK.F.R320.LOADLIB'
 D9='TTED.TSK.F.R320.SYS.JLOADLIB'
 D10='TTAD.TS2.DB2.APFLIB'
 D11='TTED.TSK.F.R320.DEVS.LOADLIB'
 D12='TTED.TSK.G.ACF2.A120.LOADLIB'
 DCNT=12
 M1='CAKSSCAN'
 M2='NEVRFIND'
 M3='UCEMPINN'
 MCNT=3
 DO I=1 TO DCNT
  INTERPRET 'OURDSN = D'I
  D.I=OURDSN
  XC=LISTDSI("'"OURDSN"'" DIRECTORY NORECALL)
  MYMEM=SYSMEMBERS
  IF MYMEM > 3640 THEN DO
   SAY 'TOO MANY MEMBERS:'OURDSN
   ML = ''
   END
   ELSE DO
   SAY 'RETRIVING MEMBER LIST FOR 'OURDSN
   GETMBRLS OURDSN
   PULL ML
   END
  DL.I=ML
  END
 SL = ''
 DO I = 1 TO MCNT
  INTERPRET 'TMP = M'I
  SL = SL||' '||TMP
  INTERPRET 'MBR.'TMP' = "NOT FOUND"'
  END
 HSL=SL
 SAY 'OK, HERE WE GO...'
 DO I = 1 TO MCNT
  TMP = WORD(SL,I)
  SAY 'PROCESSING MEMBER:'TMP
  DO J = 1 TO DCNT
   TMP1=DL.J
   WP = WORDPOS(TMP,TMP1)
   IF WP ^= 0 THEN DO
    INTERPRET 'MBR.'TMP' = "'D.J'"'
    LEAVE
    END
   END
  END
 SAY 'FINISHED SEARCH...PRESS ENTER FOR REPORT'
 PULL
 DO I = 1 TO MCNT
  TMP = WORD(SL,I)
  INTERPRET 'M = MBR.'TMP
  SAY LEFT(TMP,10)||M
  END
 SAY 'FINISHED'
###END S4MBR
$$$BEG EXPLPRM1
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA          -                                              */
 /* CEMHELP          - TSO BASE, RESTRICTED                         */
 /* CEMHELP          -                                              */
 /* CEMHELP END                                                     */
 /*                                                                 */
 /* REQUIRED PARAMETERS:                                            */
 /*  MYFUNC - FIRST PARM IDENTIFIES THE OUTPUT PROCESS              */
 /*         - SEE VAR VALFUNC                                       */
 /*  MYCMD()  - DESIRED COMMAND PROCESSING OPTION                   */
 /*           SEE VAR VALPRMS                                       */
 /*  MYAPLID() - TARGET APPLID                                      */
 /*  ODSN   - IF QUIET, IDENTIFIES THE TARGET DSN TO COLLECT THE    */
 /*           RESULTS                                               */
 /*                                                                 */
 /*  PARMS MUST BE IN THE FORMAT                                    */
 /*   ACTUAL LITERAL (SEE VALPRMS FOR LIST) EXPL: MYAPLID           */
 /*     MYAPLID=XXXX   SINGLE CHOICE                                */
 /*            =(XXXX YYYY ....) MULTIPLE CHOICES                   */
 /*            (XXXX YYYY ....) MULTIPLE CHOICES                    */
 /*            =<IIII> IDENTIFIES AN ISPFVAR NAME                   */
 /*            <IIII>                                               */
 /*    IIII ISPFVAR NAME - IS THE ACTUAL NAME OF AN ISPFVAR         */
 /*            WHICH WILL BE VGET. THE CONTENTS OF THAT VAR         */
 /*            WILL BE USED AS A LIST                               */
 /*                                                                 */
 /*  MYCMD() CAN NOT BE A LIST. IT IS USED TO DEFINE A SINGLE       */
 /*          COMMAND, TO BE USED WITH THE APPLID LIST AND PROG      */
 /*          LIST IS THE COMMAND SELECTION IS 'LIST'                */
 /*                                                                 */
 /*  ODSN - CAN BE 'DISPLAY' WHICH WILL DISPLAY UP TO 99 LINES      */
 /*       - A DATASET (NEW OR EXISTING) IF EXISTING, YOU ARE        */
 /*         PROMPTED TO ACCEPT REUSE. IT CAN BE A PDS(E) WITH MBR   */
 /*                                                                 */
 /*                                                                 */
 /*                                                                 */
 /*                                                                 */
  ARG MYFUNC PRMS
  IF MYFUNC = '' THEN SIGNAL BADFUNC
  VALFUNC = 'MSGBOXONLY MSGBOXALL VERBOSE QUIET'
  VALPRMS='MYCMD MYAPLID ODSN'
  VALCMDS = 'PING CEMT CEDA LINK'
  DFTPVALS='PING . .'
  IF PRMS ^= '' THEN DO
   NPW=WORDS(VALPRMS)
   DO I = 1 TO NPW
    TMP = WORD(VALPRMS,I)
    TMPV = WORD(DFTPVALS,I)
    IF TMPV = '.' THEN TMPV = ''
     ELSE IF TMPV = '\.' THEN TMPV = '.'
    INTERPRET TMP"='"TMPV"'"
    END
  TRACE I
   I=0
   PASSCT=0
   PRM_RC = 0
   TRACE I
    DLM='(<{[='
   MDLM=')>}] '
   #DMM=LENGTH(DLM)
PRMLOOP:
   IF PRMS = '' THEN SIGNAL DONEPRMS
   PRMX = ''
   PARSE VAR PRMS PRM PRMS
   IF PRM = '' THEN SIGNAL EXITRC8
   PRM=PRM||' ' /* TACK ON A SPACE TO HELP FIND '=' END */
   L_PRM=LENGTH(PRM)
   FDLM = ''
   EDLM = ''
   DO I = 2 TO L_PRM
    PP=SUBSTR(PRM,I,1)
    CKPP=POS(PP,DLM)
    IF CKPP ^= 0 THEN DO
     FDLM=SUBSTR(DLM,CKPP,1)
     EDLM=SUBSTR(MDLM,CKPP,1)
     LEAVE
     END
    END
   IF FDLM = '' THEN SIGNAL BADPARM
   IF I >= L_PRM THEN SIGNAL BADPARM
   LP = LASTPOS(EDLM,PRM)
   IF LP = 0 THEN LP=L_PRM
    ELSE LP = LP - 1
   PRMVAL = SUBSTR(PRM,I+1,LP-I)
   PRM = SUBSTR(PRM,1,I-1)
   IF PP = '=' THEN SIGNAL GOTEQ
   IF PP = '<' THEN SIGNAL GOBRKT
   SIGNAL GOTPARNT
GOTEQ:
   IF PRMVAL = '' THEN SIGNAL BADPARM
   L_PRM=LENGTH(PRMVAL)
   PP = SUBSTR(PRMVAL,1,1)
   CKPP=POS(PP,DLM)
   IF CKPP = 0 THEN DO
    SIGNAL GOT_PRMVAL
    END
   I = 1
   FDLM=SUBSTR(DLM,CKPP,1)
   EDLM=SUBSTR(MDLM,CKPP,1)
   LP = LASTPOS(EDLM,PRMVAL)
   IF LP = 0 THEN LP=L_PRM
    ELSE LP = LP - 1
   PRMVAL = SUBSTR(PRMVAL,I+1,LP-I)
   IF CKPP = '<' THEN SIGNAL GOBRKT
   SIGNAL GOTPARNT
GOTPARNT:
   PARSE VAR PRMVAL . '<' TMPVAL '>'
   IF TMPVAL ^= '' THEN DO
    PRMVAL = TMPVAL
    SIGNAL GOTBRKT
    END
   SIGNAL GOT_SIMPLE
GOTBRKT:
   IF LENGTH(PRMVAL) > 8 THEN SIGNAL BADPARM
   ADDRESS ISPEXEC "VGET ("PRMVAL") ASIS"
   INTERPRET "PRMVAL = "PRMVAL
   IF PRMVAL = '' THEN SIGNAL BADPARM
   SIGNAL GOT_PRMVAL
BADPARM:
    SAY 'PARM:'PRM' IS NOT A EXPECTED PARAMETER. BYPASSING.'
    PRM_RC = 4
    SIGNAL      NXTPRMS
GOT_SIMPLE:
GOT_PRMVAL:
   INTERPRET PRM "='"PRMVAL"'"
   PASSCT = PASSCT+1
NXTPRMS:
   SIGNAL PRMLOOP
DONEPRMS:
 EXIT
 TRACE I
   IF PRM_RC > 0 THEN SIGNAL EXITRC4
   ADDRESS TSO
   IF MYFUNC = '' THEN SIGNAL EXITRC8
   IF MYFUNC = 'QUIET' THEN DO
    IF ODSN = '' THEN SIGNAL EXITRC8
    SIGNAL GOTFUNC
    END
   IF MYFUNC = 'MSGBOXONLY' THEN SIGNAL GOTFUNC
   IF MYFUNC = 'MSGBOXALL' THEN SIGNAL GOTFUNC
   IF MYFUNC = 'VERBOSE' THEN SIGNAL GOTFUNC
   SIGNAL EXITRC8
 GOTFUNC:
   F1=SUBSTR(MYCMD,1,1)
   IF F1 = '"' | F1 = "'" THEN DO
    L1 = SUBSTR(MYCMD,LENGTH(MYCMD),1)
    IF L1 ^= F1 THEN SIGNAL EXITRC12
    END
    ELSE DO
    CMDCT = 1
    CMD_STM.CMDCT = MYCMD
    SIGNAL CHK_CMD
    END
   CMDCT = 0
   DO WHILE(TMPCMD ^= '')
     PARSE VAR MYCMD (F1) TMP (F1) MYCMD
     IF TMP = '' THEN ITERATE
     CMDCT = CMDCT + 1
     CMD_STM.CMDCT = TMP
     END
   IF CMDCT = 0 THEN SIGNAL EXITRC12
   LNKCT = 0
 CHK_CMD:
   DO I = 1 TO CMDCT
    CWD1 = WORD(CMD_STM.I,1)
    IF WORDPOS(CWD1,VALCMDS) = 0 THEN SIGNAL EXITRC12
    IF CWD1 = 'LINK' | CWD1 = 'PING' THEN DO
     LNKCT = LNKCT + 1
     LNK_STM.LNKCT = I
     END
    END
   IF LNKCT = 0 THEN SIGNAL TSTAPLIDS
/* WE NEED TO SEE IF THERE ARE PROGRAMS SPECIFIEC FOR LINK OR PING *\
|*  IF WE HAVE A LINK BUT NO MATCHING PROGRAM (MYPROG) THEN WE     *|
|*  HAVE TO RETURN AN ERROR. IF WE HAVE A PING, WE WILL USE THE    *|
|*  THE PROGRAM, OTHERWISE WE USE THE DEFAULT.                     *|
|*  FOR EXAMPLE: IF MYCMD HAD 3 COMMANDS LINK PING LINK            *|
|*  THEN MYPROG HAD BETTER HAVE 3 PROGRAMS (REXX WORDS())          *|
|*  THE LINK MUST BE SUPPLIED, BUT THE PING PROGRAM CAN BE A '.'   *|
|*  (PERIOD) AS A PLACEHOLDER: IMPLYING USE THE DEFAULT.           *|
|*  THERE  ARE NO DEFAULT PROGRAMS FOR LINK COMMANDS.              *|
|*  IF YOU HAVE A CEMT OR CEDA COMMNAD UP FRONT, THEN THE          *|
|*  MYPROG MUST HAVE FILLER'.' AS PLACE HOLDERS (TO MATCH UP THE   *|
\*  REXX WORDCOUNT IN THE MYCMD WITH THE RESPECTIVE WORD IN MYPROG)*/
 DO I = 1 TO LNKCT
  J = LNK_STM.I
  IF
TSTAPLIDS:
   I = 0
   IF MYAPLID = '' THEN SIGNAL EXITRC16
   DO WHILE(MYAPLID ^= '')
    I = I + 1
    PARSE VAR MYAPLID APL_STM.I MYAPLID
    END
 SINGLE_APL:
 /* OK HERE WE GO */
   J = 1     /* COUNT OF APPLIDS    */
   K = 1     /* COUNT CMD PER APLID */
   IF WORDPOS(CWD1,VALCMDS) = 0 THEN SIGNAL EXITRC12
   I = I+1
   IF I > CMDCT THEN SIGNAL TSTAPLIDS
   SIGNAL SINGLE_CMD
   IF MYCMD = 'PING' THEN DO
    IF MYPROG ^= 'UCEMPINN' THEN SIGNAL EXITRC12
    MYCAL = 1024
    MYCA = 'PING'
    SIGNAL DONECMD
    END
   IF TMP = 'Q' THEN DO
    MYCAL = 0
    MYFUNC = 'QUIET'
    MYCA = 'PING'
    END
   IF TMP = 'E' THEN DO
    IF E_STR = '' THEN DO
     "ISPEXEC VGET (DSPAFOZZ) ASIS"
     IF RC ^= 0 THEN DSPAFOZZ='CEMT INQUIRE TAS'
     IF DSPAFOZZ = '' THEN DSPAFOZZ = 'CEMT INQUIRE TAS'
     E_STR=DSPAFOZZ
     END
     ELSE DSPAFOZZ = E_STR
    MYCA=DSPAFOZZ
    MYCAL = 4080
    MYFUNC = 'MSGBOXONLY'
    END
   IF LNREST = '' THEN RETURN 4
   AP=WORDPOS('MYAPLID',AFOLISTV)
   IF AP = 0 THEN RETURN 8
   MYAPLID = WORD(LNREST,AP)
   MYPROG='UCEMPINN'
   "ISPEXEC VPUT (MYAPLID MYPROG MYCA MYCAL) ASIS"
   IF RC ^= 0 THEN RETURN 12
   CALL EXCIS2 MYFUNC
   XC = RESULT
   MYAREA = ''
   "ISPEXEC VPUT (MYAREA) ASIS"
   RETURN XC
###END EXPLPRM1
$$$BEG EXCIS2A
/* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA EXCIS2   - SUBROUTINE TO AFOLIST. SEE AFOLIST           */
 /* CEMHELP EXCIS2   - SUBROUTINE TO AFOLIST. SEE AFOLIST           */
 /* CEMHELP          -                                              */
 /* CEMHELP END                                                     */
/*  TRACE I */
   ADDRESS TSO
   ARG MYFUNC
   XC = 0
   IF WORDPOS(MYFUNC,'VERBOSE MSGBOXONLY MSGBOXALL QUIET') = 0 THEN ,
       MYFUNC='VERBOSE'
   X=OUTTRAP('LINE.')
   ADDRESS TSO "TSOLIB DISPLAY"
   X=OUTTRAP('OFF')
   LNCT=LINE.0
   TMP = LINE.1
   IF LNCT < 1 THEN DO
    IF MYFUNC = 'QUIET' THEN RETURN 12
    C_A = 'TSO COMMAND RETURNED NULL OUTPUT. PRESS PF3 TO END'
    XC = 12
    SIGNAL PROCIT
    END
   TMP = WORD(LINE.1,1)
   XFF='FF'X
  MYAREA#=XFF
  X15='15'X
ERRLST='IDY00029I'
IF WORDPOS(TMP,ERRLST) ^ = 0 THEN DO
 C_A    = XFF||TMP||'::MISSING SDFHEXCI LIBRARY, REQUIRED FOR TSO'||,
 ' ENVIRONMENT'||XFF||'PLEASE RUN THE TSOLIB COMMAND FROM NATIVE '||,
 'TSO'||XFF||'(GO BACK TO READY)'||XFF||"EX 'TTED.TSK.P.TCEM.CLIS"||,
 "T(EXCITSLB)' 'REL'"||XFF||'WHERE REL IS CICS RELEASE'||XFF||,
 '(NOW RUN FROM READY)> CICLOGON'
 H_MYCA = 'ERROR!'
 EXCI_RESP=0
 XC = 8
 SIGNAL PROCIT
 END
/*----------------- COPYINFO INTERFACE FOR EXCI CALLS ---------------*\
|* PLEASE RUN THE TSOLIB COMMAND FROM NATIVE TSO                     *|
|*  (GO BACK TO READY)> CEM EXCITSLB
|*  (NOW RUN...)      > CICLOGON
|*                                                                   *|
|* THIS EXEC USES THE EXCI LINK INTERFACE TO EXECUTE A CICS PROGRAM  *|
|*                                                                   *|
|* "CA1DCALL "PROGRAM("PROGRAM_NAME")" ,                              *|
|*              "APPLID("VTAM_APPLID")" ,                            *|
|*              "USERID("USER_ID")" ,                                *|
|*              "COMMAREA(CA_NAME)" ,           /* OPTIONAL */       *|
|*              "LENGTH("CA_LENGTH")" ,         /* OPTIONAL */       *|
|*              "DATALENGTH("COMMAREA_DLEN")" , /* OPTIONAL */       *|
|*              "TRANSID("TRANS_ID")"           /* OPTIONAL */       *|
|* PROGRAM_NAME  - CONTAINS THE NAME OF THE CICS PROGRAM TO EXECUT   *|
|*                 FOLLOWING THE NAMING CONVENTIONS FOR CICS PROGR   *|
|*                                                                   *|
|* VTAM_APPLID   - CONTAINS THE VTAM APPLID FOR THE CICS REGION WH   *|
|*                 IS TO RECEIVE THE REQUEST.                        *|
|*                                                                   *|
|* USER_ID       - CONTAINS THE CICS USERID UNDER WHICH THE CICS     *|
|*                 PROGRAM WILL EXECUTE.  THIS USERID MUST BE        *|
|*                 VALIDATED PRIOR TO CALLING THE CICS PROGRAM BEC   *|
|*                 THERE IS NO ABILITY TO PASS A PASSWORD TO CICS.   *|
|*                                                                   *|
|* COMMAREA_NAME - IS THE NAME OF THE REXX VARIABLE THAT CONTAINS    *|
|*                 COMMAREA CONTENTS.  (BE SURE TO WATCH THE '"' T   *|
|*                 AVOID THE REXX VARIABLE SUBSTITUTION. IF COMMAR   *|
|*                 NOT SPECIFIED, THEN LENGTH AND DATALENGTH ARE     *|
|*                 IGNORED IF SPECIFIED. DEFAULT IS C_A.             *|
|*                                                                   *|
|* COMMAREA_LEN  - CONTAINS THE LENGTH OF THE COMMAREA TO BE USED    *|
|*                 THE EXCI.  THIS LENGTH CANNOT EXCEED 32768. IF    *|
|*                 VALUE IS NOT SUPPLIED BUT THE CA_NAME IS SPECIF   *|
|*                 THEN THE LENGTH OF THE REXX VARIABLE IS USED.     *|
|*                                                                   *|
|* COMMAREA_DLEN - CONTAINS THE LENGTH OF THE DATA TO BE PASSED IN   *|
|*                 COMMAREA.  THIS LENGTH MUST NOT BE LARGER THAN    *|
|*                 LENGTH OF THE COMMAREA. IF THIS VALUE IS NOT      *|
|*                 SUPPLIED BUT LENGTH IS SPECIFIED, THEN LENGTH I   *|
|*                 USED.  IF LENGTH IS NOT SPECIFIED THEN THE LENG   *|
|*                 THE CA_NAME REXX VARIABLE CONTENTS IS USED.       *|
|*                                                                   *|
|* TRANS_ID      - CONTAINS THE NAME OF A TRANSACTION TO BE USED F   *|
|*                 THE MIRROR FUNCTION.  IF NOT ENTERED THE DEFAUL   *|
|*                 MIRROR TRANSACTION, CSMI IS USED.                 *|
\*-------------------------------------------------------------------*/
ARND_IDY:
   /* TRACE I */
   ADDRESS ISPEXEC
   'ISPEXEC VGET (MYAPLID MYPROG MYCA MYCAL) ASIS'
   IF RC ^= 0 THEN DO
    C_A = 'ISPEXEC VGET VARIABLES FAILED. PRESS PF3 TO END'
    XC = 8
    SIGNAL PROCIT
    END
   IF MYAPLID = '' THEN SIGNAL BADPARM
   APPLID_NAME = MYAPLID
   IF MYPROG = '' THEN SIGNAL BADPARM
   PROGRAM_NAME=MYPROG
   CAL = LENGTH(MYCA)
   MYTRANID = ''
   'ISPEXEC VGET (MYTRANID) ASIS'
   IF MYPROG = 'UCEMPINN' THEN DO
    IF MYTRANID = '' THEN TR_ID='CSMI'
     ELSE TR_ID=MYTRANID
    IF CAL < 4 | MYCAL < 4 THEN DO
     MYCA = ''
     CAL = 0
     MYCA=''
     MYCAL = 0
     COMMAREA_DLEN = 0
     MYCMD = 'PING'
     H_MYCA = 'PING TO CSSL'
     SIGNAL DO_CSSL
     END
    IF SUBSTR(MYCA,1,5) = 'SYSID' THEN DO
     MYCMD=TRANSLATE(MYCA,' ',',')
     MYCMD = WORD(MYCMD,2)
     IF LENGTH(MYCMD) \= 4 THEN SIGNAL BADPARM
     END
     ELSE MYCMD = WORD(MYCA,1)
    IF  WORDPOS(MYCMD,'PING CEMT CEDA LINK') = 0 THEN SIGNAL BADPARM
    END
    ELSE DO
    IF MYTRANID = 'CSMI' THEN SIGNAL BADPARM
    IF MYTRANID = '$SMI' THEN MYTRANID='CSMI'
    TR_ID=MYTRANID
    MYCMD=''
    END
   H_MYCA=MYCA
  COMMAREA_DLEN = LENGTH(STRIP(MYCA,'B'))
DO_CSSL:
   COMMAREA_NAME= 'C_A'
   C_A=''
   IF MYCAL < COMMAREA_DLEN THEN SIGNAL BADPARM
   C_A = MYCA||COPIES(' ',MYCAL-COMMAREA_DLEN)
   COMMAREA_LEN = LENGTH(C_A)
   ADDRESS TSO
   USER_ID=SYSVAR(SYSUID)
   PARM = "'PROGRAM("PROGRAM_NAME")','COMMAREA(C_A)',"||,
          "'TRANSID("TR_ID")',"||,
          "'LENGTH("COMMAREA_LEN")','APPLID("APPLID_NAME")'"
   P1 = "PROGRAM("PROGRAM_NAME")"
   P2 = "COMMAREA(C_A)"
   P3 = "LENGTH("COMMAREA_LEN")"
   P4 = "APPLID("APPLID_NAME")"
   P5 = "TRANSID("TR_ID")"
   P6 = "DATALENGTH("MYCAL")"
   P7 = "USERID("USER_ID")"
   EXCI_RESP='--'
   EXCI_RESP2='##'
   EXCI_ABCODE='____'
   EXCI_MESSAGE='-'
 IF MYFUNC ^= 'VERBOSE' THEN SIGNAL ARNDPRE
   SAY 'COMMAREA LENTH BEFORE LINK IS:' COMMAREA_LEN
   SAY
   SAY 'CALLING CICSLINK WITH PARAMETERS:'
   PARM1 = PARM
   DO UNTIL PARM1 = ''
     PARSE VAR PARM1 PART ',' PARM1
     SAY '   ' PART
     END
   SAY 'PRESS Y TO CONTINUE OR ANOTHER KEY TP BYPASS'
   PULL ANS
   IF ANS ^= 'Y' THEN SIGNAL EXITRC4
ARNDPRE:
    MDDN = 'ISPLLIB'
    MDSN = "'TTEP.TSK.E.TCEM.PDSE'"
    "ISPEXEC LIBDEF "MDDN" DATASET ID("MDSN") UNCOND"
    IF RC ^= 0 THEN SIGNAL DONIT
    /* "ISPEXEC SELECT PGM(ISPLLS) SCRNAME(LIBDEF)" */
   /* NEXT 2 WORK - ALL ARGS ARE COMBINED INTO ONE RX ARG */
   /* RXVARS_RESULT = CA1DLINK('P1','P2','P3','P4','P5') */
   /* CALL CA1DLINK 'P1','P2','P3','P4','P5' */
   /* THIS WORKS - EACH ARG IS SEPARATE IN RX ARG TABLE */
   SAY 'EXCIS2A:CALLING CA1DLINK WITH 'MYAPLID
    INTERPRET "CALL CA1DLINK '"P1"','"P2"','"P3"','"P4"','"P5"'"
   /* XX=CA1DLINK('PROGRAM' ,
                'APPLID' ,
                'COMMAREA' ,
                'LENGTH' ,
                'DATALENGTH' ,
                'TRANSID'      ) */
   /* XX=CA1DLINK('PROGRAM(UCEMPINN)' ,
                'APPLID(CGE5)' ,
                'COMMAREA(COMMAREA)' ,
                'LENGTH(1080)' ,
                'DATALENGTH(4)' ,
                'TRANSID(UTST)') */
   SAY 'EXCIS2A:RETURN  CA1DLINK RC:'RC
  SIGNAL PROCIT
BADPARM:
  XC = 20
  C_A='INVALID PARM RECEIVED. CANNOT PROCESS REQUEST'
PROCIT:
/* TRACE I */
 IF MYFUNC = 'QUIET' | MYFUNC = 'MSGBOXALL' THEN DO
  MYCA=C_A
  ADDRESS ISPEXEC 'VPUT (MYCA) ASIS'
  XC = EXCI_RESP
  RETURN XC
  END
 IF MYFUNC = 'MSGBOXONLY' THEN DO
  EXECSEL=MYAPLID
  "ISPEXEC VPUT (EXECSEL) ASIS"
  MYAREA =  XFF||H_MYCA||' REGION:'||MYAPLID
  IF EXCI_RESP = 0 THEN DO
   C_A=STRIP(C_A,'B')
   MYAREA=MYAREA||XFF||TRANSLATE(C_A,XFF,X15)
   END
   ELSE DO
   MYAREA = MYAREA||XFF||'EXCI_RESP IS:' EXCI_RESP||XFF||,
       'EXCI_RESP2 IS:' EXCI_RESP2||XFF||,
       'EXCI_ABCODE IS:' EXCI_ABCODE||XFF||,
       'EXCI_MESSAGE LENGTH IS:' LENGTH(EXCI_MESSAGE)||XFF||,
       'EXCI_MESSAGE IS:' EXCI_MESSAGE
    END
   ADDRESS ISPEXEC "VPUT (MYAREA MYAREA#) ASIS"
   IF MYFUNC = 'MSGBOXALL' THEN CETURN 0
   SAY 'EXCIS2A: CALLING DSLPYA'
   CALL DSPLYA
   XC = RESULT
   SAY 'EXCIS2A: RETUR   DSLPYA RC:'XC
   RETURN XC
   END
  IF MYFUNC ^= 'VERBOSE' THEN SIGNAL ARNDPOST
  O_C_A_LEN=LENGTH(C_A)
  C_A=STRIP(C_A,'T')
  N_C_A_LEN=LENGTH(C_A)
  SAY 'MAIN EXEC - RESULT VARIABLE CONTENTS:' RESULT
  SAY
  SAY 'EXCI_RESP IS:' EXCI_RESP
  SAY 'EXCI_RESP2 IS:' EXCI_RESP2
  SAY 'EXCI_ABCODE IS:' EXCI_ABCODE
  SAY 'EXCI_MESSAGE LENGTH IS:' LENGTH(EXCI_MESSAGE)
  SAY 'EXCI_MESSAGE IS:' EXCI_MESSAGE
  SAY
  SAY 'COMMAREA CONTENTS AFTER LINK ARE:'
  SAY 'LENGTH IS:' O_C_A_LEN
  SAY ' STRIPPED 'O_C_A_LEN-N_C_A_LEN' SPACES AT END OF COMMAREA'
  SAY 'COMMAREA WAS:>'H_MYCA
  MCT = 0
  DO WHILE(C_A ^= '')
   PARSE VAR C_A TMP (X15) C_A
   MCT=MCT+1
   MSG.MCT = TMP
   SAY TMP
   END
  IF MCT = 0 '' THEN MSG.1 = 'WARNING - NO OUTPUT RETURNED IN C_A'
 ARNDPOST:
DONIT:
  RETURN XC
###END EXCIS2A
$$$BEG EXCIS1A
/* REXX */
ADDRESS TSO
ARG APPLID_NAME
IF APPLID_NAME = '' THEN APPLID_NAME='CGE7'
PROGRAM_NAME = 'UCEMPINN'
COMMAREA_NAME= 'C_A'
C_A = 'CEDA EXPAND GROUP(CEM)'
C_A = 'PING'
C_A = 'CEMT INQUIRE PROGRAM(UCEMPINN)'
COMMAREA_DLEN = LENGTH(C_A)
C_A = C_A||COPIES(' ',1016-COMMAREA_DLEN)
COMMAREA_LEN = LENGTH(C_A)
/* APPLID_NAME='CGE7' */
USER_ID=SYSVAR(SYSUID)
TR_ID='CSMI'
PARM = "'PROGRAM("PROGRAM_NAME")','COMMAREA(C_A)',"||,
       "'TRANSID("TR_ID")',"||,
       "'LENGTH(COMMAREA_LEN)','APPLID("APPLID_NAME")'"
P1 = "PROGRAM("PROGRAM_NAME")"
P2 = "COMMAREA(C_A)"
P3 = "LENGTH("COMMAREA_LEN")"
P4 = "APPLID("APPLID_NAME")"
P5 = "TRANSID("TR_ID")"
P6 = "DATALENGTH("COMMAREA_DLEN")"
P7 = "USERID("USER_ID")"
EXCI_RESP='--'
EXCI_RESP2='##'
EXCI_ABCODE='____'
EXCI_MESSAGE='-'
SAY 'COMMAREA CONTENTS BEFORE LINK ARE:' COMMAREA
SAY
SAY 'CALLING EXCI LINK WITH PARAMETERS:'
PARM1 = PARM
DO UNTIL PARM1 = ''
  PARSE VAR PARM1 PART ',' PARM1
  SAY '   ' PART
  END
 INTERPRET "CALL CA1DLINK '"P1"','"P2"','"P3"','"P4"','"P5"'"
SAY 'MAIN EXEC - RESULT VARIABLE CONTENTS:' RESULT
SAY
SAY 'EXCI_RESP IS:' EXCI_RESP
SAY 'EXCI_RESP2 IS:' EXCI_RESP2
SAY 'EXCI_ABCODE IS:' EXCI_ABCODE
SAY 'EXCI_MESSAGE LENGTH IS:' LENGTH(EXCI_MESSAGE)
SAY 'EXCI_MESSAGE IS:' EXCI_MESSAGE
SAY
SAY 'COMMAREA CONTENTS AFTER LINK ARE:'
O_C_A_LEN=LENGTH(C_A)
SAY 'LENGTH IS:' O_C_A_LEN
IND = 0
X15='15'X
C_A=STRIP(C_A,'T')
N_C_A_LEN=LENGTH(C_A)
SAY ' STRIPPED 'O_C_A_LEN-N_C_A_LEN' SPACES AT END OF COMMAREA'
DO WHILE(C_A ^= '')
 PARSE VAR C_A TMP (X15) C_A
 SAY TMP
 END
/* SAY '<'||C_A||">" */
DONIT:
EXIT
###END EXCIS1A
$$$BEG EXCIDADO
/* REXX */
/*----------------- SAMPLE1 REXX EXEC -------------------------------*\
|* PLEASE RUN THE TSOLIB COMMAND FROM NATIVE TSO                     *|
|*  (GO BACK TO READY)> CEM EXCITSLB
|*  (NOW RUN...)      > CICLOGON
|*                                                                   *|
|* THIS EXEC USES THE EXCI LINK INTERFACE TO EXECUTE A CICS PROGRAM  *|
|*                                                                   *|
|* "CA1DCALL "PROGRAM("PROGRAM_NAME")" ,                              *|
|*              "APPLID("VTAM_APPLID")" ,                            *|
|*              "USERID("USER_ID")" ,                                *|
|*              "COMMAREA(CA_NAME)" ,           /* OPTIONAL */       *|
|*              "LENGTH("CA_LENGTH")" ,         /* OPTIONAL */       *|
|*              "DATALENGTH("COMMAREA_DLEN")" , /* OPTIONAL */       *|
|*              "TRANSID("TRANS_ID")"           /* OPTIONAL */       *|
|* PROGRAM_NAME  - CONTAINS THE NAME OF THE CICS PROGRAM TO EXECUT   *|
|*                 FOLLOWING THE NAMING CONVENTIONS FOR CICS PROGR   *|
|*                                                                   *|
|* VTAM_APPLID   - CONTAINS THE VTAM APPLID FOR THE CICS REGION WH   *|
|*                 IS TO RECEIVE THE REQUEST.                        *|
|*                                                                   *|
|* USER_ID       - CONTAINS THE CICS USERID UNDER WHICH THE CICS     *|
|*                 PROGRAM WILL EXECUTE.  THIS USERID MUST BE        *|
|*                 VALIDATED PRIOR TO CALLING THE CICS PROGRAM BEC   *|
|*                 THERE IS NO ABILITY TO PASS A PASSWORD TO CICS.   *|
|*                                                                   *|
|* CA_NAME       - IS THE NAME OF THE REXX VARIABLE THAT CONTAINS    *|
|*                 COMMAREA CONTENTS.  (BE SURE TO WATCH THE '"' T   *|
|*                 AVOID THE REXX VARIABLE SUBSTITUTION. IF COMMAR   *|
|*                 NOT SPECIFIED, THEN LENGTH AND DATALENGTH ARE     *|
|*                 IGNORED IF SPECIFIED.                             *|
|*                                                                   *|
|* CA_LENGTH     - CONTAINS THE LENGTH OF THE COMMAREA TO BE USED    *|
|*                 THE EXCI.  THIS LENGTH CANNOT EXCEED 32768. IF    *|
|*                 VALUE IS NOT SUPPLIED BUT THE CA_NAME IS SPECIF   *|
|*                 THEN THE LENGTH OF THE REXX VARIABLE IS USED.     *|
|*                                                                   *|
|* COMMAREA_DLEN - CONTAINS THE LENGTH OF THE DATA TO BE PASSED IN   *|
|*                 COMMAREA.  THIS LENGTH MUST NOT BE LARGER THAN    *|
|*                 LENGTH OF THE COMMAREA. IF THIS VALUE IS NOT      *|
|*                 SUPPLIED BUT LENGTH IS SPECIFIED, THEN LENGTH I   *|
|*                 USED.  IF LENGTH IS NOT SPECIFIED THEN THE LENG   *|
|*                 THE CA_NAME REXX VARIABLE CONTENTS IS USED.       *|
|*                                                                   *|
|* TRANS_ID      - CONTAINS THE NAME OF A TRANSACTION TO BE USED F   *|
|*                 THE MIRROR FUNCTION.  IF NOT ENTERED THE DEFAUL   *|
|*                 MIRROR TRANSACTION, CSMI IS USED.                 *|
\*-------------------------------------------------------------------*/
ADDRESS TSO
ARG APPLID_NAME
IF APPLID_NAME = '' THEN APPLID_NAME='CGE7'
PROGRAM_NAME = 'UCEMPINN'
COMMAREA_NAME= 'C_A'
C_A = 'PING'
COMMAREA_DLEN = LENGTH(C_A)
C_A = 'CEDA EXPAND GROUP(CEM)'
COMMAREA_DLEN = LENGTH(C_A)
C_A = 'CEMT SET FILE(DADS01) OPE'
COMMAREA_DLEN = LENGTH(C_A)
C_A = C_A||COPIES(' ',4096-COMMAREA_DLEN)
COMMAREA_LEN = LENGTH(C_A)
/* APPLID_NAME='CGE7' */
USER_ID=SYSVAR(SYSUID)
TR_ID='CSMI'
PARM = "'PROGRAM("PROGRAM_NAME")','COMMAREA(C_A)',"||,
       "'TRANSID("TR_ID")',"||,
       "'LENGTH(COMMAREA_LEN)','APPLID("APPLID_NAME")'"
P1 = "PROGRAM("PROGRAM_NAME")"
P2 = "COMMAREA(C_A)"
P3 = "LENGTH("COMMAREA_LEN")"
P4 = "APPLID("APPLID_NAME")"
P5 = "TRANSID("TR_ID")"
P6 = "DATALENGTH(4)"
P7 = "USERID("USER_ID")"
EXCI_RESP='--'
EXCI_RESP2='##'
EXCI_ABCODE='____'
EXCI_MESSAGE='-'
SAY 'COMMAREA LENGTH IS:' LENGTH(C_A)
SAY 'COMMAREA CONTENTS BEFORE LINK ARE:'
SAY '>'||STRIP(C_A,'T')||'<'
SAY
SAY 'CALLING CICSLINK WITH PARAMETERS:'
PARM1 = PARM
DO UNTIL PARM1 = ''
  PARSE VAR PARM1 PART ',' PARM1
  SAY '   ' PART
  END
SAY 'PRESS ENTER TO CONTINUE OR PA1 TO INTERUPT'
/* MDDN = 'ISPLLIB'
 MDSN = "'TTEP.TSK.E.TCEM.PDSE'"
 "ISPEXEC LIBDEF "MDDN" DATASET ID("MDSN") UNCOND"
 IF RC ^= 0 THEN SIGNAL DONIT */
 /* "ISPEXEC SELECT PGM(ISPLLS) SCRNAME(LIBDEF)" */
/* NEXT 2 WORK - ALL ARGS ARE COMBINED INTO ONE RX ARG */
/* RXVARS_RESULT = CA1DLINK('P1','P2','P3','P4','P5') */
/* CALL CA1DLINK 'P1','P2','P3','P4','P5' */
/* THIS WORKS - EACH ARG IS SEPARATE IN RX ARG TABLE */
/* INTERPRET "CALL CA1DLINK '"P1"','"P2"','"P3"','"P4"','"P5"'" */
/* CALL EXCICOBL*/
/* TTEP.TSK.E.TCEM.PDSE */
    INTERPRET "CALL CA1DLINK '"P1"','"P2"','"P3"','"P4"','"P5"'"
/* XX=CA1DLINK('PROGRAM' ,
             'APPLID' ,
             'COMMAREA' ,
             'LENGTH' ,
             'DATALENGTH' ,
             'TRANSID'      ) */
/* XX=CA1DLINK('PROGRAM(UCEMPINN)' ,
             'APPLID(CGE5)' ,
             'COMMAREA(COMMAREA)' ,
             'LENGTH(1080)' ,
             'DATALENGTH(4)' ,
             'TRANSID(UTST)') */
SAY 'MAIN EXEC - RESULT VARIABLE CONTENTS:' RESULT
SAY
SAY 'EXCI_RESP IS:' EXCI_RESP
SAY 'EXCI_RESP2 IS:' EXCI_RESP2
SAY 'EXCI_ABCODE IS:' EXCI_ABCODE
SAY 'EXCI_MESSAGE LENGTH IS:' LENGTH(EXCI_MESSAGE)
SAY 'EXCI_MESSAGE IS:' EXCI_MESSAGE
SAY
SAY 'COMMAREA CONTENTS AFTER LINK ARE:'
O_C_A_LEN=LENGTH(C_A)
SAY 'LENGTH IS:' O_C_A_LEN
IND = 0
X15='15'X
C_A=STRIP(C_A,'T')
N_C_A_LEN=LENGTH(C_A)
SAY ' STRIPPED 'O_C_A_LEN-N_C_A_LEN' SPACES AT END OF COMMAREA'
DO WHILE(C_A ^= '')
 PARSE VAR C_A TMP (X15) C_A
 SAY TMP
 END
/* SAY '<'||C_A||">" */
DONIT:
EXIT
###END EXCIDADO
$$$BEG CA1DTEST
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA          -                                              */
 /* CEMHELP          - TSO BASE, RESTRICTED                         */
 /* CEMHELP          -                                              */
 /* CEMHELP END                                                     */
 /* THIS SUPPORTPAC USES REXX STEM VARIABLES FOR PASSING            */
 /* INFORMATION TO AND FROM CICS. A STEM VARIABLE IS IN             */
 /* THE FORMAT OF NAME.COMPONENT : THE NAME. PART CAN BE            */
 /* WHATEVER DESIRED, BUT THE COMPONENT PART (AFTER THE             */
 /* DOT) IS DEFINED BY THE INTERFACE.                               */
 /* TRACE IS ENABLED BY SETTING THE RXDPLTRACE VARIABLE.            */
 /* TRACE OUTPUT GOES TO THE STANDARD DESTINATION (FOR              */
 /* THE CURRENT ENVIRONMENT) THAT THE SAY OPERATION USES            */
 /* (WHICH IS USUALLY //SYSTSPRT). IF YOU ARE USING                 */
 /* RXDPL WITHIN A PROCEDURE, YOU NEED TO EXPOSE                    */
 /* RXDPLTRACE ACCORDINGLY. TRACE IS INITIALLY OFF. THE             */
 /* AVAILABLE SETTINGS FOLLOW FUNCTIONS WITHIN RXDPL:               */
 /* COMMON THINGS EXECUTED ON EACH USAGE OF RXDPL INIT              */
 /* EXECUTION OF THIS INITIALISE FUNCTION FOR THE                   */
 /* INTERFACE TERM EXECUTION OF THIS TERMINATION                    */
 /* FUNCTION FOR THE INTERFACE LINK EXECUTION OF ACTUAL             */
 /* DPL FLOWS BY THE INTERFACE SV SETTING REXX VARIABLES            */
 /* GV READING REXX VARIABLES * TRACE EVERYTHING                    */
 /*  RCC = RXDPL('FUNCTION', P1, P2, P3)                           */
 /* RCC = RXDPL('LINK', 'CONTROLSTEM.' , ||                         */
 /* 'INPUTCOMMAREASTEM.',                ||                         */
 /* 'OUTPUTCOMMAREASTEM.')                                          */
 /* DROP CS.         -                                              */
 /* CS.PROG = 'UCEMPINN'                                            */
 /* CS.APPLID = 'CGTO    '                                          */
 /* CS.USERID = SYSVAR(SYSUID)                                      */
 /* CS.TRAN = 'CSMI' -                                              */
 /*                                                                 */
 /* THE INPUT AND OUTPUT COMMAREA STEMS FOLLOW THE USUAL            */
 /* CONVENTION FOR VARIABLE LENGTH REXX ITEMS: .0                   */
 /* CONTAINS THE LENGTH OF DATA IN .1 .                             */
 /* MAX LENGTH SPECIFIED BY INPUT OR OUTPUTLENGTH                   */
 /* ADDITIONAL OUTPUT CA STEMS: DIDFLOW, O, AC, RESP, RESP2, ABEND, */
 /* AND MSG.         -                                              */
 /* WHEN RXDPL IS CALLED, ONLY OUTPUTCOMMAREASTEM.0 CAN             */
 /* BE OPTIONALLY SUPPLIED. NO OTHER COMPONENTS SHOULD              */
 /* BE PRESENT.      -                                              */
 /*                  -                                              */
 /*                  -                                              */
 /*                  -                                              */
 /*                  -                                              */
 /*                  -                                              */
 /*                  -                                              */
 /*                  -                                              */
 /*                  -                                              */
 /*                  -                                              */
 ADDRESS TSO
 TRACE I
 RCC = 0
/*  RCC = RXDPL('INIT') */
 "ALLOC FI(SYSPRINT) DA(*)"
"ALLOC FI(SYSUDUMP) SYSOUT(*)"
 "CALL 'TTEP.TSK.E.TCEM.PDSE(EXPLPGM)' 'INIT'"
 /* "CALL 'TCEM.CA1IMODR(RXDPL)' 'INIT'" */
 "FREE FI(SYSPRINT)"
"FREE FI(SYSUDUMP)"
 RCC = RC
 SAY RCC
 LASTRC = STRIP(WORD(RCC,1),'B')
 IF LASTRC ^= 0 THEN EXIT 12
 EXIT
 LASTFAILURE = RXDPL.RCMAP.LASTRC
 DROP OCA.
 CMD.APPLID = 'CGE7    '
 CMD.PROG = 'UCEMPINN'
 CMD.USERID = SYSVAR(SYSUID)
 CMD.TRAN=UPNG
 ICA.1 = 'PING'||COPIES(' ',1000)
 ICA.0 = LENGTH(ICA.0)
 RCC = RXDPL('LINK', 'CMD.', 'ICA.', 'OCA.')
SELECT
WHEN ( DPOUT.DIDFLOW = 'Y' ) DO
 SAY '>' OCA.0 '<'
 SAY '>' OCA.1 '<'
 END
WHEN ( DPOUT.DIDFLOW = 'F' ) DO
 SAY 'ERROR IN FLOW::'
 SAY RCC
 END
OTHERWISE DO
 SAY
 END
END
RCC = RXDPL('TERM')
###END CA1DTEST
$$$BEG RXLISTC
/* REXX */                                                              00050000
 /********************************************************************/ 00100000
 /*                                                                  */ 00150000
 /*       NAME: IGGCSIRX                                             */ 00200000
 /*DESCRIPTION: THIS REXX EXEC IS USED TO CALL THE CATALOG           */ 00250000
 /*             SEARCH INTERFACE. (IGGCSICL)                         */ 00300000
 /*      INPUT: FILTER KEY                                           */ 00350000
 /*     OUTPUT: DATA SETS NAMES AND VOLUMES                          */ 00400000
 /*                                                                  */ 00406200
 /* CHANGE ACTIVITY:                                                 */ 00412400
 /* $01=OW39593,HDZ11F0,990904,SJPLMET: BUMP WORK AREA TO        @01A*/ 00418600
 /*              64,000 BYTES TO HANDLE CASES WHERE THE RETURN   @01A*/ 00424800
 /*              DATA FOR A GDG BASE CANNOT FIT IN A WORKAREA    @01A*/ 00431000
 /*              EVEN ON A RESUME.  THE EXAMPLE IS CHANGED TO    @01A*/ 00437200
 /*              STOP WHEN THIS HAPPENS AND ISSUE A MESSAGE.     @01A*/ 00443400
 /* $01=OW46614,HDZ11G0,010130,SJPLMET: CORRECT FAILURE TO       @02A*/ 00445000
 /*             DISPLAY ALL INFO WHEN THE FILTER KEY CONTAINS A  @02A*/ 00446600
 /*             GENERIC IN THE HLQ.                              @02A*/ 00448200
 /*                                                                  */ 00450000
 /********************************************************************/ 00500000
 SAY 'ENTER FILTER KEY'             /*   ASK FOR FILTER KEY          */ 00550000
 PULL KEY                           /*   GET FILTER KEY              */ 00600000
 /********************************************************************/ 00650000
 /*                                                                  */ 00700000
 /*  INITIALIZE THE PARM LIST                                        */ 00750000
 /*                                                                  */ 00800000
 /********************************************************************/ 00850000
MODRSNRC = SUBSTR(' ',1,4)          /*   CLEAR MODULE/RETURN/REASON  */ 00900000
CSIFILTK = SUBSTR(KEY,1,44)         /*   MOVE FILTER KEY INTO LIST   */ 00950000
CSICATNM = SUBSTR(' ',1,44)         /*   CLEAR CATALOG NAME          */ 01000000
CSIRESNM = SUBSTR(' ',1,44)         /*   CLEAR RESUME NAME           */ 01050000
CSIDTYPS = SUBSTR(' ',1,16)         /*   CLEAR ENTRY TYPES           */ 01100000
CSICLDI  = SUBSTR('Y',1,1)          /*   INDICATE DATA AND INDEX     */ 01150000
CSIRESUM = SUBSTR(' ',1,1)          /*   CLEAR RESUME FLAG           */ 01200000
CSIS1CAT = SUBSTR(' ',1,1)          /*   INDICATE SEARCH > 1 CATALOGS*/ 01250000
CSIRESRV = SUBSTR(' ',1,1)          /*   CLEAR RESERVE CHARACTER     */ 01300000
CSINUMEN = '0001'X                  /*   INIT NUMBER OF FIELDS       */ 01350000
CSIFLD1    = SUBSTR('VOLSER',1,8)   /*   INIT FIELD 1 FOR VOLSERS    */ 01400000
 /********************************************************************/ 01450000
 /*                                                                  */ 01500000
 /*  BUILD THE SELECTION CRITERIA FIELDS PART OF PARAMETER LIST      */ 01550000
 /*                                                                  */ 01600000
 /********************************************************************/ 01650000
CSIOPTS  = CSICLDI || CSIRESUM || CSIS1CAT || CSIRESRV                  01700000
CSIFIELD = CSIFILTK || CSICATNM || CSIRESNM || CSIDTYPS || CSIOPTS      01750000
CSIFIELD = CSIFIELD || CSINUMEN || CSIFLD1                              01800000
                                                                        01850000
 /********************************************************************/ 01900000
 /*                                                                  */ 01950000
 /*  INITIALIZE AND BUILD WORK ARE OUTPUT PART OF PARAMETER LIST     */ 02000000
 /*                                                                  */ 02050000
 /********************************************************************/ 02100000
WORKLEN = 64000                                                /*@01C*/ 02150000
DWORK = '0000FA00'X || COPIES('00'X,WORKLEN-4)                 /*@01C*/ 02200000
                                                                        02250000
 /********************************************************************/ 02300000
 /*                                                                  */ 02350000
 /*  INITIALIZE WORK VARIABLES                                       */ 02400000
 /*                                                                  */ 02450000
 /********************************************************************/ 02500000
RESUME = 'Y'                                                            02550000
PREVNAME = ''                     /* NO PREVIOUS NAME            @01A*/ 02575000
CATNAMET = SUBSTR(' ',1,44)                                             02600000
DNAMET = SUBSTR(' ',1,44)                                               02650000
                                                                        02700000
 /********************************************************************/ 02750000
 /*                                                                  */ 02800000
 /*  SET UP LOOP FOR RESUME (IF A RESUME IS NCESSARY)                */ 02850000
 /*                                                                  */ 02900000
 /********************************************************************/ 02950000
DO WHILE RESUME = 'Y'                                                   03000000
                                                                        03050000
 /********************************************************************/ 03100000
 /*                                                                  */ 03150000
 /*  ISSUE LINK TO CATALOG GENERIC FILTER INTERFACE                  */ 03200000
 /*                                                                  */ 03250000
 /********************************************************************/ 03300000
 ADDRESS LINKPGM 'IGGCSI00  MODRSNRC  CSIFIELD  DWORK'                  03350000
                                                                        03400000
 RESUME = SUBSTR(CSIFIELD,150,1)    /* GET RESUME FLAG FOR NEXT LOOP */ 03450000
 USEDLEN = C2D(SUBSTR(DWORK,9,4))   /* GET AMOUNT OF WORK AREA USED  */ 03500000
 POS1=15                            /* STARTING POSITION             */ 03550000
                                                                        03600000
 /********************************************************************/ 03650000
 /*                                                                  */ 03700000
 /*  PROCESS DATA RETURNED IN WORK AREA                              */ 03750000
 /*                                                                  */ 03800000
 /********************************************************************/ 03850000
 DO WHILE POS1 < USEDLEN            /* DO UNTIL ALL DATA IS PROCESSED*/ 03900000
   IF SUBSTR(DWORK,POS1+1,1) = '0'  /* IF CATALOG, EXTRACT CATALOG   */ 03950000
    THEN DO                         /* NAME FOR LATER PRINTING   @02C*/ 04000000
         CATNAME=SUBSTR(DWORK,POS1+2,44)                                04050000
         POS1 = POS1 + 50                                               04400000
         END                                                            04450000
  IF POS1 < USEDLEN THEN             /* IF STILL MORE DATA       @02A*/ 04487500
   DO                                /* CONTINUE WITH NEXT ENTRY @02A*/ 04525000
    DNAME = SUBSTR(DWORK,POS1+2,44)  /* GET ENTRY NAME               */ 04562500
                                                                        04600000
 /********************************************************************/ 04650000
 /*                                                                  */ 04700000
 /*  ASSIGN ENTRY TYPE NAME                                          */ 04750000
 /*                                                                  */ 04800000
 /********************************************************************/ 04850000
   IF SUBSTR(DWORK,POS1+1,1) = 'C' THEN DTYPE = 'CLUSTER '              04900000
    ELSE                                                                04950000
      IF SUBSTR(DWORK,POS1+1,1) = 'D' THEN DTYPE = 'DATA    '           05000000
     ELSE                                                               05050000
      IF SUBSTR(DWORK,POS1+1,1) = 'I' THEN DTYPE = 'INDEX   '           05100000
     ELSE                                                               05150000
      IF SUBSTR(DWORK,POS1+1,1) = 'A' THEN DTYPE = 'NONVSAM '           05200000
     ELSE                                                               05250000
      IF SUBSTR(DWORK,POS1+1,1) = 'H' THEN DTYPE = 'GDS     '           05300000
     ELSE                                                               05350000
      IF SUBSTR(DWORK,POS1+1,1) = 'B' THEN DTYPE = 'GDG     '           05400000
     ELSE                                                               05450000
      IF SUBSTR(DWORK,POS1+1,1) = 'R' THEN DTYPE = 'PATH    '           05500000
     ELSE                                                               05550000
      IF SUBSTR(DWORK,POS1+1,1) = 'G' THEN DTYPE = 'AIX     '           05600000
     ELSE                                                               05650000
      IF SUBSTR(DWORK,POS1+1,1) = 'X' THEN DTYPE = 'ALIAS   '           05700000
     ELSE                                                               05750000
      IF SUBSTR(DWORK,POS1+1,1) = 'U' THEN DTYPE = 'UCAT    '           05800000
     ELSE                                                               05850000
       IF SUBSTR(DWORK,POS1+1,1) = 'L' THEN DTYPE = 'ATLLIB  ' /*@02A*/ 05866600
      ELSE                                                     /*@02A*/ 05883200
       IF SUBSTR(DWORK,POS1+1,1) = 'W' THEN DTYPE = 'ATLVOL  ' /*@02A*/ 05899800
      ELSE ,    /*  NO ENTRIES IN THE CATALOG - LOOK AT    */  /*@02A*/ 05916400
        ITERATE   /*  NEXT CATALOG NAME - GENERIC HLQ ONLY */  /*@02A*/ 05933000
 /********************************************************************/ 05950000
 /*                                                                  */ 06000000
 /*  HAVE NAME AND TYPE, GET VOLSER INFO.  IF WE FOUND A VALID TYPE  */ 06033300
 /*  FOR THIS CATALOG, NOW PRINT THE CATALOG NAME (FIRST ENTRY ONLY).*/ 06066600
 /*                                                                  */ 06100000
 /********************************************************************/ 06150000
     IF CATNAME ^= CATNAMET THEN /* IF RESUME NAME MAY ALREADY   @02C*/ 06157100
      DO                         /*    BE PRINTED                    */ 06164200
       SAY 'CATALOG ' CATNAME    /* IF NOT, PRINT IT             @02C*/ 06171300
       SAY ' '                                                 /*@02C*/ 06178400
       CATNAMET = CATNAME                                      /*@02C*/ 06185500
      END                                                      /*@02C*/ 06192600
    POS1 = POS1 + 46                                                    06200000
    NUMVOL = C2D(SUBSTR(DWORK,POS1+4,2))/6 /* HOW MANY VOLSERS ?     */ 06250000
                                    /*                               */ 06300000
    POS2 = POS1+6                   /* POSITION ON DATA              */ 06350000
    DO I=1 TO 3                     /* ONLY CLEAR 3 VOLSER FIELDS    */ 06400000
      VOLSER.I = SUBSTR(' ',1,6)                                        06450000
    END                                                                 06500000
    DO I = 1 TO NUMVOL              /* MOVE VOLSERS TO OUTPUT FIELDS */ 06550000
      VOLSER.I = SUBSTR(DWORK,POS2,6)                                   06600000
      POS2 = POS2 + 6                                                   06650000
    END                                                                 06700000
     SAY COPIES(' ',8) DTYPE DNAME VOLSER.1 VOLSER.2 VOLSER.3           06900000
 /********************************************************************/ 07050000
 /*                                                                  */ 07100000
 /*   GET POSITION OF NEXT ENTRY                                     */ 07150000
 /*                                                                  */ 07200000
 /********************************************************************/ 07250000
    POS1 = POS1 + C2D(SUBSTR(DWORK,POS1,2))                             07300000
  END                               /* OF ROOM LEFT IN WORKAREA  @02A*/ 07318500
 END                                                                    07337000
 IF RESUME = 'Y' &,                 /* IF WE'VE TRIED THIS ENTRY @01A*/ 07355500
  PREVNAME = DNAME THEN             /* TWICE, WE'VE GOT TO QUIT  @01A*/ 07361000
   DO                                                          /*@01A*/ 07366500
     SAY STRIP(DNAME) 'CANNOT BE PROCESSED WITH THE WORK AREA SIZE ',   07372000
         'PROVIDED - YOU MUST INCREASE THE WORK AREA AND RETRY'         07377500
     RETURN                                                    /*@01A*/ 07383000
   END                                                         /*@01A*/ 07388500
 PREVNAME = DNAME                   /* SAVE FOR NEXT ITERATION   @01A*/ 07394000
END                                                                     07400000
###END RXLISTC
$$$BEG MYCALC
/* REXX */
/* TRACE I */
 MDE='M'
/*        12345678901234567890123 */
 VALRESP='0123456789ABCDEF.%R+-XM'
 VALFUNC='+-*/#=Z@XMRLOPY?'
 VALMEMF='+-*/%Z='
 DECACUM=0
 HEXVAL=0
 DECMEM=0
 HEXMEM=0
 MEMIND='0'
 LOGIND='0'
 L=1
 LOGG.1='INITIAL VALUE'
RCLOOP:
 IF LOGIND = '1' THEN DO
  LOGG.L='ENTRY --->'RESP' FN 'FUNC' === DECVAL 'DECACUM
  L = L+1
  END
 IF MDE = 'M' THEN DO
  SAY 'MODE DECIMAL ---> CURRENT DEC VALUE IS 'DECACUM
  IF MEMIND='1' THEN SAY '                    MEMORY VALUE 'DECMEM
  END
  ELSE DO
  SAY 'MODE HEX ---> CURRENT HEX VALUE IS' HEXVAL
  IF MEMIND='1' THEN SAY '                    MEMORY VALUE 'HEXMEM
  END
 PULL RESP
 IF RESP='' THEN SIGNAL EXITRC0
 RESPL = LENGTH(RESP)
 IF RESPL > 8 THEN SIGNAL INVRESP
 NEWVAL='0'
 SMDE=MDE
 SMDET=''
 DECPT=0
 J=1
 FUNC='+'
 TSTCHAR=SUBSTR(RESP,1,1)
 /* TEST IF PRIM OPERATION IS INVOKED */
 VALCHAR=POS(TSTCHAR,VALFUNC)
 IF VALCHAR \=0 THEN DO
  FUNC = TSTCHAR
  J=2
  END
 ELSE SIGNAL BYPFUNC
 IF FUNC = 'L' THEN DO
  L=1
  LOGG.L 'LOG STARTED. O TURNS LOG OFF, Y DISPLAYS LOG, P PRINTS LOG'
  SAY LOGG.L
  LOGIND = '1'
  SIGNAL RCLOOP
  END
 IF FUNC = 'O' THEN DO
  LOGG.L = 'LOG STOPPED. USE Y TO DISPLAY LOG, P TO PRINT LOG'
  SAY LOGG.L
  LOGIND = '0'
  SIGNAL RCLOOP
  END
 IF FUNC = 'P' THEN DO
  SAY 'FUNCTION NOT AVAILABLE'
  SIGNAL RCLOOP
  END
 IF FUNC = 'Y' THEN DO
  SAY 'LOG DISPLAY FOLLOWS'
  DO K=1 TO (L-1)
   SAY LOGG.K
   END
  SIGNAL RCLOOP
  END
 IF FUNC = '?' THEN DO
  CLEAR
  SAY ' MY CALC SUPPORTS THE FOLLOWING PRIMARY OPERATIONS'
  SAY ' + ADD      - SUBTRACT    / DIVIDE      * MULTIPLY'
  SAY ' # SQUARE   = SUBTTOTAL   Z ZERO ACCUM  @ RANDOM NUMBER GEN'
  SAY ' X CVT HEX  M CVT DEC     R RETRIEVE MEMORY VALUE'
  SAY '    SINGULAR PRIMARY OPERATIONS. ACCUMULATOR NOT AFFECTED'
  SAY ' L LOG ON   O LOG OFF     P PRINT LOG   Y DISPLAY LOG'
  SAY
  SAY 'MEMORY OPERATOR FOLLOW R PRIMARY OPERATION, AFFECTS ACCUM'
  SAY ' + ADD      - SUBTRACT    * MULT        / DIVIDE'
  SAY ' Z ZERO MEMORY            = ZERO ACCUM, ADD CURRENT MEMORY'
  SAY ' % DETERMINE PERCENTAGE CURACUM / MEMORY '
  SAY
  SAY 'SUPPORTED VALUES FOLLOWING FUNCTIONS'
  SAY ' 0 THRU 9 IN DECIMILE MODE    0 - F IN HEX MODE'
  SAY ' X OR M SUFFIX TO FORCE MODE OF VALUE WITHOUT CHNGING PRIM MODE'
  SAY ' % SUFFIX TREATS VALUE AS PERCT OF CURRENT ACCUM'
  SAY
  SIGNAL RCLOOP
  END
/* RETRIEVE MEMORY FUNCTION */
/* ONLY + - * /  ALLOWED */
 IF FUNC = 'R' THEN DO
  IF RESPL \= 2 THEN SIGNAL INVRESP
  TSTCHAR=SUBSTR(RESP,2,1)
  VALCHAR=POS(TSTCHAR,VALMEMF)
  IF VALCHAR =0 THEN SIGNAL INVRESP
  IF TSTCHAR = 'R' THEN SIGNAL INVRESP
  MEMIND = '1'
  FUNC = TSTCHAR
  IF FUNC='Z' THEN DO
   DECMEM=0
   HEXMEM='0'
   MEMIND='0'
   SIGNAL RCLOOP
   END
  IF FUNC='=' THEN DO
   DECACUM=DECMEM
   SIGNAL RCLOOP
   END
  IF FUNC='%' THEN DO
   DECACUM=(DECACUM*100)/DECMEM))
   SIGNAL RCLOOP
   END
  INTERPRET 'DECMEM = DECACUM'FUNC'DECMEM'
  HEXMEM=TRUNC(DECMEM,0)
  IF HEXMEM< 0 THEN DO
   HEXMEM=ABS(HEXMEM)
   END
  HEXMEM = D2X(HEXMEM)
  SIGNAL RCLOOP
  END
BYPFUNC:
 DO I = J TO RESPL
  TSTCHAR=SUBSTR(RESP,I,1)
  VALCHAR=POS(TSTCHAR,VALRESP)
  IF VALCHAR = 0 THEN INVRESP
  IF VALCHAR < 11 THEN DO
   NEWVAL=NEWVAL||TSTCHAR
   ITERATE
   END
/* IF LESS THAN 17 THEN 0-F. SET MODE TO X */
  IF VALCHAR < 17 THEN DO
   IF DECPT=1 THEN SIGNAL INVRESP
   NEWVAL=NEWVAL||TSTCHAR
   SMDET='X'
   ITERATE
   END
/* DECIMILE POINT. NOT VALID IF SMDET IS HEX */
  IF TSTCHAR = '.' THEN DO
   NEWVAL=NEWVAL||TSTCHAR
   DECPT=1
   ITERATE
   END
  IF TSTCHAR = 'R' THEN DO
   IF RESPL \= 2 THEN SIGNAL INVRESP
   IF FUNC = '@' THEN SIGNAL INVRESP
   NEWVAL=DECMEM
   SIGNAL PROCFNC
   END
  IF TSTCHAR = '%' THEN DO
   IF I \= RESPL THEN SIGNAL INVRESP
   IF FUNC = '@' THEN SIGNAL INVRESP
   NEWVAL=(DECACUM*(NEWVAL/100))
   SIGNAL PROCFNC
   END
  IF TSTCHAR = '-' | TESTCHAR = '+' THEN DO
   IF I \= RESPL & I \= RESPL-1 THEN SIGNAL INVRESP
   INTERPRET 'NEWVAL = 'TSTCHAR'1*NEWVAL'
   ITERATE
   END
  IF VALCHAR > 21 THEN DO
   IF I \= RESPL THEN SIGNAL INVRESP
   SMDET=TSTCHAR
   SIGNAL PROCFNC
   END
  IF I \= J THEN SIGNAL INVRESP
  END
PROCFNC:
 IF FUNC='Z' THEN DO
  DECACUM=0
  HEXACUM='0'
  FUNC = '+'
  SIGNAL PROCNUM
  END
 IF FUNC='=' THEN DO
  FUNC = '+'
  SIGNAL PROCNUM
  END
 IF FUNC = '@' THEN DO
  NEWVAL=RANDOM(,,TRUNC(NEWVAL))
  FUNC = '+'
  SIGNAL PROCNUM
  END
 IF FUNC = '#' THEN DO
  IF RESPL = 1 THEN DO
   NEWVAL = DECACUM
   FUNC = '*'
   SIGNAL PROCNUM
   END
  NEWVAL=NEWVAL*NEWVAL
  FUNC = '+'
  SIGNAL PROCNUM
  END
 IF FUNC = 'X' THEN DO
  SMDE='X'
  FUNC = '+'
  SIGNAL PROCNUM
  END
 IF FUNC = 'M' THEN DO
  SMDE='M'
  FUNC = '+'
  SIGNAL PROCNUM
  END
PROCNUM:
 IF SMDET = 'X' THEN DO
  NEWVAL=X2D(NEWVAL)
  END
  ELSE IF SMDET = '' & SMDE = 'X' THEN DO
    NEWVAL=X2D(NEWVAL)
    END
 INTERPRET 'DECACUM = DECACUM'FUNC'NEWVAL'
 IF SMDE = 'X' THEN DO
  MDE='X'
  HEXVAL=TRUNC(DECACUM,0)
  IF HEXVAL\=DECACUM THEN SAY 'HEX CONV TRUNCATES DECIMILE POSITIONS'
  IF HEXVAL< 0 THEN DO
   SAY 'HEX RESULT IS NEGITIVE, AND THUS IMPROPER. ABS VAL DISPLAYED'
   HEXVAL=ABS(HEXVAL)
   END
  HEXVAL = D2X(HEXVAL)
  END
  ELSE IF SMDE='M' THEN MDE='M'
 SIGNAL RCLOOP
INVRESP:
 SAY 'INVALID INPUT...RETRY'
 SIGNAL RCLOOP
EXITRC0:
 SAY 'MYCALC ENDING'
 EXIT
###END MYCALC
$$$BEG DSPSDSF
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA          -                                              */
 /* CEMHELP          - TSO BASE, RESTRICTED                         */
 /* CEMHELP          -                                              */
 /* CEMHELP END                                                     */
   ADDRESS ISPEXEC
 /* TRACE ?I */
   FFX='FF'X
   CMDIND = 0
   GOODLIST=''
   BADLIST=''
   DUPLIST=''
   VQMODE='VERBOSE'
   VALVQMODE='QUIET VERBOSE TRACE'
   ARGLIST='JOB APPLID PDS DDNAME PANEL VQMODE'
   VALSDSF='DA ST H'
   SS1='VALID PANEL:'||VALSDSF
   SS2='JESMSGLG JESJCL JESYSMSG DFHCXRF LOGUSR MSGUSR '
   SS3='PLIMSG COUT CEEMSG CEEOUT TCPDATA ACF2LOG USSTDD '
   SS4='CRPO CINT FDBDLOG XDGBLRPT XDBPARPT STDERR STDOUT'
   VALDDN=SS2||SS3||SS4||' NONE'
   VAL_DA_COLS='SRVCLASS SYSNAME'
   VAL_ST_COLS='SRVCLS ACTSYS SYSAFF QUEUE'
   VAL_H_COLS='DSDATE RETCODE DATEE'
   VALFILTER='DA('||VAL_DA_COLS||,
             ') ST('||VAL_ST_COLS||,
             ') H('||VAL_H_COLS||')'
   VALSRVCLS='SVRCLS(ONLTST ONLPRD ONLSRVR ONLSRVT)'
   VALQUEUE ='EXECUTIO PRINT'
   SS5=VALFILTER
   SS6=VALSRVCLS
   SS7=VALQUEUE
   CALL GETCPU1
   XC=RESULT
   IF XC ^= 0 THEN SIGNAL EXITRC8
   "ISPEXEC VGET (CURGRP CURCPUG) PROFILE"
   IF RC ^= 0 THEN SIGNAL EXITRC8
 GOTCPUG:
   L_CPUG=LENGTH(CURCPUG)
   HOSTLIST=''
   DO I = 1 TO L_CPUG
    /* H = 'CPUHOST'SUBSTR(CURCPUG,I,1) */
    TH = SUBSTR(CURCPUG,I,1)||'SYS'
    INTERPRET TH'=TH'
    HOSTLIST = HOSTLIST||" "TH
    END
   VALASYS  = HOSTLIST
   VALSAFF  = HOSTLIST
   SS8=HOSTLIST
   VQMODE_LIST=VALVQMODE
   SELN='INPUT'
   SDSFJOBN=''
   APPLLIST=''
   LISTLIST=''
   ISFILTER='OFF'
   HSDSFJBL=''
   HSDSFDDN='MSGUSR'
   HSDSFPNL='DA'
   CALL GETUDSN 'CICSSDSF.'HSDSFDDN
   PULL EDSN
   HSDSFOP=EDSN
   SDSFJOBL=''
   SDSFDDN=HSDSFDDN
   SDSFPNL=HSDSFPNL
   SDSFOP=HSDSFOP
/*  */
   "ISPEXEC CONTROL ERRORS RETURN"
   "ISPEXEC VGET (MYAFOIND SVAFO0) SHARED"
   IF RC = 0 THEN SIGNAL AFLD
   CALL AFOLOAD1
   "ISPEXEC VGET (MYAFOIND SVAFO0) SHARED"
   IF RC \= 0 THEN DO
    MSGBOXTX='ERROR. COULD NOT LOAD AFOLIST. ENDING'
    SIGNAL EXITRC20
    END
AFLD:
   "ISPEXEC VGET (GPAFO0) SHARED"
   IF RC \= 0 THEN DO
    MSGBOXTX='ERROR. COULD NOT ACCESS AFOLIST. ENDING'
    SIGNAL EXITRC20
    END
   "ISPEXEC VGET (AFOJOBLS AFOAPLLS) SHARED"
/*  */
   PARSE UPPER ARG A
   IF A = '' THEN SIGNAL NOARGS
   DO WHILE A \= ''
    PARSE VAR A B A
    FPOS=POS('(',B)
    IF FPOS < 2 THEN SIGNAL EXITRC14
    EPOS = POS(')',B)
    IF EPOS = 0 THEN SIGNAL EXITRC14
    CWD=SUBSTR(B,1,FPOS-1)
    FPOS=FPOS+1
    PWD=SUBSTR(B,FPOS,(EPOS-FPOS))
    WP=WORDPOS(CWD,ARGLIST)
    IF WP = 0 THEN SIGNAL EXITRC14
    IF CWD = 'JOB' THEN DO
     HSDSFJBL = PWD
     ITERATE
     END
    IF CWD = 'APPLID' THEN DO
     APPLLIST=PWD
     ITERATE
     END
    IF CWD = 'DDNAME' THEN DO
     HSDSFDDN=PWD
     ITERATE
     END
    IF CWD = 'PDS' THEN DO
     HSDSFOP=PWD
     ITERATE
     END
    IF CWD = 'PANEL' THEN DO
     SDSFPNL=PWD
     ITERATE
     END
    IF CWD = 'VQMODE' THEN DO
     VQMODE=PWD
     ITERATE
     END
    END
   IF APPLLIST \= '' | HSDSFJBL \= '' THEN DO
    IF HSDSFJBL \= '' THEN DO
     APPLLIST=APPLLIST||','||HSDSFJBL
     HSDSFJBL=''
     END
/*  CALL GETJOBL APPLLIST HSDSFJBL */
    CALL GETJOBL
    XC = RESULT
    IF XC \= 0 THEN DO
     IF XC = 20 THEN DO
      MSGBOXTX=FFX||'ERROR. APPLICATION LIST IS INVALID'||FFX||BADLIST
      SIGNAL EXITRC16
      END
     IF XC = 22 THEN DO
      MSGBOXTX=FFX||'ERROR. APPLICATION LIST IS EMPTY.'||FFX||HSDSFJBL
      SIGNAL EXITRC16
      END
     MSGBOXTX=FFX||'ERROR PROCESSING APPLICATION LIST'||FFX||HSDSFJBL
     SIGNAL EXITRC16
     END
    SDSFJOBL=HSDSFJBL
    END
   IF WORDPOS(VQMODE,VQMODE_LIST) = 0 THEN DO
     MSGBOXTX=FFX||'ERROR. PROCESSING MODE INVALID:'VQMODE||FFX||,
      'CHOOSE VALID PROCESSING MODE:'||FFX||VQMODE_LIST
     SIGNAL EXITRC16
     END
   IF SDSFDDN \= '' AND ,
      WORDPOS(SDSFDDN,VALDDN) = 0 THEN DO
     MSGBOXTX=FFX||'ERROR. SELECTED DDNAME INVALID:'SDSFDDN||FFX||,
      'CHOOSE VALID DDNAMES ARE:'||FFX||VALDDN
     SIGNAL EXITRC16
     END
   IF SDSFPNL \= '' AND ,
      WORDPOS(SDSFPNL,VALSDSF) = 0 THEN DO
     MSGBOXTX=FFX||'A_ERROR. SELECTED PANEL INVALID:'SDSFPNL||FFX||,
      'CHOOSE VALID PANEL NAME:'||FFX||VALSDSF
     SIGNAL EXITRC16
     END
NOARGS:
   HLDEMSG=''
   IF VQMODE = 'QUIET' THEN SIGNAL TSTPRMS
   "ISPEXEC ADDPOP ROW(1) COLUMN(10)"
   IF RC \= 0 THEN DO
    MSGBOXTX='ERROR. COULD NOT ADD POPUP WINDOW. ENDING'
    SIGNAL EXITRC24
    END
   FFX='FF'X
   TRCCMD='TRACE OFF'
   EXECSEL='DSPSDSF'
   DSEMSG='ENTER CICS SDSF SEARCH CRITERIA BELOW'
   MDSN='TTED.TSK.P.TCEM.CLIST'
   "ISPEXEC LIBDEF ISPPLIB DATASET ID('"MDSN"') UNCOND"
   IF RC \= 0 THEN SIGNAL EXITRC8
   DSEMSG='INITIAL VALUE FROM EXEC'
   SIGNAL ARND_CA_MSG
CLR_CA
   DSEMSG='CLEARED VALUE FROM EXEC'
ARND_CA_MSG:
   ICNT=0
   MYSC='CSR'
/* DO I = 1 TO 9
    INTERPRET 'SS'I' = ""'
    END  */
   SIGNAL DOIT
DOIT:
DISPP:
   /* TRACE I */
   "ISPEXEC DISPLAY PANEL(DSPSDSFD)"
   XC = RC
   IF XC = 8 THEN SIGNAL DONEIT
   IF XC \= 0 THEN SIGNAL EXITRC8
   IF ZCMD = 'HELP' | ZCMD = '?' THEN SIGNAL SHOWFMT
   IF ZCMD = 'RESET' THEN SIGNAL RESET
   IF ZCMD = 'CLRCA' THEN SIGNAL CLR_CA
   IF ZCMD = 'CANCEL' THEN SIGNAL EXITRC8
   IF ZCMD = 'END' THEN SIGNAL DONEIT
   MCMD=ZCMD
   IF MCMD \= '' THEN DO
    PARSE VAR MCMD FCMD RCMD
    IF FCMD = 'TRACE' THEN TRCCMD=MCMD
     ELSE "TSO MCMD"
    END
   INTERPRET TRCCMD
   IF XC = 0 THEN SIGNAL DISPP
   SIGNAL DISPP
SHOWFMT:
 MSGBOXTX=XFF||'ENTER THE CICS SDSF SELECTION CRITERIA.'||XFF||,
 'JOBNAME|APPLID(S) LIST TO PROCESS BY SDSF PANEL'||XFF||,
 'SELECT A VALID DDNAME FORM THE FOLLOWING LIST:'||FFX||VALDDN||FFX||,
 '(IF YOU REQUEST DDNAME(-) PROVIDES ACTIVE STATUS)'||FFX||,
 'PROVIDE AN DESTINATION FOR THE OUTPUT: DISPLAY TERMINAL'|XFF||,
 'A PDS CREATED JOBNAME MEMBERS, OR A SEQ DSN WILL MOD REPORTS'||XFF||,
 'CANALL CANCEL OUT OF A COMMAND PROCESS'||XFF||,
 'END AND '||XFF||'PF3 PROCESSES THE REQUEST.'
 CALL MSGBOX MSGBOXTX
   SIGNAL DISPP
TSTPRMS:
 /* TRACE ?I */
DONEIT:
/*  TRACE ?I  */
   IF SDSFJOBL = '' THEN DO
    HLDEMSG='SDSFJOBL EMPTY.'
    SIGNAL EXITJC8
    END
   NSDSF=WORDS(SDSFJOBL)
   APPLLIST = ''
   INTERPRET 'PNL_WD=VAL_'||SDSFPNL||'_COLS'
   DO I = 1 TO NSDSF
    TWD=WORD(SDSFJOBL,I)
    IF SUBSTR(TWD,1,5) = 'LIST(' THEN DO
/*   TRACE ?I */
     PARSE VAR TWD 'LIST(' LSTV ')' REST
     IF LSTV \= '' THEN DO
      "ISPEXEC VGET ("LSTV") ASIS"
      IF RC \= 0 THEN DO
       HLDEMSG=HLDEMSG||' INVALID LIST('||LSTV||'):'
       ITERATE
       END
      INTERPRET 'TWD = 'LSTV
      IF TWD = '' THEN ITERATE
      LISTLIST=LISTLIST||' '||TWD
      END
     ITERATE
     END
    PARSE VAR TWD FILWD '(' FILVAL ')'
    WP=WORDPOS(FILWD,PNL_WD)
    IF WP \= 0 THEN DO
     ISFILTER=FILWD||'='||FILVAL
     ITERATE
     END
    APPLLIST=APPLLIST||' '||TWD
    END
 /*  TRACE ?I */
   IF LISTLIST='' & APPLLIST='' &  ISFILTER='OFF' THEN DO
    HLDEMSG='LIST/APPL EMPTY.'
    SIGNAL EXITJC8
    END
   HSDSFJBL=''
   IF APPLLIST \= '' THEN DO
    CALL GETJOBL
    XC = RESULT
    IF XC \= 0 THEN DO
     IF XC = 20 THEN DO
      MSGBOXTX=FFX||'ERROR. APPLICATION LIST IS INVALID'||FFX||BADLIST
      SIGNAL EXITRC16
      END
     IF XC = 22 THEN DO
      MSGBOXTX=FFX||'ERROR. APPLICATION LIST IS EMPTY.'||FFX||HSDSFJBL
      SIGNAL EXITRC16
      END
     MSGBOXTX=FFX||'ERROR PROCESSING APPLICATION LIST'||FFX||HSDSFJBL
     SIGNAL EXITRC16
     END
    SDSFJOBL=TRANSLATE(STRIP(HSDSFJBL,'B'),',',' ')
    END
    ELSE SDSFJOBL='*'
   IF LISTLIST \= '' THEN DO
    IF SDSFJOBL = '*' THEN SDSFJOBL=''
    APPLLIST=LISTLIST
    CALL GETJOBL
    XC = RESULT
    IF XC = 22 THEN DO
     MSGBOXTX=FFX||'ERROR. APPLICATION LIST IS EMPTY.'||FFX||HSDSFJBL
     SIGNAL EXITRC16
     END
    SDSFJOBL=SDSFJOBL||' '||TRANSLATE(STRIP(HSDSFJBL,'B'),',',' ')||,
       ','||TRANSLATE(STRIP(BADLIST,'B'),',',' ')
    END
   SDSFJOBL=STRIP(SDSFJOBL,'B')
   SDSFJOBL=STRIP(SDSFJOBL,'B',',')
   IF SDSFJOBL = '' THEN DO
    MSGBOXTX=FFX||'ERROR. APPLICATION LIST IS EMPTY.'||FFX||SDSFJOBL
    SIGNAL EXITRC16
    END
   IF SDSFDDN \= '' & WORDPOS(SDSFDDN,VALDDN) = 0 THEN DO
     MSGBOXTX=FFX||'ERROR. SELECTED DDNAME INVALID:'SDSFDDN||FFX||,
      'CHOOSE VALID DDNAMES ARE:'||FFX||VALDDN
     SIGNAL EXITRC16
     END
   IF SDSFPNL \= '' &  WORDPOS(SDSFPNL,VALSDSF) = 0 THEN DO
     MSGBOXTX=FFX||'B_ERROR. SELECTED PANEL INVALID:'SDSFPNL||FFX||,
      'CHOOSE VALID PANEL NAME:'||FFX||VALSDSF
     SIGNAL EXITRC16
     END
/*  SAY 'WE ARE DONEIT' */
  /* TRACE ?I */
  IF SDSFJOBL = '' THEN DO
    HLDEMSG='SDSFJOBL EMPTY.'
    SIGNAL EXITJC8
    END
  IF SDSFDDN = '' THEN DO
    HLDEMSG='SDSFDDN  EMPTY.'
    SIGNAL EXITJC8
    END
  IF SDSFOP = '' THEN DO
    IF SDSFDDN='NONE' THEN DO
     SDSFOP='DISPLAY'
     SIGNAL CHKPNL
     END
    HLDEMSG='SDSFOP   EMPTY.'
    SIGNAL EXITJC8
    END
CHKPNL:
  IF SDSFPNL = '' THEN DO
    HLDEMSG='SDSFPNL  EMPTY.'
    SIGNAL EXITJC8
    END
  /* TRACE ?I */
  ARGLST='JOB('SDSFJOBL') DDNAME('SDSFDDN') PDS('SDSFOP||,
         ') SDSFPNL('SDSFPNL')' 'FILTER('ISFILTER') VQMODE('VQMODE')'
 /*                         */
 CALL SFISKIXA ARGLST
JSTRET0:
 CMDIND = 0
 SIGNAL EXITIT
EXITRC8:
EXITJC8:
 CMDIND = 8
 MSGBOXTX='ONE OF REQUIRED PARMS IS MISSING OR IN ERROR.'||HLDEMSG
 SIGNAL EXITIT
EXITRC14:
 CMDIND = 8
 SIGNAL EXITIT
EXITRC16:
 CMDIND = 8
 SIGNAL EXITIT
EXITRC20:
 CMDIND = 20
 SIGNAL EXITIT
EXITRC22:
 CMDIND = 20
 SIGNAL EXITIT
EXITRC24:
 CMDIND = 24
 SIGNAL EXITIT
EXITIT:
 "ISPEXEC VPUT (CMDIND) ASIS"
 IF CMDIND \= 0 THEN DO
  IF VQMODE = 'QUIET' THEN RETURN 8
  CALL MSGBOX MSGBOXTX
  END
 IF VQMODE = 'QUIET' THEN RETURN 0
 "ISPEXEC REMPOP"
 RETURN 0
GETJOBL:
 /* TRACE ?I */
    APPLLIST=TRANSLATE(APPLLIST,' ',',')
    DO WHILE APPLLIST \= ''
     PARSE VAR APPLLIST APLID APPLLIST
     ASK_P=POS('*',APLID)
     IF ASK_P > 0 THEN DO
      IF ASK_P > 8 THEN DO
       BADLIST=BADLIST||' '||APLID
       END
       ELSE DO
       HSDSFJBL=HSDSFJBL||' '||APLID
       END
      ITERATE
      END
     APLPOS=WORDPOS(APLID,AFOAPLLS)
     IF APLPOS = 0 THEN DO
      APLPOS=WORDPOS(APLID,AFOJOBLS)
      END
     IF APLPOS = 0 THEN DO
      BADLIST=BADLIST||' '||APLID
      END
      ELSE DO
      JOBNM=WORD(AFOJOBLS,APLPOS)
      HSDSFJBL=HSDSFJBL||' '||JOBNM
      END
     END      /* END DO LOOP */
/*  NWD=WORDS(HSDSFJBL) - 1 */
    NWD=WORDS(HSDSFJBL)
/*  GOODLIST=WORD(HSDSFJBL,1) */
    DO I = 1 TO NWD
     TMPWD=WORD(HSDSFJBL,I)
/*   IF WORDPOS(TMPWD,HSDSFJBL,I+1) = 0 THEN , */
     IF WORDPOS(TMPWD,GOODLIST) = 0 THEN ,
      GOODLIST=GOODLIST||' '||TMPWD
      ELSE DUPLIST=DUPLIST||' '||TMPWD
     END
/* TRACE ?I */
   IF BADLIST \= '' THEN RETURN 20
   IF GOODLIST = '' THEN RETURN 22
   IF DUPLIST \= '' THEN NOP
   HSDSFJBL=GOODLIST
/* TRACE OFF */
   RETURN 0
###END DSPSDSF
$$$BEG SFISKIXX
/* REXX */
  ADDRESS TSO
   MYAREA=''
   CTGDEVJL=''
   CTGTSTJL=''
   CTGPRDJL=''
   FFX = 'FF'X
   ARGLST='JOB(ODTG*) DDNAME(-) SDSFPNL(ST) VQMODE(QUIET)'
   CALL SFISKIXA ARGLST
   XC = RC
   PULL MYAREA
   IF MYAREA = '' THEN SIGNAL DOTST
   DO WHILE (MYAREA \= '')
    PARSE VAR MYAREA LNE (FFX) MYAREA
    IF WORDPOS('EXECUTION',LNE) = 0 THEN ITERATE
    IF WORDS(LNE) < 4 THEN ITERATE
    CTGDEVJL=CTGDEVJL||' '||WORD(LNE,1)
    END
   IF LENGTH(CTGDEVJL) = 0 THEN DO
    /* SAY 'NO DEV  CTG IN EXECUTION' */
    SIGNAL DOTST
    END
   CTGDEVJL=STRIP(CTGDEVJL,'B')
   MYAREA=''
 DOTST:
   ARGLST='JOB(OTGG*) DDNAME(-) SDSFPNL(ST) VQMODE(QUIET)'
   CALL SFISKIXA ARGLST
   XC = RC
   PULL MYAREA
   IF MYAREA = '' THEN SIGNAL DOPRD
   DO WHILE (MYAREA \= '')
    PARSE VAR MYAREA LNE (FFX) MYAREA
    IF WORDPOS('EXECUTION',LNE) = 0 THEN ITERATE
    IF WORDS(LNE) < 4 THEN ITERATE
    CTGTSTJL=CTGTSTJL||' '||WORD(LNE,1)
    END
   IF LENGTH(CTGTSTJL) = 0 THEN DO
    /* SAY 'NO TEST CTG IN EXECUTION' */
    SIGNAL DOPRD
    END
   CTGTSTJL=STRIP(CTGTSTJL,'B')
   MYAREA=''
 DOPRD:
   ARGLST='JOB(OPGG*) DDNAME(-) SDSFPNL(ST) VQMODE(QUIET)'
   CALL SFISKIXA ARGLST
   XC = RC
   PULL MYAREA
   IF MYAREA = '' THEN SIGNAL DONEIT
   DO WHILE (MYAREA \= '')
    PARSE VAR MYAREA LNE (FFX) MYAREA
    IF WORDPOS('EXECUTION',LNE) = 0 THEN ITERATE
    IF WORDS(LNE) < 4 THEN ITERATE
    CTGPRDJL=CTGPRDJL||' '||WORD(LNE,1)
    END
   IF LENGTH(CTGPRDJL) = 0 THEN DO
/*  SAY 'NO PROD CTG IN EXECUTION' */
    SIGNAL DONEIT
    END
   CTGPRDJL=STRIP(CTGPRDJL,'B')
 DONEIT:
   ADDRESS ISPEXEC 'VPUT (CTGDEVJL CTGTSTJL CTGPRDJL) ASIS'
   RETURN 0
###END SFISKIXX
$$$BEG SFISKIXA
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA          -                                              */
 /* CEMHELP          - TSO BASE, RESTRICTED                         */
 /* CEMHELP          -                                              */
 /* CEMHELP END                                                     */
 ADDRESS TSO
/*  CHECK TO SEE IF A REGIONS IS ACTIVE.                              *
 *                                                                    *
 *  JOB(<pattern>)   - jobnames.  The only wildcard accepted is a     *
 *                     single asterisk at the end of the string       *
 *                     Required unless FILTER is specified.           *
 *  SDSFPNL(DA|ST|H) - SDSF Selection Panel Action                    *
 *  DDNAME(ddname|-) - DDNAME to copy to the PDS.                     *
 *                   - if '-' then do not look at job ddnames         *
 *                   -    used to report on job existence on sdsf pnl *
 *  PDS(<dsname>)    - DSN of the PDS.  It will be                    *
 *                     allocated if it does not exist. ignored when   *
 *                     DDNAME(-)  (see above)                         *
 *  FILTER(null|x=y) - Applyu a SDSF FILTER to the panel criteria     *
 *  FILTER(SERVCLASS=ONLTST|ONLPRD|ONLSERV)                          *
 *                                                                    *
 **********************************************************************/

arg Arguments

/*  Establish default values for the input values  */
valargs='JOB SDSFPNL DDNAME PDS FILTER VQMODE'
/* *\
   Trace ?i
\* */
Opinion = "NONE"
valSDSF="DA ST H"
VALVQMODE='QUIET VERBOSE TRACE'
TRACX='OFF'
SUID=SYSVAR(SYSUID)
SDSF_Pnl_Act = "DA"
JobPattern   = "ODT*"
DDNAME       = "MSGUSR"
FilterVal    = ''
MYCCPU = MVSVAR('SYSNAME')
mysdsfds=''
address ispexec "vget (mysdsfds) asis"
if rc \= 0 then do
 call getudsn "sdsf"
 pull PDSDSN
 PDSDSN       = "TTED.TSK.D."PDSDSN
 end
 else pdsdsn=mysdsfds
MemberRule   = "JOBNAME"
Error        = "NO"
oct=1
ffx='ff'x
myarea=ffx
op.oct='Start CICS SDSF Processing'
myarea=myarea||op.oct||ffx
do while Arguments <> ""
   parse var Arguments ThisArg Arguments
   upper ThisArg
   parse var ThisArg Keyword "(" Value ")"
   if wordpos(Keyword,valargs) = 0 then do
      oct=oct+1
      op.oct =  'Invalid Keyword Value>'Keyword'< Error raised:'ThisArg
      myarea=myarea||op.oct||ffx
      Error = "YES"
      iterate
      end
   if Value = "" then do
      oct=oct+1
      op.oct =  "Missing (Value) component of argument "ThisArg
      myarea=myarea||op.oct||ffx
      Error = "YES"
      iterate
      end
   select
      when Keyword = "JOB"    then do
         JobPattern = Value
         end
      when Keyword = "VQMODE" then do
         fp = WORDPOS(Value,VALVQMODE)
         if fp = 0 then VQMODE="QUIET"
          else do
          if VQMODE = "TRACE" then do
            TRACX = "ON"
            VQMODE = "VERBOSE"
            end
            else VQMODE=Value
          end
         end
      when Keyword = "FILTER" then do
         FilterVal  = Value
         end
      when Keyword = "DDNAME" then do
         Value = strip(Value,'B')
         l_DdName = length(Value)
         if Value = "-" then do
            DdName  = Value
            iterate
            end
         if l_DdName > 0 & l_DdName < 9 then do
          if DATATYPE(substr(Value,1,1)) = "CHAR" then DdName = Value
           else do
            if Value = '-' then DdName = Value
            else do
            oct=oct+1
            op.oct =  "DDNAME is not a Valid SDSF JOB DDName"
            myarea=myarea||op.oct||ffx
            Error = "YES"
            end
           end
          end
          else do
          oct=oct+1
          op.oct =  "Length of DDNAME is not a Valid SDSF JOB DDName"
          myarea=myarea||op.oct||ffx
          Error = "YES"
          end
         end
      when Keyword = "PDS"    then do
         PDSDSN     = Value
         if Value = "DISPLAY" then Opinion = "DISPLAY"
          else do
          call msg "off"
          Opinion = sysdsn( "'"PDSDSN"'" )
          call msg "on"
          if Opinion <> "OK" & Opinion \= "DATASET NOT FOUND" then do
            oct=oct+1
            op.oct =  "PDS" PDSDSN "failed validation because" Opinion
            myarea=myarea||op.oct||ffx
            Error = "YES"
            end
          end
         end
      when Keyword = "SDSFPNL" then do
         wp=wordpos(Value,valSDSF)
         if wp = 0 then do
            oct=oct+1
       op.oct =  "Invalid SDSF Panel Action:"Value":(Require:"valSDSF")"
            myarea=myarea||op.oct||ffx
            Error = "YES"
            end
            else SDSF_Pnl_Act = Value
         end
      otherwise do
         oct=oct+1
         op.oct =  "'"ThisArg"' is not a valid argument"
         myarea=myarea||op.oct||ffx
         Error = "YES"
         end
      end
   end
/*  Verify that the PDS dataset name was specified  */

if DdName = '-' then do
 Opinion = 'DISPLAY'
 PDSDSN = 'DISPLAY'
 end
if PDSDSN = "" then do
   oct=oct+1
   op.oct =  "PDS operand (DISPLAY or PDS dataset name) must be specified"
   myarea=myarea||op.oct||ffx
   Error = "YES"
   end

/*  If an error was found while processing the input arguments then we
    can go no further  */

if Error <> "NO" then do
   oct=oct+1
   op.oct =  "Correct arguments and rerun this EXEC"
   myarea=myarea||op.oct||ffx
   msgbox myarea
   return 16
   end


/*  Get the dataset attributes for the PDS.  It will be emptied of its
    previous contents by being deleted and reallocated  */
if Opinion = "NONE" then do
    Opinion = sysdsn( "'"PDSDSN"'" )
    call msg "on"
    if Opinion <> "OK" & Opinion \= "DATASET NOT FOUND" then do
      oct=oct+1
      op.oct =  "PDS" PDSDSN "failed validation because" Opinion
      myarea=myarea||op.oct||ffx
      msgbox myarea
      return 16
      end
    end

call TestPDS
/*  Load the SDSF environment and abort on failure  */
IsfRC = isfcalls( "ON" )
if IsfRC <> 0 then do
   oct=oct+1
   op.oct =  "RC" IsfRC "returned from isfcalls( ON )"
   myarea=myarea||op.oct||ffx
   msgbox myarea
   return IsfRC
   end
/* *\
   Trace ?i
\* */
/*  "Display" the DA panel to load the related variables  */
/* *\
|* ISFOWNER  = OWNERPATTERN    *|
|  ISFFILTER = "QUEUE = EXECUTION" \* good for ST pnl *|
|  ISFFILTER = "SAFF = "MYCCPU     |* good for ST,DA pnl with wildcd *|
|  ISFFILTER = "SRVCLASS = ONL*"   |* good for DA pnl with wildcd *|
|  ISFFILTER = "SRVCLS = ONL*"     |* good for ST pnl with wildcd *|
|  also: ISFCOLS = SRVCLASS|SRVCLS                                *|
   Trace ?i
\* */
if VQMODE = "VERBOSE" then do
  call setup_MBOX
  CALL SLEEP_NOW 1
  tstmsg = "Calling SDSF Interface with Selection criteria..."
  call cont_MBOX
  end
 val_da_dcols='SRVCLASS SYSNAME'
 val_da_cols=val_da_dcols
 val_st_dcols='QUEUE ACTSYS'
 val_st_cols='SRVCLS SYSAFF '||val_st_dcol
 val_h_dcols='DSDATE RETCODE DATEE'
 val_h_cols=val_h_dcols
 str_filter=''
 if option = 'DISPLAY' then pnl_wd_sfx = '_dcols'
  else pnl_wd_sfx = '_dcols'
 pnl_wd='val_'||SDSF_Pnl_Act||pnl_wd_sfx
 INTERPRET 'ISFCOLS='PNL_WD
 eql='='
 if FilterVal \= '' then do
  parse var FilterVal filternam '=' filterstr
  if filterstr \= '' then filterstr=' = '||filterstr
  if filternam \= '' then do
   INTERPRET 'WP = WORDPOS(filternam,'pnl_wd')'
   IF WP \= 0 THEN str_filter=filternam||filterstr
   end
 /* else do
     str_filter=''
     ISFCOLS = ''
   select
    when SDSF_Pnl_Act='DA' then do
    str_filter=word(val_da_cols,1)
    ISFCOLS = val_da_cols
    end
    when SDSF_Pnl_Act='ST' then do
    str_filter=word(val_st_cols,1)
    ISFCOLS = val_st_cols
    end
    when SDSF_Pnl_Act='H' then do
    str_filter=''
    ISFCOLS = val_h_cols
    end
    otherwise do
    str_filter=''
    ISFCOLS = ''
    end
   end */
  filternam=str_filter
  end
oxt=oct
JobPatList=translate(JobPattern,' ',',')
num_jobs=words(JobPatList)
JobPattern=''
cur_job#=0
h_ISFCOLS   = "JNAME JOBID "||ISFCOLS
errmsg = ''

/*        here we go */
/* *\
|* *|
\* */
topoflop:
cur_job#=cur_job# + 1
if cur_job# > num_jobs then signal fin_job_list
JobPattern = word(JobPatList,cur_job#)
ISFCOLS   = h_ISFCOLS
 if str_filter = '' then ISFILTER = "OFF"
  else ISFFILTER = str_filter
isfprefix = JobPattern
if VQMODE = "VERBOSE" then do
  tstmsg = "Processing:"JobPattern":"
  call cont_MBOX
 end
ADDRESS SDSF "ISFEXEC "SDSF_Pnl_Act
if RC <> 0 then do
   errmsg = "RC" RC "returned from ISFEXEC "SDSF_Pnl_Act
   call DisplayMessages
   signal topoflop
   end

/*  Process every line in the  display  */
/* trace ?i */
StRows = isfrows
if StRows < 1 then do
 oct=oct+1
 op.oct= JobPattern " is NOT active"
 myarea=myarea||op.oct||ffx
 signal topoflop
 end
do i = 1 to StRows
/*                      Apply the other filters                      *\
|*                                                                   *|
|* if JobClass    <> "" & jclass.i  <> JobClass    then iterate      *|
|* if Destination <> "" & prtdest.i <> Destination then iterate      *|
|* if CondCode    <> "" & retcode.i <> CondCode    then iterate      *|
\*                                                                   */
   /*  The job is selected so go process it's SYSOUT  */
   oct=oct+1
   nwd=words(ISFCOLS)
   op.oct=''
/* trace off */
   do  j = 1 to nwd
    t_1 = word(ISFCOLS,j)
    if t_1 = 'TOKEN' then iterate
    interpret 'tmp = 't_1'.i'
    op.oct=op.oct||' '||tmp
    end
/* *\
   Trace ?i
\* */
   myarea=myarea||op.oct||ffx
   if PDSDSN = "DISPLAY" then iterate
if VQMODE = "VERBOSE" then do
  tstmsg = "Writing:"jname.i Ddname
  call cont_MBOX
 end
   if MemberRule = "JOBID" then ,
    call ProcessSysout jname.i, jobid.i, token.i, DdName, SDSF_Pnl_Act
      else ,
    call ProcessSysout jname.i, jname.i, token.i, DdName, SDSF_Pnl_Act
  end
 signal topoflop

/*  Finished!!! */
fin_job_list:
if VQMODE = "VERBOSE" then do
  call done_MBOX
 end

/*  Unload the SDSF environment  */
 oct=oct+1
 op.oct= "Finished JOB List: Unload SDSF"
 myarea=myarea||op.oct||ffx

call isfcalls "OFF"
  if PDSDSN="DISPLAY" then signal Do_Ret
  if vqmode="QUIET" then signal Do_Ret
  if PDSDSN \= mysdsfds then do
    mbarea=ffx
    oct=oct+1
    op.oct =  'Replace OP PDS name?'||ffx
    mbarea=mbarea||op.oct
    oct=oct+1
    op.oct =  'Previous SDSF OP DSN was:'||ffx
    mbarea=mbarea||op.oct
    oct=oct+1
    op.oct =  mysdsfds||ffx
    mbarea=mbarea||op.oct
    oct=oct+1
    op.oct =  'New SDSF OP DSN  is:'||ffx
    mbarea=mbarea||op.oct
    oct=oct+1
    op.oct =  PDSDSN||ffx
    mbarea=mbarea||op.oct
    oct=oct+1
    op.oct =  'Select:(Y,N)'||ffx
    mbarea=mbarea||op.oct
    MSGLOCK='Q'
    MSGSTAT='FULLPOP'
    MSGANS='Y N'
    MSGBOXTX=mbarea||'Select From Above Choices'
    "ISPEXEC VPUT (MSGLOCK MSGSTAT MSGANS MSGBOXTX) ASIS"
    CALL MSGBOX
    XC=RESULT
    "ISPEXEC VGET (MSGANS) ASIS"
    IF MSGANS = 'N' | MSGANS = '' then do
     oct=oct+1
     op.oct =  'Do Not Replace SDSF OP Var'||ffx
     myarea=myarea||op.oct||ffx
     end
    if MSGANS = 'Y' then do
     oct=oct+1
     op.oct =  'New PDS Name will be saved.'
     myarea=myarea||op.oct||ffx
     mysdsfds=PDSDSN
     address ispexec 'vput (mysdsfds) asis'
     xc=rc
     oct=oct+1
     if xc = 0 then do
      op.oct =  'ISPF variable mysdsfds was replaced'
      end
      else do
      op.oct =  'ISPF variable mysdsfds could not be replaced'
      end
      myarea=myarea||op.oct||ffx
    end
   end
   signal Do_Ret
/* *\
|* *|
\* */
 Do_Ret:
  if VQMODE = 'QUIET' then do
   push myarea
   return 0
   end
  call msgbox myarea
  return 0
/* *\
|* *|
\* */
 GetDiffPDS:
   oct=oct+1
   op.oct =  'Selecting to use Other PDS for output.'
   myarea=myarea||op.oct||ffx
 topofget:
   EDSN=PDSDSN
   EXECSEL = 'SFISKIXA'
   DSEMSG = 'Enter Output PDS Dataset'
   MYVERB = 'CANCEL ABORT'
   "ISPEXEC VPUT (EDSN) ASIS"
   "ISPEXEC VPUT (DSEMSG EXECSEL) ASIS"
   "ISPEXEC VPUT (MYVERB) ASIS"
   CALL DSNWIND
   XC = RESULT
   IF XC > 4 THEN return 2
   ADDRESS ISPEXEC "VGET (EDSN) ASIS"
   IF RC ^= 0 THEN return 8
   PDSDSN = EDSN
   ADDRESS ISPEXEC "VGET (MYVERB) ASIS"
   IF RC ^= 0 THEN return 2
   IF MYVERB ^= '' THEN DO
    IF MYVERB='ABORT' | MYVERB='CANCEL' THEN SIGNAL return 2
    return 4
    END
   call msg "off"
   Opinion = sysdsn( "'"PDSDSN"'" )
   call msg "on"
   if Opinion <> "OK" & Opinion \= "DATASET NOT FOUND" then do
     oct=oct+1
     op.oct =  "PDS" PDSDSN "failed validation because" Opinion
     myarea=myarea||op.oct||ffx
     signal topofget
     end
   call TestPDS
   if RESULT = 0 then return 0
   signal topofget
outofget:
 return 24

/*! DisplayMessages ------------------------------------------------- *
 *                                                                    *
 *  Display the SDSF messages variables for diagnostic purposes.      *
 *                                                                    *
 * ------------------------------------------------------------------ */
setup_MBOX:
  TSTMSG = "Starting SDSF Interface..."
  MSGBOXTX=TIME() TSTMSG
  MSGSTAT='ADDPOP'
  MSGLOCK = 'Y'
  ADDRESS ISPEXEC "VPUT (MSGBOXTX MSGSTAT MSGLOCK) ASIS"
  CALL MSGBOX
  MSGSTAT = 'CONTPOP'
  ADDRESS ISPEXEC "VPUT (MSGSTAT) ASIS"
  signal ret_MBOX
cont_MBOX:
  MSGBOXTX=TIME() TSTMSG
  ADDRESS ISPEXEC "VPUT (MSGBOXTX) ASIS"
  CALL MSGBOX
  signal ret_MBOX
done_MBOX:
  TSTMSG = "finished SDSF Interface..."
  MSGLOCK='R'
  "ISPEXEC VPUT (MSGLOCK) ASIS"
  CALL MSGBOX
ret_MBOX:
  return 0

DisplayMessages:
   /*  Display the messages associated with the action  */

   oct=oct+1
   op.oct=errmsg
   myarea=myarea||op.oct||ffx
   errmsg = "isfmsg: '"isfmsg"'"
   oct=oct+1
   op.oct=errmsg
   errmsg = isfmsg2.0 "long messages in the isfmsg2 stem"
   oct=oct+1
   op.oct=errmsg
   do i = 1 to isfmsg2.0
      errmsg = "   '"isfmsg2.i"'"
      oct=oct+1
      op.oct=errmsg
      end
   errmsg = ''
   return

/*! ProcessSysout --------------------------------------------------- *
 *                                                                    *
 *  Copy SYSOUT for the selected DDNAME to the PDS.                   *
 *                                                                    *
 * ------------------------------------------------------------------ */

ProcessSysout:
   parse arg JobName, MemberName, SdsfToken, DDN, Actn

   /*  Display the job's datasets  */

ADDRESS SDSF "ISFACT "ACTN" TOKEN('"SDSFTOKEN"') PARM(NP ?) (PREFIX J_"
   ActRC = RC
   if RC <> 0 then do
      oct=oct+1
      op.oct =  "SDSF processing failed for job" JobName "with RC" ActRC
      myarea=myarea||op.oct||ffx
      call DisplayMessages
      return 8
      end

   /*  Find the line for the specified DD name  */

   do jX = 1 to j_ddname.0
      if j_ddname.jX = DDN then signal DDN_fnd
      end
   oct=oct+1
   op.oct =  "DDN:"DDN" was not found in job" JobName
   myarea=myarea||op.oct||ffx
   return 8
/*  */
DDN_fnd:
/* *\
   Trace ?i
\* */
    /*  Got the correct dataset.  Now allocate the SYSOUT  */
  hreccnt=j_RECCNT.jX
  ADDRESS SDSF "ISFACT "ACTN" TOKEN('"J_TOKEN.JX"') PARM(NP SA)"
  ActRC = RC
  if RC <> 0 then do
     oct=oct+1
     op.oct =  "SYSOUT "DDN" alloc failed for" JobName "with RC" ActRC
     myarea=myarea||op.oct||ffx
     call DisplayMessages
     return 8
     end
  /*  Copy the SYSOUT to the PDS member */
  if CopySysout( PDSDSN"("MemberName")", ,
                 "DD:"isfddname.1 ) <> 0 then do
     oct=oct+1
     op.oct =  "Copy failed!"
     myarea=myarea||op.oct||ffx
     return 8
     end

  return 0

/*! CopySysout ------------------------------------------------------ *
 *                                                                    *
 *  Copy a file.  The input is represented by the second argument;    *
 *  the output by the first.  If either begins with "DD:" then the    *
 *  argument is a DD name; otherwise it's a DS name and is allocated. *
 *                                                                    *
 *  This routine uses bpxwdyn to perform the allocations so that the  *
 *  code is not dependent on an established TSO environment.          *
 *                                                                    *
 * ------------------------------------------------------------------ */

DOEXECIO:
             oct=oct+1
             op.oct =  "NOW READING" ISFDSNAME.1
             myarea=myarea||op.oct||ffx
             "EXECIO * DISKR" ISFDDNAME.1 "(STEM LINE. FINIS"
             xc=RC
             if xc \= 0 then return xc
             MXLN=0
             oct=oct+1
             op.oct =  " LINES READ:" LINE.0
             myarea=myarea||op.oct||ffx
             DO KX = 1 TO LINE.0
/*             op.oct =  " LINE."KX "IS:" LINE.KX */
               MXLN=MAX(MXLN,LENGTH(LINE.KX))
             END
/* *\
   Trace ?i
\* */
             oct=oct+1
             op.oct =  "MAXLNG IS "MXLN
             myarea=myarea||op.oct||ffx
             pull
             RETURN 0
CopySysout:
   parse arg CS_Output, CS_Input

   /*  Allocate the input dataset if necessary  */

   if left( CS_Input, 3 ) = "DD:" then
      Sysut1DD = substr( CS_Input, 4 )
   else do
      call bpxwdyn "ALLOC DSN('"CS_Input"') SHR RTDDN(Sysut1DD)" ,
                         "MSG(CS_Msg.)"
      if Result <> 0 then do
         oct=oct+1
         op.oct =  "RC" Result "allocating" CS_Input
         myarea=myarea||op.oct||ffx
         do ierr = 1 to CS_Msg.0
            oct=oct+1
            op.oct =  CS_Msg.ierr
            myarea=myarea||op.oct||ffx
            end

         return 162
         end
      end

   /*  Allocate the output dataset if necessary  */

   if left( CS_Output, 3 ) = "DD:" then
      Sysut2DD = substr( CS_Output, 4 )
   else do

      call bpxwdyn "ALLOC DSN('"CS_Output"') SHR RTDDN(Sysut2DD)" ,
                         "MSG(CS_Msg.)"
      if Result <> 0 then do
         oct=oct+1
         op.oct =  "RC" Result "allocating" CS_Output
         myarea=myarea||op.oct||ffx
         do ierr = 1 to CS_Msg.0
            oct=oct+1
            op.oct =  CS_Msg.ierr
            myarea=myarea||op.oct||ffx
            end

         return 162
         end
      end

   /* Allocate a dummy dataset for SYSIN  */

   call bpxwdyn "ALLOC DUMMY RTDDN(SysinDD) MSG(CS_Msg.)"
   if Result <> 0 then do
      oct=oct+1
      op.oct =  "RC" Result "allocating SYSIN to a dummy dataset"
      myarea=myarea||op.oct||ffx
      do ierr = 1 to CS_Msg.0
         oct=oct+1
         op.oct =  CS_Msg.ierr
         myarea=myarea||op.oct||ffx
         end

      return 162
      end

   /* Allocate a temporary dataset for SYSPRINT  */

   call bpxwdyn "ALLOC UNIT(SYSALLDA) SPACE(10,10) TRACKS" ,
                      "RTDDN(SysprintDD) MSG(CS_Msg.)"
   if Result <> 0 then do
      oct=oct+1
      op.oct =  "RC" Result "allocating SYSPRINT to a temporary dataset"
      myarea=myarea||op.oct||ffx
      do ierr = 1 to CS_Msg.0
         oct=oct+1
         op.oct =  CS_Msg.ierr
         myarea=myarea||op.oct||ffx
         end

      return 162
      end

 /*  Build the DD name substitution list  */

   Parm   = ""                          /* No PARM= parm    */
   DDlist = copies( '00'x, 8 )    ||,   /* DD  1: SYSLIN    */
            copies( '00'x, 8 )    ||,   /* DD  2:  n/a      */
            copies( '00'x, 8 )    ||,   /* DD  3: SYSLMOD   */
            copies( '00'x, 8 )    ||,   /* DD  4: SYSLIB    */
            left( SysinDD, 8 )    ||,   /* DD  5: SYSIN     */
            left( SysprintDD, 8 ) ||,   /* DD  6: SYSPRINT  */
            copies( '00'x, 8 )    ||,   /* DD  7: SYSPUNCH  */
            left( Sysut1DD, 8 )   ||,   /* DD  8: SYSUT1    */
            left( Sysut2DD, 8 )   ||,   /* DD  9: SYSUT2    */
            copies( '00'x, 8 )    ||,   /* DD 10: SYSUT3    */
            copies( '00'x, 8 )    ||,   /* DD 11: SYSUT4    */
            copies( '00'x, 8 )    ||,   /* DD 12: SYSTERM   */
            copies( '00'x, 8 )    ||,   /* DD 13:  n/a      */
            copies( '00'x, 8 )          /* DD 14: SYSCIN    */

   /*  Call IEBGENER with two pointers: the first to a null PARM string
       and the second to the DD name substitution list  */

   address LINKMVS "IEBGENER Parm DDlist"
   GenerRC = RC

   /*  Free the SYSIN and SYSUT2 allocations  */

   /*  If IEBGENER ended with anything other than CC 0, display
       SYSPRINT to the user  */

   if GenerRC <> 0 then do
      oct=oct+1
      op.oct =  "IEBGENER returned RC" GenerRC
      myarea=myarea||op.oct||ffx
      oct=oct+1
      op.oct =  "IEBGENER SYSPRINT follows:"
      myarea=myarea||op.oct||ffx
      oct=oct+1
      op.oct =
      myarea=myarea||op.oct||ffx
      if hreccnt<32750 then do
       "execio * diskr" Sysut1DD" (stem ip. finis"
         if RC <> 0 then signal do_free
         oct=oct+1
         op.oct ="Using EXECIO to read/write "hreccnt" records."
         myarea=myarea||op.oct||ffx
         "execio * diskw "Sysut2DD" (stem ip. finis"
         end
      end

   /* Free the SYSPRINT allocation  */

   call bpxwdyn "FREE FI("SysinDD")"
   call bpxwdyn "FREE FI("Sysut2DD")"

   call bpxwdyn "FREE FI("SysprintDD")"

   return GenerRC
/*
     Test the PDS Name
*/
TestPDS:
 if Opinion = "OK" then do
    call msg "off"
    ReturnCode = listdsi( "'"PDSDSN"' directory" )
    call msg "on"
    if ReturnCode <> 0 then do
       oct=oct+1
       op.oct =  "Cannot retrieve the attributes of" PDSDSN "-" SYSREASON
       myarea=myarea||op.oct||ffx
       return 16
       end
    if SYSDSORG <> "PO" then do
       oct=oct+1
       op.oct =  PDSDSN "is not a partitioned dataset"
       myarea=myarea||op.oct||ffx
       return 16
       end
    if SYSLRECL < "240" then do
       oct=oct+1
       op.oct =  PDSDSN "LRECL("SYSLRECL")< 240: is not usable by this EXEC"
       myarea=myarea||op.oct||ffx
       return 16
       end

    /*  TSO/E returns RECFM without blanks between the attribute characters
        but requires blanks on the allocate statement  */

    Hold  = SYSRECFM
    Recfm = ""
/*  reqRecfm = "V B A" */
    reqRecfm = "V B"
    do while Hold <> ""
       parse var Hold Recchr 2 Hold
       wp=wordpos(RecChr,reqRecfm)
       if wp = 0 then do
         oct=oct+1
         op.oct =  PDSDSN "has invalid RECFM:"RecChr":not usable by this EXEC"
         myarea=myarea||op.oct||ffx
         return 16
         end
       reqRecfm=delword(reqRecfm,wp,1)
       Recfm = Recfm RecChr
       end
    reqRecfm=strip(reqRecfm,"B")
    if reqRecfm \= "" then do
         oct=oct+1
         op.oct =  PDSDSN "missing RECFM:"reqRecfm":not usable by this EXEC"
         myarea=myarea||op.oct||ffx
         return 16
         end
    Recfm = strip( Recfm )
    end
    else do
    if Opinion = "DATASET NOT FOUND" then do
        AllocCmd = "alloc da('"PDSDSN"')" ,
                    "recfm(V B) lrecl(240)" ,
                    "blksize(2440)" ,
                    "space(9 1)  dsorg(po)" ,
                    "dsntype(library) CYL"
        AllocCmd
        xc=RC
        if xc <> 0 then do
          oct=oct+1
          op.oct =  "CouldNot ALLOC the PDS:" PDSDSN ":RC="xc
          myarea=myarea||op.oct||ffx
          return 16
          end
        end
     end
    return 0

SLEEP_NOW:
ARG SLEEP_TIME
IF SLEEP_TIME = '' THEN SLEEP_TIME = 10
IF JUNK = '' THEN JUNK = SYSCALLS('ON')
ADDRESS SYSCALL "SLEEP" SLEEP_TIME
RETURN
###END SFISKIXA
$$$BEG DSPSDSFD
)ATTR
/*.........1.........2.........3.........4.........5.........6 */
  # AREA(scrl) extend(on)
  + TYPE(TEXT) INTENS(LOW) SKIP(ON)
   TYPE(INPUT) INTENS(HIGH) COLOR(GREEN) JUST(ASIS)
  } TYPE(INPUT) INTENS(HIGH) COLOR(GREEN) JUST(ASIS) caps(off)
  ! TYPE(INPUT) INTENS(LOW) COLOR(yellow) JUST(ASIS)
  $ TYPE(OUTPUT) INTENS(HIGH) CAPS(OFF) COLOR(red)
  { TYPE(OUTPUT) INTENS(HIGH) CAPS(OFF) COLOR(blue)
)BODY WINDOW(61,12)
{execsel +:ZCMD                         mysc+
$dsemsg
+CICS SDSF: job,applid,LIST(x),filter(x):!sdsfjobn          +
$sdsfjobl                                                   +
+SDSF Panel:Z +(options:$valSDSF                         +)+
+Capture a specific SDSF DDNAME from JOB:sdsfddn +         +
+Send SDSF output to PDS DSN (update DSN if needed):        +
sdsfop                                                     +
#myarea                                                     #
#                                                           #
)AREA MYAREA DEPTH(4)
$ss1
$ss2                                                        +
$ss3                                                        +
$ss4                                                        +
$ss5                                                        +
$ss6                                                        +
$ss7                                                        +
$ss8                                                        +
$ss9                                                        +
)INIT
 &zcmd = ''
 .ZVARS = '(sdsfpnl)'
 .CURSOR = sdsfjobn
 &h1=TRUNC(&dsemsg,1)
 IF (&h1 NE '!')
  &dsepfx='&ZTIMEL &icnt'
 ELSE
  &dsemsg=''
 IF (&dsemsg = '')
  &dsemsg=&dsepfx
  &dsepfx='&ZTIMEL &icnt'
  &icnt=0000
 *REXX(*,icnt)
  icnt=icnt+1
 *ENDREXX
)REINIT
 *REXX(*,icnt)
  icnt=icnt+10
 *ENDREXX
 &zcmd=''
 &cmd=''
 REFRESH(*)
)PROC
 &cmd=&zcmd
 &myverb=&zverb
 if (VER (&sdsfjobn,DSNAME))
  IF (VER(&sdsfjobn,LISTV,&sdsfjobl))
   &dsemsg='&dsepfx dup: &sdsfjobn'
  ELSE
   &dsemsg='&dsepfx add: &sdsfjobn'
   &sdsfjobl='&sdsfjobl &sdsfjobn'
   &sdsfjobn=''
 ELSE
  IF (VER(&sdsfjobn,LISTV,&sdsfjobl))
   &dsemsg='&dsepfx dup: &sdsfjobn'
  ELSE
   &sdsfjobl='&sdsfjobl &sdsfjobn'
 VER (&sdsfpnl,LISTV,&valSDSF)
 VER (&sdsfddn,LISTV,&valddn)
 VER (&sdsfop,NB,DSNAME)
 *REXX (*,cmd,icnt,hsdsfjbl,hsdsfddn,hsdsfop,hsdsfpnl,dsepfx)
 trace O
/* dsemsg="here in rexx "icnt */
 if cmd = 'CLR' then do
  call clrflds
  return
  end
 if cmd = 'RES' then do
  call resflds
  return
  end
 return
 /* clear all fields */
 clrflds:
 icnt=0
 sdsfjobl=''
 sdsfop=''
 SDSFPNL='XX'
 SDSFDDN=''
 call ressrch
 dsepfx="All Fields Cleared"
 dsemsg = '!'
 return
 /*  reset search fields */
 resflds:
 sdsfjobl=hsdsfjbl
 sdsfop=hsdsfop
 SDSFPNL=HSDSFPNL
 SDSFDDN=HSDSFDDN
 dsepfx="Fields Reset:"
 ressrch:
/* ss1='';ss2='';ss3='';ss4='';ss5='';ss6='';ss7='';ss8='';ss9='' */
 dsemsg = '!'
 cmd=''
 return
 *ENDREXX
)END
###END DSPSDSFD
$$$BEG MYTSO
/* REXX */
/* CEMHELP BEGIN                                                     */
/* CEMHELP MYTSO    - TSO BASE, PROMPTS OR ACCEPTS AS PARMS A NATIVE */
/* CEMHELP          - TSO COMMAND WHERE THE OP OF THE COMMAND IS     */
/* CEMHELP          - CAPTURED TO A TEMP DS, POPING YOU INTO BROWSE  */
/* CEMHELP END                                                       */
  ARG MTSOC
  IF MTSOC = '' THEN DO
   SAY 'ENTER TSO COMMAND WITH PARMS (IF ANY)'
   PULL MTSOC
   IF MTSOC = '' THEN EXIT
   END
  SUID=SYSVAR(SYSUID)
  DFTDSN='%NQA%('SUID'.TEMPREX.SYSPRINT)'
  IF SUBSTR(MTSOC,1,1) = '<' THEN DO
   FP = POS('>',MTSOC,2)
   IF FP = 0 THEN SIGNAL BADPARM
   PARSE VAR MTSOC '<' MTSOC '>' MDSN
   IF MDSN = '' THEN DO
    MDSN=DFTDSN
    SIGNAL DOIT
    END
   HL=LENGTH(MDSN)
   IF HL < 8 | HL > 62 THEN SIGNAL BADDSN
   END
   ELSE MDSN=DFTDSN
 DOIT:
  EDSN=MDSN
  X=OUTTRAP('LINE.')
  MTSOC
  X=OUTTRAP('OFF')
  MXLN=80
  LNCT=LINE.0
  IF LNCT < 1 THEN DO
   CALL MSGBOX 'TSO COMMAND RETURNED NULL OUTPUT. PRESS PF3 TO END'
   EXIT
   END
  DO I = 1 TO LNCT
   LL=LENGTH(LINE.I)
   IF LL > MXLN THEN MXLN = LL
   END
  MXLN=MXLN+4
  BLKMXLN=MXLN+4
  EXECSEL = 'MYTSO'
  DSEMSG = '(R) REUSE,(D) DEL/REALLOC,(A) ABORT'
  MODATTR="NEW DSORG(PS) "||,
   "RECFM(V,B) BLOCK("BLKMXLN") SPACE("LNCT",0) "||,
   "CATALOG REUSE"
  MYVERB = 'ABORT BYPASS CANCEL REUSE DELETE'
  MODDSN=''
  "ISPEXEC VPUT (MYVERB MODDSN) ASIS"
  "ISPEXEC VPUT (EDSN EXECSEL DSEMSG MODATTR) ASIS"
  IF RC ^= 0 THEN SIGNAL CANCEL8
  CALL ALOCDSN
  XC = RESULT
  IF XC = 8 THEN SIGNAL CANCEL8
  IF XC ^= 0 THEN SIGNAL CANCEL8
  "ISPEXEC VGET (EDSN) ASIS"
  "ALLOC FI(O) DA('"EDSN"') SHR REUSE"
  "EXECIO * DISKW O (STEM LINE. FINIS"
  "FREE FI(O)"
  "ISPEXEC VIEW DATASET('"EDSN"')"
  EXIT
 CANCEL8:
  SAY 'ABORT OR CANCEL SELECTED'
  EXIT 8
###END MYTSO
$$$BEG GIMLIBD
/*********************************************************************/
/*  PERFORM ANY SPECIAL LIBDEFS OR ALLOCATIONS FOR THIS DIALOG       */
/*********************************************************************/
%EXPLLDEF ISPTLIB TTED.TSK.D.SGIMTENU
ALLOCATE FI(SMPTABL)    DA('TTED.TSK.D.SGIMTENU') SHR REUSE
ALLOCATE FI(ISPTABL)    DA('TMF.SMPE.OTABLES') SHR REUSE
/*                                                                   */
/*********************************************************************/
/*  INVOKE DIALOG                                                    */
/*********************************************************************/
ISPEXEC  SELECT      PGM(GIMSTART) PARM(&ZCMD) SCRNAME(SMPE) NOCHECK
/*                                                                   */
/*********************************************************************/
/*  FREE ANY LIBDEFS OR OTHER ALLOCATIONS THAT WERE DONE             */
/*********************************************************************/
/* FREE     FI(SMPTABL ISPTABL)                                      */
###END GIMLIBD
$$$BEG ISPF#CMD
/* REXX */
/* UNKNOWN WHAT THIS DOES
ADDRESS ISPEXEC
"%ISPFCMDS CEM  DD SELECT PGM(ISRDDN)"
"%ISPFCMDS CEM  EE SELECT CMD(PDS &ZPARM)" */
###END ISPF#CMD
$$$BEG HLASM#DB
/* REXX
 * not found - cem 20120904
 * Name: HLASMDB
 *
 * Author: David Alcock
 *
 * Purpose: Invoke the HLASM toolkit IDF, InterActive Debugging Fac.
 *
 * Requirements:
 * - ASMLANGX file
 * - SYSADATA file
 * - Member of a load library that matchs ASMLANGX and SYSADATA
 *
 * Syntax: %HLASMDB member
 */
arg member
if member == "" then do
   say "%HLASMDB - Member not given, it is required"
   exit
   end
member = strip(member)
address TSO
"allocate file(ASMLANGX) da(spftemp1."member".asmlangx) shr reuse"
"allocate file(SYSADATA) da(spftemp1."member".sysadata) shr reuse"
"allocate file(LIBEDD)   da(test.load) shr reuse"
"TSOEXEC asmidf "member" (LIBE LIBEDD"
say "%HLASMDB - asmidf rc="rc " pgm("member")"
"free file(asmlangx)"
"free file(sysadata)"
"free file(libedd)"
exit
###END HLASM#DB
$$$BEG ABC
/* REXX */                                                              00000100
trace ?i
call msg 'off'                                                          00000110
X=OUTTRAP('LINE.')
'listc'                                                                 00000130
X=OUTTRAP('OFF')
say 'count =' line.0                                                    00000150
do n = 1 to line.0                                                      00000160
  say 'line' n'.' line.n                                                00000170
end                                                                     00000180
/* exit  */                                                             00000190
DO N = 1 TO 50                                                          00000200
  if n = 3 then signal xyz                                              00000210
  SAY N                                                                 00000300
  xyz:                                                                  00000310
 /* signal gives
 IRX0010I Error running ABC, line 17: Unexpected or unmatched END */
  say after label                                                       00000320
END                                                                     00000400
say 'we are out of the loop now'
###END ABC
$$$BEG ATEST
TEST
###END ATEST
$$$BEG WHOHASIT
 /* REXX */
/* CEMHELP BEGIN                                                     */
/* CEMHELA WHOHASIT - PROVIDE CICS DSN. REPORT ON CONTENTION WITH DSN*/
/* CEMHELP WHOHASIT - TSO BASE, PROMPTS YOUR FOR A DSN WHICH IT      */
/* CEMHELP          - ATTEMPTS TO ALLOC OLD. MIM WILL REPORT TO YOU  */
/* CEMHELP          - IF THE DSN IS IN USE BY SOMEONE, OTHERWISE     */
/* CEMHELP          - IT JUST FREES THE DSN AND TELLS YOU NOONE HASIT*/
/* CEMHELP END                                                       */
 ARG RESP
 IF RESP = '' THEN DO
  SAY 'ENTER THE FULL DATASET NAME (NO QUOTES)'
  PULL RESP
  END
 UPPER RESP
 RESP=STRIP(TRANSLATE(RESP,'  ','"'||"'"),'B')
 IF LENGTH(RESP) < 2 THEN SIGNAL EXITRC4
 IF LENGTH(RESP) > 56 THEN SIGNAL EXITRC8
 IF SYSDSN("'"RESP"'") ^= 'OK' THEN SIGNAL EXITRC12
 ADDRESS TSO
 SIGNAL ON ERROR NAME EXITRC1
 "ALLOC FI(WHOHASIT) DA('"RESP"') OLD"
 XC = RC
         SAY "NOBODY HAS "RESP" ALLOCATED"
         "FREE FI(WHOHASIT)"
         SIGNAL EXITIT
        EXITRC12:
         SAY "DATASET "RESP" DOES NOT EXIST"
         SIGNAL EXITIT
        EXITRC8:
         SAY "DATASET NAME "RESP" IS TOO LONG. VALID 2   56 CHARACTERS"
         SIGNAL EXITIT
        EXITRC4:
         SAY "EXIT SELECTED. BYE BYE."
         SIGNAL EXITIT
        EXITRC1:
         SAY "DATASET IS IN USE. BYE."
        EXITIT:
         RETURN
###END WHOHASIT
$$$BEG BATSDSFX
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA          -                                              */
 /* CEMHELP          - TSO BASE, RESTRICTED                         */
 /* CEMHELP          -                                              */
 /* CEMHELP END                                                     */
 ADDRESS TSO
 /*********************************************/
 /** READ IN SDSF COLUMN DEFINITIONS          */
 /*********************************************/
 "EXECIO * DISKR SDSFIN  (FINIS STEM DATA.  "
 IF RC > 0 THEN
   DO
     SAY "************************************"
     SAY "** ERROR ON READ OF SDSF DEFS   **"
     SAY "************************************"
     SAY "   ERROR ON READ  ====> RC="||RC
     RETURN_CODE = 16
     EXIT RETURN_CODE
   END
 DO I = 1 TO DATA.0
  PARSE VAR DATA.I FIELDID FIELD_DESC FIELD_LEN FIELD_JUST
  SDSF_DATA.I = STRIP(FIELDID)
  SDSF_DATA.I.0 = STRIP(FIELD_DESC)
  SDSF_DATA.I.1 = STRIP(FIELD_LEN)
  SDSF_DATA.I.2 = STRIP(FIELD_JUST)
 END
 SDSF_DATA.0 = DATA.0
 DROP DATA.
 /*********************************************/
 /** READ IN SDSF DATA TO REPORT              */
 /*********************************************/
 "EXECIO * DISKR RPTDATA (FINIS STEM DATA.  "
 IF RC > 0 THEN
   DO
     SAY "************************************"
     SAY "** ERROR ON READ OF RPTDATA     **"
     SAY "************************************"
     SAY "   ERROR ON READ  ====> RC="||RC
     RETURN_CODE = 16
     EXIT RETURN_CODE
   END
 DO I = 1 TO DATA.0
   REPORT_DATA.I = STRIP(DATA.I)
 END
 REPORT_DATA.0 = DATA.0
 DROP DATA.
 DO I = 1 TO REPORT_DATA.0
   DO F = 1 TO SDSF_DATA.0
     IF REPORT_DATA.I = SDSF_DATA.F THEN
       DO
         REPORT_DATA.I.0 = F
         F = SDSF_DATA.0
       END
   END
 END
 HDR_REPORT = "DATE____ TIME____ "
 CSV_REPORT = "DATE,TIME,"
 DO I = 1 TO REPORT_DATA.0
   X = REPORT_DATA.I.0
   HDR_REPORT = HDR_REPORT || LEFT(SDSF_DATA.X.0||"______________",SDSF_DATA.X.1
   CSV_REPORT = CSV_REPORT || SDSF_DATA.X.0||","
 END
 ODATA.1 = HDR_REPORT
 "EXECIO 1 DISKW REPORT (STEM ODATA."
 ODATA.1 = CSV_REPORT
 "EXECIO 1 DISKW REPTCSV (STEM ODATA."
 /********************************/
 /**  GET RUN AND SLEEP TIMES   **/
 /********************************/
 PARSE ARG RUN_TIME DE_LAY JPREFIX
 RUN_TIME = STRIP(RUN_TIME)
 DE_LAY = STRIP(DE_LAY)
 IF LENGTH(JPREFIX) > 0 THEN
   JPREFIX = STRIP(JPREFIX)
 ELSE
   JPREFIX = "*"
 LOOP_CNT = RUN_TIME / DE_LAY
 SAY "RUN_TIME=" RUN_TIME " SLEEP TIME=" DE_LAY
 RC=ISFCALLS('ON')
 ICOL_DATA = ""
 DO ICOL = 1 TO REPORT_DATA.0
   ICOL_DATA = ICOL_DATA || REPORT_DATA.ICOL || " "
 END
 ISFCOLS = ICOL_DATA
 SAY  "DATA TO BE COLLCTED=" ICOL_DATA
 ISFPREFIX=JPREFIX
 /*
 ISFPREFIX="*"
 */
 ISFOWNER=""
 ISFSORT="ECPUPR D"
 /**********************/
 /* ACCESS THE ST PANEL */
 /**********************/
 DO XX = 1 TO LOOP_CNT
 ADDRESS SDSF "ISFEXEC DA"
 IF RC<>0 THEN
 EXIT RC
 /****************************************/
 /* GET FIXED FIELD NAME FROM FIRST WORD */
 /* OF ISFCOLS SPECIAL VARIABLE */
 FIXEDFIELD = WORD(ISFCOLS,1)
 /*
 SAY "NUMBER OF ROWS RETURNED:" ISFROWS
 */
 /********************/
 /* PROCESS ALL ROWS */
 /********************/
 DO IX=1 TO ISFROWS
   DO CD = 1 TO REPORT_DATA.0
     REPORT_DATA.CD.1 = ""
   END
   R_DATA =  DATE('U') || " " || TIME() || " "
   C_DATA =  DATE('U') || "," || TIME() || ","
   SAY "NOW PROCESSING JOB:" VALUE(FIXEDFIELD"."IX)
   /****************************/
   /* LIST ALL COLUMNS FOR ROW */
   /****************************/
   DO JX=1 TO WORDS(ISFCOLS)
     COL = WORD(ISFCOLS,JX)
     DO CD = 1 TO REPORT_DATA.0
       IF REPORT_DATA.CD = COL THEN
         DO
           REPORT_DATA.CD.1 = VALUE(COL"."IX)
           CD = REPORT_DATA.0
         END
     END
   END
   DO RPD = 1 TO REPORT_DATA.0
     C_DATA = C_DATA || REPORT_DATA.RPD.1 || ","
     X = REPORT_DATA.RPD.0
     IF SDSF_DATA.X.2 = "R" THEN
       R_DATA = R_DATA || RIGHT("         "||REPORT_DATA.RPD.1,SDSF_DATA.X.1) ||
     ELSE
       R_DATA = R_DATA || LEFT(REPORT_DATA.RPD.1||"           ",SDSF_DATA.X.1) |
   END
   ODATA.1 = R_DATA
   "EXECIO 1 DISKW REPORT (STEM ODATA."
   ODATA.1 = C_DATA
   "EXECIO 1 DISKW REPTCSV (STEM ODATA."
END
   CALL SLEE_P
END
RC=ISFCALLS('OFF')
EXIT
SLEE_P:
 CALL SYSCALLS 'ON'
 ADDRESS SYSCALL
 "SLEEP" DE_LAY
 CALL SYSCALLS 'OFF'
RETURN
###END BATSDSFX
$$$BEG CTGCNFIG
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA          -                                              */
 /* CEMHELP          - TSO BASE, RESTRICTED                         */
 /* CEMHELP          -                                              */
 /* CEMHELP END                                                     */
   SIGNAL ON HALT NAME HALT
   SN = MVSVAR('SYSNAME')
   CALL GETUDSN 'CTGCNFIG'
   PULL odsn
   TMP = odsn
   PARSE VAR odsn PFX '.D' RPTDT '.T' RPTTM
   opc=4
   op.1="Starting CTG configuration listing report on"
   OP.2="ZOS SYSTEM:"SN": AT 20"||RPTDT RPTTM
   op.3='Report written to 'odsn
   OP.4="End of CTG configuration Listing: Finished at "
   mxln = 80
  /* ADDRESS TSO */
    IF SYSCALLS('ON')>3 THEN DO
     SAY 'UNABLE TO ESTABLISH THE SYSCALL ENVIRONMENT'
     RETURN
     END
   sc = ";"
  /*  XC = SYSCALLS('SIGON') */
  ADDRESS SYSCALL
  /* 'SLEEP '10 */
  ctgroot='/shared_products/ctgtest/regions'
  'READDIR (ctgroot) ctglist.'
  op=''
  DO I = 1 TO CTGLIST.0
   ctgrgndir=ctglist.i
   if ctgrgndir = '.' | ctgrgndir = '..' then iterate
   ctgcfg=ctgroot||'/'||ctgrgndir||'/config'
   op=ctgrgndir
   opc=opc+1
   op.opc = "Report for CTG Region:" ctgrgndir
   'READDIR (ctgcfg) ctgrgncfg.'
   DO j = 1 TO ctgrgncfg.0
    ctgrgnfil=ctgrgncfg.j
    if ctgrgnfil = '.' | ctgrgnfil = '..' then iterate
    if ctgrgnfil = 'ctg.ini' then do
     call writdata
     iterate
     end
    if ctgrgnfil = 'ctg.env' then do
     call writdata
     iterate
     end
   END
   opc=opc+1
   op.opc = copies("#",80)
  END
/*   TRACE ?I */
  if opc < 4 then do
   say "!Error. No Data Processed!"
   exit
   end
  op.4 = op.4||DATE('J') TIME()
  EDSN = ODSN
  EXECSEL = 'CTGCNFIG'
  MYVERB='CANCEL ABORT'
  VRBSTR=MYVERB
  MODDSN = ''
  DSEMSG = '(R) REUSE,(D) DEL/REALLOC,(A) ABORT'
  /* DIR(N) NEEDED IF DSORG(PO) */
    BS=MXLN*10
    MODATTR="NEW BLKSIZE("BS") DSORG(PS) RECFM(F,B) SPACE("OPC",1) "||,
     "BLOCK("BS") LRECL("MXLN") CATALOG REUSE"
 ADDRESS ISPEXEC "VPUT (EDSN EXECSEL DSEMSG MYVERB MODATTR MODDSN) ASIS"
  IF RC ^= 0 THEN SIGNAL EXITRC8
  CALL ALOCDSN
  IF RESULT = 8 THEN SIGNAL CANCEL8
  IF RESULT ^= 0 THEN SIGNAL EXITRC8
DOALOC:
  ADDRESS ISPEXEC "VGET (EDSN MYVERB) ASIS"
  IF RC ^= 0 THEN SIGNAL EXITRC8
  IF WORDPOS(MYVERB,VRBSTR) ^= 0 THEN SIGNAL EXITRC8
  ADDRESS TSO
  "ALLOC FI(CFGDATA) DA('"EDSN"') SHR REUSE"
  IF RC ^= 0 THEN SIGNAL EXITRC8
  "EXECIO * DISKW CFGDATA (STEM OP. FINIS"
  "FREE FI(CFGDATA)"
  say op.3
  RETURN 0
EXITRC8:
 SAY 'ERROR OCCURRED. ENDING EXEC.'
 RETURN 4
CANCEL8:
 SAY 'CANCEL/ABORT/BYPASS OPTIONS SELECTED'
 RETURN 4
writdata:
    ctgrgnfil=ctgcfg||'/'||ctgrgnfil
    'stat (ctgrgnfil) myst.'
    fbz=myst.ST_BLKSIZE
    f#b=myst.ST_BLOCKS
    fty=myst.ST_TYPE
    if fty ^= 3 then do
     opc=opc+1
     op.opc='!Error: 'ctgrgnfil' has improper TYPE'
     say op.opc
     return
     end
    'readfile (ctgrgnfil) mydata.'
    opc=opc+1
    op.opc=ctgrgnfil
     say op.opc
    do k = 1 to mydata.0
     tmp=strip(mydata.k,'b')
     tmpl=length(tmp)
     if tmpl > mxln then mxln = tmp
     if tmp='' | substr(tmp,1,1) = '#' then iterate
     opc=opc+1
     op.opc=tmp
     end
   opc=opc+1
   op.opc = copies(" ",80)
    drop mydata.
    return
###END CTGCNFIG
$$$BEG CTGLIST
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA          -                                              */
 /* CEMHELP          - TSO BASE, RESTRICTED                         */
 /* CEMHELP          -                                              */
 /* CEMHELP END                                                     */
   SIGNAL ON HALT NAME HALT
   SN = MVSVAR('SYSNAME')
  /* ADDRESS TSO */
    IF SYSCALLS('ON')>3 THEN DO
     SAY 'UNABLE TO ESTABLISH THE SYSCALL ENVIRONMENT'
     RETURN
     END
   sc = ";"
  /*  XC = SYSCALLS('SIGON') */
  ADDRESS SYSCALL
  /* 'SLEEP '10 */
  ctgroot='/shared_products/ctgtest/regions'
  'READDIR (ctgroot) ctglist.'
  op=''
  DO I = 1 TO CTGLIST.0
   ctgrgndir=ctglist.i
   if ctgrgndir = '.' | ctgrgndir = '..' then iterate
   ctgcfg=ctgroot||'/'||ctgrgndir||'/config'
   op=ctgrgndir
   'READDIR (ctgcfg) ctgrgncfg.'
   DO j = 1 TO ctgrgncfg.0
    ctgrgnfil=ctgrgncfg.j
    if ctgrgnfil = '.' | ctgrgnfil = '..' then iterate
    if ctgrgnfil ^= 'ctg.ini' then iterate
    ctgrgnfil=ctgcfg||'/'||ctgrgnfil
    'stat (ctgrgnfil) myst.'
    fbz=myst.ST_BLKSIZE
    f#b=myst.ST_BLOCKS
    fty=myst.ST_TYPE
    if fty ^= 3 then iteate
 /* TRACE ?I */
    'readfile (ctgrgnfil) mydata.'
    trigind=0
    myurl=''
    myport=''
    do k = 1 to mydata.0
     tmp=strip(mydata.k,'b')
     if substr(tmp,1,1) = '#' then iterate
     if trigind = 0 then do
      if pos('protocol@tcp.parameters',tmp) = 0 then iterate
       else trigind = 1
      end
 /*  trace i */
     fp=pos('bind=',tmp)
     if fp > 0 then do
      zmp = substr(tmp,fp)
      parse var zmp 'bind=' myurl (sc) rest
      trigind=trigind + 1
      fp=pos('port=',tmp)
      if fp > 0 then do
       zmp = substr(tmp,fp)
       parse var zmp 'port=' myport (sc) rest
       trigind=3
       leave
       end
       else iterate
      end
     fp=pos('port=',tmp)
     if fp > 0 then do
      zmp = substr(tmp,fp)
      parse var zmp 'port=' myport (sc) rest
      trigind=trigind + 1
      if myurl ^= '' then do
       trigind=3
       leave
       end
       else do
       fp=pos('bind=',tmp)
       if fp > 0 then do
        zmp = substr(tmp,fp)
        parse var zmp 'bind=' myurl (sc) rest
        trigind=trigind + 1
        end
        else iterate
       end
     if trigind > 2 then leave
     end
    END
    drop mydata.
    op = ctgrgndir||','||myurl||','||myport||','||sn||',Z,cp1047'
    say op
    /* trace off */
   END
  END
###END CTGLIST
$$$BEG DSPSDSF0
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA          -                                              */
 /* CEMHELP          - TSO BASE, RESTRICTED                         */
 /* CEMHELP          -                                              */
 /* CEMHELP END                                                     */
   ADDRESS ISPEXEC
 /* TRACE ?I */
   FFX='FF'X
   CMDIND = 0
   GOODLIST=''
   BADLIST=''
   DUPLIST=''
   VQMODE='VERBOSE'
   VALVQMODE='QUIET VERBOSE TRACE'
   ARGLIST='JOB APPLID PDS DDNAME PANEL VQMODE'
   VALSDSF='DA ST H'
   SS1='VALID PANEL:'||VALSDSF
   SS2='JESMSGLG JESJCL JESYSMSG DFHCXRF LOGUSR MSGUSR '
   SS3='PLIMSG COUT CEEMSG CEEOUT TCPDATA ACF2LOG USSTDD '
   SS4='CRPO CINT FDBDLOG XDGBLRPT XDBPARPT STDERR STDOUT'
   VALDDN=SS2||SS3||SS4
   VAL_DA_COLS='SRVCLASS SYSNAME'
   VAL_ST_COLS='SRVCLS ACTSYS SYSAFF QUEUE'
   VAL_H_COLS='DSDATE RETCODE DATEE'
   VALFILTER=VAL_DA_COLS||' '||VAL_ST_COLS||' '||VAL_H_COLS
   VALSRVCLS='ONLTST ONLPRD ONLSRVR'
   VALQUEUE ='EXECUTIO PRINT'
   SS5=VALFILTER
   SS6=VALSRVCLS
   SS7=VALQUEUE
   CALL GETCPU1
   XC=RESULT
   IF XC ^= 0 THEN SIGNAL EXITRC8
   "ISPEXEC VGET (CURGRP CURCPUG) PROFILE"
   IF RC ^= 0 THEN SIGNAL EXITRC8
 GOTCPUG:
   L_CPUG=LENGTH(CURCPUG)
   HOSTLIST=''
   DO I = 1 TO L_CPUG
    /* H = 'CPUHOST'SUBSTR(CURCPUG,I,1) */
    TH = SUBSTR(CURCPUG,I,1)||'SYS'
    INTERPRET TH'=TH'
    HOSTLIST = HOSTLIST||" "TH
    END
   VALASYS  = HOSTLIST
   VALSAFF  = HOSTLIST
   SS8=HOSTLIST
   VQMODE_LIST=VALVQMODE
   SELN='INPUT'
   SDSFJOBN=''
   APPLLIST=''
   ISFILTER='OFF'
   HSDSFJBL=''
   HSDSFDDN='MSGUSR'
   HSDSFPNL='DA'
   CALL GETUDSN 'CICSSDSF.'HSDSFDDN
   PULL EDSN
   HSDSFOP=EDSN
   SDSFJOBL=''
   SDSFDDN=HSDSFDDN
   SDSFPNL=HSDSFPNL
   SDSFOP=HSDSFOP
/*  */
   "ISPEXEC CONTROL ERRORS RETURN"
   "ISPEXEC VGET (MYAFOIND SVAFO0) SHARED"
   IF RC = 0 THEN SIGNAL AFLD
   CALL AFOLOAD1
   "ISPEXEC VGET (MYAFOIND SVAFO0) SHARED"
   IF RC \= 0 THEN DO
    MSGBOXTX='ERROR. COULD NOT LOAD AFOLIST. ENDING'
    SIGNAL EXITRC20
    END
AFLD:
   "ISPEXEC VGET (GPAFO0) SHARED"
   IF RC \= 0 THEN DO
    MSGBOXTX='ERROR. COULD NOT ACCESS AFOLIST. ENDING'
    SIGNAL EXITRC20
    END
   "ISPEXEC VGET (AFOJOBLS AFOAPLLS) SHARED"
/*  */
   PARSE UPPER ARG A
   IF A = '' THEN SIGNAL NOARGS
   DO WHILE A \= ''
    PARSE VAR A B A
    FPOS=POS('(',B)
    IF FPOS < 2 THEN SIGNAL EXITRC14
    EPOS = POS(')',B)
    IF EPOS = 0 THEN SIGNAL EXITRC14
    CWD=SUBSTR(B,1,FPOS-1)
    FPOS=FPOS+1
    PWD=SUBSTR(B,FPOS,(EPOS-FPOS))
    WP=WORDPOS(CWD,ARGLIST)
    IF WP = 0 THEN SIGNAL EXITRC14
    IF CWD = 'JOB' THEN DO
     HSDSFJBL = PWD
     ITERATE
     END
    IF CWD = 'APPLID' THEN DO
     APPLLIST=PWD
     ITERATE
     END
    IF CWD = 'DDNAME' THEN DO
     HSDSFDDN=PWD
     ITERATE
     END
    IF CWD = 'PDS' THEN DO
     HSDSFOP=PWD
     ITERATE
     END
    IF CWD = 'PANEL' THEN DO
     SDSFPNL=PWD
     ITERATE
     END
    IF CWD = 'VQMODE' THEN DO
     VQMODE=PWD
     ITERATE
     END
    END
   IF APPLLIST \= '' | HSDSFJBL \= '' THEN DO
    IF HSDSFJBL \= '' THEN DO
     APPLLIST=APPLLIST||','||HSDSFJBL
     HSDSFJBL=''
     END
/*  CALL GETJOBL APPLLIST HSDSFJBL */
    CALL GETJOBL
    XC = RESULT
    IF XC \= 0 THEN DO
     IF XC = 20 THEN DO
      MSGBOXTX=FFX||'ERROR. APPLICATION LIST IS INVALID'||FFX||BADLIST
      SIGNAL EXITRC16
      END
     IF XC = 22 THEN DO
      MSGBOXTX=FFX||'ERROR. APPLICATION LIST IS EMPTY.'||FFX||HSDSFJBL
      SIGNAL EXITRC16
      END
     MSGBOXTX=FFX||'ERROR PROCESSING APPLICATION LIST'||FFX||HSDSFJBL
     SIGNAL EXITRC16
     END
    SDSFJOBL=HSDSFJBL
    END
   IF WORDPOS(VQMODE,VQMODE_LIST) = 0 THEN DO
     MSGBOXTX=FFX||'ERROR. PROCESSING MODE INVALID:'VQMODE||FFX||,
      'CHOOSE VALID PROCESSING MODE:'||FFX||VQMODE_LIST
     SIGNAL EXITRC16
     END
   IF SDSFDDN \= '' AND ,
      WORDPOS(SDSFDDN,VALDDN) = 0 THEN DO
     MSGBOXTX=FFX||'ERROR. SELECTED DDNAME INVALID:'SDSFDDN||FFX||,
      'CHOOSE VALID DDNAMES ARE:'||FFX||VALDDN
     SIGNAL EXITRC16
     END
   IF SDSFPNL \= '' AND ,
      WORDPOS(SDSFPNL,VALSDSF) = 0 THEN DO
     MSGBOXTX=FFX||'ERROR. SELECTED PANEL INVALID:'SDSFPNL||FFX||,
      'CHOOSE VALID PANEL NAME:'||FFX||VALSDSF
     SIGNAL EXITRC16
     END
NOARGS:
   IF VQMODE = 'QUIET' THEN SIGNAL TSTPRMS
   "ISPEXEC ADDPOP ROW(1) COLUMN(10)"
   IF RC \= 0 THEN DO
    MSGBOXTX='ERROR. COULD NOT ADD POPUP WINDOW. ENDING'
    SIGNAL EXITRC24
    END
   FFX='FF'X
   TRCCMD='TRACE OFF'
   EXECSEL='DSPSDSF'
   DSEMSG='ENTER CICS SDSF SEARCH CRITERIA BELOW'
   MDSN='TTED.TSK.P.TCEM.CLIST'
   "ISPEXEC LIBDEF ISPPLIB DATASET ID('"MDSN"') UNCOND"
   IF RC \= 0 THEN SIGNAL EXITRC8
   DSEMSG='INITIAL VALUE FROM EXEC'
   SIGNAL ARND_CA_MSG
CLR_CA
   DSEMSG='CLEARED VALUE FROM EXEC'
ARND_CA_MSG:
   ICNT=0
   MYSC='CSR'
/* DO I = 1 TO 9
    INTERPRET 'SS'I' = ""'
    END  */
   SIGNAL DOIT
DOIT:
DISPP:
   /* TRACE I */
   "ISPEXEC DISPLAY PANEL(DSPSDSFD)"
   XC = RC
   IF XC = 8 THEN SIGNAL DONEIT
   IF XC \= 0 THEN SIGNAL EXITRC8
   IF ZCMD = 'HELP' | ZCMD = '?' THEN SIGNAL SHOWFMT
   IF ZCMD = 'RESET' THEN SIGNAL RESET
   IF ZCMD = 'CLRCA' THEN SIGNAL CLR_CA
   IF ZCMD = 'CANCEL' THEN SIGNAL EXITRC8
   IF ZCMD = 'END' THEN SIGNAL DONEIT
   MCMD=ZCMD
   IF MCMD \= '' THEN DO
    PARSE VAR MCMD FCMD RCMD
    IF FCMD = 'TRACE' THEN TRCCMD=MCMD
     ELSE "TSO MCMD"
    END
   INTERPRET TRCCMD
   IF XC = 0 THEN SIGNAL DISPP
   SIGNAL DISPP
SHOWFMT:
 MSGBOXTX=XFF||'ENTER THE CICS SDSF SELECTION CRITERIA.'||XFF||,
 'JOBNAME|APPLID(S) LIST TO PROCESS BY SDSF PANEL'||XFF||,
 'SELECT A VALID DDNAME FORM THE FOLLOWING LIST:'||FFX||VALDDN||FFX||,
 '(IF YOU REQUEST DDNAME(-) PROVIDES ACTIVE STATUS)'||FFX||,
 'PROVIDE AN DESTINATION FOR THE OUTPUT: DISPLAY TERMINAL'|XFF||,
 'A PDS CREATED JOBNAME MEMBERS, OR A SEQ DSN WILL MOD REPORTS'||XFF||,
 'CANALL CANCEL OUT OF A COMMAND PROCESS'||XFF||,
 'END AND '||XFF||'PF3 PROCESSES THE REQUEST.'
 CALL MSGBOX MSGBOXTX
   SIGNAL DISPP
TSTPRMS:
 /* TRACE ?I */
DONEIT:
/*  TRACE ?I  */
   IF SDSFJOBL = '' THEN SIGNAL EXITRC8
   NSDSF=WORDS(SDSFJOBL)
   APPLLIST = ''
   INTERPRET 'PNL_WD=VAL_'||SDSFPNL||'_COLS'
   DO I = 1 TO NSDSF
    TWD=WORD(SDSFJOBL,I)
    IF SUBSTR(TWD,1,5) = 'LIST(' THEN DO
     PARSE VAR TWD 'LIST(' LSTV ')' REST
     IF LSTV \= '' THEN DO
      "ISPEXEC VGET ("LSTV ") ASIS"
      IF RC \= 0 THEN ITERATE
      INTERPRET 'TWD = 'LSTV
      IF TWD = '' THEN ITERATE
      APPLLIST=APPLLIST||' '||TWD
      END
     ITERATE
     END
    PARSE VAR TWD FILWD '(' FILVAL ')'
    WP=WORDPOS(FILWD,PNL_WD)
    IF WP \= 0 THEN DO
     ISFILTER=FILWD||'='||FILVAL
     ITERATE
     END
    APPLLIST=APPLLIST||' '||TWD
    END
   IF APPLLIST = '' &  ISFILTER='OFF' THEN SIGNAL EXITRC8
   HSDSFJBL=''
   IF APPLLIST \= '' THEN DO
    CALL GETJOBL
    XC = RESULT
    IF XC \= 0 THEN DO
     IF XC = 20 THEN DO
      MSGBOXTX=FFX||'ERROR. APPLICATION LIST IS INVALID'||FFX||BADLIST
      SIGNAL EXITRC16
      END
     IF XC = 22 THEN DO
      MSGBOXTX=FFX||'ERROR. APPLICATION LIST IS EMPTY.'||FFX||HSDSFJBL
      SIGNAL EXITRC16
      END
     MSGBOXTX=FFX||'ERROR PROCESSING APPLICATION LIST'||FFX||HSDSFJBL
     SIGNAL EXITRC16
     END
    SDSFJOBL=TRANSLATE(STRIP(HSDSFJBL,'B'),',',' ')
    END
    ELSE SDSFJOBL='*'
   IF SDSFDDN \= '' & WORDPOS(SDSFDDN,VALDDN) = 0 THEN DO
     MSGBOXTX=FFX||'ERROR. SELECTED DDNAME INVALID:'SDSFDDN||FFX||,
      'CHOOSE VALID DDNAMES ARE:'||FFX||VALDDN
     SIGNAL EXITRC16
     END
   IF SDSFPNL \= '' &  WORDPOS(SDSFPNL,VALSDSF) = 0 THEN DO
     MSGBOXTX=FFX||'ERROR. SELECTED PANEL INVALID:'SDSFPNL||FFX||,
      'CHOOSE VALID PANEL NAME:'||FFX||VALSDSF
     SIGNAL EXITRC16
     END
/*  SAY 'WE ARE DONEIT' */
  /* TRACE ?I */
  IF SDSFJOBL = '' THEN SIGNAL EXITRC8
  IF SDSFDDN = '' THEN SIGNAL EXITRC8
  IF SDSFOP = '' THEN SIGNAL EXITRC8
  IF SDSFPNL = '' THEN SIGNAL EXITRC8
  /* TRACE ?I */
  ARGLST='JOB('SDSFJOBL') DDNAME('SDSFDDN') PDS('SDSFOP||,
         ') SDSFPNL('SDSFPNL')' 'FILTER('ISFILTER') VQMODE('VQMODE')'
 /*                         */
 CALL SFISKIXA ARGLST
JSTRET0:
 CMDIND = 0
 SIGNAL EXITIT
EXITRC8:
 CMDIND = 8
 MSGBOXTX='ERROR. ONE OF REQUIRED PARMS IS MISSING'
 SIGNAL EXITIT
EXITRC14:
 CMDIND = 8
 SIGNAL EXITIT
EXITRC16:
 CMDIND = 8
 SIGNAL EXITIT
EXITRC20:
 CMDIND = 20
 SIGNAL EXITIT
EXITRC22:
 CMDIND = 20
 SIGNAL EXITIT
EXITRC24:
 CMDIND = 24
 SIGNAL EXITIT
EXITIT:
 "ISPEXEC VPUT (CMDIND) ASIS"
 IF CMDIND \= 0 THEN DO
  IF VQMODE = 'QUIET' THEN RETURN 8
  CALL MSGBOX MSGBOXTX
  END
 IF VQMODE = 'QUIET' THEN RETURN 0
 "ISPEXEC REMPOP"
 RETURN 0
GETJOBL:
 /* TRACE ?I */
    APPLLIST=TRANSLATE(APPLLIST,' ',',')
    DO WHILE APPLLIST \= ''
     PARSE VAR APPLLIST APLID APPLLIST
     ASK_P=POS('*',APLID)
     IF ASK_P = 0 THEN DO
      APLPOS=WORDPOS(APLID,AFOAPLLS)
      IF APLPOS = 0 THEN DO
       JOBPOS=WORDPOS(APLID,AFOJOBLS)
       IF JOBPOS = 0 THEN DO
        BADLIST=BADLIST||' '||APLID
        END
        ELSE DO
        JOBNM=WORD(AFOJOBLS,JOBPOS)
        END
       END
      ELSE JOBNM=WORD(AFOJOBLS,APLPOS)
     HSDSFJBL=HSDSFJBL||' '||JOBNM
     END
     ELSE DO
     HSDSFJBL=HSDSFJBL||' '||APLID
     END
    END
/*  NWD=WORDS(HSDSFJBL) - 1 */
    NWD=WORDS(HSDSFJBL)
/*  GOODLIST=WORD(HSDSFJBL,1) */
    DO I = 1 TO NWD
     TMPWD=WORD(HSDSFJBL,I)
/*   IF WORDPOS(TMPWD,HSDSFJBL,I+1) = 0 THEN , */
     IF WORDPOS(TMPWD,GOODLIST) = 0 THEN ,
      GOODLIST=GOODLIST||' '||TMPWD
      ELSE DUPLIST=DUPLIST||' '||TMPWD
     END
/* TRACE ?I */
   IF BADLIST \= '' THEN RETURN 20
   IF GOODLIST = '' THEN RETURN 22
   IF DUPLIST \= '' THEN NOP
   HSDSFJBL=GOODLIST
   TRACE OFF
   RETURN 0
###END DSPSDSF0
$$$BEG CVTJN2RG
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA CVTJN2RN - CONVERTS CICS JOBNAMES TO APPLID NAME        */
 /* CEMHELP CVTJN2RN - ISPF BASE, CONVERTS AN ARG   LIST OF         */
 /* CEMHELP - CICS JOBNAMES INTO THEIR RESPECTIVE REGION APPLID     */
 /* CEMHELP - NAME. RETURN A 2 COL DISPLAY 'APPLID JOBNAME'         */
 /* CEMHELP - THE   ARG INPUT LIST CAN BE:                          */
 /* CEMHELP - NOTHING - YOU ARE PROMPTED FOR THE JOBNAME(S)         */
 /* CEMHELP -     THE RESULTANT APPLID STRING IS WRITTEN TO THE     */
 /* CEMHELP -     DISPLAY, 1 LINE PER ENTRY                         */
 /* CEMHELP - JOB NAMES AS A SPACE SEPARATED STRING                 */
 /* CEMHELP -     THE RESULTANT APPLID STRING IS WRITTEN TO THE     */
 /* CEMHELP -     DISPLAY, 1 LINE PER ENTRY                         */
 /* CEMHELP - DSN<MY.DSN.WITH.JOBNAMES> WHERE THE DSN HOLDS THE     */
 /* CEMHELP -     LIST OF JOBNAMES. EACH LINE OF THE DSN IS:        */
 /* CEMHELP -      COLS 1 - 72                                      */
 /* CEMHELP -      '*' COMMENT DATA (TO RIGHT OF * IGNORED)         */
 /* CEMHELP -      JOB NAMES 1 - 8 CHARACTERS IN A SPACE SEPARATED  */
 /* CEMHELP -        LIST OF NAMES                                  */
 /* CEMHELP -     THE RESULTANT APPLID STRING IS WRITTEN TO THE     */
 /* CEMHELP -     DISPLAY, 1 LINE PER ENTRY                         */
 /* CEMHELP - LIST<LISTNAME> NAMES AN ISPFVAR WITH A LIST OF        */
 /* CEMHELP -      JOB NAMES 1 - 8 CHARACTERS IN A SPACE SEPARATED  */
 /* CEMHELP -        LIST OF NAMES                                  */
 /* CEMHELP -     THE RESULTANT APPLID STRING IS WRITTEN TO THE     */
 /* CEMHELP -     DISPLAY, 1 LINE PER ENTRY                         */
 /* CEMHELP - NOTE - TO BE USEFUL, USE THE OUTTRAP COMMAND IN YOUR  */
 /* CEMHELP -     CALLING EXEC. CAPTURE EACH DISPLAY LINE AS A      */
 /* CEMHELP -     REXX.STEM VARIABLE AND THEN USE THAT SET OF       */
 /* CEMHELP -     RETURNED APPLIDS IN YOUR OWN EXEC.                */
 /* CEMHELP -     INVALID JOBNAME/APPLIDS ARE REPRESENTED '!!!!!!!!'*/
 /* CEMHELP -     A RC > 0 REPRESENTS AN ERROR.                     */
 /* CEMHELP END                                                     */
 /* TRACE ?I */
   INPLIST=''
   PARSE UPPER ARG A
   IF A = '' THEN DO
    SAY 'ENTER A JOBNAME, OR LIST OF JOBNAMES (SPACE SEPARATED):'
    PULL A
    SIGNAL GOTLIST
    END
   PARSE VAR A 'DSN<' EDSN '>'
   IF EDSN ^= '' THEN DO
    ADDRESS TSO
    "ALLOC FI(I) DA('"EDSN"') SHR"
    "EXECIO * DISKR I (STEM JCL. FINIS"
    "FREE FI(I)"
    IF JCL.0 < 1 THEN DO
     MSGBOXTX='ERROR._NO_RECORDS_IN_'EDSN
     MXRC = 6
     SIGNAL EXITRC
     END
    LCT=JCL.0
    A = ''
    DO I = 1 TO LCT
     TMP=STRIP(SUBSTR(JCL.I,1,72),'B')
     PARSE VAR TMP TMP '*' REST
     IF TMP = '' THEN ITERATE
     A = A||' '||TMP
     END
    SIGNAL GOTLIST
    END
   PARSE VAR A 'LIST<' LVAR '>'
   IF LVAR ^= '' THEN DO
    ADDRESS ISPEXEC
    "ISPEXEC VGET ("LVAR") ASIS"
    INTERPRET 'A = 'LVAR
    SIGNAL GOTLIST
    END
 /* A REPRESENTS THE LIST OF JOB NAMES */
 GOTLIST:
   IF A = '' THEN DO
     MSGBOXTX='ERROR._LIST_IS_EMPTY'
     MXRC = 4
     SIGNAL EXITRC
     END
   ADDRESS ISPEXEC
   "ISPEXEC CONTROL ERRORS RETURN"
   CALL GETCPU1
   XC=RESULT
   IF XC ^= 0 THEN DO
    MSGBOXTX='ERROR. COULD NOT ACCESS CPU LIST. ENDING'
    MXRC = 8
    SIGNAL EXITRC
    END
   "ISPEXEC VGET (CURGRP CURCPUG) PROFILE"
   IF RC ^= 0 THEN DO
    MSGBOXTX='ERROR. COULD NOT ACCESS CPU GROUP. ENDING'
    MXRC = 8
    SIGNAL EXITRC
    END
   "ISPEXEC VGET (MYAFOIND SVAFO0) SHARED"
   IF RC = 0 THEN SIGNAL AFLD
   CALL AFOLOAD1
   "ISPEXEC VGET (MYAFOIND SVAFO0) SHARED"
   IF RC ^= 0 THEN DO
    MSGBOXTX='ERROR. COULD NOT LOAD AFOLIST. ENDING'
    MXRC = 8
    SIGNAL EXITRC
    END
AFLD:
   "ISPEXEC VGET (GPAFO0) SHARED"
   IF RC ^= 0 THEN DO
    MSGBOXTX='ERROR. COULD NOT ACCESS AFOLIST. ENDING'
    MXRC = 8
    SIGNAL EXITRC
    END
   "ISPEXEC VGET (AFOJOBLS AFOAPLLS) SHARED"
   IF RC ^= 0 THEN DO
    MSGBOXTX='ERROR. COULD NOT ACCESS JOB AND APPLID LIST. ENDING'
    MXRC = 8
    SIGNAL EXITRC
    END
/*  *\
|* VAR A HOLDS THE LIST OF JOBNAME *|
\*  */
   A = TRANSLATE(A,' ',',')
   LCT=WORDS(A)
   MXRC = 0
   DO I = 1 TO LCT
    TMP = WORD(A,I)
    IF (DATATYPE(TMP) \= 'CHAR') | (LENGTH(TMP) > 8) THEN DO
     INPLIST = INPLIST||' !!!!!!!!'
     MXRC = MXRC + 1
     ITERATE
     END
    IF LENGTH(TMP) > 8 THEN DO
     INPLIST = INPLIST||' !!!!!!!!'
     ITERATE
     END
    INPLIST=INPLIST||' '||TMP
    END
 /* TRACE ?I */
   INPLIST = TRANSLATE(INPLIST,' ',',')
   INPLIST=STRIP(INPLIST,'B')
   IF INPLIST = '' THEN DO
    MSGBOXTX='ERROR._LIST_IS_EMPTY._ENDING'
    MXRC = 4
    SIGNAL EXITRC
    END
   NWD=WORDS(INPLIST)
   IF NWD ^= LCT THEN DO
    MSGBOXTX='ERROR._LIST_COUNT_BAD._ENDING'
    MXRC = 10
    SIGNAL EXITRC
    END
   APLLIST = ''
   JOBLIST = ''
 /* TRACE ?I */
   DO I = 1 TO NWD
     INPID=WORD(INPLIST,I)
     IF INPID = '!!!!!!!!' THEN DO
      JOBLIST=JOBLIST||' '||INPID
      APLLIST=APLLIST||' !!!!!!!!'
      ITERATE
      END
     JOBPOS=WORDPOS(INPID,AFOJOBLS)
     IF JOBPOS > 0 THEN DO
      JOBLIST=JOBLIST||' '||INPID
      APLLIST=APLLIST||' '||WORD(AFOAPLLS,JOBPOS)
      ITERATE
      END
     APLPOS=WORDPOS(INPID,AFOAPLLS)
     IF APLPOS > 0 THEN DO
      JOBLIST=JOBLIST||' '||WORD(AFOJOBLS,APLPOS)
      APLLIST=APLLIST||' '||INPID
      ITERATE
      END
     JOBLIST=JOBLIST||' '||INPID
     APLLIST=APLLIST||' !!!!!!!!'
    END
   NWD=WORDS(JOBLIST)
   IF NWD ^= WORDS(APLLIST) THEN DO
    MSGBOXTX='ERROR. JOB_CNT_NE_APL_CNT._ENDING'
    MXRC = 10
    SIGNAL EXITRC
    END
   DO I = 1 TO NWD
    SAY LEFT(WORD(APLLIST,I),9)||LEFT(WORD(JOBLIST,I),9)
    END
   SIGNAL EXITRC
 EXITRC8:
     MSGBOXTX='ERROR._UNKNOWN_ERROR._ENDING'
     MXRC = 8
 EXITRC:
    RETURN MXRC
###END CVTJN2RG
$$$BEG DSPAFOEO
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA          -                                              */
 /* CEMHELP          - TSO BASE, RESTRICTED                         */
 /* CEMHELP          -                                              */
 /* CEMHELP END                                                     */
    ADDRESS ISPEXEC
    "ISPEXEC CONTROL ERRORS RETURN"
    AFODSLST = ''
    AFO_LSTS=''
    'ISPEXEC VGET (AFODSLST) PROFILE'
    IF RC ^= 0 THEN SIGNAL GET_AFODSLST
    IF AFODSLST ^= '' THEN DO
     EDSN=AFODSLST
     SIGNAL GOT_AFODSLST_0
     END
GET_AFODSLST:
   AFODSLST=''
   EDSN='YOUR.DSN.GOES.HERE(MBR)'
GOT_AFODSLST_0:
   DSEMSG = 'ENTER SRC DSN(MBR) CONTAINING AFO LISTS'
   MYVERB = 'ABORT BYPASS CANCEL'
   "ISPEXEC VPUT (EDSN DSEMSG MYVERB) ASIS"
   CALL DSNWIND
   XC = RESULT
   IF XC > 4 THEN SIGNAL BYPASS_DSLST
   ADDRESS ISPEXEC "VGET (MYVERB) ASIS"
   IF RC ^= 0 THEN SIGNAL BYPASS_DSLST
 /* SIMPLE TEST OF MYVERB */
   IF MYVERB ^= '' THEN DO
    IF MYVERB='ABORT' | MYVERB='CANCEL' THEN SIGNAL BYPASS_DSLST
    IF MYVERB^='BYPASS' THEN SIGNAL BYPASS_DSLST
    END
 PROCSRC:
   ADDRESS ISPEXEC "VGET (EDSN) ASIS"
   IF RC ^= 0 THEN SIGNAL BYPASS_DSLST
   AFODSLST = EDSN
   "ISPEXEC VPUT (AFODSLST) PROFILE"
    IF RC ^= 0 THEN SIGNAL BYPASS_DSLST
GOT_AFODSLST:
    ADDRESS TSO
    XC=LISTDSI("'"AFODSLST"'" DIRECTORY NORECALL)
    IF XC ^= 0 THEN DO
     DSEMSG='INVALID DS FOR AFOLIST REQUIREMENT'
     AFODSLST=''
    "ISPEXEC VPUT (AFODSLST) PROFILE"
     SIGNAL BYPASS_DSLST
     END
    "ALLOC FI(I) DA('"AFODSLST"') SHR"
    "EXECIO * DISKR I (STEM ALST. FINIS"
    "FREE FI(I)"
    ADDRESS ISPEXEC
    ACNT=ALST.0
    TMP_LST=''
    DUPLS=0
    IN_LST = '('
    DO I = 1 TO ACNT
     TMP = STRIP(SUBSTR(ALST.I,1,72),'B')
     IF SUBSTR(TMP,1,1) = '*' THEN ITERATE
     IF IN_LST = '(' THEN DO
      PARSE VAR TMP LST_NM '=' TMP
      IF LST_NM = '' THEN ITERATE
      IF POS(LST_NM,AFO_LSTS) = 0 THEN DO
       AFO_LSTS=AFO_LSTS||' '||LST_NM
       END
      IN_LST=')'
      END
      FP=POS('(',TMP)
      IF FP ^= 0 THEN TMP=SUBSTR(TMP,FP+1)
      EP = POS(')',TMP)
      IF EP ^= 0 THEN IN_LST='('
      PARSE VAR TMP TMP '*' REST
      IF TMP ^= '' THEN DO
       PARSE VAR TMP TMP ')' REST
       END
      TMP=TRANSLATE(TMP,' ',',')
      NWD=WORDS(TMP)
      IF NWD > 0 THEN DO
       IF DATATYPE(WORD(TMP,NWD)) = 'NUM' THEN DO
        IF NWD = 1 THEN TMP = ''
        ELSE TMP = SUBSTR(TMP,1,WORDINDEX(TMP,NWD)-1)
        END
       END
      TMP=STRIP(TMP,'B')
      IF DATATYPE(TMP) = 'NUM' THEN TMP = ''
      TMP_LST=TMP_LST||' '||TMP
      IF IN_LST='(' THEN DO
       TMP_LST=TRANSLATE(TMP_LST,' ',',')
       INTERPRET LST_NM' = TMP_LST'
       'ISPEXEC VPUT ('LST_NM') ASIS'
       TMP_LST=''
       END
      END
BYPASS_DSLST:
     MAFOLSTS=STRIP(AFO_LSTS,'B')
     'ISPEXEC VPUT (MAFOLSTS) ASIS'
     RETURN
###END DSPAFOEO
$$$BEG DSNL2REX
 /* REXX */
 /* %%% */
/* CEMHELP BEGIN                                                     */
/* CEMHELA DSNL2REX - PROCESS A  LIST. USE DYNM REXX TO MANIPULATE   */
/* CEMHELP DSNL2REX - ISPF BASED, USED TO PROCESS A LIST TO PERFORM  */
/* CEMHELP          - REPETATIVE PROCESSING. OPTIONAL 3 PARMS:       */
/* CEMHELP          -  TRAC(ON) OR TRAC(N) TO TRACE ALL OR N ITERATNS*/
/* CEMHELP          -  SRC(X) WHERE X IS A DSN OR X IS '-'           */
/* CEMHELP          -  TGT(X) WHERE X IS A DSN OR X IS '-'           */
/* CEMHELP          - TRAC ARGUMENT WHICH MUST BE IN FORMAT          */
/* CEMHELP          - TRAC(ON) FOR PERM TRACE, TRAC(N) WHERE N IS    */
/* CEMHELP          - NUMBER OF SRC RECORDS TO PROCESS W/ TRACE ON.  */
/* CEMHELP          - SRC DSN IS USED TO FEED THE EXEC A LIST TO     */
/* CEMHELP          - PROCESS AGAINST. YOU ARE PROMPTED FOR IT IF    */
/* CEMHELP          - YOU DO NOT PROVIDE IT IN THE PARM.  IF YOU     */
/* CEMHELP          - SPECIFY A '-' (E.G. SRC(-)) THEN YOU BYPASS    */
/* CEMHELP          - THE LIST OPTION AND WILL NOT BE PROMPTED.      */
/* CEMHELP          - SAME MEANING FOR TGT.  THE TGT DSN CAN BE USED */
/* CEMHELP          - TO WRITE OP (WHICH YOU ACCUMULATE TO A STEM)   */
/* CEMHELP          - TO A DATASET FOR YOUR OWN USE.                 */
/* CEMHELP          - THE SRC LIST FILE CAN BE ANY PS OR PO DSN(MBR) */
/* CEMHELP          - IN WHICH YOU WISH TO PROCESS (SUCH AS THE OP OF*/
/* CEMHELP          - COPYSEL)AS A SOURCE FOR MANIPULATING RESOURCES */
/* CEMHELP          - (NOTE - ANY SEQ LIST WILL DO). A TARGET DSN IS */
/* CEMHELP          - OPTIONAL AND WOULD BE USED BY YOU IF DESIRED.  */
/* CEMHELP          - IT IS WRITTEN AUTOMATICALLY FROM STEM VAR TGT. */
/* CEMHELP          - A REXXSRC BOX IS DISPLAYED FOR THREE PHASES:   */
/* CEMHELP          -  PREFIX TO SET UP HOUSEKEEPING VARIABLES ONE   */
/* CEMHELP          -   TIME PRIOR TO ENTERING THE LOOP.             */
/* CEMHELP          -  SUFFIX TO SET UP A POST LOOP ROUTINE TO DO    */
/* CEMHELP          -   ANY OTHER ADDITIONAL PROCESSING.             */
/* CEMHELP          -  MAIN   TO SET UP A THE LIST PROCESSING LOGIC  */
/* CEMHELP          - THE BOX IS NOT AN EDITOR, IT WILL ACCUMULATE   */
/* CEMHELP          - 1 TO MANY REXX STATEMENTS WHICH YOU WANT TO    */
/* CEMHELP          - EXECUTE ENTIRITY, AS PREFIX OR SUFFIX LOGIC, OR*/
/* CEMHELP          - EXECUTE ALL STATEMENTS FOR EACH LINE IN SRC.   */
/* CEMHELP          - THIS ALLOWS YOU TO MANIPULATE ANYTHING FOR EACH*/
/* CEMHELP          - LINE IN THE SRC LIST, AND CREATE OUTPUT IF SO  */
/* CEMHELP          - DESIRED. YOU CAN ALSO COPYB, COPYA A MEMBER    */
/* CEMHELP          - FROM CLIST DSN, OR PASTEB, PASTEA LINES CUT    */
/* CEMHELP          - FROM SOMEWHATE ELSE.  THE B OR A INDICATE THE  */
/* CEMHELP          - PLACEMENT OF STATEMENTS WRT THE CURRENT TOP    */
/* CEMHELP          - AND BOTTOM LINE OF THIS SCREEN. YOU CAN ALSO   */
/* CEMHELP          - PRINT THE CURRENT REXX STATEMENTS TO JRPPNT    */
/* CEMHELP          - VIA REXP OR TO JRPPNT  VIA REXPN. SEE CEMHELP  */
/* CEMHELP          - REXXSRC FOR MORE DETAIL.                       */
/* CEMHELP          - NOTES                                          */
/* CEMHELP          - SRC MUST EXIST. TGT WILL BE REUSED OR CREATED. */
/* CEMHELP          - SPECIAL LABELS      WHICH CAN BE REFERENCED    */
/* CEMHELP          -  WITHIN THE REXX                               */
/* CEMHELP          -   INCRSRC LABEL TO INCR SRC LOOP               */
/* CEMHELP          -   INCRREX LABEL TO INCR REXX STMT LOOP         */
/* CEMHELP          -   EXITRC8 ABORT                                */
/* CEMHELP          -   CANCEL8 CANCEL                               */
/* CEMHELP          - SPECIAL VARIABLES                              */
/* CEMHELP          -   D#####Z SRC DSN LINE NO                      */
/* CEMHELP          -   T#####Z TGT DSN OP LINE NO                   */
/* CEMHELP          -    NOTE - USE 'INTERPRET I#'                   */
/* CEMHELP          -         - TO INCREMENT T#####Z                 */
/* CEMHELP          -    NOTE - USE 'INTERPRET SI#'                  */
/* CEMHELP          -         - TO 'SIGNAL INCRSRC;END'              */
/* CEMHELP          -         - USED AS PART OF YOUR DO LOOP BREAK   */
/* CEMHELP          -   Z#####Z YOUR CURRENT REXX INTERPRETED LINE#  */
/* CEMHELP          -   SRC. STEM VAR FOR SOURCE DSN                 */
/* CEMHELP          -   TGT. STEM VAR FOR TARGET DSN                 */
/* CEMHELP          -   MANY VARIABLES USED IN THIS ROUTINE.         */
/* CEMHELP          -    YOU CAN SAFELY USE ANY VARS BEGINING WITH:  */
/* CEMHELP          -    H,L,Y OR ANY VAR WHICH USES $ AS SECOND CHAR*/
/* CEMHELP          -   USE LABEL INCRSRC TO SIGNAL TO READ NEXT SRC.*/
/* CEMHELP          -   USE LABEL INCRREX TO SIGNAL TO READ NEXT REXX*/
/* CEMHELP          -    INPUT STATEMENT.                            */
/* CEMHELP          - LIMITATIONS                                    */
/* CEMHELP          -  CAN USE INTERPRET OR VALUE STMTS WITH CAUTION */
/* CEMHELP          -  CAN ADDRESS ISPEXEC OR TSO                    */
/* CEMHELP          -  USE " TO DELIMIT STRINGS OR COMMANDS NOT '    */
/* CEMHELP          -  DO LOOPS CAN BE IMPLEMENTED AS A MULTIPLE     */
/* CEMHELP          -   COMMAND REXX STATEMENT, SUCH AS:             */
/* CEMHELP          -  A="IF D#####Z=1 THEN DO;SAY D#####Z;END"      */
/* CEMHELP          -  INTERPRET A                                   */
/* CEMHELP          -   THIS WILL PERFORM THE DO LOOP. YOU CAN STRING*/
/* CEMHELP          -   MULTIPLE PARTS OF A DO LOOP TOGETHER TO THE  */
/* CEMHELP          -   MAX OF 32K???? WITH THE CONCAT E.G. A=A||B   */
/* CEMHELP END                                                       */
/* %%% */
   ADDRESS ISPEXEC
   EXECSEL = 'DSNL2REX'
   "ISPEXEC VPUT (EXECSEL) ASIS"
   TRCX='TRACE I'
   VALPRMS='TRAC SRC TGT'
   NPW=WORDS(VALPRMS)
   DO I = 1 TO NPW
    TMP=WORD(VALPRMS,I)
    INTERPRET TMP"=''"
    END
   ARG PRMS
   IF PRMS = '?' THEN DO
    CALL CEMHELP DSNL2REX
    EXIT
    END
   IF PRMS ^= '' THEN DO
    PASSCT=0
    DO WHILE(PRMS ^= '')
     PASSCT = PASSCT + 1
     IF PASSCT > NPW THEN SIGNAL INVALPRM
     PARSE VAR PRMS PRM '(' PRMVAL ')' PRMS
     IF WORDS(PRM) ^= 1 THEN DO
      PARSE VAR PRM PRMVAL TPRMS
      PRM=WORD(VALPRMS,PASSCT)
      PRMS=TPRMS||PRMS
      END
     IF WORDPOS(PRM,VALPRMS) = 0 THEN DO
      IF PRMVAL = '' THEN DO
       PRMVAL=PRM
       PRM=WORD(VALPRMS,PASSCT)
       END
       ELSE SIGNAL INVALPRM
      END
     INTERPRET PRM "='"PRMVAL"'"
     PRMS=STRIP(PRMS,'B')
     END
    END
   TRCI=TRAC
   IF TRCI = '' THEN SIGNAL SETTRCI0
   IF TRCI='ON' THEN DO
    TRCI=99999
    SIGNAL DONTRCI
    END
   IF DATATYPE(TRCI) = 'NUM' THEN SIGNAL DONTRCI
SETTRCI0:
    TRCI=0
    TRCX='NOP'
DONTRCI:
    TRCH=TRCI
 SIGNAL ON SYNTAX NAME SAVEX
   SSRC = SRC
   TTGT = TGT
   DROP SRC
   DROP TGT
   IF SSRC='-' THEN SIGNAL SRCBYP
   IF SSRC ^= '' THEN DO
    SDSN=SSRC
    SIGNAL N#SDSN
    END
   "ISPEXEC VGET (DSNL2IDS) ASIS"
   IF RC ^= 0 THEN DSNL2IDS='YOUR.DSN.GOES.HERE'
   EDSN=DSNL2IDS
   DSEMSG = 'ENTER SRC DSN(MBR) CONTAINING DSN LIST'
  TRYAGN:
   MYVERB = 'ABORT BYPASS CANCEL'
   "ISPEXEC VPUT (EDSN) ASIS"
   "ISPEXEC VPUT (DSEMSG) ASIS"
   "ISPEXEC VPUT (MYVERB) ASIS"
   CALL DSNWIND
   XC = RESULT
   IF XC > 4 THEN SIGNAL EXITRC2
   ADDRESS ISPEXEC "VGET (MYVERB) ASIS"
   IF RC ^= 0 THEN SIGNAL EXITRC8
 /* SIMPLE TEST OF MYVERB */
   IF MYVERB ^= '' THEN DO
    IF MYVERB='ABORT' | MYVERB='CANCEL' THEN SIGNAL CANCEL8
    IF MYVERB^='BYPASS' THEN SIGNAL CANCEL8
    END
    ELSE SIGNAL PROCSRC
 SRCBYP:
   SDSN=''
   SRC.0=0
   SIGNAL N#SDSN
 PROCSRC:
   ADDRESS ISPEXEC "VGET (EDSN) ASIS"
   IF RC ^= 0 THEN SIGNAL EXITRC8
   IF EDSN ^= DSNL2IDS THEN DO
    DSNL2IDS = EDSN
    "ISPEXEC VPUT (DSNL2IDS) ASIS"
    END
   SDSN=EDSN
   IF SYSDSN("'"SDSN"'") ^= 'OK' THEN DO
    DSEMSG='DATASET OR MEMBER NOT AVAILABLE. RETRY'
    SIGNAL TRYAGN
    END
 N#SDSN:
/* GET THE TARGET FOR THE RESULT */
  IF TTGT = '-' THEN SIGNAL TGTBYP
  IF TTGT ^= '' THEN DO
   ODSN=TTGT
   SIGNAL GETSTMT
   END
  SUID=SYSVAR(SYSUID)
  ODSN=SUID||'.DSNL2REX.DATA'
  MYVERB = 'ABORT BYPASS CANCEL REUSE DELETE'
  EDSN = ODSN
  MODDSN = ''
  DSEMSG = 'TGT DSN:(R)REUSE,(D)DEL/REALLOC,(A)ABORT,(B)BYPASS'
  MODATTR="NEW BLKSIZE(80) DSORG(PS) RECFM(F,B) SPACE(1,1)"||,
   "CYLINDER LRECL(80) CATALOG REUSE"
 ADDRESS ISPEXEC "VPUT (MYVERB EDSN EXECSEL DSEMSG MODATTR MODDSN) ASIS"
  IF RC ^= 0 THEN SIGNAL EXITRC8
  BYPIND = 0
  CALL ALOCDSN
  IF RESULT = 0 THEN SIGNAL GOTTGT
  ADDRESS ISPEXEC "VGET (MYVERB) ASIS"
  IF MYVERB = '' THEN SIGNAL GOTTGT
  IF MYVERB = 'REUSE' THEN SIGNAL GOTTGT
  IF MYVERB = 'CANCEL'|MYVERB = 'ABORT' THEN SIGNAL CANCEL8
  IF MYVERB ^= 'BYPASS' THEN SIGNAL EXITRC8
 TGTBYP:
  BYPIND = 1
  ODSN=''
  SIGNAL GETSTMT
 GOTTGT:
  ADDRESS ISPEXEC "VGET (EDSN) ASIS"
  ODSN = EDSN
 GETSTMT:
   K = 1
 PRESTMT:
   SELECT
    WHEN K = 1 THEN DO
    DSEMSG = 'ENTER PREFIX REXX STMTS. PF3 TO END. ABORT.'
    MYVARO = 'PDSNL'
    SIGNAL RXSRCLP
    END
    WHEN K = 2 THEN DO
    DSEMSG = 'ENTER SUFFIX REXX STMTS. PF3 TO END. ABORT.'
    MYVARO = 'SDSNL'
    SIGNAL RXSRCLP
    END
    WHEN K = 3 THEN DO
    DSEMSG = 'ENTER MAIN REXX STMTS. PF3 TO END. ABORT.'
    MYVARO = 'MDSNL'
    SIGNAL RXSRCLP
    END
    OTHERWISE SIGNAL EXITRC8
    END
 RXSRCLP:
   ADDRESS TSO "NEWSTACK"
   INTERPRET MYVARO"I = 0"
   "ISPEXEC VPUT (DSEMSG) ASIS"
   CALL REXXSRC "PULL("MYVARO")"
   XC = RESULT
   IF XC > 2 THEN SIGNAL EXITRC8
   MY#VCT = QUEUED()
   DO J = 1 TO MY#VCT
    INTERPRET "PULL "MYVARO".J"
    END
   ADDRESS TSO "DELSTACK"
   INTERPRET MYVARO".0 = MY#VCT"
   IF MY#VCT > 0 THEN INTERPRET MYVARO"I = 1"
 N#TSTMT:
   K = K + 1
   IF K < 4 THEN SIGNAL PRESTMT
  SAY '....> PROCESSING REXX STATEMENTS <.....'
  DSNL2CAN=0
  ADDRESS ISPEXEC 'VPUT (DSNL2CAN) ASIS'
  ADDRESS TSO
  IF SDSN = '' THEN SIGNAL ARNDSRC
  "ALLOC FI(IDSNL) DA('"SDSN"') SHR REUSE"
 "EXECIO * DISKR IDSNL (STEM SRC. FINIS"
 "FREE FI(IDSNL)"
  /* OUTER LOOP WILL READ 1 LINE FROM THE IDSNL AND PROCESS */
  /* THE SET OF REXX COMMANDS FOR EACH LINE */
  /* D#####Z IS USED TO REFERENCE EACH SRC. LINE */
  /* T#####Z IS USED TO REFERENCE EACH TGT. OUTPUT LINE */
  /* Z#####Z IS USED TO REFERENCE EACH LINE OF THE REXX INPUT STREAM */
 ARNDSRC:
  T#####Z=0
  I#="T#####Z=T#####Z+1"
  SI#="SIGNAL INCRSRC; END;"
  IF PDSNLI=1 THEN DO
   PDSNLI=2
   ZMPL='PDSNL'
   SIGNAL S#LOOP
   END
   ELSE PDSNLI=3
 C#KMAIN:
  IF TRCH ^= 0 THEN DO
   TRCI=TRCH
   TRCX='TRACE I'
   END
  PDSNLI=PDSNLI+2
  R#TVAR='C#KMAIN'
  ZMPL='MDSNL'
  SIGNAL S#LOOP
 C#KSFX:
  IF SDSNLI=1 THEN DO
   IF TRCH ^= 0 THEN DO
    TRCI=TRCH
    TRCX='TRACE I'
    END
   SDSNLI=2
   ZMPL='SDSNL'
   SIGNAL S#LOOP
   END
  SDSNLI=SDSNLI+2
  SIGNAL D#NEALL
 S#LOOP:
  D#####Z=1
  SAY 'PROCESSING 'ZMPL
 SRCLOOP:
  LOG.D#####Z=''
  IF TRCX='TRACE I' THEN DO
   TRCI=TRCI-1
   IF TRCI = -1 THEN TRCX='NOP'
   END
  Z#####Z = 1
  INTERPRET 'Z#CT = 'ZMPL'.0'
 REXLOOP:
  LOG.D#####Z=LOG.D#####Z||'<'||Z#####Z
  INTERPRET TRCX
  INTERPRET 'TMP = 'ZMPL'.Z#####Z'
  INTERPRET TMP
  TRACE OFF
  LOG.D#####Z=LOG.D#####Z||'>'
 INCRREX:
  Z#####Z = Z#####Z + 1
  IF Z#####Z ^> Z#CT THEN SIGNAL REXLOOP
 INCRSRC:
  ADDRESS ISPEXEC "VGET (DSNL2CAN) ASIS"
  IF DSNL2CAN ^= 0 THEN SIGNAL SAVEX
  IF PDSNLI = 2 THEN SIGNAL C#KMAIN
  IF SDSNLI > 1 THEN SIGNAL D#NEALL
  D#####Z = D#####Z + 1
  IF D#####Z ^> SRC.0 THEN SIGNAL SRCLOOP
  IF SDSNLI = 1 THEN SIGNAL C#KSFX
 D#NEALL:
  IF BYPIND = 1 THEN SIGNAL DONEBYP
  IF TGT.0 = 0 THEN SIGNAL DONEBYP
  ADDRESS TSO
 "ALLOC FI(ODSNL) DA('"ODSN"') SHR REUSE"
 "EXECIO * DISKW ODSNL (STEM TGT. FINIS"
 "FREE FI(ODSNL)"
 SAY 'PROCESSING FINISHED RC 0. OP CREATED AS REQUESTED.'
 SIGNAL WRITIT
 RETURN 0
SAVEX:
   XC=RC
 SIGNAL ON HALT NAME SAVEXY
  OKCAN1 = 'REXX HALTED ON LINE 'SIGL
  OKCAN1 = SOURCELINE(SIGL)
  OKCAN2 = '(O)K TO CONTINUE, (C)ANCEL TO ABORT'
  OKCANX = 'C'
  ADDRESS ISPEXEC 'VPUT (OKCAN1 OKCAN2 OKCANX) ASIS'
  CALL OKCANBOX
  IF RESULT ^= 0 THEN SIGNAL EXITRC8
  ADDRESS ISPEXEC 'VGET (OKCANX) ASIS'
  IF OKCANX ^= 'O' THEN SIGNAL EXITRC8
  SIGNAL ON HALT NAME SAVEX
  SIGNAL DOINTACT
SAVEXY:
INVALPRM:
 SAY 'INVALID PARM SUPPLIED.>'VALPRMS'< USE ? OR CEMHELP DSNL2REX '||,
  'FOR ADDITIONAL INFORMATION'
 RETURN 4
EXITRC8:
 SAY 'ERROR OCCURRED. ENDING EXEC.'
 RETURN 4
CANCEL8:
 SAY 'CANCEL/ABORT/BYPASS OPTIONS SELECTED'
 RETURN 4
EXITRC12:
 SAY 'INTERPRET OR VALUE IS NOT SUPPORTED.'
 RETURN 12
NOOPDSN:
 SAY 'INVALID TARGET DSN SPECIFIED. NO OP WRITTEN'
 SIGNAL WRITIT
NOFADSN:
 SAY 'SOURCE DSN LIST NOT SPECIFIED CORRECTLY. BYE'
 SIGNAL WRITIT
NONDONE
 SAY 'NO SOURCE DSN PASSED EDIT CRITERIA. NO OP CREATED.'
 SIGNAL WRITIT
DONEBYP:
 SAY 'PROCESSING FINISHED RC 0. NO OP CREATED AS REQUESTED.'
 SIGNAL WRITIT
WRITIT:
 RETURN 4
SNTXX:
   XC=RC
DOINTACT:
 SAY 'REXX ERROR 'RC' ON LINE 'SIGL':'ERRORTEXT(XC)
 SAY SOURCELINE(SIGL)
 DO WHILE (1)
  SAY 'ENTER A VALID REXX COMMAND EXCEPT INTERPRET'
  PULL RESP
  INTERPRET RESP
  END
 EXIT
###END DSNL2REX
$$$BEG SRCH4FSA
/* REXX */
TRACE I?
EDSN = "TTET.TSK.F.R320.CGTG.TABLE.SOURCE(DFHPLTIY)"
EDTRC = 0;ADDRESS ISPEXEC "VPUT (EDTRC) ASIS"
ADDRESS ISPEXEC "EDIT DATASET('"EDSN"') MACRO(SRCH4HG)"
ADDRESS ISPEXEC "VGET (EDTRC) ASIS"
IF EDTRC = 0 THEN SAY "FOUND"
XC = RC
RS = RESULT
EXIT
 CVTCOLD='TTEP.TSK.G.PROD.SYSJCL('KIXCOLD')'
 "ISPEXEC EDIT DATASET ('"CVTCOLD"') MACRO($CVTFSA)"
 "ISPEXEC VGET (EDTRC) ASIS"
 IF EDTRC = 0 THEN DO
  "ISPEXEC VGET (EDSN) ASIS"
  IF RC ^= 0 THEN SIGNAL CHKPRC
  R212FSA=EDSN||'('||KIXAPPL||')'
  SIGNAL GOTFSA
  END
CHKPRC:
 "ISPEXEC VGET (KIXSTRT) ASIS"
 IF RC ^= 0 THEN SIGNAL FSADFLT
 IF KIXSTRT = '' THEN SIGNAL FSADFLT
 CVTPROC='TTEP.TSK.G.PROCLIB('KIXSTRT')'
 "ISPEXEC EDIT DATASET ('"CVTSTRT"') MACRO($CVTFSA)"
 "ISPEXEC VGET (EDTRC) ASIS"
 IF EDTRC = 0 THEN DO
  "ISPEXEC VGET (EDSN) ASIS"
  IF RC ^= 0 THEN SIGNAL CHKPRC
  R212FSA=EDSN||'('||KIXAPPL||')'
  SIGNAL GOTFSA
  END
FSADFLT:
 R212FSA=$CVTDSN||'($FSA)'
 SIGNAL NOFSASUB
GOTFSA:
 IF POS('&',R212FSA) = 0 THEN SIGNAL NOFSASUB
 $CVTSYMB='INXX$CVT('
 INDEX1=$CVTSYMB||DSHLQ||'.TSK)'
 DSTYP1=$CVTSYMB||'F)'
 REL=$CVTSYMB||'R'||KIXREL||')'
 ARCH=$CVTSYMB||'FILESRCE.R331)'
 "ISPEXEC VPUT (INDEX1 DSTYP1 REL ARCH) ASIS"
 CALL EXPDSYMB '// '||R212FSA
 PULL R212FSA
NOFSASUB:
###END SRCH4FSA
$$$BEG RDOPROC#
 /* REXX */
###END RDOPROC#
$$$BEG SHOWISFL
/* REXX */
XX=ISFCALLS('ON')
IF XX <> 0 THEN DO
    SAY 'ISFCALLS FAILED. RC='XX
    EXIT 16
END
TRACE ?I
ISFPREFIX='ODT*'
/* ADDRESS SDSF "ISFEXEC H (DELAYED ALTERNATE)" *\
\*ADDRESS SDSF "ISFEXEC DA (DELAYED ALTERNATE)" */
ISFCOLS = 'JNAME JNUM JOBID ACTSYS'
ISFFILTER = 'ACTSYS = XSYS'
ADDRESS SDSF "ISFEXEC ST (DELAYED ALTERNATE)"
SAY 'ISFROWS='ISFROWS
DO I=1 TO ISFROWS
SAY JNAME.I JNUM.I JOBID.I ACTSYS.I
END
/* ADDRESS SDSF "ISFEXEC ST (VERBOSE ALTERNATE)" */
ISFFILTER = 'OFF'
ISFCOLS =
ADDRESS SDSF "ISFEXEC ST (DELAYED ALTERNATE)"
SAY 'ISFDISPLAY='ISFDISPLAY
SAY 'ISFCOLS='ISFCOLS
SAY 'ISFDCOLS='ISFDCOLS
IF RC <> 0 THEN DO
     SAY 'ISFEXEC H * FAILED. RC='RC
     EXIT 16
END
SAY 'ISFROWS='ISFROWS
DO I=1 TO ISFROWS
SAY JNAME.I JTYPE.I JNUM.I JOBID.I OWNERID.I OCLASS.I FORMS.I STATUS.I,
     TIMER.I DATER.I JCLASS.I
END
/* DA COLS
ISFCOLS=JNAME TOKEN STEPN PROCS JOBID OWNERID JCLASS POS DP REAL PAGING
EXCPRT CPUPR ASID ASIDX EXCP CPU SWAPR STATUS SYSNAME SPAGING SCPU
WORKLOAD SRVCLASS P ERIOD RESGROUP SERVER QUIESCE ECPU ECPUPR CPUCRIT
STORCRIT RPTCLASS MEMLIMIT TR ANACT TRANRES SPIN SECLABEL GCPTIME
ZAAPTIME ZAAPCPTM GCPUSE ZAAPUSE SZAAP SZIIP PROMOTED ZAAPNTIM ZIIPTIME
ZIIPCPTM ZIIPNTIM ZIIPUSE SLCPU
   ST COLS
ISFCOLS=JNAME TOKEN JOBID OWNERID JPRIO QUEUE JCLASS POS PRTDEST SYSAFF
ACTSYS STATUS SECLABEL TGNUM TGPCT ORIGNODE EXECNODE DEVID OFFDEVS
RETCODE SRVCLS WLMP OS SCHENV DELAY SSMODE PHASENAME PHASE JTYPE ROOMN
PNAME ACCTN NOTIFY ISYSID TIMER DATER ESYSID TIMEE DATEE TIMEN DATEN
ICARDS MCLASS TSREC SPIN SUBGROUP SUBU SER
ISFDCOLS=ROOMN PNAME ACCTN NOTIFY ISYSID TIMER DATER ESYSID TIMEE DATEE
TIMEN DATEN ICARDS MCLASS TSREC SUBGROUP SUBUSER
   H  COLS
ISFCOLS=JNAME TOKEN JOBID OWNERID DPRIO OCLASS OUTDISP DESTN RECCNT
PAGECNT FOR MS FCBID STATUS UCSID WTRID FLASHID BURST PRMODE DEST NODE
SECLABEL OGNAME OGID OGID2 JPRIO DSDATE OHREASON OHRSNTXT DEVID DSYSID
OFFDEVS RETCODE JTYPE ROOMN PNAME ACCTN NOTIFY ISYSID TIMER DATER ESYSID
TIMEE DATEE TIMEN DATEN ICARDS JCL ASS MCLASS SUBGROUP
ISFDCOLS=ROOMN PNAME ACCTN NOTIFY ISYSID TIMER DATER TIMEE DATEE TIMEN
DATEN ICARDS MCLASS SUBGROUP
*/
###END SHOWISFL
$$$BEG DSPNSTBL
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA DSPNSTBL - ISPF DISPLAY CICS NETSTAT INFO FROM MYAREA   */
 /* CEMHELP          - ISPF BASED, DISPLAYS A TWO COLUMN TBL LIST   */
 /* CEMHELP          - OF APLID AND PORTNUM. EACH PAIR IS A SINGLE  */
 /* CEMHELP          - LINE TO BE DISPLAYED. ALL LINES ARE PASSED   */
 /* CEMHELP          - TO VIA ISPF VAR MYAREA. LINES IN THE MYAREA  */
 /* CEMHELP          - ARE SEPARATED BY THE 1 CHAR VALUE PASSED     */
 /* CEMHELP          - IN AS ISPF VAR MYAREA#. TABLE CAN BE SORTED  */
 /* CEMHELP          - BY EITHER APLID OR PORTNUM. DEFAULT IS       */
 /* CEMHELP          - PORTNUM.                                     */
 /* CEMHELP END                                                     */
 /* -                                                               */
 /* THIS EXEC DISPLAYS DATA FROM THE MYAREA VARIABLE, USING THE     */
 /* ISPF TABLEDISP SERVICE. THE PANEL IS SET TO ALLOW A SELECTION   */
 /* ACTION, 1 PER LINE. YOU CAN PROCESS THE DATA ASSOCIATED WITH    */
 /* SELECTED LINE                                                   */
  ADDRESS ISPEXEC
/*  'ISPEXEC CONTROL ERRORS RETURN' */
  "ISPEXEC VGET (EXECSEL) ASIS"
  IF RC ^= 0 THEN DO
   EXECSEL = 'DSPNSTBL'
   "ISPEXEC VPUT (EXECSEL) ASIS"
   END
  "ISPEXEC VGET (MYAREA#) ASIS"
  IF RC ^= 0 THEN SIGNAL NOPOOL
  IF LENGTH(MYAREA#) ^= 1 THEN SIGNAL NOPOOL
  SEP=MYAREA#
  "ISPEXEC VGET (MYAREA) ASIS"
  IF RC ^= 0 THEN SIGNAL NOPOOL
  I = 0
  HL_MYAREA = 0
  DO WHILE(MYAREA ^= '')
   PARSE VAR MYAREA TMP (SEP) MYAREA
   IF TMP = '' & I = 0 THEN ITERATE
   TL = LENGTH(TMP)
   IF TL > MXLNG THEN MXLNG = TL
   I = I+1
   IP.I = TMP
   HP.I = TMP
   END
  /* TRACE I */
  IF I = 0 THEN SIGNAL NOPOOL
  IPCT=I
  ARG MYFUNC
  IF MYFUNC ^= 'QUIET' THEN TYPSEL = 'INPUT'
    ELSE TYPSEL='OUTPUT'
  SUID=SYSVAR(SYSUID)
  ICT=IP.0
  COLNAMES='APLID,PORTNUM'
  SORTWDS='APLID PORTNUM'
  SORTCOLS='1 2'
  SORTSELN='PORTNUM'
  SORTCUR#=WORDPOS(SORTSELN,SORTWDS)
  CANSTR='CANCEL ABORT'
  DONSTR='END SAVE RESET SORT'
  CMDSTR=CANSTR||' '||DONSTR
  NWDS=WORDS(CMDSTR)
  CMDSTR3=''
  DO C = 1 TO NWDS
   CMDSTR3=CMDSTR3||SUBSTR(WORD(CMDSTR,C),1,3)||' '
   END
  PROCLST='S'   /* LINE COMMAND. IF MORE ENTRIES, COMMA SEPARATED */
  PROCLST='S,-' /* LINE COMMAND. IF MORE ENTRIES, COMMA SEPARATED */
  SIGNAL OFF ERROR
  ADDRESS ISPEXEC
/*  "ISPEXEC CONTROL ERRORS RETURN" */
  MDSN='TTED.TSK.D.TCEM.ISPPLIB'
  "ISPEXEC LIBDEF ISPPLIB DATASET ID('"MDSN"') STACK"
  IF RC ^= 0 THEN DO
    MSGBOXTX='ERROR ON LIBDEF ISPPLIB::'MDSN
    SIGNAL SHOWMBOX
    END
  "ISPEXEC TBCREATE DSPNSTBT "||,
    "NAMES("COLNAMES") NOWRITE REPLACE"
   IF RC > 4 THEN DO
   MSGBOXTX ='COULD NOT CREATE THE DSPNSTBT TABLE'
   SIGNAL SHOWMBOX
   END
  SELSTR = ''
  "ISPEXEC TBSORT DSPNSTBT FIELDS("SORTSELN")"
   IF RC > 4 THEN DO
   MSGBOXTX ='COULD NOT BE SORTED BY 'SORTSELN
   SIGNAL SHOWMBOX
   END
  /* TRACE ?I */
  DO I = 1 TO IPCT
   FA = IP.I
   PARSE VAR FA APLID PORTNUM
   A = APLID PORTNUM
   "ISPEXEC TBADD DSPNSTBT ORDER SAVE(ACTION)"
   IF RC > 4 THEN DO
   MSGBOXTX ='COULD NOT ADD ROW I TO DISPLAY. '||IP.I
   SIGNAL SHOWMBOX
   END
   IF I > 2 THEN TRACE OFF
   END
 /*  TRACE ?I */
  SIGNAL SHOW_TBL
 TBL_RESET:
  FDS=1
  SDT=DATE('U')
  ACTION='-'
  MDROW=0
  MYCRP=0
  "ISPEXEC TBTOP DSPNSTBT"
  XC = RC
  DO I = 1 TO IPCT
  "ISPEXEC TBSKIP DSPNSTBT NUMBER(1)"
   FA = HP.I
   PARSE VAR FA APLID PORTNUM
   A = APLID PORTNUM
   "ISPEXEC TBPUT DSPNSTBT"
   IF I > 2 THEN TRACE OFF
   END
/*  TRACE ?I  */
  XC = RC
  SELSTR = ''
  SELSTR=''
 SHOW_TBL:
  "ISPEXEC TBTOP DSPNSTBT"
  XC = RC
  AMT='CSR'
  MCMD=''
  UPDTIND=0
 TOPOFLOP:
  ACTION = '-'
  DSEMSG = SELSTR
  "ISPEXEC TBDISPL DSPNSTBT PANEL(DSPNSTBD) "||,
           "ROWID(MDROW) POSITION(MYCRP) "
  XC = RC
  /* TRACE I */
  IF XC > 8 THEN DO
   MSGBOXTX ='SEVERE ERROR FROM TBDISPL FUNCTION.  ABORT.'
   SIGNAL SHOWMBOX
   END
  IF XC = 8 THEN MCMD = 'END'
  MCMDVAL=''
  IF WORDS(MCMD > 1) THEN DO
   PARSE VAR MCMD MCMD MCMDVAL
   END
  NUD=ZTDSELS
  HR#=MDROW
  HC#=MYCRP
  DO WHILE (ZTDSELS > 0)
   TST = ACTION
   HR#=MDROW
   HC#=MYCRP
   IF TST = 'S' THEN DO
    TMP = WORD(FA,1)
    IF WORDPOS(TMP,SELSTR) = 0 THEN SELSTR = SELSTR||' '||TMP
    END
   ACTION='-'
   IF ZTDSELS = 1 THEN LEAVE
   "ISPEXEC TBDISPL DSPNSTBT"
   END
  IF XC = 0 & MCMD = '' THEN SIGNAL TOPOFLOP
  IF WORDPOS(MCMD,CMDSTR) = 0 THEN SIGNAL TOPOFLOP
  IF WORDPOS(MCMD,CANSTR) ^=  0 THEN DO
   MSGBOXTX='COMMAND:'MCMD' SIGNALS ABORT'
   SIGNAL SHOWMBOX
   END
  IF MCMD = 'RESET' THEN SIGNAL TBL_RESET
  IF MCMD \= 'SORT' THEN SIGNAL ARNDSORT
  /* TRACE ?I */
  NEWSORTSELN=''
  CURSORT# = WORDPOS(SORTSELN,SORTWDS)
  IF MCMDVAL = '' THEN DO
   IF SORTCUR# = 1 THEN SORTCUR# = 2
    ELSE SORTCUR# = 2
   NEWSORTSELN=WORD(SORTWDS,SORTCUR#)
   SIGNAL CHKSORT
   END
  SP = WORDPOS(MCMDVAL,SORTWDS)
  IF SP > 0 THEN SIGNAL GOTWD
  IF WORDPOS(MCMDVAL,SORTCOLS) = 0 THEN DO
   SIGNAL DONESORT
   END
  NEWSORTSELN=WORD(SORTWDS,MCMDVAL)
  SIGNAL CHKSORT
GOTWD:
  NEWSORTSELN=MCMDVAL
CHKSORT:
  IF NEWSORTSELN = SORTSELN THEN SIGNAL DONESORT
  SORTSELN = NEWSORTSELN
  CURSORT# = WORDPOS(SORTSELN,SORTWDS)
  "ISPEXEC TBSORT DSPNSTBT FIELDS("SORTSELN")"
DONESORT:
  MCMD = ''
  MCMDVAL = ''
  SIGNAL TOPOFLOP
ARNDSORT:
  IF WORDPOS(MCMD,DONSTR) ^= 0 THEN SIGNAL OKDOIT
  MSGBOXTX='UNKNOWN COMMAND:'MCMD
  SIGNAL TOPOFLOP
/*PROCESS END SAVE OR RESET COMMANDS */
 OKDOIT:
  IF MCMD = 'END' THEN SIGNAL RTN_STR
  IF MCMD = 'RESET' THEN SIGNAL TBL_RESET
  IF MCMD \= 'SAVE' THEN SIGNAL TOPOFLOP
 /*                       SAVE COMMAND */
 /*    BYPASS READ THRUOGH TABLE
  "ISPEXEC TBTOP DSPNSTBT"
  DO I = 1 TO ICT
    "ISPEXEC TBSKIP DSPNSTBT NUMBER(1)"
    "ISPEXEC TBGET DSPNSTBT"
    TMP = APLID
    IF I > 2 THEN TRACE OFF
    END
   TRACE I
   */
   MSGBOXTX='SAVE TO FILE NOT AVAILABLE'N
   XC = 0
   CALL SHOWMBOX
  SIGNAL TOPOFLOP
RTN_STR:
   'ISPEXEC LIBDEF ISPPLIB'
   'ISPEXEC VPUT (SELSTR) ASIS'
   RETURN 0
   SIGNAL SHOWMBOX
SHOWMBOX:
   'ISPEXEC LIBDEF ISPPLIB'
   SELSTR = ''
   FFX='FF'X
   MSGBOXTX=FFX||MSGBOXTX||FFX||'RC WAS 'XC'. PRESS PF3 TO END'
   CALL MSGBOX MSGBOXTX
   'ISPEXEC VPUT (SELSTR) ASIS'
   RETURN XC
 NOPOOL:
  XC = 8
  ZEDSMSG = "NO POOLED DATA"
  ZEDLMSG = "NO DATA PREVIOUSLY POOLED FOR RECALL"
  SIGNAL WRITIT
  WRITIT:
  "ISPEXEC SETMSG MSG(ISRZ001)"
  RETURN 4
###END DSPNSTBL
$$$BEG MYWAIT
 /* REXX */                                                             00150000
 /* CEMHELP BEGIN                                                   */  00160000
 /* CEMHELA          -                                              */  00170000
 /* CEMHELP          - TSO BASE, RESTRICTED                         */  00180000
 /* CEMHELP          -                                              */  00190000
 /* CEMHELP END                                                     */  00200000
 /* trace i */                                                          00210000
  arg wttime wtmsg                                                      00211002
 retryit:                                                               00211100
  if wttime = '' then do                                                00212002
   wttime = 10                                                          00212102
   end                                                                  00212302
   else do                                                              00213000
    if datatype(wttime) ^= 'NUM' then signal badarg                     00214000
    if wttime > 60 then do                                              00215000
     say 'Your wait tme is 'wttime'; the ATTN routine interupt will '   00216000
     say '     not see the interrupt until the wait time has passed'    00217000
     say ' enter 0 to quit, G to Go, or another wait time value'        00218000
     pull wttime                                                        00219000
     if wttime = 0 then signal abortit                                  00219100
     if wttime = 'g' or wttime = 'G' then signal doit                   00219200
     signal retryit                                                     00219301
    end                                                                 00219400
   end                                                                  00219500
 doit:                                                                  00220000
  SIGNAL ON HALT NAME HALT                                              00230000
 /* ADDRESS TSO */                                                      00240000
   if syscalls('ON')>3 then do                                          00250000
    say 'Unable to establish the SYSCALL environment'                   00260000
    return                                                              00270000
    end                                                                 00280000
 /*  xc = syscalls('SIGON') */                                          00290000
   mxlop=60                                                             00330000
   cxlop=1                                                              00340000
   FFX='FF'X                                                            00341000
   MSGSTAT='ADDPOP'                                                     00343000
   MSGLOCK='Y'                                                          00344000
   h_wtmsg=wtmsg                                                        00344102
   if wtmsg = '' then h_wtmsg='START Waiting for ATTN'                  00344202
   MSGBOXTX=h_wtmsg||':'||TIME()||FFX||"<"cxlop">"                      00345002
   address ISPEXEC "VPUT (MSGSTAT MSGLOCK MSGBOXTX) ASIS"               00346000
   do forever                                                           00350000
     CALL MSGBOX                                                        00359300
     address syscall "sleep "wttime                                     00361000
     cxlop=cxlop+1                                                      00430000
     if cxlop>mxlop then do                                             00450000
      MSGBOXTX="Reached loop threshold:"mxlop||FFX||"<"cxlop">"||,      00460000
       FFX||" Forcing end."||FFX||"Press any PF3 to END"                00461000
      signal doneit                                                     00470000
      end                                                               00480000
     MSGSTAT='CONTPOP'                                                  00480200
     if wtmsg = '' then h_wtmsg="Still Waiting for ATTN"                00480302
     MSGBOXTX=h_wtmsg||':'||TIME()||FFX||"<"cxlop">"                    00480402
     address ISPEXEC "VPUT (MSGSTAT MSGBOXTX) ASIS"                     00482000
     end                                                                00500000
   if wtmsg = '' then h_wtmsg="Finished Waiting for ATTN"               00510002
   MSGBOXTX=h_wtmsg||':'||TIME()||FFX||"<"cxlop">"                      00510102
       FFX||'"Press any PF or Enter key to END'                         00511100
   signal doneit                                                        00512000
  HALT:                                                                 00520000
   MSGBOXTX="HALTed by the ATTN key:"TIME()||FFX||"<"cxlop">"||,        00520100
       FFX||"Press any PF3 to END"                                      00520200
  doneit:                                                               00520300
   MSGSTAT='REMPOP'                                                     00521000
   MSGLOCK='N'                                                          00522000
   address ISPEXEC "VPUT (MSGSTAT MSGLOCK MSGBOXTX) ASIS"               00524000
     CALL MSGBOX                                                        00526000
   exit 0                                                               00540001
badarg:                                                                 00550001
 say 'Invalid argument value specified'                                 00560001
 exit 8                                                                 00570001
abortit:                                                                00580001
 say 'Abort selected. Bye.'                                             00590001
 exit 8                                                                 00600001
###END MYWAIT
$$$BEG VLIB
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA RESTRICTED                                              */
 /* CEMHELP          - TSO BASE, RESTRICTED                         */
 /* CEMHELP END                                                     */
  ARG TRGVAR REST
  IF TRGVAR = '' THEN SIGNAL EXITRC8
  CALL VLIBS TRGVAR 'ELIB' REST
  EXIT
 EXITRC8:
  ZEDSMSG = 'VAR OMITTED'
  ZEDLMSG = 'REQUIRED VARIABLE OMITTED'
 WRITIT:
  'ISPEXEC SETMSG MSG(ISRZ001)'
  EXIT
###END VLIB
$$$BEG VLIBS
 /* REXX */
 /* TRACE I */
  ACTN = 'VIEW'
  ARG TRGVAR ELIBIND REST
  IF TRGVAR = '' THEN TRGVAR = 'COMLIBS'
  IF TRGVAR='CODELIBS'|TRGVAR='COMLIBS'|TRGVAR='MYLOADS' THEN DO
   ACTN = 'VIEW'
   END
  IF SUBSTR(TRGVAR,1,5)='ESFX(' THEN DO
   TRGVARL=LENGTH(TRGVAR)
   IF SUBSTR(TRGVAR,TRGVARL,1) = ')' THEN TRGVARL=TRGVARL-1
   ESFXT=SUBSTR(TRGVAR,6,TRGVARL-5)
   TRGVAR='ESFX'
   END
  ADDRESS 'ISPEXEC'
  "ISPEXEC VGET ("VALUE('TRGVAR')") PROFILE"
  IF RC ^= 0 THEN SIGNAL EXITRC8
  IF TRGVAR='ESFX' THEN PRM1 = VALUE(TRGVAR)||ESFXT
   ELSE  PRM1 = VALUE(TRGVAR)
 "ISPEXEC VGET (ELVL) ASIS"
 IF RC ^= 0 THEN ELVL=1
  ELSE ELVL=ELVL+1
 "ISPEXEC VPUT (ELVL) ASIS"
 FP=POS('(',PRM1)
 IF FP = 0 THEN DO
  X=LISTDSI("'"PRM1"'" DIRECTORY NORECALL)
  IF X ^= 0 THEN SIGNAL EXITRC8
  IF SYSDSORG = 'PO' THEN ELIBIND='ELIBS'
  END
 IF POS('F',SYSRECFM) = 0 & POS('V',SYSRECFM) = 0 THEN DO
  ACTN='VIEW'
  END
 IF SYSLRECL>256 THEN DO
  ACTN='VIEW'
  END
 OKCMD:
  PARSE VAR REST '(' EMBR ')' EMAC
  IF EMBR = '-'  | EMBR = '*' THEN DO
   PARSE VAR PRM1 PRM1 '(' .
   END
   ELSE DO
   IF EMBR^='' THEN PRM1=PRM1||'('||EMBR||')'
   END
  IF ACTN = 'VIEW' THEN EMAC=''
   ELSE DO
   IF SUBSTR(EMAC,1,4) = 'MAC(' | SUBSTR(EMAC,1,6) = 'MACRO(' THEN DO
    PARSE VAR EMAC . '(' EMAC ')'
    END
   IF EMAC^='' THEN EMAC=' MACRO('EMAC')'
   END
  IF ELIBIND ^= 'ELIB' THEN DO
   "ISPEXEC "ACTN" DATASET('"PRM1"')"||EMAC
   END
   ELSE DO
   ADDRESS TSO
   "ALLOC FI(I) DA('"PRM1"') SHR REUSE"
   "EXECIO * DISKR I (STEM JCL. FINIS"
   "FREE FI(I)"
   IF JCL.0 = 0 THEN SIGNAL EXITRC4
   ADDRESS ISPEXEC
   IF TRGVAR='MYLOADS' THEN  ACTN = 'BROWSE'
    ELSE ACTN = 'EDIT'
   PRM1=WORD(JCL.1,1)
   "ISPEXEC "ACTN" DATASET('"PRM1"')"||EMAC
   IF RC > 4 THEN SIGNAL EXITRC6
   END
 "ISPEXEC VGET (ELVL) ASIS"
 IF RC^=0 THEN ELVL=0
 ELVL=ELVL-1
  "ISPEXEC VPUT (ELVL) ASIS"
 ZEDSMSG = 'ELVL='ELVL
 ZEDLMSG = 'CURRENT EDIT LEVEL 'ELVL' (1 IS LOWEST)'
 SIGNAL WRITIT
 EXITRC4:
  ZEDSMSG = TRGVAR' EMPTY'
  ZEDLMSG = 'VAR 'TRGVAR' WAS FOUND EMPTY. NO DSN IN LIST'
  SIGNAL WRITIT
 EXITRC6:
  ZEDSMSG = 'EDIT TGTDSN INVL'
  ZEDLMSG = 'DS POINTED TO BY ELIB 'TGTVAR' NOT EDITABLE'
  SIGNAL WRITIT
 EXITRC8:
  ZEDSMSG = 'VAR NOT FOUND'
  ZEDLMSG = 'VAR 'TRGVAR' FOR TARGET DSN LIST NOT FOUND'
 WRITIT:
  'ISPEXEC SETMSG MSG(ISRZ001)'
  EXIT
###END VLIBS
$$$BEG JRPPNT
/* REXX */
/* CEMHELP BEGIN                                                     */
/* CEMHELP RESTRICTED                                                */
/* CEMHELP END                                                       */
 ADDRESS ISPEXEC
 SP132 = COPIES(' ',132)
 SP2 = '  '
 ARG DDEST DSNME
 IF DDEST = '' THEN SIGNAL EXITRC4
 IF DATATYPE(DDEST) = 'NUM' THEN DDEST='JRP'||DDEST
 IF LENGTH(HDDEST) > 8 THEN SIGNAL DDESTBAD
 HDDEST=DDEST
 PDDEST=POS('P',DDEST)
 HDDEST=SUBSTR(DDEST,PDDEST)
 IF SUBSTR(HDDEST,1,1) ^= 'P' THEN SIGNAL DDESTBAD
 DDEST3=SUBSTR(DDEST,1,PDDEST)
 IF DSNME ^= '' THEN SIGNAL DOPNT
 IF DDEST3 ^= 'RRP' THEN SIGNAL TST1ST
 DDEST='JR'||HDDEST
 "ISPEXEC VGET ("DDEST") ASIS"
 IF RC ^= 0 THEN SIGNAL NOPOOL
 INTERPRET 'TDDEST = 'DDEST
 PARSE VAR TDDEST TDDEST '<' MYCN '>'
 IF HDDEST ^= TDDEST THEN SIGNAL DDESTBAD
 IF LENGTH(MYCN) > 5 THEN DO
  DSNME=MYCN
  SIGNAL DOPNT
  END
 SIGNAL ARNDMYCN
TST1ST:
 "ISPEXEC VGET (MYCN) ASIS"
 IF RC ^= 0 THEN SIGNAL NOPOOL
ARNDMYCN:
 INTERPRET "A = "MYCN"TOT"
 "ISPEXEC VGET ("A") ASIS"
 IF RC ^= 0 THEN SIGNAL NOPOOL
 INTERPRET "MYCNTOT = "A
 IF MYCNTOT ^> 0 THEN SIGNAL NOPOOL
 IF MYCNTOT > 999 THEN SIGNAL BADPOOL
 A = VALUE(MYCN)
 MXLNG = 0
 TOTCNT = MYCNTOT
 J=0
 DO WHILE(TOTCNT > 0)
  IF TOTCNT > 255 THEN DO
   LPCNT=255
   TOTCNT=TOTCNT-255
   END
   ELSE DO
   LPCNT=TOTCNT
   TOTCNT = 0
   END
  VGTSTR=''
  DO I = 1 TO LPCNT
   VGTSTR=VGTSTR||' '||MYCN||I
   END
  VGTSTR=STRIP(VGTSTR,'B')
  "ISPEXEC VGET ("VGTSTR") ASIS"
  IF RC ^= 0 THEN SIGNAL GETPOOLR
  DO I = 1 TO LPCNT
   J=J+1
   INTERPRET 'MYL =  LENGTH('A||I')'
   IF MYL > MXLNG THEN MXLNG = MYL
   INTERPRET 'TOUT.J = SP2||'A||I
   END
 JRPSRC=MYCN
 SIGNAL PRTIT
DOPNT:
 ADDRESS TSO
 X = LISTDSI("'"DSNME"'")
 IF X > 8 THEN SIGNAL EXITRC8
 MXLNG = SYSLRECL
 "ALLOC FI(I) DA('"DSNME"') SHR REUSE"
 "EXECIO * DISKR I (STEM TOUT. FINIS"
 IF RC ^= 0 THEN SIGNAL EXITRC8
 "FREE FI(I)"
 MYCN=DSNME
PRTIT:
/* JRPSRC=HDDEST||"<"||MYCN||">"
   TDEST = DDEST
   INTERPRET TDEST' = JRPSRC'
   ADDRESS ISPEXEC "VPUT (JRPSRC "TDEST") ASIS"
*/
 ADDRESS ISPEXEC "VGET (CURGRP CURCPU) ASIS"
 IF RC ^= 0 THEN DO
  CALL GETCPU1
  IF RC ^= 0 THEN SIGNAL EXITRC8
  ADDRESS ISPEXEC "ISPEXEC VGET (CURGRP CURCPU) ASIS"
  IF RC ^= 0 THEN SIGNAL EXITRC8
  END
 CALL JRPSET DDEST
 IF RESULT > 0 THEN PDST=DDEST||' 80'
  ELSE PULL PDST
 DDEST=WORD(PDST,1)
 PMAX=WORD(PDST,2)
 ADDRESS TSO
 RDEST=SUBSTR(DDEST,4)
 IF CURGRP ^= 'GRP2' THEN DDEST = 'N12.'||DDEST
 "ALLOC FI(O) DA(TEMP) SYSOUT(A) DEST("DDEST") BLKSIZE("PMAX") "||,
  "LRECL("PMAX") RECFM(F,B)"
 "EXECIO * DISKW O (STEM TOUT. FINIS"
 "FREE FI(O)"
 RETURN RDEST
DDESTBAD:
 RETURN 8
NOPOOL:
 RETURN 2
EXITRC4:
 RETURN 4
EXITRC8:
 RETURN 8
###END JRPPNT
$$$BEG JRP4182
/* REXX */
/* CEMHELP BEGIN                                                     */
/* CEMHELA JRP4182  - PRINT A DSN TO JRP4182   WIDE CARRAGE, 246     */
/* CEMHELP JRP4182  - TSO BASE, PROMPTS YOU FOR A DSN WHICH IT WILL  */
/* CEMHELP          - PRINT AT JRP4182 VIA MSPRINT. WIDE CARRAGE, 246*/
/* CEMHELP END                                                       */
 ARG DSNME
 CALL JRPPRMT 'JRP4182' DSNME
 XC = RESULT
 IF SYSVAR(SYSNEST) = 'NO' THEN DO
  IF XC='0'|XC>'20' THEN SAY DSNME ' SENT TO JRP'XC
    ELSE SAY DSNME ' NOT PRINTED AT 'DDEST 'ERROR RC 'XC
  END
 RETURN XC
###END JRP4182
$$$BEG JRP4181
/* REXX */
/* CEMHELP BEGIN                                                     */
/* CEMHELA JRP4181  - PRINT A DSN TO JRP4181, 80 COL                 */
/* CEMHELP JRP4181  - TSO BASE, PROMPTS YOU FOR A DSN WHICH IT WILL  */
/* CEMHELP          - PRINT AT JRP4181 VIA MSPRINT, 80 COLS.         */
/* CEMHELP END                                                       */
 ARG DSNME
 CALL JRPPRMT 'JRP4181' DSNME
 XC = RESULT
 IF SYSVAR(SYSNEST) = 'NO' THEN DO
  IF XC='0'|XC>'20' THEN SAY DSNME ' SENT TO JRP'XC
    ELSE SAY DSNME ' NOT PRINTED AT 'DDEST 'ERROR RC 'XC
  END
 RETURN XC
###END JRP4181
$$$BEG FNDINLST
 /* REXX */
 /* CEMHELP BEGIN                                                   */
 /* CEMHELA          -                                              */
 /* CEMHELP          - TSO BASE, RESTRICTED                         */
 /* CEMHELP          -                                              */
 /* CEMHELP END                                                     */
 ADDRESS TSO
 "ALLOC FI(I) DA('TTED.TSK.HG2000.R610.STAGE(ACCPREGN)') SHR REUSE"
"EXECIO * DISKR I (STEM HGL. FINIS"
HGLST=''
DO I = 1 TO HGL.0
 TMP=STRIP(WORD(HGL.I,1),'B')
 HGLST=HGLST||' '||TMP
 END
 "ALLOC FI(P) DA('TTEP.TSK.P.TCEM.NOTES(PDOBKXXA)') SHR REUSE"
"EXECIO * DISKR P (STEM PDL. FINIS"
DO I = 1 TO PDL.0
 TMP=STRIP(WORD(PDL.I,1),'B')
 WP=WORDPOS(TMP,HGLST)
 IF WP \= 0 THEN DO
  HGL.WP=PDL.I
  SAY HGL.WP
  END
 END
"EXECIO * DISKW I (STEM HGL. FINIS"
"FREE FI(I P)"
###END FNDINLST
